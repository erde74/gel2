/* This file contains 10 copies of gel.gel concatenated together, with classes renamed
 * in each copy to avoid duplicate class definitions.  It is about 73,000 lines long;
 * we use it as input in a benchmarking test to measure compilation speed. */

/*
Copyright (c) 2006 Google Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

import "gel_collection.gel";

import "jay/gel2/jay.gel";
import "gel.tab.gel";

class Syntax {
  public readonly string file_;
  public readonly int line_;

  public Syntax() { file_ = Gel.CurrentFile(); line_ = Gel.Line(); }

  static void Report(string file, int line, string type) {
    Console.Write("{0}({1}): ", file, line);
    Console.Write("{0}: ", type);
    if (Gel.error_test_)
      Gel.error_lines_.Add(line);
  }

  public void Error(string message) {
    Report(file_, line_, "error");
    Console.WriteLine(message);
  }

  public void Error(string format, object arg) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg);
  }

  public void Error(string format, object arg1, object arg2) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2);
  }

  public void Error(string format, object arg1, object arg2, object arg3) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2, arg3);
  }

  public void Warning(string message) {
    Report(file_, line_, "warning");
    Console.WriteLine(message);
  }
}

abstract class TypeExpr : Syntax {
  public abstract GType Resolve(Program program);
  public abstract TypeExpr ^Copy();
}

class ConversionContext {
  public const int Other = 0,
                   AssignVar = 1,
                   MethodArg = 2;
}

// GEL2 includes the following kinds of types:
// - simple types (int, bool, char, float, double): SimpleType
// - owned types (including array types): ArrayType or Class with Owned() => true
// - owning types: Owning
// - string: GString
// - null type: NullType
// - void: VoidType

abstract class GType {
  public virtual bool IsOwned() { return false; }

  // A reference type is an owned, owning, string or null type.
  public virtual bool IsReference() { return true; }

  // A value type is a simple or string type.
  public virtual bool IsValue() { return false; }

  public virtual Class Parent() { return GObject.type_; }
  
  // If this is an owning type T ^ then return T; otherwise return this.
  public virtual GType BaseType() { return this; }

  // Return the set of types which may be destroyed when a variable of this type
  // is destroyed.
  public virtual TypeSet VarDestroys() { return TypeSet.empty_; }

  // Return the set of types which may be destroyed when a value of this concrete type
  // is destroyed.
  public virtual TypeSet TypeDestroys() { return TypeSet.empty_; }

  public virtual void FindVarDestroys(int marker, TypeSet set) { }

  public virtual void FindTypeDestroys(int marker, TypeSet set) { }

  public virtual bool IsSubtype(GType type) {
    for (GType t = this; t != null ; t = t.Parent())
      if (type.Equals(t))
        return true;
    return false;
  }

  public virtual Owning OwningType() { Debug.Assert(false); return null; }

  protected virtual bool CanConvertOwnership(GType t, int context) {
    bool from_owning = this is Owning;
    bool to_owning = t is Owning;
    if (IsValue() && t.BaseType() == GObject.type_) {
      Debug.Assert(!from_owning);
      // boxing conversion yields an owning pointer; string->object conversion may
      // yield an owning or non-owning pointer
      return to_owning || context == ConversionContext.MethodArg || this == GString.type_;
    }
    if (BaseType() == GObject.type_ && t.IsValue()) {
      Debug.Assert(!to_owning);
      return true;  // an unboxing or object->string conversion, OK in any context
    }
    return from_owning == to_owning ||
           from_owning && !to_owning &&
             (context == ConversionContext.AssignVar || context == ConversionContext.MethodArg);
  }

  // Ensure that this class will inherit from Object in generated C++ code.
  public virtual void SetObjectInherit() { }

  // Return true if there is a non-subtyping implicit conversion from this to t.
  public virtual bool CanConvert1(GType t) { return false; }

  // Return true if there is a non-subtyping explicit conversion from this to t.
  protected virtual bool CanConvertExplicit1(GType t) { return false; }

  // Return true if this type can be converted to type [to].
  public bool CanConvert(GType to, int context, bool is_explicit, bool subtype_only) {
    if (!CanConvertOwnership(to, context))
      return false;

    GType from_base = BaseType();
    GType to_base = to.BaseType();
    if (from_base.Equals(to_base))
      return true;   // identity conversion

    // If we ever perform a conversion to C ^, then C must have a vtable so that we can call
    // a virtual destructor when an owning pointer is destroyed.
    if (to is Owning && this != Null.type_)
      to_base.SetVirtual();

    // If we ever perform an explicit conversion from a class, that class must
    // have a vtable so that every instance of the class will have run-time type information.
    if (is_explicit)
      from_base.SetVirtual();

    // If we ever convert between C and Object, then C must derive from Object in generated code.
    if (from_base == GObject.type_)
      to_base.SetObjectInherit();
    else if (to_base == GObject.type_)
      from_base.SetObjectInherit();

    return from_base.IsSubtype(to_base) ||
           !subtype_only && from_base.CanConvert1(to_base) ||
           is_explicit && (to_base.IsSubtype(from_base) ||
                           !subtype_only && from_base.CanConvertExplicit1(to_base));
  }

  public bool CanConvert(GType t, int context) { return CanConvert(t, context, false, false); }
  public bool CanConvert(GType t) { return CanConvert(t, ConversionContext.Other); }

  public bool CanConvertExplicit(GType t, bool subtype_only) {
    return CanConvert(t, ConversionContext.Other, true, subtype_only);
  }

  public bool CheckConvert(Syntax caller, GType t, int context) {
    if (!CanConvert(t, context)) {
      caller.Error("can't convert {0} to {1}", this, t);
      return false;
    }
    return true;
  }

  public bool CheckConvert(Syntax caller, GType t) {
    return CheckConvert(caller, t, ConversionContext.Other);
  }

  // Return a type to which the types [this] and t can both be implicitly converted.
  public GType CommonType(Syntax caller, GType t) {
    if (CanConvert(t))
      return t;
    if (t.CanConvert(this))
      return this;
    caller.Error("incompatible types: {0} and {1}", this, t);
    return null;
  }

  public abstract SimpleValue DefaultValue();

  static ArrayList ^empty_array_ = new ArrayList();
  public virtual ArrayList /* of Member */ Members() { return empty_array_; }

  public Member GetMatchingMember(Member m1) {
    foreach (Member m in Members())
      if (m.MatchSignature(m1))
        return m;
    return null;
  }

  // Find a match for m in this type or its ancestors, ignoring private members and
  // optionally ignoring overrides.
  public Member FindMatchingMember(Member m, bool override_ok) {
    for (GType t = this ; t != null ; t = t.Parent()) {
      Member m1 = t.GetMatchingMember(m);
      if (m1 != null && !m1.IsPrivate() && (override_ok || !m1.IsOverride()))
        return m1;
    }
    return null;
  }

  int Score(bool accessible, int mismatches) {
    return (accessible ? 0 : 100) + mismatches;
  }

  public Member Lookup(Syntax caller, Class from_class, bool through_base,
                       int kind, string name, ArrayList /* of Argument */ arguments, bool report_error) {
    Member m1 = null;   // the best match we've found so far
    bool found_any = false;
    bool accessible = false;
    int score = -1;

    GType this_type = BaseType();
    GType t;
    for (t = this_type; t != null; t = (kind == MemberKind.Constructor ? null : t.Parent())) {
      foreach (Member m in t.Members())
        if (Member.MatchKind(m.Kind(), kind) && m.name_ == name && !m.IsOverride()) {
          found_any = true;
          int mismatches = 0;
          if (arguments != null && !m.IsApplicable(arguments, out mismatches))
            continue; // wrong argument count
          bool new_accessible = m.IsAccessible(from_class, this_type, through_base);
          int new_score = Score(new_accessible, mismatches);
          if (new_score == 0 && score == 0) {
            if (report_error)
              caller.Error("{0}: ambiguous {1} call", name, Member.ToString(kind));
            return null;
          }
          if (score == -1 || new_score < score) {
            m1 = m;
            score = new_score;
            accessible = new_accessible;
          }
        }
      if (score == 0)
        break;
    }

    if (score != 0) {
      if (report_error) {
        string k = Member.ToString(kind);
        if (!found_any)
          caller.Error("{0}: {1} not found", name, k);
        else if (score == -1) {
          string a = String.Format("{0} argument{1}", arguments.Count, arguments.Count == 1 ? "" : "s");
          caller.Error("{0}: no {1} overload takes {2}", name, k, a);
        } else if (!accessible)
          caller.Error("{0}: can't access {1} {2}",
                       name, m1.IsProtected() ? "protected" : "private", k);
        else {
          caller.Error("{0}: the best overloaded {1} match has some invalid arguments", name, k);
          m1.ReportMismatches(caller, arguments);
        }
      }
      return null;
    }

    // If we've found a member of the Object class, then we're using this class as an object,
    // so in generated code it must ultimately inherit from Object, not _Object.
    if (t == GObject.type_)
      this_type.SetObjectInherit();

    if (through_base) {
      // As a special case, whenever we're accessing through base we find the member which will
      // actually be invoked; this is not necessarily the same as the member we've just found
      // if the member is virtual.
      m1 = FindMatchingMember(m1, true);
      Debug.Assert(m1 != null);
    }

    return m1;
  }

  public virtual void SetVirtual() { }

  // Emit the name of the C++ class we use to hold instances of this type.
  public virtual string EmitTypeName() { Debug.Assert(false); return null; }

  // Return a C++ type of the form "T<U>".  If U ends with a '>', we emit an
  // extra space to avoid emitting the token >>, which will cause GCC to complain.
  public static string ConstructType(string generic, string type) {
    return String.Format("{0}<{1}{2}>", generic, type,
                         type.EndsWith(">") ? " " : "");
  }

  string EmitNonOwningPointer(string name) {
    if (Gel.program_.safe_)
      return ConstructType(this == GObject.type_ ? "_PtrRef" : "_Ptr", name);
    return String.Format("{0} *", name);
  }

  // Emit a C++ type used for variables holding instances of this type.
  public virtual string EmitType() {
    return EmitNonOwningPointer(EmitTypeName());
  }

  // Emit a C++ type used for expressions holding instances of this type.
  public virtual string EmitExprType() {
    return EmitTypeName() + " *";
  }

  public virtual string EmitReturnType() {
    return EmitExprType();
  }

  public virtual string EmitGenericType() {
    return IsReference() ? EmitNonOwningPointer("Object") : EmitType();
  }
}

class TypeSet {
  NonOwningArrayList /* of GType */ ^types_ = new NonOwningArrayList();

  public static readonly TypeSet ^empty_ = new TypeSet();

  public void Add(GType type) {
    for (int i = 0; i < types_.Count; ++i) {
      GType t = (GType) types_[i];
      if (type.IsSubtype(t))
        return;
      if (t.IsSubtype(type)) {
        types_[i++] = type;
        while (i < types_.Count) {
          t = (GType) types_[i];
          if (t.IsSubtype(type))
            types_.RemoveAt(i);
          else ++i;
        }
        return;
      }
    }
    types_.Add(type);
  }

  public void Add(TypeSet set) {
    foreach (GType t in set.types_)
      Add(t);
  }

  public bool Contains(GType type) {
    foreach (GType t in types_)
      if (type.IsSubtype(t))
        return true;
    return false;
  }

  public bool IsObject() {
    return types_.Count > 0 && types_[0] == GObject.type_;
  }

  public override string ToString() {
    StringBuilder ^sb = new StringBuilder();
    sb.Append("{");
    foreach (GType t in types_)
      sb.AppendFormat(" {0}", t.ToString());
    sb.Append(" }");
    return sb.ToString();
  }
}

class VoidType : GType {
  public override bool IsReference() { Debug.Assert(false); return false; }

  public override SimpleValue DefaultValue() { Debug.Assert(false); return null; }

  public override string ToString() { return "void"; }

  public override string EmitExprType() { return "void"; }
  public override string EmitType() { return "void"; }
}

class Void {
  public static readonly GType ^type_ = new VoidType();
}

// an RValue, a Location containing an RValue, or a LocationRef pointing to a Location containing an RValue
abstract class ValueOrLocation {
  public abstract GValue Get();
}

// a GValue or a reference to a GValue
abstract class RValue : ValueOrLocation {
  public abstract RValue ^CopyRef();
}

abstract class GValue : RValue {
  public override GValue Get() { return this; }

  public abstract GType Type();

  public override RValue ^CopyRef() { return new Reference(this); }

  public virtual RValue ^Get(Field field) { Debug.Assert(false); return null; }
  public virtual RValue ^Take(Field field) { Debug.Assert(false); return null; }

  public virtual RValue ^ConvertExplicit(ref RValue ^this_own, GType t) {
    // try implicit conversion
    RValue ^v = Convert(ref this_own, t);
    if (v != this || Type().IsSubtype(t) )
      return v;

    Console.WriteLine("type cast failed: object of type {0} is not a {1}", Type(), t);
    Gel.Exit();
    return null;
  }

  // Implicitly convert this value to type t.
  public virtual RValue ^Convert(ref RValue ^this_own, GType t) {
    return take this_own;
  }

  public virtual bool DefaultEquals(object o) { return Equals(o); }
  public virtual int DefaultHashCode() { return GetHashCode(); }
  public virtual string DefaultToString() { return ToString(); }

  public virtual RValue ^Invoke(Method m, ValueList args) {
    switch (m.name_) {
      case "Equals": return new GBool(DefaultEquals(args.Object(0)));
      case "GetHashCode": return new GInt(DefaultHashCode());
      case "ToString": return new GString(DefaultToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class Reference : RValue {
  public readonly GValue value_;    // a reference value, never a SimpleValue

  public Reference(GValue v) { value_ = v; }

  public override GValue Get() { return value_; }

  public override RValue ^CopyRef() { return new Reference(value_); }
}

abstract class SimpleValue : GValue {
  public abstract SimpleValue ^Copy();
  public override RValue ^CopyRef() { return Copy(); }
  public abstract string Emit();
}

class GBool : SimpleValue {
  public readonly bool b_;

  public GBool(bool b) { b_ = b; }

  public override bool Equals(object o) {
    GBool b = o as GBool;
    return b != null && b.b_ == b_;
  }

  public override int GetHashCode() { return b_.GetHashCode(); }

  public override SimpleValue ^Copy() { return new GBool(b_); }

  public static readonly BoolClass ^type_ = new BoolClass();

  public override GType Type() { return type_; }

  public override string ToString() { return b_.ToString(); }

  public override string Emit() { return b_ ? "true" : "false"; }
}

class GInt : SimpleValue {
  public readonly int i_;

  public GInt(int i) { i_ = i; }

  public static readonly IntClass ^type_ = new IntClass();

  public override GType Type() { return type_; }

  public override bool Equals(object o) {
    GInt i = o as GInt;
    return i != null && i.i_ == i_;
  }

  public override int GetHashCode() { return i_.GetHashCode(); }

  public override SimpleValue ^Copy() { return new GInt(i_); }

  public override RValue ^Convert(ref RValue ^this_own, GType t) {
    if (t == GFloat.type_)
      return new GFloat(i_);
    if (t == GDouble.type_)
      return new GDouble(i_);
    return base.Convert(ref this_own, t);
  }

  public override RValue ^ConvertExplicit(ref RValue ^this_own, GType t) {
    return t == GChar.type_ ? new GChar((char) i_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return i_.ToString(); }

  public override string Emit() { return i_.ToString(); }
}

class GFloat : SimpleValue {
  public readonly float f_;

  public GFloat(float f) { f_ = f; }

  public static readonly FloatClass ^type_ = new FloatClass();

  public override GType Type() { return type_; }

  public override bool Equals(object o) {
    GFloat f = o as GFloat;
    return f != null && f.f_ == f_;
  }

  public override int GetHashCode() { return f_.GetHashCode(); }

  public override SimpleValue ^Copy() { return new GFloat(f_); }

  public override RValue ^Convert(ref RValue ^this_own, GType t) {
    if (t == GDouble.type_)
      return new GDouble(f_);
    return base.Convert(ref this_own, t);
  }

  public override RValue ^ConvertExplicit(ref RValue ^this_own, GType t) {
    return t == GInt.type_ ? new GInt((int) f_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return f_.ToString(); }

  public override string Emit() {
    string s = f_.ToString();
    return s + (s.IndexOf('.') == -1 ? ".0f" : "f");
  }
}

class GDouble : SimpleValue {
  public readonly double d_;

  public GDouble(double d) { d_ = d; }

  public static readonly DoubleClass ^type_ = new DoubleClass();

  public override GType Type() { return type_; }

  public override bool Equals(object o) {
    GDouble d = o as GDouble;
    return d != null && d.d_ == d_;
  }

  public override int GetHashCode() { return d_.GetHashCode(); }

  public override SimpleValue ^Copy() { return new GDouble(d_); }

  public override RValue ^ConvertExplicit(ref RValue ^this_own, GType t) {
    if (t == GInt.type_)
      return new GInt((int) d_);
    if (t == GFloat.type_)
      return new GFloat((float) d_);
    return base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return d_.ToString(); }

  public override string Emit() {
    string s = d_.ToString();
    if (s.IndexOf('.') == -1)
      s = s + ".0";
    return s;
  }
}

class GChar : SimpleValue {
  public readonly char c_;

  public GChar(char c) { c_ = c; }

  public static readonly CharClass ^type_ = new CharClass();

  public override GType Type() { return type_; }

  public override bool Equals(object o) {
    GChar c = o as GChar;
    return c != null && c.c_ == c_;
  }

  public override int GetHashCode() { return c_.GetHashCode(); }

  public override SimpleValue ^Copy() { return new GChar(c_); }

  public override RValue ^Convert(ref RValue ^this_own, GType t) {
    return t == GInt.type_ ? new GInt(c_) : base.Convert(ref this_own, t);
  }

  public override string ToString() { return c_.ToString(); }

  public static string Emit(char c) {
    switch (c) {
      case '\0': return "\\0";
      case '\n': return "\\n";
      case '\r': return "\\r";
      case '\t': return "\\t";
      case '\'': return "\\'";
      case '\"': return "\\\"";
      case '\\': return "\\\\";
    }
    if (c < 32) {
      Debug.Assert(false); return null;
    }
    return c.ToString();
  }

  public override string Emit() {
    return String.Format("'{0}'", Emit(c_));
  }
}

abstract class LocationOrRef : ValueOrLocation {
  public abstract Location GetLoc();
}

class Location : LocationOrRef {
  public RValue ^value_;

  public Location(RValue ^val) { value_ = val; }

  public override GValue Get() { return value_.Get(); }

  public override Location GetLoc() { return this; }
}

// We allocate a LocationRef when we need an owning reference to a Location which we don't own.
class LocationRef : LocationOrRef {
  public readonly Location location_;

  public LocationRef(Location loc) { location_ = loc; }

  public override GValue Get() { return location_.Get(); }

  public override Location GetLoc() { return location_; }
}

class MapNode {
  public readonly MapNode ^next_;
  public readonly object key_;
  public ValueOrLocation ^value_;   // (must appear after next_ so it will be destroyed first)

  public MapNode(object key, ValueOrLocation ^value, MapNode ^next) {
    key_ = key; value_ = value; next_ = next;
  }
}

class Map {
  MapNode ^nodes_;

  protected MapNode Find1(object key) {
    for (MapNode n = nodes_; n != null; n = n.next_)
      if (n.key_ == key)
        return n;
    return null;
  }

  protected virtual MapNode Find(object key) {
    MapNode n = Find1(key);
    Debug.Assert(n != null);
    return n;
  }

  public RValue ^Get(object key) {
    return Find(key).value_.Get().CopyRef();
  }

  public RValue ^Take(object key) {
    MapNode n = Find(key);
    LocationOrRef l = n.value_ as LocationOrRef;
    if (l != null)
      return take l.GetLoc().value_;
    return (RValue) take n.value_;
  }

  public void Set(object key, RValue ^val) {
    MapNode n = Find(key);
    LocationOrRef l = n.value_ as LocationOrRef;
    if (l != null)
      l.GetLoc().value_ = val;
    else n.value_ = val;
  }

  public void Add(object key, ValueOrLocation ^val) {
    nodes_ = new MapNode(key, val, take nodes_);
  }

  public Location GetLocation(object key) {
    MapNode n = Find(key);
    LocationOrRef l = n.value_ as LocationOrRef;
    if (l != null)
      return l.GetLoc();
    Location ^loc1 = new Location((RValue) take n.value_);
    Location loc = loc1;
    n.value_ = loc1;
    return loc;
  }
}

class GObject : GValue {
  public readonly Class class_;   // the class of this object

  Map ^map_ = new Map();

  public GObject(Class cl) {
    class_ = cl;
    while (cl != null) {
      foreach (Field f in cl.fields_)
        map_.Add(f, f.Type().DefaultValue().Copy() );
      cl = cl.Parent();
    }
  }

  // the type of this object
  public override GType Type() { return class_; }

  public override RValue ^Get(Field field) { return map_.Get(field); }
  public override RValue ^Take(Field field) { return map_.Take(field); }
  public void Set(Field field, RValue ^val) { map_.Set(field, val); }
  public Location GetLocation(Field field) { return map_.GetLocation(field); }

  public override int DefaultHashCode() { return base.GetHashCode(); }
  public override int GetHashCode() {
    GInt ^i = (GInt) Invocation.InvokeMethod(this, GObject.type_.get_hash_code_, new ArrayList(), true);
    return i.i_;
  }

  public override bool DefaultEquals(object o) { return base.Equals(o); }
  public override bool Equals(object o) {
    GValue v = o as GValue;
    if (v == null)
      return false;

    ArrayList ^args = new ArrayList();
    args.Add(v.CopyRef());
    GBool ^b = (GBool) Invocation.InvokeMethod(this, GObject.type_.equals_, args, true);
    return b.b_;
  }

  public override string DefaultToString() { return String.Format("<object {0}>", class_.name_); }
  public override string ToString() {
    GString ^s = (GString) Invocation.InvokeMethod(this, GObject.type_.to_string_, new ArrayList(), true);
    return s.s_;
  }

  // the Object class
  public static readonly ObjectClass ^type_ = new ObjectClass();
}

class NullType : GType {
  public override string ToString() { return "null_type"; }

  public override SimpleValue DefaultValue() { Debug.Assert(false); return null; }

  public override bool IsSubtype(GType t1) {
    return t1.IsReference();
  }

  protected override bool CanConvertOwnership(GType t, int context) {
    return true;    // conversion from null type to owning type is okay
  }

  public override string EmitType() { Debug.Assert(false); return null; }
}

class Null : SimpleValue {
  public Null() { }

  public static readonly NullType ^type_ = new NullType();

  public override GType Type() { return type_; }

  public override bool Equals(object o) {
    return o is Null;
  }

  public override SimpleValue ^Copy() { return new Null(); }

  public override int GetHashCode() { return 0; }

  public static readonly Null ^Instance = new Null();

  public override string ToString() { return ""; }

  public override string Emit() { return "0"; }
}

class Owning : GType {
  GType base_type_;

  public Owning(GType type) {
    base_type_ = type;
  }

  public override Class Parent() { Debug.Assert(false); return null; }

  public override SimpleValue DefaultValue() { return Null.Instance; }

  public override GType BaseType() { return base_type_; }

  public override TypeSet VarDestroys() { return base_type_.TypeDestroys(); }

  public override void FindVarDestroys(int marker, TypeSet set) {
    base_type_.FindTypeDestroys(marker, set);
  }

  public override bool Equals(object o) {
    Owning t = o as Owning;
    return t != null && t.base_type_.Equals(base_type_);
  }

  public override int GetHashCode() { return base_type_.GetHashCode() * 87; }

  public override string ToString() { return base_type_.ToString() + " ^"; }

  public override string EmitTypeName() {
    return base_type_.EmitTypeName();
  }

  string EmitType(string name) {
    return ConstructType(base_type_ == GObject.type_ ? "_OwnRef" : "_Own", name);
  }

  public override string EmitType() {
    // We represent an object ^ using a _OwnRef<Object>.
    // We represent a Foo ^ using an _Own<Foo>.
    return EmitType(EmitTypeName());
  }

  public override string EmitGenericType() {
    // We represent an object ^ [] using an _Array<_OwnRef<Object>>.
    // We represent a Foo ^ [] using an _Array<_Own<Object>>.
    return EmitType("Object");
  }
}

class OwningExpr : TypeExpr {
  readonly TypeExpr ^expr_;

  public OwningExpr(TypeExpr ^expr) { expr_ = expr; }

  public override TypeExpr ^Copy() { return new OwningExpr(expr_.Copy()); }

  public override GType Resolve(Program program) {
    GType t = expr_.Resolve(program);
    if (t == null)
        return null;
    if (t.IsValue()) {
      Error("^ cannot be applied to primitive types or strings");
      return null;
    }
    return t.OwningType();
  }
}

class GString : SimpleValue {
  public readonly string s_;

  public GString(string s) { s_ = s; }

  public static readonly StringClass ^type_ = new StringClass();

  public override GType Type() { return type_; }

  public override bool Equals(object o) {
    GString s = o as GString;
    return s != null && s.s_ == s_;
  }

  public override SimpleValue ^Copy() { return new GString(s_); }

  public override int GetHashCode() { return s_.GetHashCode(); }

  public override string ToString() { return s_; }

  public override RValue ^Invoke(Method m, ValueList args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StartsWith": return new GBool(s_.StartsWith(args.GetString(0)));
      case "EndsWith": return new GBool(s_.EndsWith(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public static string EmitStringConst(string s) {
    return String.Format("L{0}", EmitString(s));
  }

  public static string EmitString(string s) {
    StringBuilder ^sb = new StringBuilder();
    sb.Append('"');
    for (int i = 0; i < s.Length; ++i)
      sb.Append(GChar.Emit(s[i]));
    sb.Append('"');
    return sb.ToString();
  }

  public override string Emit() {
    string s = String.Format("new String({0})", EmitStringConst(s_));
    s = String.Format("_Ref<String>({0}).Get()", s);
    return s;
  }
}

abstract class Ownable : GType {
  Owning ^owning_type_;

  public override Owning OwningType() {
    if (owning_type_ == null)
      owning_type_ = new Owning(this);
    return owning_type_;
  }
}

class ArrayType : Ownable {
  GType element_type_;

  public ArrayType(GType type) {
    element_type_ = type;

    // Any type used generically must inherit from Object in C++ code.
    type.BaseType().SetObjectInherit();
  }

  public override bool IsOwned() { return true; }

  public override Class Parent() { return GArray.array_class_; }

  public override SimpleValue DefaultValue() { return Null.Instance; }

  public GType ElementType() { return element_type_; }

  public override bool Equals(object o) {
    ArrayType t = o as ArrayType;
    return (t != null && t.element_type_.Equals(element_type_));
  }

  public override TypeSet TypeDestroys() { return element_type_.VarDestroys(); }

  public override void FindTypeDestroys(int marker, TypeSet set) {
    element_type_.FindVarDestroys(marker, set);
  }

  public override int GetHashCode() { return element_type_.GetHashCode() * 77; }

  public override string EmitTypeName() {
    return ConstructType("_Array", element_type_.EmitGenericType());  
  }

  public override string ToString() {
    return element_type_.ToString() + "[]";
  }
}

class ArrayTypeExpr : TypeExpr {
  readonly TypeExpr ^expr_;
  GType ^type_;

  public ArrayTypeExpr(TypeExpr ^expr) { expr_ = expr; }

  public override TypeExpr ^Copy() { return new ArrayTypeExpr(expr_.Copy()); }

  public override GType Resolve(Program program) {
    GType t = expr_.Resolve(program);
    return t == null ? null : (type_ = new ArrayType(t));
  }
}

class GArray : GValue {
  ArrayType type_;

  ValueOrLocation^[] ^elements_;   // each element is a GValue or a Location

  public override GType Type() { return type_; }

  public GArray(ArrayType type, int count) {
    type_ = type;
    elements_ = new ValueOrLocation^[count];
    for (int i = 0 ; i < count ; ++i)
      elements_[i] = type_.ElementType().DefaultValue().Copy();
  }

  void CheckIndex(int index) {
    if (index < 0 || index >= elements_.Length) {
      Console.WriteLine("error: array access out of bounds");
      Gel.Exit();
    }
  }

  public RValue ^Get(int index) {
    CheckIndex(index);
    return elements_[index].Get().CopyRef();
  }

  public RValue ^Take(int index) {
    CheckIndex(index);
    Location loc = elements_[index] as Location;
    if (loc != null)
      return take loc.value_;
    return (RValue) (take elements_[index]);
  }

  public void Set(int index, RValue ^val) {
    CheckIndex(index);
    Location loc = elements_[index] as Location;
    if (loc != null)
      loc.value_ = val;
    else elements_[index] = val;
  }

  public Location GetLocation(int index) {
    CheckIndex(index);
    Location loc = elements_[index] as Location;
    if (loc != null)
      return loc;
    Location ^loc1 = new Location((RValue) take elements_[index]);
    loc = loc1;
    elements_[index] = loc1;
    return loc;
  }

  public static readonly ArrayClass ^array_class_ = new ArrayClass();

  public override RValue ^Invoke(Method m, ValueList args) {
    if (m.GetClass() != array_class_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "CopyTo":
        GArray a = (GArray) args.Object(0);
        if (!type_.Equals(a.type_)) {
          Console.WriteLine("error: can't copy between arrays of different types");
          Gel.Exit();
        }
        if (a.type_.ElementType() is Owning) {
          Console.WriteLine("error: can't copy to owning array");
          Gel.Exit();
        }
        // should check for index out of bounds here!
        int dest = args.Int(1);
        for (int i = 0 ; i < elements_.Length ; ++i)
          a.Set(dest + i, Get(i));
        return null;
      case "get_Length":
        return new GInt(elements_.Length);
      default:
        Debug.Assert(false); return null;
    }
  }
}

// A control graph object representing temporary variables destroyed when a top-level
// expression completes evaluation. 
class Temporaries : Node {
  NonOwningArrayList /* of GType */ ^types_ = new NonOwningArrayList();
  TypeSet ^destroys_;

  public void Add(GType t) {
    Debug.Assert(t is Owning);
    types_.Add(t.BaseType());
  }

  public override TypeSet NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet();
    foreach (GType t in types_)
        destroys_.Add(t.TypeDestroys());
    }
    return destroys_;
  }
}

class Context {
  public readonly Program program_;   // containing program
  public readonly Class class_;       // containing class
  public readonly Method method_;     // containing method
  public readonly Escapable escape_;  // containing switch, while, do, for, or foreach
  public readonly Loop loop_;         // containing while, do, for, or foreach
  public Local var_;    // chain of local variable declarations

  // subexpressions of the current top-level expression possibly yielding temporary objects
  NonOwningArrayList /* of Expression */ ^temporaries_ = new NonOwningArrayList();

  public Context(Program program) { program_ = program; }

  public Context(Class cl) { program_ = cl.GetProgram(); class_ = cl; }

  // Copy a context; new variable declarations in either copy will not be visible in the other.
  public Context(Context cx) {
    program_ = cx.program_;
    class_ = cx.class_;
    method_ = cx.method_;
    escape_ = cx.escape_;
    loop_ = cx.loop_;
    var_ = cx.var_;
  }

  public Context(Context cx, Class c) : this(cx) { class_ = c; }

  public Context(Context cx, Method m) : this(cx) { method_ = m; }

  public Context(Context cx, Loop l) : this(cx) {
    escape_ = l;
    loop_ = l;
  }

  public Context(Context cx, Switch s) : this(cx) { escape_ = s; }

  public bool IsStatic() { return method_ == null || method_.IsStatic(); }

  public void SetVar(Local var) {
    var_ = var;
  }

  public Local FindVar(string name) {
    for (Local v = var_; v != null; v = v.next_)
      if (v.name_ == name)
        return v;
    return null;
  }

  public Control Prev() { return program_.prev_; }

  public void SetPrev(Control c) {
    Debug.Assert(c != null);
    program_.prev_ = c;
  }

  public void ClearPrev() { program_.prev_ = null; }

  // Called when we begin type-checking a top-level expression.
  public void EnterExpression() {
    Debug.Assert(temporaries_.Count == 0);
  }

  public void AddTemporary(Expression e) {
    temporaries_.Add(e);
  }

  // Called when we've finished type-checking a top-level expression.
  public void FinishExpression() {
    Temporaries t = null;
    foreach (Expression e in temporaries_)
      if (!e.LosesOwnership()) {
        if (t == null)
          t = class_.NewTemporaries();
        t.Add(e.TemporaryType());
      }
    if (t != null)
      t.AddControl(this);
    temporaries_.Clear();
  }
}

class Env : Map {
  public readonly GValue this_;
  readonly Env next_;

  public Env(GValue _this) { this_ = _this; next_ = null; }
  public Env(Env next) { this_ = next.this_; next_ = next; }

  protected override MapNode Find(object key) {
    for (Env e = this; e != null; e = e.next_) {
      MapNode n = e.Find1(key);
      if (n != null)
        return n;
    }
    Debug.Assert(false);
    return null;
  }

  public static readonly Env ^static_ = new Env((GValue) null);
}

class TypeLiteral : TypeExpr {
  public readonly GType type_;

  public TypeLiteral(GType type) { type_ = type; }

  public override GType Resolve(Program program) {
    return type_;
  }

  public override TypeExpr ^Copy() { return new TypeLiteral(type_); }
}

class TypeName : TypeExpr {
  string name_;

  public TypeName(string name) { name_ = name; }

  public override GType Resolve(Program program) {
    GType type = program.FindClass(name_);
    if (type == null)
      Error("unknown type: {0}", name_);
    return type;
  }

  public override TypeExpr ^Copy() { return new TypeName(name_); }
}

abstract class Traverser {
  // Handle a graph item found in a depth first search; returns one of the exit codes below.
  public abstract int Handle(Control control);

  public const int Continue = 0,  // continue searching, including children of this node
                   Cut = 1,       // continue searching, excluding children of this node
                   Abort = 2;     // abort the search

}

// an item in the control graph: either a Node or Joiner
abstract class Control : Syntax {
  public int marker_ = 0;    // marker for depth first search of control flow graph

  static int marker_value_ = 0;
  public static int GetMarkerValue() { return ++marker_value_; }

  // A node representing unreachability.  We could represent this using null, but it's
  // clearer to have this be explicit. 
  public static readonly Node ^unreachable_ = new Node();

  // A helper function for Traverse.  If we return true then we should cut the
  // traversal at this point.
  protected bool Visit(Traverser traverser, int marker, out bool ok) {
    ok = true;
    if (marker_ == marker)
      return true;  // we've already seen this node
    marker_ = marker;
    int code = traverser.Handle(this);
    if (code == Traverser.Abort)
      ok = false;
    return (code != Traverser.Continue);
  }

  // Perform a depth-first search of the graph starting with this item, calling the
  // given Traverser for each Node found.  Returns false if the search was aborted.
  public abstract bool Traverse(Traverser traverser, int marker);
}

// A node in the control graph.
class Node : Control {
  public Control prev_;   // previous item in graph

  // add this node to the control graph
  public bool AddControl(Context ctx) {
    Control prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      prev_ = prev;
      ctx.SetPrev(this);
      return true;
    }
    else return false;
  }

  // If this node calls a method or constructor then return it; otherwise return null.
  // implementers: LValue, Invocation, New, Assign, Constructor
  public virtual Method Calls() { return null; }

  // Return the set of types which this node may destroy.
  // implementers: Assign, RefOutArgument, Scoped, Temporaries
  public virtual TypeSet NodeDestroys() { return TypeSet.empty_; }

  // Return true if this node assigns a value to the given Local.
  // implementers: Assign, RefOutArgument, VariableDeclaration, Method, ForEach
  public virtual bool Sets(Local local) { return false; }

  // Return true if this node takes ownership from the given local.
  // implementers: Name
  public virtual bool Takes(Local local) { return false; }

  public bool CanDestroy(GType type) {
    Method m = Calls();
    if (m != null && m.Destroys().Contains(type))
      return true;
    return NodeDestroys().Contains(type);
  }

  public override bool Traverse(Traverser traverser, int marker) {
    Node n = this;
    Control prev = null;

    // Traverse nodes iteratively until we come to a Join; this efficiently avoids
    // making a recursive call on each successive node.
    while (n != null) {
      bool ok;
      if (n.Visit(traverser, marker, out ok))
        return ok;
      prev = n.prev_;
      n = prev as Node;
    }
    Debug.Assert(prev != null);  // a Traverser must end traversal before we run off the end
    return prev.Traverse(traverser, marker);
  }
}

class Joiner : Control {
  NonOwningArrayList /* of Control */ ^prev_ = new NonOwningArrayList();

  public void Join(Control c) {
    Debug.Assert(c != null);
    if (c == unreachable_)
      return;
    if (prev_.Count == 0 || c != prev_[0])
      prev_.Add(c);
  }

  // add this joiner to the control graph
  public void AddControl(Context ctx) {
    Control prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      Join(prev);
      ctx.SetPrev(this);
    }
  }

  // Once we've finished merging paths into a Joiner, if the Joiner points to only a single path
  // then as an optimization we can discard the Joiner and just use that path instead.
  public Control Combine() {
    switch (prev_.Count) {
      case 0:
        prev_ = null;
        return unreachable_;
      case 1:
        Control c = (Control) prev_[0];
        prev_ = null;
        return c;
      default: return this;
    }
  }

  public override bool Traverse(Traverser traverser, int marker) {
    bool ok;
    if (Visit(traverser, marker, out ok))
      return ok;

    foreach (Control p in prev_)
      if (!p.Traverse(traverser, marker))
        return false;  // aborted
    return true;
  }
}

class ExprKind {
  public const int Value = 0,

  // either a local variable, or an expression whose value is derived from local variables
                   Local = 1,

                   Field = 2,
                   Property = 3,
                   Indexer = 4,
                   Type = 5;
}

class SourceWriter {
  public readonly StreamWriter writer_;
  int indent_ = 0;

  public SourceWriter(StreamWriter writer) { writer_ = writer; }

  public void AddIndent() { ++indent_; }
  public void SubIndent() { --indent_; }

  public void Indent(int adjust) {
    for (int i = 0; i < 2 * indent_ + adjust; ++i)
      writer_.Write(' ');
  }

  public void Indent() { Indent(0); }

  public void Write(string s) { writer_.Write(s); }
  public void Write(string s, object arg) { writer_.Write(s, arg); }
  public void Write(string s, object arg1, object arg2) { writer_.Write(s, arg1, arg2); }
  public void Write(string s, object arg1, object arg2, object arg3) { writer_.Write(s, arg1, arg2, arg3); }

  public void IWrite(string s) { Indent(); Write(s); }
  public void IWrite(string s, object arg) { Indent(); Write(s, arg); }
  public void IWrite(string s, object arg1, object arg2) { Indent(); Write(s, arg1, arg2); }
  public void IWrite(string s, object arg1, object arg2, object arg3) { Indent(); Write(s, arg1, arg2, arg3); }

  public void WriteLine(string s) { writer_.WriteLine(s); }
  public void WriteLine(string s, object arg) { writer_.WriteLine(s, arg); }
  public void WriteLine(string s, object arg1, object arg2) { writer_.WriteLine(s, arg1, arg2); }
  public void WriteLine(string s, object arg1, object arg2, object arg3) { writer_.WriteLine(s, arg1, arg2, arg3); }

  public void IWriteLine(string s) { Indent(); WriteLine(s); }
  public void IWriteLine(string s, object arg) { Indent(); WriteLine(s, arg); }
  public void IWriteLine(string s, object arg1, object arg2) { Indent(); WriteLine(s, arg1, arg2); }
  public void IWriteLine(string s, object arg1, object arg2, object arg3) { Indent(); WriteLine(s, arg1, arg2, arg3); }

  public void OpenBrace() { WriteLine("{"); AddIndent(); }
  public void CloseBrace() { SubIndent(); IWriteLine("}"); }
}

class Usage {
  public const int Used = 0, LosesOwnership = 1, Unused = 2;
}

abstract class Expression : Node {
  protected int usage_ = Usage.Used;

  // start_ and end_ mark the points in the control graph where this expression is evaluated and used,
  // respectively.  If this expression's type is owned, we use this information to determine whether
  // we need to emit a reference count for this expression.
  Control start_;
  Control end_;

  public abstract GType Check(Context ctx);

  public GType CheckTop(Context ctx) {
    ctx.EnterExpression();
    GType t = Check(ctx);
    ctx.FinishExpression();
    return t;
  }

  public GType CheckAndHold(Context ctx) {
    GType t = Check(ctx);
    if (t != null)
      HoldRef(ctx);
    return t;
  }

  // A fancier checking protocol implemented by lvalues and used by certain callers.
  public virtual GType Check(Context ctx, bool read, bool write, bool type_ok) {
    return Check(ctx);
  }

  public virtual int Kind() { return ExprKind.Value; }
  public virtual bool IsRefOutParameter() { return false; }

  public virtual bool IsTrueLiteral() { return false; }
  public virtual bool IsFalseLiteral() { return false; }

  // If this expression is a local variable (possibly cast to a different type),
  // then return that local; otherwise return null.
  public virtual Local GetLocal() { return null; }

  // Return the type of an expression yielding a temporary object.
  // (It might be convenient to generalize this to be able to return any expression's type.)
  public virtual GType TemporaryType() { Debug.Assert(false); return null; }

  public void HoldRef(Context ctx) {
    start_ = ctx.Prev();
    Debug.Assert(start_ != null);
  }

  public void ReleaseRef(Context ctx) {
    end_ = ctx.Prev();
    Debug.Assert(end_ != null);
  }

  public abstract RValue ^Eval(Env env);

  public bool Check(Context ctx, GType t2) {
    GType t = Check(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public bool CheckTop(Context ctx, GType t2) {
    GType t = CheckTop(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public RValue ^Eval(Env env, GType t) {
    RValue ^r = Eval(env);
    GValue v = r.Get();
    return v.Convert(ref r, t);
  }

  public bool EvalBool(Env env) { return ((GBool) Eval(env)).b_; }

  public int EvalInt(Env env) {
    RValue ^r = Eval(env, GInt.type_);
    GInt i = (GInt) r;
    return i.i_;
  }

  public double EvalDouble(Env env) { return ((GDouble) Eval(env, GDouble.type_)).d_; }
  public float EvalFloat(Env env) { return ((GFloat) Eval(env, GFloat.type_)).f_; }
  public string EvalString(Env env) { return ((GString) Eval(env)).s_; }

  public virtual bool IsConstant() {
    return false;
  }

  public bool CheckConstant() {
    if (IsConstant())
      return true;
    Error("expression must be a constant");
    return false;
  }

  public bool LosesOwnership() { return usage_ == Usage.LosesOwnership; }

  public virtual void LoseOwnership() {
    usage_ = Usage.LosesOwnership;
  }

  public void SetUnused() {
    Debug.Assert(usage_ == Usage.Used);
    usage_ = Usage.Unused;
  }

  protected static string EmitAllocate(string type, string args, bool lose_ownership) {
    // If an allocated object never loses ownership then it can be stack allocated.  We
    // can't emit "&Foo(...)" since standard C++ doesn't allow us to take the address
    // of a temporary (both GCC and Visual C++ will allow this, but will emit a warning).
    // So instead we call a function _Addr() to get the address.
    return String.Format(
      !lose_ownership ? "{0}({1})._Addr<{0} *>()" : "new {0}({1})",
      type, args);
  }

  public void CheckLoseOwnership(GType from, GType to) {
    if (to is Owning)
      LoseOwnership();
  }

  public abstract string Emit();    // return a C++ expression representing this GEL2 expression

  public bool NeedsRef(GType type) {
    return Gel.program_.safe_ && type.IsOwned() && ExpressionTraverser.NeedRef(start_, end_, this, type);
  }

  // Emit this expression, adding a reference-counting _Ptr wrapper if needed.
  public string EmitRef(GType type) {
    string s = Emit();
    if (NeedsRef(type))
      s = String.Format("{0}({1}).Get()", type.EmitType(), s);
    return s;
  }

  // Emit an implicit conversion from type [source] to type [dest].
  public static string EmitImplicit(GType source, GType dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (!source.IsReference() && dest == GObject.type_) {   // a boxing conversion
      Class c = (Class) source;
      return EmitAllocate(c.name_, val, loses_ownership);
    }

    if (source == GInt.type_ && dest == GFloat.type_)
      // an implicit conversion in GEL2, but C++ compilers may warn if we don't use a cast
      return String.Format("static_cast<float>({0})", val);
    
    return val;
  }

  // Emit this expression, converting implicitly from type [source] to type [dest].
  public string Emit(GType source, GType dest) {
    return EmitImplicit(source, dest, Emit(), LosesOwnership());
  }

  public string EmitRef(GType source, GType dest) {
    return EmitImplicit(source, dest, EmitRef(source), LosesOwnership());
  }

  public static string EmitExplicit(GType source, GType dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (source.CanConvert(dest)) {
      string v = EmitImplicit(source, dest, val, loses_ownership);
      if (v != val)
        return v;

      // There's nothing to do, but we emit a static_cast anyway since a GEL2 programmer
      // may use a type cast for method call disambiguation; we want to pass such casts onward.
      return String.Format("static_cast<{0} >({1})", dest.EmitExprType(), val);
    }

    if (source.IsReference() && dest.IsReference()) {
      string s = String.Format("_Cast<{0} *>({1})", dest.EmitTypeName(), val);
      ArrayType at = dest as ArrayType;
      if (at != null) {
        GType element_type = at.ElementType();
        if (element_type.IsReference())
          s = String.Format("({0})->CheckType(&typeid({1}))", s, element_type.EmitType());
      }
      return s;
    }

    if (source == GObject.type_ && !dest.IsReference())  // unboxing conversion
      return String.Format("_Unbox<{0} *>({1})->Value()", ((Class) dest).name_, val);

    if (!source.IsReference() && !dest.IsReference())
      return String.Format("static_cast<{0}>({1})", dest.EmitType(), val);

    Debug.Assert(false);
    return null;
  }

  public string EmitExplicit(GType source, GType dest) {
    return EmitExplicit(source, dest, Emit(), LosesOwnership());
  }

  public virtual string EmitArrow(GType t, Member m) {
    return String.Format("({0})->", EmitRef(t));
  }

  // Emit this expression as a local or field initializer, implicitly casting to [type].
  public void EmitAsInitializer(SourceWriter w, GType initializer_type, GType type) {
    // For owning variables, we must emit an initializer of the form "Foo var(val)" since
    // _Own has no copy constructor and hence GCC won't allow "Foo var = val".  For other
    // variables either form is valid, but we emit the second form since it looks clearer.
    w.Write(type is Owning ? "({0})" : " = {0}", Emit(initializer_type, type));
  }

  // Given a value retrieved from a variable, emit an accessor call if needed.
  protected string OwnSuffix(GType t) {
    if (t is Owning)
      return LosesOwnership() ? ".Take()" : ".Get()";
    if (t == GString.type_ || Gel.program_.safe_ && t.IsReference() )
      return ".Get()";
    return "";
  }

  // Given a value returned from a function call, emit a wrapper and/or accessor call if needed.
  protected string Hold(GType t, string s) {
    if (t == GString.type_)
      return s + ".Get()";
    if (t is Owning)
      switch (usage_) {
        case Usage.Used:  // does not lose ownership; we need a freeing wrapper
          return String.Format("{0}({1}).Get()", t.EmitType(), s);
        case Usage.LosesOwnership:
          return s;
        case Usage.Unused:  // a top-level owning expression
          return "delete " + s;
        default: Debug.Assert(false); break;
      }
    return s;
  }
}

class Literal : Expression {
  public readonly SimpleValue ^value_;

  public Literal(SimpleValue ^v) { value_ = v; }

  public override bool IsTrueLiteral() {
    GBool b = value_ as GBool;
    return b != null && b.b_;
  }

  public override bool IsFalseLiteral() {
    GBool b = value_ as GBool;
    return b != null && !b.b_;
  }

  public override GType Check(Context ctx) { return value_.Type(); }

  public override RValue ^Eval(Env env) { return value_.Copy(); }

  public override bool IsConstant() { return true; }

  public override string Emit() { return value_.Emit(); }
}

// An LValue is an expression which can be assigned to: a Name, Dot, or Sub.
//
// In the control graph, an LValue represents a read; if an LValue is written then
// some other node (e.g. an Assign) will appear representing the write.
abstract class LValue : Expression {
  public override GType Check(Context ctx) {
    return Check(ctx, true, false, false);
  }

  public abstract override GType Check(Context ctx, bool read, bool write, bool type_ok);

  public abstract GType StorageType();

  public virtual bool IsLocal() { return false; }
  public virtual bool IsLocal(Local l) { return false; }

  public abstract PropertyOrIndexer GetPropertyOrIndexer();

  public override Method Calls() {
    PropertyOrIndexer pi = GetPropertyOrIndexer();
    return pi == null ? null : pi.Getter();
  }

  public virtual void ReleaseAll(Context ctx) { }

  // For LValues, evaluation proceeds in two stages: the caller first calls Eval1(), then
  // passes the resulting values to EvalGet(), EvalSet() and/or EvalLocation().  This lets
  // us evaluate the left side of an assignment expression before evaluating the right side,
  // and also lets us get and then set an indexer without evaluating its expression twice.

  public abstract void Eval1(Env env, out RValue ^v1, out RValue ^v2);
  public abstract RValue ^EvalGet(Env env, RValue ^v1, RValue ^v2);
  public abstract void EvalSet(Env env, RValue ^v1, RValue ^v2, RValue ^val);
  public abstract Location EvalLocation(Env env, RValue ^v1, RValue ^v2);

  public override RValue ^Eval(Env env) {
    RValue ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalGet(env, val1, val2);
  }

  public void EvalSet(Env env, RValue ^v) {
    RValue ^val1, val2;
    Eval1(env, out val1, out val2);
    EvalSet(env, val1, val2, v);
  }

  public Location EvalLocation(Env env) {
    RValue ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalLocation(env, val1, val2);
  }

  public abstract string EmitSet(string val);

  public abstract string EmitLocation();
}

class Name : LValue {
  public readonly string name_;

  protected Local local_;
  protected LMember field_;  // a field or property

  public Name(string n) { name_ = n; }

  public override bool IsLocal() { return local_ != null; }
  public override bool IsLocal(Local l) { return local_ == l; }
  public override bool IsRefOutParameter() { return local_ is RefOutParameter; }

  public override bool IsConstant() {
    Debug.Assert(local_ != null || field_ != null);   // make sure we were already type checked
    return field_ is ConstField;
  }

  public override GType Check(Context ctx, bool read, bool write, bool type_ok) {
    local_ = ctx.FindVar(name_);
    if (local_ != null) {
      // For reads, we add this Name node to the flow graph; for writes,
      // the caller must add a node which defines this Name.
      if (read)
        if (AddControl(ctx))
          local_.AddUse(this);
      if (write)
        local_.SetMutable();
      return local_.ReadType();
    }

    GType cl = type_ok ? ctx.program_.FindClass(name_) : null;
    field_ = (LMember) ctx.class_.Lookup(this, ctx.class_, false, MemberKind.Field, name_, null, cl == null);
    if (field_ != null) {
      if (!field_.CheckAccess(this, ctx, write, true, !ctx.IsStatic()))
        return null;
      if (read) {
        // Only property reads have side effects we need to register in the control graph.
        if (field_ is Property)
          AddControl(ctx);
      }
      return field_.Type().BaseType();
    }

    return cl;
  }

  public override int Kind() {
    if (local_ != null)
      return ExprKind.Local;
    if (field_ is Field)
      return ExprKind.Field;
    if (field_ is Property)
      return ExprKind.Property;
    Debug.Assert(field_ == null);
    return ExprKind.Type;
  }

  public override Local GetLocal() { return local_; }

  public override GType StorageType() { return local_ != null ? local_.Type() : field_.Type(); }

  public override bool Takes(Local local) {
    return local_ == local && LosesOwnership() && local.Type() is Owning;
  }

  public override PropertyOrIndexer GetPropertyOrIndexer() { return field_ as Property; }

  public override void Eval1(Env env, out RValue ^v1, out RValue ^v2) { v1 = v2 = null; }

  public override RValue ^EvalGet(Env env, RValue ^v1, RValue ^v2) {
    if (LosesOwnership() && StorageType() is Owning)
      return local_ != null ? env.Take(local_) : field_.Take(env.this_);
    else return local_ != null ? env.Get(local_) : field_.Get(env.this_);
  }

  public override void EvalSet(Env env, RValue ^v1, RValue ^v2, RValue ^val) {
    if (local_ != null)
      env.Set(local_, val);
    else field_.Set((GObject) env.this_, val);
  }

  public override Location EvalLocation(Env env, RValue ^v1, RValue ^v2) {
    return local_ != null ? env.GetLocation(local_) : field_.GetLocation((GObject) env.this_);
  }

  public override string Emit() {
    if (local_ != null) {
      string s = local_.Emit();
      return local_.IsWrapper() ? s + OwnSuffix(local_.Type()) : s;
    }
    if (field_ != null)
      return field_.Emit() + OwnSuffix(field_.Type());
    return name_;
  }

  public override string EmitSet(string val) {
    if (local_ != null)
      return String.Format("{0} = {1}", local_.Emit(), val);
    Debug.Assert(field_ != null);
    return field_.EmitSet(val);
  }

  public override string EmitLocation() {
    if (local_ != null)
      return "&" + local_.Emit();
    if (field_ != null)
      return "&" + field_.Emit();
    return "&" + name_;
  }
}

class Parenthesized : Expression {
  Expression ^expr_;

  public Parenthesized(Expression ^e) { expr_ = e; }

  public override GType Check(Context ctx) { return expr_.Check(ctx); }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue ^Eval(Env env) { return expr_.Eval(env); }

  public override string Emit() { return String.Format("({0})", expr_.Emit()); }
}

class PredefinedType : Expression {
  Class type_;

  public PredefinedType(Class type) { type_ = type; }

  public override GType Check(Context ctx) { Debug.Assert(false); return null; }

  public override GType Check(Context ctx, bool read, bool write, bool type_ok) {
    Debug.Assert(type_ok);
    return type_;
  }

  public override int Kind() {
    return ExprKind.Type;
  }

  public override RValue ^Eval(Env env) { Debug.Assert(false); return null; }

  public override string Emit() { return type_.name_; }
}

class Dot : LValue {
  Expression ^expr_;  // set to null for a static invocation
  GType expr_type_;
  string name_;

  LMember field_;

  public Dot(Expression ^expr, string name) { expr_ = expr; name_ = name; }

  public override bool IsConstant() {
    Debug.Assert(field_ != null);   // make sure we were already type checked
    return field_ is ConstField;
  }

  public override GType Check(Context ctx, bool read, bool write, bool type_ok) {
    expr_type_ = expr_.Check(ctx, true, false, true);
    if (expr_type_ == null)
      return null;
    bool is_static = (expr_.Kind() == ExprKind.Type);
    if (is_static)
      expr_ = null;
    else expr_.HoldRef(ctx);

    field_ = (LMember) expr_type_.Lookup(this, ctx.class_, expr_ is Base,
                                         MemberKind.Field, name_, null, true);
    if (field_ == null)
      return null;

    if (!field_.CheckAccess(this, ctx, write, is_static, !is_static))
      return null;

    if (read) {
      // Only property reads have side effects we need to register in the control graph.
      // (For writes the caller, such as Assign, will add its own node.)
      if (field_ is Property)
        AddControl(ctx);
      if (expr_ != null)
        expr_.ReleaseRef(ctx);
    }

    return field_.Type().BaseType();
  }

  public override void ReleaseAll(Context ctx) {
    if (expr_ != null)
      expr_.ReleaseRef(ctx);
  }

  public override int Kind() {
    if (field_ is Field)
      return ExprKind.Field;
    if (field_ is Property)
      return ExprKind.Property;
    Debug.Assert(false);
    return 0;
  }

  public override GType StorageType() { return field_.Type(); }

  public override PropertyOrIndexer GetPropertyOrIndexer() { return field_ as Property; }

  public override void Eval1(Env env, out RValue ^v1, out RValue ^v2) {
    v1 = v2 = null;
    if (expr_ != null) {  // instance field
      v1 = expr_.Eval(env);
      if (v1 is Null) {
        Error("attempted to access field of null object");
        Gel.Exit();
      }
    }
  }

  public override RValue ^EvalGet(Env env, RValue ^v1, RValue ^v2) {
    GValue obj = v1 == null ? null : v1.Get();
    return LosesOwnership() && field_.Type() is Owning ? field_.Take(obj) : field_.Get(obj);
  }

  public override void EvalSet(Env env, RValue ^v1, RValue ^v2, RValue ^val) {
    GObject obj = v1 == null ? null : (GObject) v1.Get();
    field_.Set(obj, val);
  }

  public override Location EvalLocation(Env env, RValue ^v1, RValue ^v2) {
    return field_.GetLocation((GObject) v1);
  }

  string EmitPrefix() {
    return expr_ != null ?
      expr_.EmitArrow(expr_type_, field_) :  // instance access
      field_.GetClass().name_ + "::";   // static access
  }

  public override string Emit() {
    string s = EmitPrefix() + field_.Emit();
    GType t = field_.Type();
    return field_ is Property ? Hold(t, s) : s + OwnSuffix(t);
  }

  public override string EmitSet(string val) {
    return EmitPrefix() + field_.EmitSet(val);
  }

  public override string EmitLocation() {
    return "&" + EmitPrefix() + field_.Emit();
  }
}

class Mode {
  public const int In = 0,
                   Ref = 1,
                   Out = 2;

  public static string ToString(int mode) {
    switch (mode) {
      case In: return "";
      case Ref: return "ref ";
      case Out: return "out ";
      default: Debug.Assert(false); return null;
    }
  }
}

abstract class Argument : Node {
  protected GType type_;

  public GType Type() { return type_; }

  public abstract int GetMode();
  public string TypeString() { return Mode.ToString(GetMode()) + type_.ToString(); }

  public abstract bool Check(Context ctx);
  public abstract void FinishCall(Context ctx);

  public abstract void AddEval(ArrayList a, Env env, GType t);

  public abstract string Emit(GType t);
}

class InArgument : Argument {
  public readonly Expression ^expr_;

  public InArgument(Expression ^expr) { expr_ = expr; }
  public InArgument(GType type) { type_ = type; }

  public override int GetMode() { return 0; }

  public override bool Check(Context ctx) {
    if (type_ == null)
      type_ = expr_.CheckAndHold(ctx);
    return type_ != null;
  }

  public override void FinishCall(Context ctx) {
    expr_.ReleaseRef(ctx);
  }

  public override void AddEval(ArrayList a, Env env, GType t) {
    a.Add(expr_.Eval(env, t));
  }

  public override string Emit(GType t) {
    return expr_.EmitRef(type_, t);
  }
}

class RefOutArgument : Argument {
  public readonly int mode_;
  public readonly LValue ^lvalue_;

  public RefOutArgument(int mode, LValue ^lvalue) { mode_ = mode; lvalue_ = lvalue; }

  public override int GetMode() { return mode_; }

  public override bool Check(Context ctx) {
    type_ = lvalue_.Check(ctx, mode_ == Mode.Ref, true, false);
    if (type_ == null)
      return false;
    if (lvalue_.Kind() == ExprKind.Indexer) {
      Error("can't pass indexer as ref or out argument");
      return false;
    }
    return true;
  }

  public override void FinishCall(Context ctx) {
    AddControl(ctx);
  }

  public override bool Sets(Local local) { return lvalue_.IsLocal(local); }

  public override TypeSet NodeDestroys() { return lvalue_.StorageType().VarDestroys(); }

  public GType StorageType() { return lvalue_.StorageType(); }

  public override void AddEval(ArrayList a, Env env, GType t) {
    a.Add(new LocationRef(lvalue_.EvalLocation(env)));
  }

  public override string Emit(GType t) { return lvalue_.EmitLocation(); }
}

class Invocation : Expression {
  Expression ^obj_;    // may be null
  GType obj_type_;
  string name_;
  ArrayList /* of Argument */ ^arguments_;

  Method method_;

  public Invocation(Expression ^obj, string name, ArrayList ^arguments) {
    obj_ = obj; name_ = name; arguments_ = arguments;
  }

  public static Method CheckInvoke(Node caller, Context ctx, bool through_base, GType type,
                                   string name, ArrayList /* of Argument */ arguments,
                                   int kind) {
    foreach (Argument arg in arguments)
      if (!arg.Check(ctx))
        return null;

    // Add the caller to the graph; this node represents the invocation itself.
    caller.AddControl(ctx);

    // Now we can release temporary expressions and add control graph nodes representing
    // assignments to ref and out parameters.
    foreach (Argument arg in arguments)
      arg.FinishCall(ctx);

    Method m = (Method) type.Lookup(caller, ctx.class_, through_base, kind, name, arguments, true);
    if (m != null)
      for (int i = 0; i < m.parameters_.Count; ++i) {
        Parameter p = m.Param(i);
        if (p.GetMode() == Mode.In) {
          InArgument a = (InArgument) arguments[i];
          a.expr_.CheckLoseOwnership(a.Type(), p.Type());
        }
      }
    return m;
  }

  public override GType Check(Context ctx) {
    GType t;
    bool is_class = false;  // true when calling a static method using a class name

    if (obj_ == null)
      t = ctx.class_;
    else {
      t = obj_type_ = obj_.Check(ctx, true, false, true);
      if (t == null)
        return null;
      if (obj_.Kind() == ExprKind.Type)
        is_class = true;
      else obj_.HoldRef(ctx);
    }

    method_ = CheckInvoke(this, ctx, obj_ is Base, t, name_, arguments_, MemberKind.Method);
    if (method_ == null)
      return null;

    if (method_ is Constructor) {
      Error("can't call constructor directly");
      return null;
    }

    if (obj_ == null) {
      if (!method_.IsStatic() && ctx.IsStatic()) {
        Error("can't call instance method in static context");
        return null;
      }
    } else {
      obj_.ReleaseRef(ctx);
      if (is_class) {
        if (!method_.IsStatic()) {
          Error("can't invoke non-static method through class name");
          return null;
        }
      } else {
        if (method_.IsStatic()) {
          Error("can't invoke static method through object");
          return null;
        }
      }
    }

    GType ret = method_.ReturnType();
    if (ret is Owning)
      ctx.AddTemporary(this);
    return ret;
  }

  public override GType TemporaryType() { return method_.ReturnType(); }

  public override Method Calls() { return method_; }

  public static RValue ^InvokeMethod(GValue obj, Method m, ArrayList /* of RValue */ values,
                                    bool virtual_ok) {
    if (m.IsVirtual() && virtual_ok) {
      GType t = obj.Type();
      m = (Method) t.FindMatchingMember(m, true);
      Debug.Assert(m != null);
    }
    return m.Invoke(obj, values);
  }

  public static RValue ^CallMethod(Env env, GValue obj,
                                  Method m, ArrayList /* of Argument */ args,
                                  bool virtual_ok) {
    ArrayList /* of ValueOrLocation */ ^values = new ArrayList();
    int i;
    for (i = 0 ; i < args.Count ; ++i) {
      Argument a = (Argument) args[i];
      a.AddEval(values, env, m.Param(i).Type());
    }
    return InvokeMethod(obj, m, values, virtual_ok);
  }

  public RValue ^Eval(Env env, Expression obj, Method m, ArrayList /* of Argument */ args) {
    RValue ^r;
    GValue v;
    if (m.IsStatic())
      v = null;
    else {
      if (obj == null)
        v = env.this_;
      else {
        r = obj.Eval(env);
        v = r.Get();
        if (v is Null) {
          Error("attempted to call method on null object");
          Gel.Exit();
        }
      }
    }

    return CallMethod(env, v, m, args, !(obj is Base));
  }

  public override RValue ^Eval(Env env) {
    return Eval(env, obj_, method_, arguments_);
  }

  public static string EmitArguments(Method m, ArrayList /* of Argument */ arguments) {
    StringBuilder ^sb = new StringBuilder();
    Debug.Assert(m.parameters_.Count == arguments.Count);
    for (int i = 0; i < arguments.Count; ++i) {
      if (i > 0)
        sb.Append(", ");
      Argument a = (Argument)arguments[i];
      sb.Append(a.Emit(m.Param(i).Type()));
    }
    return sb.ToString();
  }

  public override string Emit() {
    StringBuilder ^sb = new StringBuilder();
    if (obj_ != null) {
      if (method_.IsStatic())
        sb.AppendFormat("{0}::", obj_.Emit());
      else if (obj_type_.IsReference())
        sb.Append(obj_.EmitArrow(obj_type_, method_));
      else sb.AppendFormat("({0})->", obj_.Emit(obj_type_, GObject.type_));   // box values
    }
    sb.AppendFormat("{0} ({1})", method_.name_, EmitArguments(method_, arguments_));
    return Hold(method_.ReturnType(), sb.ToString());
  }
}

// an expression of the form a[b]
class Sub : LValue {
  readonly Expression ^base_;
  GType base_type_;
  readonly Expression ^index_;
  GType index_type_;

  GType element_type_;    // for array accesses; null for indexers
  Indexer indexer_;

  public Sub(Expression ^base_exp, Expression ^index) { base_ = base_exp; index_ = index; }

  public override GType Check(Context ctx, bool read, bool write, bool type_ok) {
    base_type_ = base_.CheckAndHold(ctx);
    if (base_type_ == null)
      return null;

    index_type_ = index_.CheckAndHold(ctx);
    if (index_type_ == null)
      return null;

    if (read)
      ReleaseAll(ctx);

    ArrayType at = base_type_.BaseType() as ArrayType;
    if (at != null) {
      if (!index_type_.CheckConvert(this, GInt.type_))
        return null;
      element_type_ = at.ElementType();
      return element_type_.BaseType();
    }

    ArrayList ^arguments = new ArrayList();
    arguments.Add(new InArgument(index_type_));

    indexer_ = (Indexer) base_type_.Lookup(this, ctx.class_, base_ is Base,
                                           MemberKind.Indexer, null, arguments, true);
    if (indexer_ == null)
      return null;

    if (read && !indexer_.CheckAssigning(this, ctx, false) ||
        write && !indexer_.CheckAssigning(this, ctx, true))
      return null;

    if (read)
      AddControl(ctx);

    return indexer_.Type();
  }

  public override void ReleaseAll(Context ctx) {
    base_.ReleaseRef(ctx);
    index_.ReleaseRef(ctx);
  }

  public override int Kind() {
    return element_type_ != null ? ExprKind.Field : ExprKind.Indexer;
  }

  public override GType StorageType() {
    return element_type_ != null ? element_type_ : indexer_.Type();
  }

  public override PropertyOrIndexer GetPropertyOrIndexer() { return indexer_; }

  public override void Eval1(Env env, out RValue ^v1, out RValue ^v2) {
    v1 = base_.Eval(env);
    if (v1 is Null) {
      Error("attempted array or indexer access through null");
      Gel.Exit();
    }
    v2 = index_.Eval(env);
  }

  int Index(RValue ^v) {
    // ++ We get an ownership error if we combine the following two lines into one; why?
    v = v.Get().Convert(ref v, GInt.type_);
    return ((GInt) v).i_;
  }

  public override RValue ^EvalGet(Env env, RValue ^v1, RValue ^v2) {
    if (indexer_ == null) {
      GArray arr = (GArray) v1.Get();
      int i = Index(v2);
      return LosesOwnership() && element_type_ is Owning ? arr.Take(i) : arr.Get(i);
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    return Invocation.InvokeMethod(v1.Get(), indexer_.Getter(), args, true);
  }

  public override void EvalSet(Env env, RValue ^v1, RValue ^v2, RValue ^val) {
    if (indexer_ == null) {
      ((GArray) v1.Get()).Set(Index(v2), val);
      return;
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    args.Add(val);
    Invocation.InvokeMethod(v1.Get(), indexer_.Setter(), args, true);
  }

  public override Location EvalLocation(Env env, RValue ^v1, RValue ^v2) {
    int i = ((GInt) v2).i_;
    return ((GArray) v1).GetLocation(i);
  }

  string EmitBase() {
    return base_.EmitArrow(base_type_, indexer_);
  }

  string EmitIndex() {
    return index_.Emit(index_type_, indexer_ != null ? indexer_.parameter_.Type() : GInt.type_);
  }

  public override string Emit() {
    string get = String.Format("{0}get_Item({1})", EmitBase(), EmitIndex());
    if (element_type_ != null) {
      get = get + OwnSuffix(element_type_);
      if (!element_type_.IsValue())
        get = String.Format("static_cast<{0} >({1})", element_type_.EmitExprType(), get);
      return get;
    } else return Hold(indexer_.Type(), get);
  }

  public override string EmitSet(string val) {
    return String.Format(element_type_ != null ? "{0}get_Item({1}) = {2}" : "{0}set_Item({1}, {2})",
       EmitBase(), EmitIndex(), val);
  }

  public override string EmitLocation() {
    return String.Format("{0}get_location({1})", EmitBase(), EmitIndex());
  }
}

class This : Expression {
  public override GType Check(Context ctx) {
    if (ctx.IsStatic()) {
      Error("can't access this in a static context");
      return null;
    }
    return ctx.class_;
  }

  public override RValue ^Eval(Env env) {
    return new Reference(env.this_);
  }

  public override string Emit() { return "this"; }
}

class Base : Expression {
  Class parent_;

  public override GType Check(Context ctx) {
    if (ctx.IsStatic()) {
      Error("can't access base in a static context");
      return null;
    }
    parent_ = ctx.class_.Parent();
    if (parent_ == null) {
      Error("can't access base: class has no parent");
      return null;
    }
    return parent_;
  }

  public override RValue ^Eval(Env env) {
    return new Reference(env.this_);
  }

  public override string Emit() { return "this"; }

  public override string EmitArrow(GType t, Member m) {
    return m.GetClass().name_ + "::"; 
  }
}

class New : Expression {
  Expression ^creator_;    // either a pool or null
  TypeExpr ^type_expr_;
  ArrayList /* of Expression */ ^arguments_;

  Class class_;
  Constructor constructor_;

  public New(Expression ^creator, TypeExpr ^expr, ArrayList ^arguments) {
    creator_ = creator;
    type_expr_ = expr;
    arguments_ = arguments;
  }

  GType Type() {
    return creator_ == null ? (GType) class_.OwningType() : class_;
  }

  public override GType TemporaryType() { return Type(); }    

  public override GType Check(Context ctx) {
    if (creator_ != null) {
      GType c = creator_.Check(ctx);
      if (c == null)
        return null;
      if (!c.BaseType().IsSubtype(PoolClass.instance_)) {
        Error("object creator must be a pool");
        return null;
      }
    }
    GType t = type_expr_.Resolve(ctx.program_);
    if (t == null)
      return null;
    class_ = (Class) t;
    if (class_.HasAttribute(Attribute.Abstract)) {
      Error("can't instantiate abstract class");
      return null;
    }
    if (creator_ != null) {
      class_.NeedDestroy(); // every pool-allocated class needs the _Destroy1 and _Destroy2 methods
      class_.SetVirtual();  // every pool-allocated class must be virtual
    }

    constructor_ = (Constructor) Invocation.CheckInvoke(this, ctx, false, class_,
                                      class_.name_, arguments_, MemberKind.Constructor);
    if (constructor_ == null)
      return null;

    GType type = Type();
    if (type is Owning)
      ctx.AddTemporary(this);
    return type;
  }

  public override Method Calls() { return constructor_; }

  public override RValue ^Eval(Env env) {
    GValue ^obj = class_.New();
    Invocation.CallMethod(env, obj, constructor_, arguments_, false);
    return obj;
  }

  public override string Emit() {
    string args = Invocation.EmitArguments(constructor_, arguments_);

    return creator_ == null ?
      EmitAllocate(class_.name_, args, LosesOwnership()) :
      String.Format("new ({0}->Alloc(sizeof({1}))) {1}({2})", creator_.Emit(), class_.name_, args);
  }
}

class ArrayInitializer : Expression {
  public readonly ArrayList /* of Expression */ ^initializers_;

  public ArrayInitializer(ArrayList ^initializers) { initializers_ = initializers; }

  public override GType Check(Context ctx) {
    Error("only static fields may have array initializers");
    return null;
  }

  public bool CheckElements(Context ctx, GType element_type) {
    foreach (Expression e in initializers_)
      if (!e.CheckConstant() || !e.Check(ctx, element_type))
        return false;
    return true;
  }

  public override RValue ^Eval(Env env) { Debug.Assert(false); return null; }

  public GArray ^Eval(ArrayType type) {
    GArray ^a = new GArray(type, initializers_.Count);
    for (int i = 0; i < initializers_.Count; ++i) {
      Expression e = (Expression) initializers_[i];
      a.Set(i, e.Eval(Env.static_, type.ElementType()));
    }
    return a;
  }

  public override string Emit() { Debug.Assert(false); return null; }

  public void Emit(SourceWriter w) {
    int count = initializers_.Count;
    int per_row = 12;

    w.Write("{ ");
    if (count > per_row) {    // format onto multiple rows
      w.WriteLine("");
      w.AddIndent();
      w.Indent();
    }
    for (int i = 0; i < count; ++i) {
      if (i > 0) {
        w.Write(", ");
        if (i % per_row == 0) {
          w.WriteLine("");
          w.Indent();
        }
      }
      Expression e = (Expression) initializers_[i];
      SimpleValue ^v = (SimpleValue) e.Eval(Env.static_);
      w.Write(v.Emit());
    }
    if (count > per_row) {
      w.SubIndent();
      w.WriteLine("");
    }
    w.Write(" }");
  }
}

class NewArray : Expression {
  TypeExpr ^element_type_expr_;
  int dimensions_;
  ArrayType ^array_type_;

  Expression ^count_;

  public NewArray(TypeExpr ^element_type_expr, int dimensions, Expression ^count) {
    element_type_expr_ = element_type_expr;
    dimensions_ = dimensions;
    count_ = count;
  }

  GType Type() {
    return (GType) array_type_.OwningType();
  }

  public override GType TemporaryType() { return Type(); }

  public override GType Check(Context ctx) {
    if (element_type_expr_ is ArrayTypeExpr) {
      Error("syntax error in new expression");
      return null;
    }
    for (int i = 0; i < dimensions_; ++i)
      element_type_expr_ = new ArrayTypeExpr(take element_type_expr_);
    GType element_type = element_type_expr_.Resolve(ctx.program_);
    if (element_type == null)
      return null;
    array_type_ = new ArrayType(element_type);

    if (!count_.Check(ctx, GInt.type_))
      return null;

    GType t = Type();
    if (t is Owning)
      ctx.AddTemporary(this);
    return t;
  }

  public override RValue ^Eval(Env env) {
    return new GArray(array_type_, count_.EvalInt(env));
  }

  public override string Emit() {
    GType t = array_type_.ElementType();
    string array_type = GType.ConstructType(
      t is Owning ? "_Array" : "_CopyableArray",
      t.EmitGenericType());
    string args = String.Format("&typeid({0}), {1}", t.EmitType(), count_.Emit());
    return EmitAllocate(array_type, args, LosesOwnership());
  }
}

abstract class Unary : Expression {
  protected Expression ^exp_;

  protected Unary(Expression ^e) { exp_ = e; }

  public override bool IsConstant() { return exp_.IsConstant(); }
}

// unary minus operator
class Minus : Unary {
  GType type_;

  public Minus(Expression ^e) : base(e) { }

  public override GType Check(Context ctx) {
    type_ = exp_.Check(ctx);
    if (type_ != GInt.type_ && type_ != GFloat.type_ && type_ != GDouble.type_) {
      Error("- operator cannot be applied to value of type {0}", type_);
      return null;
    }
    return type_;
  }

  public override RValue ^Eval(Env env) {
    if (type_ == GInt.type_) {
    int i = exp_.EvalInt(env);
    return new GInt(-i);
  }
    if (type_ == GFloat.type_) {
      float f = exp_.EvalFloat(env);
      return new GFloat(-f);
    }
    if (type_ == GDouble.type_) {
      double d = exp_.EvalDouble(env);
      return new GDouble(-d);
    }
    Debug.Assert(false);
    return null;
  }

  public override string Emit() { return "-" + exp_.Emit(); }
}

class Not : Unary {
  public Not(Expression ^e) : base(e) { }

  public override GType Check(Context ctx) {
    return exp_.Check(ctx, GBool.type_) ? GBool.type_ : null;
  }

  public override RValue ^Eval(Env env) {
    bool b = exp_.EvalBool(env);
    return new GBool(!b);
  }

  public override string Emit() { return "!" + exp_.Emit(); }
}

// the bitwise complement (~) operator
class Complement : Unary {
  public Complement(Expression ^e) : base(e) { }

  public override GType Check(Context ctx) {
    return exp_.Check(ctx, GInt.type_) ? GInt.type_ : null;
  }

  public override RValue ^Eval(Env env) {
    int i = exp_.EvalInt(env);
    return new GInt(~i);
  }

  public override string Emit() { return "~" + exp_.Emit(); }
}

class IncDec : Expression {
  bool pre_;    // true for pre-increment/decrement; false for post-increment/decrement
  bool inc_;
  LValue ^lvalue_;

  public IncDec(bool pre, bool inc, LValue ^lvalue) { pre_ = pre; inc_ = inc; lvalue_ = lvalue; }

  public override GType Check(Context ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    GType t = lvalue_.Check(ctx, true, true, false);
    if (t == null)
      return null;
    if (lvalue_.Kind() == ExprKind.Indexer) {
      Error("++ and -- can't yet operate on indexers");
      return null;
    }
    if (t != GInt.type_) {
      Error("++ and -- can operate only on integers");
      return null;
    }
    return GInt.type_;
  }

  public override RValue ^Eval(Env env) {
    Location loc = lvalue_.EvalLocation(env);
    GInt ^i = (GInt) take loc.value_;
    loc.value_ = new GInt(inc_ ? i.i_ + 1 : i.i_ - 1);
    return pre_ ? ((GInt) loc.value_).Copy() : i;
  }

  string EmitOp() { return inc_ ? "++" : "--"; }

  public override string Emit() {
    return pre_ ? EmitOp() + lvalue_.Emit() : lvalue_.Emit() + EmitOp();
  }
}

abstract class Conversion : Expression {
  protected Expression ^expr_;
  protected TypeExpr ^type_expr_;

  protected GType from_base_;
  protected GType to_type_, to_base_;

  protected Conversion(Expression ^expr, TypeExpr ^type_expr) {
    expr_ = expr; type_expr_ = type_expr;
  }

  protected bool CheckConversion(Context ctx, bool subtype_only) {
    GType from = expr_.Check(ctx);
    if (from == null)
      return false;
    from_base_ = from.BaseType();

    to_base_ = type_expr_.Resolve(ctx.program_);
    if (to_base_ == null)
      return false;
    if (!to_base_.IsValue() &&
       (from is Owning || from_base_.IsValue()))
      to_type_ = to_base_.OwningType();
    else to_type_ = to_base_;

    if (!from.CanConvertExplicit(to_type_, subtype_only)) {
      Error("can't convert from {0} to {1}", from_base_, to_base_);
      return false;
    }
    return true;
  }
}

class Cast : Conversion {
  public Cast(Expression ^expr, TypeExpr ^type_expr) : base(expr, type_expr) { }

  public override Local GetLocal() { return expr_.GetLocal(); }
  
  public override GType Check(Context ctx) {
    return CheckConversion(ctx, false) ? to_type_ : null;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind.Local ? ExprKind.Local : ExprKind.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue ^Eval(Env env) {
    RValue ^r = expr_.Eval(env);
    return r.Get().ConvertExplicit(ref r, to_base_);
  }

  public override string Emit() {
    return expr_.EmitExplicit(from_base_, to_type_);
  }
}

class Binary : Expression {
  int op_;
  Expression ^left_, right_;
  GType left_type_, right_type_;
  GType type_;

  const int CONCATENATE = 0;

  public Binary(Expression ^left, int op, Expression ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public static GType Promote(Syntax caller, GType left, int op, GType right) {
    if (left.CanConvert(GInt.type_) && right.CanConvert(GInt.type_))
      return GInt.type_;
    if (left.CanConvert(GFloat.type_) && right.CanConvert(GFloat.type_))
      return GFloat.type_;
    if (left.CanConvert(GDouble.type_) && right.CanConvert(GDouble.type_))
      return GDouble.type_;
    caller.Error("can't apply operator {0} to operands of type {1} and {2}", OpName(op), left, right);
    return null;
  }

  bool CheckIntArgs() {
    if (left_type_.CheckConvert(this, GInt.type_) && right_type_.CheckConvert(this, GInt.type_)) {
      type_ = GInt.type_;
      return true;
    }
    return false;
  }

  public override GType Check(Context ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);

    if (op_ == '+' && (left_type_ == GString.type_ || right_type_ == GString.type_)) {
      op_ = CONCATENATE;

      // If we'll be calling ToString() on a class, ensure that it will inherit from
      // Object in generated code.
      if (left_type_ != GString.type_)
        left_type_.CanConvert(GObject.type_);
      if (right_type_ != GString.type_)
        right_type_.CanConvert(GObject.type_);

      return GString.type_;
    }

    switch (op_) {
      case '*':
      case '/':
      case '+':
      case '-':
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_;

      case '%':
      case Parser.OP_LEFT_SHIFT:
      case Parser.OP_RIGHT_SHIFT:
        return CheckIntArgs() ? GInt.type_ : null;

      case '&':
      case '|':
        if (left_type_ == GBool.type_ && right_type_ == GBool.type_)
          type_ = GBool.type_;
        else {
          if (!CheckIntArgs())
            return null;
          type_ = GInt.type_;
        }
        return type_;

      case '<':
      case Parser.OP_LE:
      case '>':
      case Parser.OP_GE:
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_ == null ? null : GBool.type_;

      default:
        Debug.Assert(false);
        return null;
    }
  }

  public static GBool ^BoolOp(bool x, int op, bool y) {
    switch (op) {
      case '&': return new GBool(x & y);
      case '|': return new GBool(x | y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue ^IntOp(int x, int op, int y) {
    switch (op) {
      case '*': return new GInt(x * y);
      case '/': return new GInt(x / y);
      case '%': return new GInt(x % y);
      case '+': return new GInt(x + y);
      case '-': return new GInt(x - y);
      case Parser.OP_LEFT_SHIFT: return new GInt(x << y);
      case Parser.OP_RIGHT_SHIFT: return new GInt(x >> y);
      case '&': return new GInt(x & y);
      case '|': return new GInt(x | y);
      case '<': return new GBool(x < y);
      case Parser.OP_LE: return new GBool(x <= y);
      case '>': return new GBool(x > y);
      case Parser.OP_GE: return new GBool(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue ^FloatOp(float x, int op, float y) {
    switch (op) {
      case '*': return new GFloat(x * y);
      case '/': return new GFloat(x / y);
      case '+': return new GFloat(x + y);
      case '-': return new GFloat(x - y);
      case '<': return new GBool(x < y);
      case Parser.OP_LE: return new GBool(x <= y);
      case '>': return new GBool(x > y);
      case Parser.OP_GE: return new GBool(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue ^DoubleOp(double x, int op, double y) {
    switch (op) {
      case '*': return new GDouble(x * y);
      case '/': return new GDouble(x / y);
      case '+': return new GDouble(x + y);
      case '-': return new GDouble(x - y);
      case '<': return new GBool(x < y);
      case Parser.OP_LE: return new GBool(x <= y);
      case '>': return new GBool(x > y);
      case Parser.OP_GE: return new GBool(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public override RValue ^Eval(Env env) {
    if (op_ == CONCATENATE)
      return new GString(left_.Eval(env).ToString() + right_.Eval(env).ToString());

    if (type_ == GBool.type_)
      return BoolOp(left_.EvalBool(env), op_, right_.EvalBool(env));
    if (type_ == GInt.type_)
      return IntOp(left_.EvalInt(env), op_, right_.EvalInt(env));
    if (type_ == GFloat.type_)
      return FloatOp(left_.EvalFloat(env), op_, right_.EvalFloat(env));
    if (type_ == GDouble.type_)
      return DoubleOp(left_.EvalDouble(env), op_, right_.EvalDouble(env));

    Debug.Assert(false);
    return null;
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  static string OpName(int op) {
    switch (op) {
      case Parser.OP_LEFT_SHIFT: return "<<";
      case Parser.OP_RIGHT_SHIFT: return ">>";
      case Parser.OP_LE: return "<=";
      case Parser.OP_GE: return ">=";
      default: return ((char) op).ToString();
    }
  }

  public override string Emit() {
    if (op_ == CONCATENATE)
      return Hold(GString.type_,
        String.Format("String::_Concat({0}, {1})",
          left_.EmitRef(left_type_, GObject.type_), right_.Emit(right_type_, GObject.type_)));

    return String.Format("{0} {1} {2}",
      left_.EmitRef(left_type_), OpName(op_), right_.Emit() );
  }
}

class Equality : Expression {
  bool equal_;    // true for ==, false for !=
  Expression ^left_, right_;
  GType left_type_, right_type_, type_;

  public Equality(Expression ^left, int op, Expression ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_EQUAL: equal_ = true; break;
      case Parser.OP_NE: equal_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType Check(Context ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);
    if (left_type_.IsReference() != right_type_.IsReference()) {
      Error("can't compare types {0} and {1}", left_type_, right_type_);
      return null;
    }
    type_ = left_type_.BaseType().CommonType(this, right_type_.BaseType());
    return type_ == null ? null : GBool.type_;
  }

  public override RValue ^Eval(Env env) {
    RValue ^left = left_.Eval(env, type_);
    RValue ^right = right_.Eval(env, type_);
    bool eq = left.Get().DefaultEquals(right.Get());
    return new GBool(equal_ ? eq : !eq);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    string emit_left = left_.EmitRef(left_type_);
    string emit_right = right_.Emit();
    if (type_ == GString.type_)
      return String.Format("{0}String::_Equals({1}, {2})",
                           equal_ ? "" : "!", emit_left, emit_right);
    return String.Format("{0} {1} {2}", emit_left, equal_ ? "==" : "!=", emit_right);
  }
}

class Is : Conversion {
  public Is(Expression ^expr, TypeExpr ^type_expr) : base(expr, type_expr) { }

  public override GType Check(Context ctx) {
    return CheckConversion(ctx, true) ? GBool.type_ : null;
  }

  public override RValue ^Eval(Env env) {
    RValue ^r = expr_.Eval(env);
    GValue v = r.Get();
    return new GBool(!(v is Null) && v.Type().IsSubtype(to_base_));
  }

  public override string Emit() {
    if (from_base_.IsReference()) {
      Class c = (Class) to_base_;
      return String.Format("dynamic_cast<{0} *>({1}) != 0", c.name_, expr_.Emit());
    }
    return to_base_ == from_base_ || to_base_ == GObject.type_ ? "true" : "false";
  }
}

class As : Conversion {
  public As(Expression ^expr, TypeExpr ^type_expr) : base(expr, type_expr) { }

  public override Local GetLocal() { return expr_.GetLocal(); }

  public override GType Check(Context ctx) {
    if (!CheckConversion(ctx, true))
      return null;
    if (!to_base_.IsReference()) {
      Error("as operator must convert to reference type");
      return null;
    }
    return to_type_;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind.Local ? ExprKind.Local : ExprKind.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue ^Eval(Env env) {
    RValue ^r = expr_.Eval(env);
    return r.Get().Type().IsSubtype(to_base_) ? r : Null.Instance.Copy();
  }

  public override string Emit() {
    if (from_base_.CanConvert(to_base_))
      return expr_.Emit(from_base_, to_base_);
    Class c = (Class) to_base_;
    return String.Format("dynamic_cast<{0} *>({1})", c.name_, expr_.Emit());
  }
}

// a && or || operator
class LogicalOp : Expression {
  bool and_;  // true => &&, false => ||
  Expression ^left_, right_;
  Joiner ^join_ = new Joiner();

  public LogicalOp(Expression ^left, int op, Expression ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_AND: and_ = true; break;
      case Parser.OP_OR: and_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType Check(Context ctx) {
    if (!left_.Check(ctx, GBool.type_))
      return null;

    join_.Join(ctx.Prev());
    if (!right_.Check(ctx, GBool.type_))
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    return GBool.type_;
  }

  public override RValue ^Eval(Env env) {
    bool left = left_.EvalBool(env);
    bool b = and_ ? left && right_.EvalBool(env) : left || right_.EvalBool(env);
    return new GBool(b);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    return String.Format("{0} {1} {2}", left_.Emit(), and_ ? "&&" : "||", right_.Emit());
  }

}

// the ?: operator
class Conditional : Expression {
  Expression ^condition_;
  Expression ^if_true_, if_false_;

  GType true_type_, false_type_;
  GType type_;
  Joiner ^join_ = new Joiner();

  public Conditional(Expression ^condition, Expression ^if_true, Expression ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override GType Check(Context ctx) {
    if (!condition_.Check(ctx, GBool.type_))
      return null;

    Control c = ctx.Prev();

    true_type_ = if_true_.Check(ctx);
    if (true_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    false_type_ = if_false_.Check(ctx);
    if (false_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    type_ = true_type_.CommonType(this, false_type_);
    return type_;
  }

  public override int Kind() {
    return if_true_.Kind() == ExprKind.Local && if_false_.Kind() == ExprKind.Local ? ExprKind.Local : ExprKind.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    if_true_.LoseOwnership();
    if_false_.LoseOwnership();
  }

  public override RValue ^Eval(Env env) {
    return condition_.EvalBool(env) ? if_true_.Eval(env, type_) : if_false_.Eval(env, type_);
  }

  public override string Emit() {
    return String.Format("{0} ? {1} : {2}", condition_.Emit(),
                         if_true_.Emit(true_type_, type_), if_false_.Emit(false_type_, type_));
  }
}

class Assign : Expression {
  LValue ^left_;
  Expression ^right_;

  GType left_type_, right_type_;

  public Assign(LValue ^left, Expression ^right) {
    left_ = left; right_ = right;
  }

  public static bool CheckAssign(Syntax caller, GType left_type, Expression right, GType right_type) {
    if (!right_type.CheckConvert(caller, left_type,
      right.Kind() == ExprKind.Local ? ConversionContext.AssignVar : ConversionContext.Other))
      return false;
    right.CheckLoseOwnership(right_type, left_type);
    return true;
  }

  public override GType Check(Context ctx) {
    left_type_ = left_.Check(ctx, false, true, false);
    if (left_type_ == null)
      return null;

    right_type_ = right_.Check(ctx, true, false, false);
    if (right_type_ == null || !CheckAssign(this, left_.StorageType(), right_, right_type_))
      return null;
    right_.HoldRef(ctx);

    AddControl(ctx);
    left_.ReleaseAll(ctx);
    right_.ReleaseRef(ctx);
    return left_type_;
  }

  public override Method Calls() {
    PropertyOrIndexer pi = left_.GetPropertyOrIndexer();
    return pi == null ? null : pi.Setter();
  }

  public override bool Sets(Local local) { return left_.IsLocal(local); }

  public override TypeSet NodeDestroys() {
    return left_.GetPropertyOrIndexer() != null ? TypeSet.empty_ : left_.StorageType().VarDestroys();
  }

  public override RValue ^Eval(Env env) {
    RValue ^v1, v2;
    left_.Eval1(env, out v1, out v2);
    RValue ^val = right_.Eval(env, left_type_);
    RValue ^ret = val.CopyRef();
    left_.EvalSet(env, v1, v2, val);
    return ret;
  }

  public override string Emit() {
    return left_.EmitSet(right_.EmitRef(right_type_, left_type_));
  }
}

// a compound assignment operator such as += or -=
class CompoundAssign : Expression {
  LValue ^left_;
  int op_;
  Expression ^right_;

  GType type_;

  public CompoundAssign(LValue ^left, int op, Expression ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public override GType Check(Context ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    type_ = left_.Check(ctx, true, true, false);
    if (type_ == null)
      return null;
    if (left_.Kind() == ExprKind.Indexer) {
      Error("compound assignments don't yet work on indexers");
      return null;
    }
    if (type_ == GBool.type_ && (op_ == '&' || op_ == '|')) {
      if (!right_.Check(ctx, GBool.type_))
        return null;
      return type_;
    }
    if (type_ != GInt.type_ && type_ != GFloat.type_ && type_ != GDouble.type_) {
      Error("compound assignment operator {0}= can't operate on object of type {1}", (char) op_, type_);
      return null;
    }
    if (!right_.Check(ctx, type_))
      return null;
    return type_;
  }

  public override RValue ^Eval(Env env) {
    Location loc = left_.EvalLocation(env);
    if (type_ == GBool.type_) {
      bool x = ((GBool) loc.value_).b_;
      bool y = right_.EvalBool(env);
      loc.value_ = Binary.BoolOp(x, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GInt.type_) {
      GInt x = (GInt) loc.value_;
      int y = right_.EvalInt(env);
      loc.value_ = Binary.IntOp(x.i_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GFloat.type_) {
      GFloat x = (GFloat) loc.value_;
      float y = right_.EvalFloat(env);
      loc.value_ = Binary.FloatOp(x.f_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GDouble.type_) {
      GDouble x = (GDouble) loc.value_;
      double y = right_.EvalDouble(env);
      loc.value_ = Binary.DoubleOp(x.d_, op_, y);
      return loc.value_.CopyRef();
    } else {
      Debug.Assert(false);
      return null;
    }
  }

  public override string Emit() {
    return String.Format("{0} {1}= {2}", left_.Emit(), (char) op_, right_.Emit());
  }
}

class Take : Expression {
  LValue ^exp_;
  Owning type_;

  public Take(LValue ^exp) { exp_ = exp; }

  public override GType Check(Context ctx) {
    GType t = exp_.Check(ctx);
    if (t == null)
      return null;
    type_ = exp_.StorageType() as Owning;
    if (type_ == null) {
      Error("take must be applied to owning pointer");
      return null;
    }
    exp_.LoseOwnership();
    ctx.AddTemporary(this);
    return type_;
  }

  public override GType TemporaryType() { return type_; }

  public override RValue ^Eval(Env env) {
    RValue ^v = exp_.Eval(env);
    exp_.EvalSet(env, Null.Instance.Copy());
    return v;
  }

  public override string Emit() {
    return Hold(exp_.StorageType(), exp_.Emit());
  }
}

abstract class Statement : Node {
  public abstract bool Check(Context ctx);
  public abstract RValue ^Eval(Env env);

  public abstract void Emit(SourceWriter w);

  public virtual void EmitEmbedded(SourceWriter w) {
    w.WriteLine("");
    w.AddIndent();
    w.Indent();
    Emit(w);
    w.SubIndent();
  }

  public virtual void EmitInExistingBlock(SourceWriter w) {
    w.Indent();
    Emit(w);
  }
}

class StatementList {
  public readonly ArrayList /* of Statement */ ^statements_ = new ArrayList();

  public void Add(Statement ^s) { statements_.Add(s); }

  public bool Check(Context ctx) {
    bool ok = true;
    foreach (Statement s in statements_)
      ok &= s.Check(ctx);
    return ok;
  }

  public RValue ^Eval(Env env) {
    foreach (Statement s in statements_) {
      RValue ^v = s.Eval(env);
      if (v != null)
        return v;
    }
    return null;
  }

  public void Emit(SourceWriter w) {
    foreach (Statement s in statements_) {
      w.Indent();
      s.Emit(w);
    }
  }
}

class EmptyStatement : InlineStatement {
  public EmptyStatement() { }

  public override bool Check(Context ctx) { return true; }
  public override RValue ^Eval(Env env) { return null; }
  public override void EmitInline(SourceWriter w) { }

  public static readonly EmptyStatement ^instance_ = new EmptyStatement();
}

// A Scoped is a statement defining one or more local variables.  If a Scoped appears in the
// control graph, then it destroys those variables when traversed.
abstract class Scoped : Statement {
  protected Local start_;   // the first local outside this statement
  protected Local top_;     // the top local defined inside this statement

  TypeSet ^destroys_;

  protected void SetStartVar(Context ctx) { start_ = top_ = ctx.var_; }
  protected void SetTopVar(Context ctx) { top_ = ctx.var_; }

  public Local GetStart() { return start_; }
  public Local GetTop() { return top_; }

  public override TypeSet NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet();
    for (Local l = top_; l != start_; l = l.next_)
        destroys_.Add(l.Type().VarDestroys());
    }
    return destroys_;
  }
}

class Block : Scoped {
  public readonly StatementList ^list_;

  public Block(StatementList ^list) { list_ = list; }

  public bool Absent() { return list_ == null; }

  public override bool Check(Context ctx) {
    Context ^ctx1 = new Context(ctx);   // don't pass declarations outside block
    SetStartVar(ctx1);

    if (!list_.Check(ctx1))
      return false;

    SetTopVar(ctx1);

    // Add this Block to the control graph; this represents the destruction of variables
    // within the block at block exit.
    AddControl(ctx1);

    return true;
  }

  public override RValue ^Eval(Env env) {
    return list_.Eval(new Env(env));
  }

  public static Block ^EmptyBlock() { return new Block(new StatementList()); }

  public override void Emit(SourceWriter w) {
    w.OpenBrace();
    list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitEmbedded(SourceWriter w) {
    w.Write(" ");
    Emit(w);
  }

  public override void EmitInExistingBlock(SourceWriter w) {
    list_.Emit(w);
  }
}

class MemberKind {
  public const int
    Field = 0,
    Method = 1,
    Property = 2,
    Indexer = 3,
    Constructor = 4;
}

class Named : Node {
  public readonly TypeExpr ^type_expr_;   // may be null for certain objects such as constructors
  protected GType type_;

  public readonly string name_;

  public Named(TypeExpr ^type_expr, string name) {
    type_expr_ = type_expr;
    name_ = name;
  }

  public GType Type() { return type_; }

  public virtual bool Resolve(Program program) {
    if (type_expr_ == null || type_ != null)
      return true;
    type_ = type_expr_.Resolve(program);
    return type_ != null;
  }
}

abstract class Member : Named {
  protected Class class_;    // containing class

  public readonly int attributes_;

  protected Member(int attributes, TypeExpr ^type_expr, string name) : base(type_expr, name) {
    attributes_ = attributes;
  }

  public abstract int Kind();

  public static string ToString(int kind) {
    switch (kind) {
      case MemberKind.Field: return "field";
      case MemberKind.Method: return "method";
      case MemberKind.Property: return "property";
      case MemberKind.Indexer: return "indexer";
      case MemberKind.Constructor: return "constructor";
      default: Debug.Assert(false); return null;
    }
  }

  public string KindString() { return ToString(Kind()); }

  protected abstract int ValidAttributes();

  public Class GetClass() { return class_; }
  public void SetClass(Class cl) { class_ = cl; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public bool IsOverride() { return HasAttribute(Attribute.Override); }

  public bool IsProtected() { return HasAttribute(Attribute.Protected); }

  public bool IsPublic() { return HasAttribute(Attribute.Public); }

  public bool IsPrivate() { return !HasAttribute(Attribute.Public | Attribute.Protected); }

  public bool IsVirtual() {
    return HasAttribute(Attribute.Virtual | Attribute.Abstract | Attribute.Override);
  }

  static ArrayList ^empty_ = new ArrayList();

  public virtual ArrayList /* of Parameter */ Parameters() { return empty_; }

  public Parameter Param(int i) {
    return (Parameter) Parameters()[i];
  }

  public bool IsAccessible(Class from_class, GType through_type, bool through_base) {
    if (IsPublic())
      return true;

    // In GEL2 (as in C# and C++), a class [from_class] can access a protected member of
    // a class C only if [from_class] is a subtype of C and the access is
    // through a subtype of [from_class].  See e.g. C# 3.5.3 "Protected Access for Instance Members".
    if (IsProtected())
      return through_base || from_class.IsSubtype(class_) && through_type.IsSubtype(from_class);

    // default private access
    return from_class == class_;
  }

  public static bool MatchKind(int kind1, int kind2) {
    return kind1 == kind2 ||
           kind1 == MemberKind.Field && kind2 == MemberKind.Property ||
           kind1 == MemberKind.Property && kind2 == MemberKind.Field;
  }

  public bool MatchSignature(Member m) {
    if (!MatchKind(Kind(), m.Kind()))
      return false;

    if (name_ != m.name_ || Parameters().Count != m.Parameters().Count)
      return false;

    int i = 0;
    foreach (Parameter p in m.Parameters()) {
      Parameter q = Param(i);
      if (!p.Match(q))
        return false;
      ++i;
    }
    return true;
  }

  public bool IsApplicable(ArrayList arguments, out int mismatches) {
    mismatches = 0;
    if (Parameters().Count != arguments.Count)
      return false;
    int i = 0;
    foreach (Argument a in arguments) {
      if (!Param(i).CanReceive(a))
        ++mismatches;
      ++i;
    }
    return true;
  }

  public void ReportMismatches(Syntax caller, ArrayList arguments) {
    Debug.Assert(Parameters().Count == arguments.Count);
    int i = 0;
    foreach (Argument a in arguments) {
      Parameter p = Param(i);
      if (!p.CanReceive(a))
        caller.Error("argument {0}: can't convert from {1} to {2}", i + 1, a.TypeString(), p.TypeString());
      ++i;
    }
  }

  protected virtual void AddOverride(Member m) { }

  bool CheckOverride(Context ctx) {
    Class parent = ctx.class_.Parent();
    Member m = parent != null ? parent.FindMatchingMember(this, false) : null;
    if (m != null) {
      if (this is Field) {
        Error("can't define field with same name as field/property in superclass");
        return false;
      }
      if (m is Field) {
        Error("can't define property with same name as field in superclass");
        return false;
      }
      if (!HasAttribute(Attribute.Override)) {
        Error("must use override keyword to override superclass {0}", KindString());
        return false;
      }
      if (HasAttribute(Attribute.Virtual)) {
        Error("{0} with override or abstract keyword cannot be marked virtual", KindString());
        return false;
      }
      if (!m.IsVirtual()) {
        Error("attempting to override non-virtual {0}", KindString());
        return false;
      }
      if (!m.Type().Equals(Type())) {
        Error("can't override {0} with different return type", KindString());
        return false;
      }
      if (m.IsPublic() != IsPublic()) {
        Error("override {0} must have same accessibility as {0} it overrides", KindString());
        return false;
      }
      m.AddOverride(this);
    } else if (HasAttribute(Attribute.Override)) {
      Error("can't find {0} to override", KindString());
      return false;
    }
    return true;
  }

  bool CheckAccessibility() {
    int n = 0;
    if ((attributes_ & Attribute.Private) != 0)
      ++n;
    if ((attributes_ & Attribute.Protected) != 0)
      ++n;
    if ((attributes_ & Attribute.Public) != 0)
      ++n;
    if (n > 1) {
      Error("only one access level (private, protected, public) may be specified");
      return false;
    }

    if (IsVirtual() && IsPrivate()) {
      Error("a virtual or abstract {0} may not be private", KindString());
      return false;
    }

    return true;
  }

  public virtual bool Check(Context ctx) {
    if (!AttributeUtil.CheckOnly(attributes_, ValidAttributes())) {
      Error("illegal {0} attribute", KindString());
      return false;
    }

    if (HasAttribute(Attribute.Abstract) && !ctx.class_.HasAttribute(Attribute.Abstract)) {
      Error("an abstract {0} can be defined only in an abstract class", KindString());
      return false;
    }

    if (name_ == class_.name_ && !(this is Constructor)) {
      Error("{0} cannot have same name as enclosing class", KindString());
      return false;
    }

    if (class_.GetMatchingMember(this) != this) {
      Error("{0} {1} appears twice in same class", KindString(), name_ != null ? name_ : "");
      return false;
    }

    return CheckOverride(ctx) && CheckAccessibility();
  }
}

// a member which represents a storage location: a field, property, or indexer
abstract class LMember : Member {
  protected LMember(int attributes, TypeExpr ^type_expr, string name)
    : base(attributes, type_expr, name) { }

  public bool IsConstOrStatic() {
    return HasAttribute(Attribute.Const | Attribute.Static);
  }

  protected bool CheckStatic(Syntax caller, bool static_ok, bool instance_ok) {
    if (!static_ok && IsConstOrStatic()) {
      caller.Error("{0} {1} is static", KindString(), name_);
      return false;
    }
    if (!instance_ok && !IsConstOrStatic()) {
      caller.Error("{0} {1} is not static", KindString(), name_);
      return false;
    }
    return true;
  }

  public abstract bool CheckAssigning(Syntax caller, Context ctx, bool assigning);

  public bool CheckAccess(Syntax caller, Context ctx, bool assigning, bool static_ok, bool instance_ok) {
    return CheckStatic(caller, static_ok, instance_ok) && CheckAssigning(caller, ctx, assigning);
  }

  public abstract Location GetLocation(GObject obj);

  // These methods are for fields and properties; indexers have their own versions which take
  // an extra index argument.
  public virtual RValue ^Get(GValue obj) { Debug.Assert(false); return null; }
  public virtual RValue ^Take(GValue obj) { Debug.Assert(false); return null; }
  public virtual void Set(GObject obj, RValue ^val)  { Debug.Assert(false); }

  public virtual string Emit()  { Debug.Assert(false); return null; }
  public virtual string EmitSet(string val)  { Debug.Assert(false); return null; }
}

class Field : LMember {
  protected Expression ^initializer_;    // or null if none
  protected GType initializer_type_;

  public Field(int attributes, TypeExpr ^type_expr, string name, Expression ^initializer)
  : base(attributes, type_expr, name) {
    initializer_ = initializer;
  }

  // Create a field for an internal class.  Such fields will never be type checked.
  public Field(GType type, string name) : this(Attribute.Public | Attribute.ReadOnly, null, name, null) {
    type_ = type;
  }

  public static Field ^New(int attributes, TypeExpr ^type_expr, string name, Expression ^initializer) {
    if ((attributes & Attribute.Static) != 0)
      return new StaticField(attributes, type_expr, name, initializer);
    if ((attributes & Attribute.Const) != 0)
      return new ConstField(attributes, type_expr, name, initializer);
    return new Field(attributes, type_expr, name, initializer);
  }

  public override int Kind() { return MemberKind.Field; }

  public Expression Initializer() { return initializer_; }

  protected virtual bool CheckInitializer(Context ctx) {
    if (initializer_ == null)
      return true;

    ctx.EnterExpression();
    initializer_type_ = initializer_.Check(ctx);
    bool b = initializer_type_ != null &&
             Assign.CheckAssign(this, type_, initializer_, initializer_type_);
    ctx.FinishExpression();
    return b;
  }

  protected override int ValidAttributes() {
    return Attribute.Const | Attribute.Private | Attribute.Protected | Attribute.Public |
           Attribute.ReadOnly | Attribute.Static;
  }

  public override bool Check(Context ctx) {
    if (!base.Check(ctx))
      return false;

    // We build up a small control graph even when checking field initializers; we do this
    // since expression-checking code uses the graph to determine when temporary
    // ref counts are needed.
    prev_ = unreachable_;
    ctx.SetPrev(this);

    bool b = CheckInitializer(ctx);

    ctx.ClearPrev();
    return b;
  }

  public override bool CheckAssigning(Syntax caller, Context ctx, bool assigning) {
    if (assigning) {
      if (HasAttribute(Attribute.Const)) {
        caller.Error("can't assign to const field");
        return false;
      }
      if (HasAttribute(Attribute.ReadOnly) &&
          (ctx.class_ != class_ || !(ctx.method_ is Constructor)) ) {
        caller.Error("readonly field {0} can only be assigned in constructor", name_);
        return false;
      }
    }
    return true;
  }

  public override RValue ^Get(GValue obj) { return obj.Get(this); }
  public override RValue ^Take(GValue obj) { return obj.Take(this); }
  public override void Set(GObject obj, RValue ^val) { obj.Set(this, val); }
  public override Location GetLocation(GObject obj) { return obj.GetLocation(this); }

  protected void WriteField(SourceWriter w, bool declaration) {
    w.Indent();
    if (declaration && IsConstOrStatic())
      w.Write("static ");
    w.Write("{0} ", type_.EmitType());
    if (this is ConstField)
      w.Write("const ");
    if (!declaration)
      w.Write("{0}::", class_.name_);
    w.Write(name_);
  }

  protected void WriteDeclaration(SourceWriter w) { WriteField(w, true); }
  protected void WriteDefinition(SourceWriter w) { WriteField(w, false); }

  public virtual void EmitDeclaration(SourceWriter w) {
    WriteDeclaration(w);
    w.WriteLine(";");
  }

  public void EmitInitializer(SourceWriter w) {
    w.IWrite("{0} = ", name_);
    if (initializer_ != null)
      w.Write(initializer_.Emit(initializer_type_, type_));
    else w.Write(type_.DefaultValue().Emit());
    w.WriteLine(";");
  }

  public virtual void Emit(SourceWriter w) { }

  public override string Emit() { return name_; }

  public override string EmitSet(string val) {
    return String.Format("{0} = {1}", name_, val);
  }
}

class StaticField : Field {
  protected Location ^loc_;

  public StaticField(int attributes, TypeExpr ^type_expr, string name, Expression ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context ctx) {
    if (!base.Check(ctx))
      return false;
    loc_ = new Location(Type().DefaultValue().Copy());
    return true;
  }

  protected override bool CheckInitializer(Context ctx) {
    ArrayInitializer ai = initializer_ as ArrayInitializer;
    if (ai != null) {
      GType type = type_;
      Owning o = type as Owning;
      type = (o != null) ? o.BaseType() : null;
      ArrayType at = type as ArrayType;
      if (at == null) {
        Error("only owning arrays may have initializers");
        return false;
      }
      return ai.CheckElements(ctx, at.ElementType());
    }

    return base.CheckInitializer(ctx);
  }

  public virtual void Init() {
    ArrayInitializer ai = initializer_ as ArrayInitializer;
    if (ai != null)
      loc_.value_ = ai.Eval((ArrayType) type_.BaseType());
    else if (initializer_ != null)
      loc_.value_ = initializer_.Eval(Env.static_, type_);
  }

  public override RValue ^Get(GValue obj) { return loc_.Get().CopyRef(); }
  public override RValue ^Take(GValue obj) { return take loc_.value_; }
  public override void Set(GObject obj, RValue ^val) { loc_.value_ = val; }
  public override Location GetLocation(GObject obj) { return loc_; }

  public override void Emit(SourceWriter w) {
    ArrayInitializer ai = initializer_ as ArrayInitializer;
    if (ai != null) {
      GType element_type = ((ArrayType) type_.BaseType()).ElementType();
      string varname = String.Format("_{0}_{1}", class_.name_, name_);
      w.Write("{0} {1}[] = ", element_type.EmitGenericType(), varname);
      ai.Emit(w);
      w.WriteLine(";");
      WriteDefinition(w);
      w.Write("(new {0}", GType.ConstructType("_StaticArray", element_type.EmitGenericType()));
      w.Write("(&typeid({0}), {1}, {2}))", element_type.EmitType(), ai.initializers_.Count, varname);
    } else {
      WriteDefinition(w);
      if (initializer_ != null)
        initializer_.EmitAsInitializer(w, initializer_type_, type_);
    }
    w.WriteLine(";");
    w.WriteLine("");
  }
}

class ConstField : Field {
  protected SimpleValue ^value_;

  public ConstField(int attributes, TypeExpr ^type_expr, string name, Expression ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context ctx) {
    if (!base.Check(ctx))
      return false;
    return initializer_.CheckConstant();
  }

  SimpleValue ^Get() {
    if (value_ == DefaultValue.instance_) {
      Error("circular dependency among constant fields");
      Gel.Exit();
    }
    if (value_ == null) {
      value_ = new DefaultValue();    // marker used to catch circular const references
      value_ = (SimpleValue)initializer_.Eval(Env.static_, type_);
    }
    return value_.Copy();
  }

  public override RValue ^Get(GValue obj) {
    return Get();
  }

  public override void Set(GObject obj, RValue ^val) { Debug.Assert(false); }
  public override Location GetLocation(GObject obj) { Debug.Assert(false); return null; }

  public override void EmitDeclaration(SourceWriter w) {
    WriteDeclaration(w);
    if (type_ is IntegralType)
      w.Write(" = {0}", Get().Emit());
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter w) {
    WriteDefinition(w);
    if (!(type_ is IntegralType)) {
      w.WriteLine(" = {0};", Get().Emit());
    }
    w.WriteLine(";");
  }
}

class ExpressionTraverser : Traverser {
  readonly Control start_;
  Local local_;
  GType type_;
  bool assign_;
  bool destroy_;

  public ExpressionTraverser(Control start, Local local, GType type) {
    start_ = start; local_ = local; type_ = type;
  }

  public override int Handle(Control control) {
    if (control == start_)
      return Cut;
    Node node = control as Node;
    if (node != null) {
      if (!destroy_ && node.CanDestroy(type_))
        destroy_ = true;
      else if (local_ != null && node.Sets(local_))
        assign_ = true;
    }
    return Continue;
  }

  // Return true if the given expression needs a reference count while we evaluate
  // the control graph nodes between [start] and [end].
  // A local variable needs a ref count if it is assigned to and the object
  // the variable previously pointed to might possibly be destroyed.
  // Any other expression needs a ref count if the object it evaluates to
  // might possibly be destroyed.
  public static bool NeedRef(Control start, Control end, Expression expr, GType type) {
    Debug.Assert(start != null && end != null);
    if (start == end || !type.IsOwned() || expr is This || expr is Base)
      return false;
    Local local = expr.GetLocal();
    ExpressionTraverser ^et = new ExpressionTraverser(start, local, type);
    end.Traverse(et, Control.GetMarkerValue());
    return et.destroy_ && (local == null || et.assign_);
  }
}

abstract class LocalHandler {
  public abstract bool Handle(Local local, Node node, Name use);
}

class LocalChecker : LocalHandler {
  public override bool Handle(Local local, Node node, Name use) {
    if (node == Control.unreachable_) {
      if (use != null)
        use.Error("variable {0} may be used before it is assigned a value", use.name_);
      else
        local.Error("out parameter {0} must be assigned before leaving method", local.name_);
      return false;
    }
    if (node.Takes(local)) {
      Name name = (Name) node;
      name.Error("can't transfer ownership from {0}: value may be used again", name.name_);
      return false;
    }
    return true;
  }
}

class LocalRefAnalyzer : LocalHandler {
  public override bool Handle(Local local, Node node, Name use) {
    Debug.Assert(node != Control.unreachable_);
    if (node.CanDestroy(local.Type())) {
      local.NeedsRef();
      return false;   // abort search
    }
    return true;
  }
}

class LocalTraverser : Traverser {
  readonly Local local_;
  readonly LocalHandler handler_;
  Name use_;

  public LocalTraverser(Local local, LocalHandler handler) {
    local_ = local;
    handler_ = handler;
  }

  public void SetUse(Name use) { use_ = use; }

  public override int Handle(Control control) {
    Node node = control as Node;
    if (node == null)
      return Continue;

    if (node.Sets(local_))
      return Cut;

    return handler_.Handle(local_, node, use_) ? Continue : Abort;
  }
}

class Local : Named {
  protected Expression ^initializer_;    // or null if none
  protected GType initializer_type_;

  public Local next_;    // next variable upward in scope chain

  NonOwningArrayList /* of Name */ ^uses_ = new NonOwningArrayList();    // all uses of this variable

  protected bool mutable_;   // true if this local may ever change after it's first initialized

  protected bool needs_ref_;    // true if this variable needs a reference count in emitted code

  public Expression Initializer() { return initializer_; }

  public void NeedsRef() { needs_ref_ = true; }

  public virtual string Emit() { return name_; }

  // Return true if we represent this local using a smart pointer wrapper (i.e.
  // _Ptr, _Own, _OwnRef or _Ref).
  public virtual bool IsWrapper() {
    return type_ is Owning || type_ == GString.type_ || needs_ref_;
  }

  public Local(TypeExpr ^type_expr, string name, Expression ^initializer) : base(type_expr, name) {
    initializer_ = initializer;
    next_ = null;
  }

  public bool Check(Context ctx) {
    Local decl = ctx.FindVar(name_);
    if (decl != null) {
      Error("error: variable already defined");
      return false;
    }

    if (initializer_ != null) {
      ctx.EnterExpression();
      initializer_type_ = initializer_.Check(ctx);
      bool ok = initializer_type_ != null &&
                Assign.CheckAssign(this, type_, initializer_, initializer_type_);

      // Add this Local to the control graph.  We need to do this before calling
      // FinishExpression since the Local will be initialized before temporaries 
      // are destroyed.
      AddControl(ctx);

      ctx.FinishExpression();
      if (!ok)
        return false;
    }

    next_ = ctx.var_;
    ctx.SetVar(this);

    ctx.method_.AddVar(this);
    return true;
  }

  public override bool Sets(Local local) {
    return this == local && initializer_ != null;
  }

  public virtual GType ReadType() {
    return type_;
  }

  public void AddUse(Name name) {
    uses_.Add(name);
  }

  public void SetMutable() { mutable_ = true; }

  // Traverse the control graph nodes where this local is live, calling the given
  // LocalHandler's Handle method on each node.
  public bool Traverse(Method method, LocalHandler h) {
    LocalTraverser ^t = new LocalTraverser(this, h);
    int marker = Control.GetMarkerValue();
    foreach (Name name in uses_) {
      t.SetUse(name);
      if (!name.prev_.Traverse(t, marker))
        return false;
    }

    Parameter p = this as Parameter;
    if (p != null && p.GetMode() == Mode.Out) {
      t.SetUse(null);
      if (!method.exit_.Traverse(t, marker))
        return false;
    }
    return true;
  }

  // check variable usage once control flow graph is complete
  public bool CheckUsage(Method method) {
    return Traverse(method, new LocalChecker());
  }

  // Determine whether this Local needs a reference count.  This can happen only after
  // we've built up a control graph for all methods.
  public void ComputeRef(Method method) {
    // For now, a variable of type object always needs a reference count since it may
    // contain a string and we don't yet detect string destruction in the graph traversal.
    if (type_ == GObject.type_)
      NeedsRef();
    else if (type_.IsOwned())
      Traverse(method, new LocalRefAnalyzer());
  }

  public void EvalInit(Env env) {
    env.Add(this, initializer_ != null ? initializer_.Eval(env, type_) : null);
  }

  protected virtual string EmitDeclarationType() {
    return IsWrapper() ? type_.EmitType() : type_.EmitExprType();
  }

  public virtual string EmitDeclarationName() { return name_; }

  public void EmitDeclaration(SourceWriter w) {
    w.Write("{0} {1}", EmitDeclarationType(), EmitDeclarationName());
  }

  public void EmitInitializer(SourceWriter w) {
    if (initializer_ != null)
      initializer_.EmitAsInitializer(w, initializer_type_, type_);
  }
}

class Parameter : Local {
  public Parameter(TypeExpr ^type_expr, string name) : base(type_expr, name, null) { }

  // We represent some parameters using both a C++ parameter and a C++ local, which
  // have different types; we call these dual parameters.  For such parameters
  // param_name_ is the C++ parameter name.
  string param_name_;

  public static Parameter ^New(int mode, TypeExpr ^type_expr, string name) {
    return mode == 0 ? new Parameter(type_expr, name) :
                               new RefOutParameter(mode, type_expr, name);
  }

  public virtual int GetMode() { return 0; }
  public string TypeString() { return Mode.ToString(GetMode()) + type_.ToString(); }

  public virtual Parameter ^Copy() {
    return new Parameter(new TypeLiteral(type_), name_);
  }

  public virtual bool CanReceive(Argument a) {
    return a.GetMode() == 0 && a.Type().CanConvert(type_, ConversionContext.MethodArg);
  }

  public bool Match(Parameter p) {
    return GetMode() == p.GetMode() && type_.Equals(p.type_);
  }

  public override bool IsWrapper() {
    return type_ is Owning || type_ == GString.type_ || mutable_ && needs_ref_;
  }

  public void CheckParameterUsage(Method method) {
    if (type_ is Owning && !(this is RefOutParameter)) {
      // We need both a C++ parameter and a C++ local: the parameter type can't be
      // _Own<>, since _Own has no public copy constructor and GCC doesn't allow passing
      // by value when a class's copy constructor is private.
      string n = name_;
      do {
        n = "_" + n;
      } while (method.HasLocal(n));
      param_name_ = n;
    }
  }

  protected override string EmitDeclarationType() {
    // For owning parameters the declaration type is the expression type since we can't
    // pass _Own<> by value.
    return type_ is Owning ? type_.EmitExprType() : base.EmitDeclarationType();
  }

  public override string EmitDeclarationName() {
    return param_name_ != null ? param_name_ : name_;
  }

  public void EmitExtraDeclaration(SourceWriter w) {
    if (param_name_ != null)
      w.IWriteLine("{0} {1}({2});", type_.EmitType(), name_, param_name_);
  }
}

class RefOutParameter : Parameter {
  public readonly int mode_;
  public override int GetMode() { return mode_; }

  public RefOutParameter(int mode, TypeExpr ^type_expr, string name) : base(type_expr, name) {
    mode_ = mode;
    mutable_ = true;
  }

  public override Parameter ^Copy() { Debug.Assert(false); return null; }

  public override bool CanReceive(Argument a) {
    if (mode_ != a.GetMode())
      return false;
    RefOutArgument ra = (RefOutArgument) a;
    return type_.Equals(ra.StorageType());
  }

  public override GType ReadType() {
    // If a ref parameter has an owning type, we require the user to use the take operator to take
    // ownership of the value, since taking ownership has the visible side effect of clearing the
    // value the ref parameter points to.
    return mode_ == Mode.Ref ? type_.BaseType() : type_;
  }

  public override string Emit() {
    return "(*" + name_ + ")";
  }

  protected override string EmitDeclarationType() {
    return type_.EmitType() + " *";
  }
}

abstract class InlineStatement : Statement {
  public abstract void EmitInline(SourceWriter w);

  public override void Emit(SourceWriter w) {
    EmitInline(w);
    w.WriteLine(";");
  }
}

class VariableDeclaration : InlineStatement {
  ArrayList /* of Local */ ^locals_ = new ArrayList();

  public VariableDeclaration(TypeExpr ^type_expr, string name, Expression ^initializer) {
    locals_.Add(new Local(type_expr, name, initializer));
  }

  public void Add(string name, Expression ^initializer) {
    TypeExpr ^t = ((Local) locals_[0]).type_expr_.Copy();
    locals_.Add(new Local(t, name, initializer));
  }

  public override bool Check(Context ctx) {
    // local variables are not resolved during the Resolve phase, so we must resolve them here
    foreach (Local l in locals_)
      if (!l.Resolve(ctx.program_) || !l.Check(ctx))
        return false;

    return true;
  }

  // Return the type of all variables in this VariableDeclaration.
  public GType Type() { return ((Local) locals_[0]).Type(); }

  public override RValue ^Eval(Env env) {
    foreach (Local l in locals_)
      l.EvalInit(env);
    return null;
  }

  void Emit(SourceWriter w, bool in_line) {
    if (in_line)
      Debug.Assert(locals_.Count == 1);

    foreach (Local l in locals_) {
      l.EmitDeclaration(w);
      l.EmitInitializer(w);
      if (!in_line)
        w.WriteLine(";");
    }
  }

  public override void EmitInline(SourceWriter w) { Emit(w, true); }
  public override void Emit(SourceWriter w) { Emit(w, false); }
}

class ExpressionStatement : InlineStatement {
  Expression ^exp_;

  public ExpressionStatement(Expression ^e) {
    exp_ = e;
  }

  public override bool Check(Context ctx) {
    if (exp_.CheckTop(ctx) == null)
      return false;
    exp_.SetUnused();
    return true;
  }

  public override RValue ^Eval(Env env) {
    exp_.Eval(env);   // discard expression value
    return null;
  }

  public override void EmitInline(SourceWriter w) {
    w.Write(exp_.Emit());
  }

}

class If : Statement {
  Expression ^condition_;
  Statement ^if_true_;
  Statement ^if_false_;
  Joiner ^join_ = new Joiner();

  public If(Expression ^condition, Statement ^if_true, Statement ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override bool Check(Context ctx) {
    if (!condition_.Check(ctx, GBool.type_))
      return false;

    Control c = ctx.Prev();

    if (!if_true_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    if (if_false_ != null && !if_false_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());
    return true;
  }

  public override RValue ^Eval(Env env) {
    if (condition_.EvalBool(env))
      return if_true_.Eval(env);
    else
      return if_false_ != null ? if_false_.Eval(env) : null;
  }

  public override void Emit(SourceWriter w) {
    w.Write("if ({0})", condition_.Emit());
    if_true_.EmitEmbedded(w);
    if (if_false_ != null) {
      w.IWrite("else");
      if_false_.EmitEmbedded(w);
    }
  }

}

class DefaultValue : SimpleValue {
  public DefaultValue() { }
  public static readonly DefaultValue ^instance_ = new DefaultValue();

  public override SimpleValue ^Copy() { Debug.Assert(false); return null; }
  public override GType Type()  { Debug.Assert(false); return null; }
  public override string Emit() { Debug.Assert(false); return null; }
}

// A section in a switch statement.
//
// In GEL2, unlike C# and C++, local variables declared in a switch section are visible only
// in that section.  There doesn't seem to be much point in allowing sections to share locals
// since GEL2 (like C#) doesn't allow control to fall through from one section to the next.  This also
// makes compiling to C++ slightly easier since C++ doesn't allow local variables in switch sections
// other than the last to have initializers (see e.g. C++ Primer, 4th ed., 6.6.5 "Variable Definitions
// inside a switch").

class SwitchSection : Node {
  ArrayList /* of Expression */ ^cases_;     // null represents default:
  public readonly Block ^block_;

  ArrayList /* of GValue */ ^values_ = new ArrayList();

  public SwitchSection(ArrayList ^cases, StatementList ^statements) {
    cases_ = cases;
    block_ = new Block(statements);
  }

  public bool Check(Context ctx, GType switch_type, OwningHashtable all_values, out bool is_default) {
    is_default = false;
    foreach (Expression e in cases_) {
      GValue ^v;
      if (e == null) {
        is_default = true;
        v = new DefaultValue();
      } else {
        if (!e.Check(ctx, switch_type) || !e.CheckConstant())
          return false;
        v = (GValue) e.Eval(Env.static_, switch_type);
      }
      if (all_values.ContainsKey(v)) {
        Error("switch statement cannot contain the same value twice");
        return false;
      }
      all_values.Set(v, null);
      values_.Add(v);
    }
    return block_.Check(ctx);
  }

  public bool Match(GValue v) {
    foreach (GValue val in values_)
      if (val.Equals(v))
        return true;
    return false;
  }

  public void Emit(SourceWriter w) {
    foreach (Expression c in cases_)
      if (c == null)
        w.IWriteLine("default:");
      else w.IWriteLine("case {0}:", c.Emit());
    w.Indent();
    block_.Emit(w);
  }

  public void EmitString(SourceWriter w) {
    w.IWrite("if (");
    for (int i = 0 ; i < values_.Count ; ++i) {
      if (i > 0) {
        w.WriteLine(" ||");
        w.IWrite("    ");
      }
      w.Write("_s->_Equals({0})", 
              GString.EmitStringConst(((GString) values_[i]).s_));
    }
    w.Write(") ");
    block_.Emit(w);
  }
}

abstract class Escapable : Scoped {
  public readonly Joiner ^exit_ = new Joiner();
}

class Switch : Escapable {
  Expression ^expr_;
  GType type_;
  ArrayList /* of SwitchSection */ ^sections_;
  SwitchSection default_;    // or null if no default section

  public Switch(Expression ^expr, ArrayList ^sections) { expr_ = expr; sections_ = sections; }

  public override bool Check(Context ctx) {
    SetStartVar(ctx);
    type_ = expr_.CheckTop(ctx);
    if (type_ == null)
      return false;
    if (type_ != GInt.type_ && type_ != GChar.type_ && type_ != GString.type_) {
      Error("switch expression must be of type int, char or string");
      return false;
    }
    Context ^ctx1 = new Context(ctx, this);
    OwningHashtable ^values = new OwningHashtable();
    Control c = ctx1.Prev();
    foreach (SwitchSection s in sections_) {
      bool is_default;
      ctx1.SetPrev(c);
      if (!s.Check(ctx1, type_, values, out is_default))
        return false;
      if (is_default)
        default_ = s;
      if (ctx1.Prev() != unreachable_) {
        s.Error("switch case may not fall through to following case");
        return false;
      }
    }
    if (default_ == null)
      exit_.Join(c);
    ctx1.SetPrev(exit_.Combine());
    return true;
  }

  SwitchSection FindSection(GValue v) {
    foreach (SwitchSection s in sections_)
      if (s.Match(v))
        return s;
    return default_;
  }

  RValue ^CatchBreak(RValue ^v) {
    return v is BreakValue ? null : v;
  }

  public override RValue ^Eval(Env env) {
    RValue ^v = expr_.Eval(env);
    if (v == null)
      return null;
    SwitchSection s = FindSection(v.Get());
    if (s == null)
      return null;
    return CatchBreak(s.block_.Eval(env));
  }

  public override void Emit(SourceWriter w) {
    if (type_ == GString.type_) {
      // For now, we implement a switch on strings using a sequence of if statements.  We wrap
      // the sequence in a dummy switch statement so that break statements will work properly.
      // If the switch statement has just a default: label then the Microsoft C++ compiler issues
      // a warning, and if it has just a case 0: label then the compiler doesn't realize that the
      // case will always be executed, which may lead to warnings about not all code paths returning
      // a value.  So we use both default: and case 0:, which seems to work fine.
      w.Write("switch (0) ");
      w.OpenBrace();
      w.IWriteLine("case 0:");
      w.IWriteLine("default:");
      w.IWriteLine("StringPtr _s = {0};", expr_.Emit());
      foreach (SwitchSection s in sections_)
        if (s != default_)
          s.EmitString(w);
      if (default_ != null)
        default_.block_.Emit(w);
      w.CloseBrace();
    } else {
      w.Write("switch ({0}) ", expr_.Emit());
      w.OpenBrace();

      foreach (SwitchSection s in sections_)
        s.Emit(w);

      w.CloseBrace();
    }
  }
}

abstract class Loop : Escapable {
  public readonly Joiner ^loop_ = new Joiner();
}

abstract class ForOrWhile : Loop {
  protected Expression ^condition_;
  protected Statement ^statement_;

  protected ForOrWhile(Expression ^condition, Statement ^statement) {
    condition_ = condition; statement_ = statement;
  }

  protected abstract InlineStatement Initializer();
  protected abstract InlineStatement Iterator();

  public override bool Check(Context prev_ctx) {
    Context ^ctx = new Context(prev_ctx, this);   // initializer may declare new local variable
    SetStartVar(ctx);
    if (!Initializer().Check(ctx))
      return false;
    SetTopVar(ctx);

    loop_.AddControl(ctx);

    if (!condition_.CheckTop(ctx, GBool.type_))
      return false;

    if (!condition_.IsTrueLiteral())  // we may exit the loop at this point
      exit_.Join(ctx.Prev());  

    if (!statement_.Check(ctx))
      return false;

    if (!Iterator().Check(ctx))
      return false;

    loop_.Join(ctx.Prev());  // loop back to top

    ctx.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy any local defined in an initializer above.
    AddControl(ctx);

    return true;
  }

  public override RValue ^Eval(Env outer_env) {
    Env ^env = new Env(outer_env);   // initializer may declare new local
    for (Initializer().Eval(env); condition_.EvalBool(env); Iterator().Eval(env)) {
      RValue ^v = statement_.Eval(env);
      if (v is BreakValue)
        break;
      if (v is ContinueValue)
        continue;
      if (v != null)
        return v;
    }
    return null;
  }
}

class While : ForOrWhile {
  public While(Expression ^condition, Statement ^statement) : base(condition, statement) { }

  protected override InlineStatement Initializer()  { return EmptyStatement.instance_; }
  protected override InlineStatement Iterator()  { return EmptyStatement.instance_; }

  public override void Emit(SourceWriter w) {
    w.Write("while ({0})", condition_.Emit());
    statement_.EmitEmbedded(w);
  }
}

class For : ForOrWhile {
  InlineStatement ^initializer_;
  InlineStatement ^iterator_;

  public For(InlineStatement ^initializer, Expression ^condition, InlineStatement ^iterator,
             Statement ^statement)
    : base(condition != null ? condition : new Literal(new GBool(true)),
           statement) {
    initializer_ = initializer != null ? initializer : new EmptyStatement();
    iterator_ = iterator != null ? iterator : new EmptyStatement();
  }

  protected override InlineStatement Initializer()  { return initializer_; }
  protected override InlineStatement Iterator()  { return iterator_; }

  public override void Emit(SourceWriter w) {
    w.Write("for (");
    initializer_.EmitInline(w);
    w.Write("; {0}; ", condition_.Emit());
    iterator_.EmitInline(w);
    w.Write(")");
    statement_.EmitEmbedded(w);
  }
}

class Do : Loop {
  Statement ^statement_;
  Expression ^condition_;

  Joiner ^join_ = new Joiner();

  public Do(Statement ^statement, Expression ^condition) {
    statement_ = statement;
    condition_ = condition;
  }

  public override bool Check(Context ctx) {
    join_.AddControl(ctx);

    Context ^ctx1 = new Context(ctx, this);
    SetStartVar(ctx);

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx.Prev());  // continue statements jump here
    ctx.SetPrev(loop_.Combine());

    if (!condition_.CheckTop(ctx, GBool.type_))
      return false;

    if (!condition_.IsFalseLiteral())
      join_.Join(ctx.Prev());   // loop back to top
    if (!condition_.IsTrueLiteral())
      exit_.Join(ctx.Prev());   // fall through to exit
    ctx.SetPrev(exit_.Combine());

    return true;
  }

  public override RValue ^Eval(Env env) {
    do {
      RValue ^v = statement_.Eval(env);
      if (v is BreakValue)
        break;
      if (v is ContinueValue)
        continue;
      if (v != null)
        return v;
    } while (condition_.EvalBool(env));
    return null;
  }

  public override void Emit(SourceWriter w) {
    w.IWrite("do");
    statement_.EmitEmbedded(w);
    w.IWriteLine("while ({0});", condition_.Emit());
  }
}

// A helper class for ForEach: a node defining a single variable in the control graph.
class Definer : Node {
  Local local_;

  public Definer(Local local) { local_ = local; }

  public override bool Sets(Local local) {
    return local_ == local;
  }
}

class ForEach : Loop {
  Local ^local_;
  Expression ^expr_;
  GType expr_type_;
  Statement ^statement_;

  Property count_;
  Indexer indexer_;

  Definer ^definer_;

  public ForEach(TypeExpr ^type_expr, string name, Expression ^expr, Statement ^statement) {
    local_ = new Local(type_expr, name, null);
    expr_ = expr;
    statement_ = statement;
  }

  public override bool Check(Context ctx) {
    if (!local_.Resolve(ctx.program_))
      return false;

    expr_type_ = expr_.CheckTop(ctx);
    if (expr_type_ == null)
      return false;

    count_ = expr_type_.Lookup(this, ctx.class_, false, MemberKind.Property, "Count", null, false) as Property;
    if (count_ == null) {
      Error("object enumerable by foreach must have an accessible property Count");
      return false;
    }
    if (count_.Type() != GInt.type_) {
      Error("object enumerable by foreach must have a property Count of type int");
      return false;
    }

    ArrayList ^args = new ArrayList();
    args.Add(new InArgument(GInt.type_));
    indexer_ = (Indexer) expr_type_.Lookup(this, ctx.class_, false, MemberKind.Indexer, null, args, false);
    if (indexer_ == null) {
      Error("object enumerable by foreach must have an accessible indexer on integers");
      return false;
    }
    if (!indexer_.CheckAssigning(this, ctx, false))
      return false;

    GType indexer_type = indexer_.Type();
    GType iterator_type = local_.Type();
    if (!indexer_type.CanConvertExplicit(iterator_type, false)) {
      Error("enumeration type {0} is not explicitly convertible to iteration variable type {1}",
        indexer_type, iterator_type);
      return false;
    }

    Context ^ctx1 = new Context(ctx, this);

    SetStartVar(ctx1);
    if (!local_.Check(ctx1))   // will add local to scope chain
      return false;
    SetTopVar(ctx1);

    // Add a control graph node representing the creation of the local above.
    definer_ = new Definer(local_);
    definer_.AddControl(ctx1);

    loop_.AddControl(ctx1);   // continue statements jump here

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx1.Prev());   // loop back to top

    exit_.Join(loop_);  // any loop iteration may exit

    ctx1.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy the local variable created above.
    AddControl(ctx1);

    return true;
  }

  public override RValue ^Eval(Env outer_env) {
    RValue ^r = expr_.Eval(outer_env);
    GValue e = r.Get();
    if (e is Null) {
      Error("foreach: can't iterate over null object");
      Gel.Exit();
    }

    int count = ((GInt) count_.Get(e)).i_;

    Env ^env = new Env(outer_env);
    env.Add(local_, null);
    for (int i = 0 ; i < count ; ++i) {
      RValue ^v = indexer_.Get(e, new GInt(i));
      env.Set(local_, v.Get().ConvertExplicit(ref v, local_.Type()));
      RValue ^s = statement_.Eval(env);
      if (s is BreakValue)
        break;
      if (s is ContinueValue)
        continue;
      if (s != null)
        return s;
    }
    return null;
  }

  public override void Emit(SourceWriter w) {
    w.OpenBrace();
    w.IWriteLine("{0} _collection = {1};", expr_type_.BaseType().EmitType(), expr_.Emit());
    w.IWriteLine("int _count = _collection->get_Count();");
    w.IWrite("for (int _i = 0 ; _i < _count ; ++_i) ");
    w.OpenBrace();
    w.Indent();
    local_.EmitDeclaration(w);
    w.WriteLine(" = {0}; ",
      Expression.EmitExplicit(indexer_.Type(), local_.Type(), "_collection->get_Item(_i)", true));
    statement_.EmitInExistingBlock(w);
    w.CloseBrace();
    w.CloseBrace();
  }
}

class BreakValue : GValue {
  public BreakValue() { }

  public static readonly BreakValue ^instance_ = new BreakValue();

  public override GType Type()  { Debug.Assert(false); return null; }
}

abstract class BreakOrContinue : Scoped {
  protected void Link(Context ctx, Scoped target, Joiner joiner) {
    // When traversed in the control graph, we destroy all variables in the scopes we are exiting,
    // excluding variables defined in the containing Escapable or Loop.
    start_ = target.GetTop();
    SetTopVar(ctx);

    prev_ = ctx.Prev();
    if (prev_ != unreachable_)
      joiner.Join(this);

    ctx.SetPrev(unreachable_);
  }
}

class Break : BreakOrContinue {
  public override bool Check(Context ctx) {
    Escapable e = ctx.escape_;
    if (e == null) {
      Error("break statement must appear inside a while, do, for, foreach or switch statement");
      return false;
    }
    Link(ctx, e, e.exit_);
    return true;
  }

  public override RValue ^Eval(Env env) {
    return new BreakValue();
  }

  public override void Emit(SourceWriter w) {
    w.WriteLine("break;");
  }
}

class ContinueValue : GValue {
  public ContinueValue() { }

  public static readonly ContinueValue ^instance_ = new ContinueValue();

  public override GType Type()  { Debug.Assert(false); return null; }
}

class Continue : BreakOrContinue {
  public override bool Check(Context ctx) {
    Loop l = ctx.loop_;
    if (l == null) {
      Error("continue statement must appear inside a while, do, for or foreach statement");
      return false;
    }
    Link(ctx, l, l.loop_);
    return true;
  }

  public override RValue ^Eval(Env env) {
    return new ContinueValue();
  }

  public override void Emit(SourceWriter w) {
    w.WriteLine("continue;");
  }
}

class Return : Statement {
  Expression ^exp_;    // null if no return value
  GType exp_type_;
  GType type_;

  public Return(Expression ^exp) {
    exp_ = exp;
  }

  public override bool Check(Context ctx) {
    if (exp_ == null) {
      if (ctx.method_.ReturnType() != Void.type_) {
        Error("error: returning value from function returning void");
        return false;
      }
    } else {
      type_ = ctx.method_.ReturnType();
      ctx.EnterExpression();
      exp_type_ = exp_.CheckAndHold(ctx);
      if (exp_type_ == null ||
          !exp_type_.CheckConvert(this, type_,
            exp_.IsRefOutParameter() ? ConversionContext.AssignVar : ConversionContext.Other))
        return false;
      exp_.CheckLoseOwnership(exp_type_, type_);
      ctx.FinishExpression();
      exp_.ReleaseRef(ctx);
    }

    ctx.method_.JoinReturn(ctx);
    ctx.SetPrev(unreachable_);
    return true;
  }

  public override RValue ^Eval(Env env) {
    return exp_ != null ? exp_.Eval(env, type_)
                        : Null.Instance.Copy();    // an arbitrary value
  }

  public override void Emit(SourceWriter w) {
    if (exp_ != null && exp_.NeedsRef(exp_type_)) {
      // If exp_ needs a reference count, that reference count needs to survive the destruction
      // of temporaries, so we can't simply emit a temporary reference count wrapper.  For example,
      // when compiling the expression "return (new Foo()).Fun();", if Fun() returns a Foo then we
      // need a wrapper, and we can't generate "return _Ptr<Fun>(Foo().Fun()).Get()" since the _Ptr<Fun>
      // wrapper will be destroyed before the temporary Foo() object is destroyed.  So we need to
      // use an extra variable here.
      w.OpenBrace();
      w.IWriteLine("{0} __ret = {1};", exp_type_.EmitType(), exp_.Emit());
      w.IWriteLine("return __ret.Get();");
      w.CloseBrace();
    } else {
      w.Write("return ");
      if (exp_ != null)
        w.Write(exp_.Emit(exp_type_, type_));
      w.WriteLine(";");
    }
  }
}

class Attribute {
  public const int Abstract = 1,
  Const = 2,
  Extern = 4,
  Override = 8,
  Private = 16,
  Protected = 32,
  Public = 64,
  ReadOnly = 128,
  Ref = 256,
  Static = 512,
  Virtual = 1024,
  Setter = 2048;
}

class AttributeUtil {
  public static bool CheckOnly(int a, int allowed) {
    return (a & ~allowed) == 0;
  }
}

class MethodTraverser : Traverser {
  Method method_;

  public MethodTraverser(Method method) { method_ = method; }

  public override int Handle(Control control) {
    if (control == Control.unreachable_)
      return Cut;

    Node node = control as Node;
    if (node != null) {
      Method c = node.Calls();
      if (c != null)
        method_.calls_.Add(c);
      method_.internal_destroys_.Add(node.NodeDestroys());
    }

    return Continue;
  }
}

class Method : Member {
  public readonly ArrayList /* of Parameter */ ^parameters_;

  protected Block ^body_;

  public Joiner ^exit_ = new Joiner();

  // all parameters and locals defined in this method
  readonly NonOwningArrayList /* of Local */ ^locals_ = new NonOwningArrayList();

  NonOwningArrayList /* of Method */ ^overrides_;   // list of all overrides (virtual methods only)

  // methods called from this method
  public readonly NonOwningArrayList /* of Method */ ^calls_ = new NonOwningArrayList();

  // Types destroyed inside this method, not including types destroyed through
  // calls to other methods.
  public readonly TypeSet ^internal_destroys_ = new TypeSet();

  // Types destroyed inside this method or in any methods called by this method.
  TypeSet ^destroys_;

  TypeSet ^parameter_destroys_;

  // A marker used when performing a depth-first search of the method graph to compute destroys_.
  int method_marker_;

  public Method(int attributes, TypeExpr ^return_type_expr,
                string name, ArrayList /* of Parameter */ ^parameters, Block ^body)
    : base(attributes, return_type_expr, name) {
    parameters_ = parameters;
    body_ = body;
  }

  public override int Kind() { return MemberKind.Method; }

  public GType ReturnType() { return type_; }

  public override ArrayList Parameters() {
    return parameters_;
  }

  public bool IsExtern() { return class_.IsExtern(); }

  public bool IsStatic() {
    return HasAttribute(Attribute.Static);
  }

  public override bool Resolve(Program program) {
    if (!base.Resolve(program))
      return false;
    foreach (Parameter p in parameters_)
      if (!p.Resolve(program))
        return false;
    return true;
  }

  public void AddVar(Local v) {
    locals_.Add(v);
  }

  public override bool Sets(Local local) {
    foreach (Parameter p in parameters_)
      if (p == local && p.GetMode() != Mode.Out)
        return true;
    return false;
  }

  public void JoinReturn(Context ctx) {
    exit_.Join(ctx.Prev());
  }

  public const int kValidAttributes =
    Attribute.Abstract | Attribute.Override |
    Attribute.Private | Attribute.Protected | Attribute.Public |
    Attribute.Static | Attribute.Virtual | Attribute.Setter;

  protected override int ValidAttributes() {
    return kValidAttributes;
  }

  // overridden by Constructor subclass
  protected virtual bool CheckEntry(Context ctx) { return true; }

  // overridden by Constructor subclass
  public override bool Check(Context prev_ctx) {
    if (!base.Check(prev_ctx))
      return false;

    bool abstract_or_extern = HasAttribute(Attribute.Abstract) || IsExtern();

    if (body_.Absent()) {
      if (!abstract_or_extern) {
        Error("a method without a body must be abstract or extern");
        return false;
      }
      return true;
    } 

    if (abstract_or_extern) {
      Error("an abstract or extern method cannot have a body");
      return false;
    }

    Context ^ctx = new Context(prev_ctx, this);

    prev_ = unreachable_;
    ctx.SetPrev(this);    // begin the control graph with this Method

    foreach (Parameter p in parameters_)
      if (!p.Check(ctx))
        return false;

    if (!CheckEntry(ctx))
      return false;

    if (!body_.Check(ctx))
      return false;

    if (!(this is Constructor) && type_ != Void.type_ && ctx.Prev() != unreachable_) {
      Error("method must return a value");
      return false;
    }
    JoinReturn(ctx);

    ctx.ClearPrev();  // control graph is complete

    // Traverse the control graph to build calls_ and internal_destroys_.
    MethodTraverser ^mt = new MethodTraverser(this);
    exit_.Traverse(mt, Control.GetMarkerValue());

    bool ok = true;
    foreach (Local v in locals_)    // for all locals and parameters
      ok &= v.CheckUsage(this);

    foreach (Parameter p in parameters_)
      p.CheckParameterUsage(this);

    return ok;
  }

  // Determine whether each local variable needs a reference count.
  protected void ComputeRefs() {
    foreach (Local v in locals_)
      v.ComputeRef(this);
  }

  // Return true if this method has a local or parameter with the given name.
  public bool HasLocal(string name) {
    foreach (Local l in locals_)
      if (l.name_ == name)
        return true;
    return false;
  }

  public override TypeSet NodeDestroys() {
    if (parameter_destroys_ == null) {
      parameter_destroys_ = new TypeSet();
    foreach (Parameter p in parameters_)
        parameter_destroys_.Add(p.Type().VarDestroys());
    }
    return parameter_destroys_;
  }

  protected override void AddOverride(Member m) {
    if (overrides_ == null)
      overrides_ = new NonOwningArrayList();
    overrides_.Add((Method) m);
  }

  bool Visit(int marker, TypeSet set) {
    if (method_marker_ == marker)
      return true;

    method_marker_ = marker;
    set.Add(internal_destroys_);
    if (set.IsObject())
      return false;   // we already have object; no point in traversing further

    foreach (Method m in calls_)
      if (!m.Visit(marker, set))
        return false;

    if (overrides_ != null)
      foreach (Method m in overrides_)
        if (!m.Visit(marker, set))
          return false;

    return true;
  }

  public TypeSet Destroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet();
      Visit(Control.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  // overridden by Constructor subclass
  public virtual RValue ^Eval(Env env) {
    return body_.Eval(env);
  }

  public RValue ^Invoke(GValue obj, ArrayList /* of ValueOrLocation */ values) {
    if (body_.Absent()) { // an external method
      ValueList ^list = new ValueList(values);
      if (IsStatic())
        return class_.InvokeStatic(this, list);   // let the class handle it
      return obj.Invoke(this, list);   // let the object handle it
    }

    Env ^env = new Env(obj);
    Debug.Assert(values.Count == parameters_.Count);
    for (int i = 0 ; i < values.Count ; ++i)
      env.Add((Parameter) parameters_[i], (ValueOrLocation) values.Take(i));

    return Eval(env);
  }

  protected void EmitParameterNames(SourceWriter w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      w.Write(Param(i).EmitDeclarationName());
    }
    w.Write(")");
  }

  protected void EmitParameters(SourceWriter w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      Param(i).EmitDeclaration(w);
    }
    w.Write(") ");
  }

  void EmitAttributes(SourceWriter w, bool declaration) {
    w.Indent();
    if (!IsStatic() && !IsVirtual())
      return;

    if (!declaration)
      w.Write("/* ");
    if (IsStatic())
      w.Write("static ");
    if (IsVirtual())
      w.Write("virtual ");
    if (!declaration)
      w.Write("*/ ");
  }

  void EmitSignature(SourceWriter w, bool declaration) {
    EmitAttributes(w, declaration);
    w.Write("{0} ", type_.EmitReturnType());
    if (!declaration)
      w.Write("{0}::", class_.name_);
    if (HasAttribute(Attribute.Setter))
      w.Write("_");
    w.Write(name_);
    EmitParameters(w);
  }

  public virtual void EmitDeclaration(SourceWriter w) {
    ComputeRefs();
    EmitSignature(w, true);
    if (body_.Absent())
      w.Write("= 0");
    w.WriteLine(";");

    if (HasAttribute(Attribute.Setter)) {
      w.WriteLine("");
      EmitAttributes(w, true);
      w.Write("{0} ", Param(parameters_.Count - 1).Type().EmitType());
      w.Write(name_);
      EmitParameters(w);
      w.OpenBrace();
      w.IWrite("_{0}", name_);
      EmitParameterNames(w);
      w.WriteLine(";");
      w.IWriteLine("return value;");
      w.CloseBrace();
    }
  }

  protected void EmitExtraDeclarations(SourceWriter w) {
    foreach (Parameter p in parameters_)
      p.EmitExtraDeclaration(w);
  }

  public virtual void Emit(SourceWriter w) {
    if (!body_.Absent()) {
      EmitSignature(w, false);
      w.OpenBrace();
      EmitExtraDeclarations(w);
      body_.list_.Emit(w);
      w.CloseBrace();
      w.WriteLine("");
    }
    if (Gel.print_type_sets_)
      Console.WriteLine("{0}.{1}: {2}", class_.name_, name_, Destroys());
  }
}

class Constructor : Method {
  bool call_base_;
  ArrayList /* of Argument */ ^initializer_params_;

  Constructor initializer_;

  bool invoked_;  // true if another constructor invokes this one using : base() or : this()

  public Constructor(int attributes, string name, ArrayList ^parameters,
                     bool call_base, ArrayList ^initializer_params, Block ^body)
    : base(attributes, null, name, parameters, body) {
    call_base_ = call_base;
    initializer_params_ = initializer_params;
  }

  public Constructor(int attributes, string name, ArrayList ^parameters, Block ^body)
    : this(attributes, name, parameters, true, new ArrayList(), body) { }

  public override int Kind() { return MemberKind.Constructor; }

  protected override int ValidAttributes() {
    return Attribute.Private | Attribute.Protected | Attribute.Public;
  }

  public override bool Check(Context ctx) {
    if (name_ != class_.name_) {
      Error("constructor name must match class name");
      return false;
    }
    return base.Check(ctx);
  }

  protected override bool CheckEntry(Context ctx) {
    Class c = call_base_ ? class_.Parent() : class_;
    if (c != null || initializer_params_.Count > 0) {
      initializer_ = (Constructor) Invocation.CheckInvoke(this, ctx, call_base_, c,
                                      c.name_, initializer_params_, MemberKind.Constructor);
      if (initializer_ == null)
        return false;
      if (initializer_ == this) {
        Error("constructor initializer invokes itself");
        return false;
      }
      initializer_.invoked_ = true;
    }
    return true;
  }

  // A Constructor node in the control graph represents the call to the base constructor;
  // this node gets added when we call Invocation.CheckInvoke() above.
  public override Method Calls() { return initializer_; }

  public override RValue ^Eval(Env env) {
    if (initializer_ == null || initializer_.class_ != class_) {
      // run instance variable initializers
      foreach (Field f in class_.fields_)
        if (!f.IsConstOrStatic() && f.Initializer() != null)
          ((GObject) env.this_).Set(f, f.Initializer().Eval(Env.static_, f.Type()));
    }
    if (initializer_ != null)
      Invocation.CallMethod(env, env.this_, initializer_, initializer_params_, false);
    return body_.Eval(env);
  }

  void EmitInitializerArgs(SourceWriter w) {
    w.WriteLine("({0});", Invocation.EmitArguments(initializer_, initializer_params_));
  }

  void EmitConstructorBody(SourceWriter w) {
    w.OpenBrace();
    EmitExtraDeclarations(w);
    if (call_base_) {
      if (class_.constructors_.Count > 1)
        w.IWriteLine("_Init();");
      else class_.EmitInitializers(w);

      Class parent = class_.Parent();
      if (parent != GObject.type_) {
        w.IWrite("{0}::_Construct", parent.name_);
        EmitInitializerArgs(w);
      }
    } else {
      w.IWrite("_Construct");
      EmitInitializerArgs(w);
    }

    body_.list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitDeclaration(SourceWriter w) {
    ComputeRefs();

    // If we're invoked by some other constructor then we need to declare a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void _Construct");
      EmitParameters(w);
      w.WriteLine(";");
    }

    // Now declare the actual C++ constructor.
    w.IWrite(name_);
    EmitParameters(w);
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter w) {
    // If we're invoked by some other constructor then we need to emit a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void {0}::_Construct", name_);
      EmitParameters(w);
      EmitConstructorBody(w);
      w.WriteLine("");
    }

    // Now emit the actual C++ constructor.
    w.IWrite("{0}::{1}", name_, name_);
    EmitParameters(w);
    Class parent = class_.Parent();
    if (parent != GObject.type_)
      w.Write(": {0}((Dummy *) 0) ", parent.name_);

    if (invoked_) {   // call the _Construct method we just generated
      w.Write("{ _Construct");
      EmitParameterNames(w);
      w.WriteLine("; }");
    } else EmitConstructorBody(w);
    w.WriteLine("");
  }
}

abstract class PropertyOrIndexer : LMember {
  // If a get accessor is not declared at all, then get_block_ will be null; if it is
  // declared, but has an empty body ("get;") then get_block_ will be a Block whose list_ is
  // null.  We need to distinguish these cases since for abstract or extern properties the
  // presence of a get accessor with an empty body indicates that a property is readable.
  // (set_block_ works similarly.)
  Block ^get_block_, set_block_;

  protected Method getter_, setter_;

  protected PropertyOrIndexer(int attributes, TypeExpr ^type_expr, string name,
                              string id1, Block ^block1, string id2, Block ^block2)
    : base(attributes, type_expr, name) {
    StoreAccessor(id1, block1);
    if (id2 != null)
      StoreAccessor(id2, block2);
    if (id1 == id2)
      Error("can't have two {0} accessors", id1);
  }

  void StoreAccessor(string id, Block ^block) {
    // Note that we don't have scanner tokens GET and SET since these are not keywords in GEL2.
    switch (id) {
      case "get": get_block_ = block; return;
      case "set": set_block_ = block; return;
    }
    Error("expected get or set");
  }

  public Method Getter() { return getter_; }
  public Method Setter() { return setter_; }

  protected abstract string BaseName();

  ArrayList ^CopyParameters() {
    ArrayList ^a = new ArrayList();
    foreach (Parameter p in Parameters())
      a.Add(p.Copy());
    return a;
  }

  public override bool Check(Context ctx) {
    if (!base.Check(ctx))
      return false;

    if (get_block_ != null) {
      Method ^m = new Method(attributes_, new TypeLiteral(type_), "get_" + BaseName(), CopyParameters(), take get_block_);
      getter_ = m;
      class_.Add(m);
      if (!getter_.Resolve(ctx.program_) || !getter_.Check(ctx))
        return false;
    }

    if (set_block_ != null) {
      ArrayList ^set_params = CopyParameters();
      set_params.Add(new Parameter(new TypeLiteral(type_), "value"));
      Method ^m = new Method(attributes_ | Attribute.Setter,
                           new TypeLiteral(Void.type_), "set_" + BaseName(), set_params, take set_block_);
      setter_ = m;
      class_.Add(m);
      if (!setter_.Resolve(ctx.program_) || !setter_.Check(ctx))
        return false;
    }

    return true;
  }

  public override bool CheckAssigning(Syntax caller, Context ctx, bool assigning) {
    if (assigning && set_block_ == null && setter_ == null) {
      caller.Error("can't assign to read-only {0}", KindString());
      return false;
    }
    if (!assigning && get_block_ == null && getter_ == null) {
      caller.Error("can't read from write-only {0}", KindString());
      return false;
    }
    return true;
  }

  public override Location GetLocation(GObject obj) { Debug.Assert(false); return null; }
}

class Property : PropertyOrIndexer {
  public Property(int attributes, TypeExpr ^type_expr, string name,
                  string id1, Block ^block1, string id2, Block ^block2)
    : base(attributes, type_expr, name, id1, block1, id2, block2) { }

  public override int Kind() { return MemberKind.Property; }

  protected override int ValidAttributes() {
    return Method.kValidAttributes;
  }

  protected override string BaseName() { return name_; }

  public override RValue ^Get(GValue obj) {
    return Invocation.InvokeMethod(obj, getter_, new ArrayList(), true);
  }

  public override void Set(GObject obj, RValue ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(val);
    Invocation.InvokeMethod(obj, setter_, a, true);
  }

  public override string Emit() {
    return String.Format("get_{0}()", name_);
  }

  public override string EmitSet(string val) {
    return String.Format("set_{0}({1})", name_, val);
  }
}

class Indexer : PropertyOrIndexer {
  public readonly Parameter parameter_;

  ArrayList /* of Parameter */ ^parameters_;

  public Indexer(int attributes, TypeExpr ^type_expr, Parameter ^parameter,
                 string id1, Block ^block1, string id2, Block ^block2)
    : base(attributes, type_expr, null, id1, block1, id2, block2) {
    parameter_ = parameter;

    parameters_ = new ArrayList();
    parameters_.Add(parameter);
  }

  public override int Kind() { return MemberKind.Indexer; }

  public override bool Resolve(Program program) {
    return base.Resolve(program) && parameter_.Resolve(program);
  }

  protected override int ValidAttributes() {
    return Attribute.Abstract | Attribute.Override |
    Attribute.Private | Attribute.Protected | Attribute.Public | Attribute.Virtual;
  }

  protected override string BaseName() { return "Item"; }

  public override bool Check(Context ctx) {
    if (parameter_ is RefOutParameter) {
      Error("indexer parameter may not be ref or out");
      return false;
    }

    return base.Check(ctx);
  }

  public override ArrayList /* of Parameter */ Parameters() {
    return parameters_; 
  }

  public RValue ^Get(GValue obj, RValue ^index) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    return Invocation.InvokeMethod(obj, getter_, a, true);
  }

  public void Set(GObject obj, RValue ^index, RValue ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    a.Add(val);
    Invocation.InvokeMethod(obj, setter_, a, true);
  }
}

class Class : Ownable {
  Syntax ^syntax_ = new Syntax();
  Program program_;   // containing program
  int attributes_;
  public readonly string name_;
  string parent_name_;    // or null if not specified

  Class parent_;

  public readonly NonOwningArrayList /* of Field */ ^fields_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Method */ ^methods_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Property */ ^properties_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Indexer */ ^indexers_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Constructor */ ^constructors_ = new NonOwningArrayList();

  public readonly ArrayList /* of Member */ ^members_ = new ArrayList();

  public readonly ArrayList /* of Temporaries */ ^temporaries_ = new ArrayList();

  public readonly NonOwningArrayList /* of Class */ ^subclasses_ = new NonOwningArrayList();
  bool emitted_;

  // If virtual_ is true, then this class needs a vtable; we set this for a class C
  // in any of the following cases:
  // - the program converts some type T to C ^ (for then a C ^ may hold a T, and when
  // the owning pointer is destroyed we need to know which destructor to call)
  // - the program explicitly converts from C to some other type (so we need RTTI for C)
  bool virtual_;
  
  // If object_inherit_ is true, then this class must derive from Object in generated C++
  // code; we set this for a class C in any of the following cases:
  // - a member lookup in C yields a member in Object
  // - the program converts from C to Object or from Object to C
  // - the class is used in a generic context, i.e. in the type C [] or C ^ [].  All such types
  //   use the generic compiled classes Array<Object> / Array<_Own<Object>>, and so in this case we need
  //   to be able to cast between C and Object.
  //
  // If object_inherit_ is true then this class and all its superclasses will have vtables since
  // the C++ Object class has a vtable.
  bool object_inherit_;

  bool need_destroy_;  // true if we need to emit _Destroy methods for this class

  // The set of types which may be destroyed when an instance of this class is destroyed.
  TypeSet ^destroys_;

  // A marker used in performing a depth-first search to construct the destroys_ type set.
  int marker_;

  protected Class(string name) { name_ = name; }

  public static Class New(int attributes, string name, string parent_name) {
    Class c = Internal.Find(name);
    if (c == null) {
      Class ^c1 = new Class(name);
      c = c1;
      Gel.program_.AddOwn(c1);
    }

    c.attributes_ = attributes;
    c.parent_name_ = parent_name;

    return c;
  }

  public override bool IsOwned() { return true; }

  public Program GetProgram() { return program_; }
  public void SetProgram(Program p) { program_ = p; }

  public bool IsExtern() { return HasAttribute(Attribute.Extern); }

  public override Class Parent() { return parent_; }

  public override string ToString() { return name_; }

  public override ArrayList Members() { return members_; }

  public override SimpleValue DefaultValue() { return Null.Instance; }

  public override void SetVirtual() { virtual_ = true; }
  public override void SetObjectInherit() { object_inherit_ = true;  }
  public void NeedDestroy() { need_destroy_ = true; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public virtual GValue ^New() { return new GObject(this); }
  public virtual RValue ^InvokeStatic(Method m, ValueList args) { Debug.Assert(false); return null; }

  public void Add(Field ^f) { f.SetClass(this); fields_.Add(f); members_.Add(f);  }

  public virtual void Add(Method ^m) { m.SetClass(this); methods_.Add(m); members_.Add(m);  }

  public void Add(Property ^p) { p.SetClass(this); properties_.Add(p); members_.Add(p);  }

  public void Add(Indexer ^i) { i.SetClass(this); indexers_.Add(i); members_.Add(i); }

  public void AddConstructor(Constructor ^c) { c.SetClass(this); constructors_.Add(c); members_.Add(c);  }

  public NonOwningArrayList /* of Member */ ^FindAbstractMembers() {
    NonOwningArrayList /* of Member */ ^a;
    if (parent_ != null)  {
      a = parent_.FindAbstractMembers();

      // remove members overridden in this class
      int i = 0;
      while (i < a.Count) {
        Member m = (Member) a[i];
        Member n = GetMatchingMember(m);
        if (n != null) {
          Debug.Assert(n.HasAttribute(Attribute.Abstract | Attribute.Override));
          a.RemoveAt(i);
        } else ++i;
      }
    } else a = new NonOwningArrayList();

    // add abstract members from this class
    foreach (Member m in members_) {
      if (m.HasAttribute(Attribute.Abstract))
        a.Add(m);
    }

    return a;
  }

  public bool ResolveAll(Program program) {
    if (parent_name_ != null) {
      parent_ = program.FindClass(parent_name_);
      if (parent_ == null) {
        syntax_.Error("can't find parent class {0}", parent_name_);
        return false;
      }
    } else if (this == GObject.type_)
      parent_ = null;
    else parent_ = GObject.type_;
    if (parent_ != null)
      parent_.subclasses_.Add(this);

    foreach (Member m in members_)
      if (!m.Resolve(program))
        return false;

    if (!IsExtern() && constructors_.Count == 0)
      // add a default constructor
      AddConstructor(new Constructor(Attribute.Public, name_, new ArrayList(), Block.EmptyBlock()));

    return true;
  }

  // In our first checking pass we check all constant fields since we may need to evaluate them
  // in the course of checking other code.
  public bool Check1(Context prev_ctx) {
    if (!AttributeUtil.CheckOnly(attributes_,
         Attribute.Abstract | Attribute.Extern | Attribute.Public)) {
      syntax_.Error("illegal class attribute");
      return false;
    }

    if (prev_ctx.program_.FindClass(name_) != this) {
      syntax_.Error("can't have two classes named {0}", name_);
      return false;
    }

    Context ^ctx = new Context(prev_ctx, this);
    bool ok = true;
    foreach (Field f in fields_) {
      ConstField cf = f as ConstField;
      if (cf != null)
        ok &= cf.Check(ctx);
    }
    return ok;
  }

  public bool Check(Context prev_ctx) {
    Context ^ctx = new Context(prev_ctx, this);

    bool ok = true;

    foreach (Member m in members_)
      if (m is Field && !(m is ConstField) || m is Method)
        ok &= m.Check(ctx);

    // We need to check properties and indexers separately since they add methods to the members_
    // array as they are checked.
    foreach (Property p in properties_)
      ok &= p.Check(ctx);
    foreach (Indexer i in indexers_)
      ok &= i.Check(ctx);

    if (!HasAttribute(Attribute.Abstract)) {
      NonOwningArrayList ^a = FindAbstractMembers();
      if (a.Count > 0) {
        foreach (Member m in a)
          syntax_.Error("class does not define inherited abstract {0} {1}", m.KindString(), m.name_);
        ok = false;
      }
    }

    return ok;
  }

  public void GetMainMethod(NonOwningArrayList /* of Method */ result) {
    foreach (Method m in methods_)
      if (m.name_ == "Main" && m.IsPublic() && m.IsStatic() && m.ReturnType() == Void.type_) {
        int c = m.parameters_.Count;
        if (c > 1)
          continue;
        if (c == 1) {
          Parameter p = m.Param(0);
          if (p.GetMode() != 0 || !p.Type().Equals(new ArrayType(GString.type_)) )
            continue;
        }
        result.Add(m);
      }
  }

  public override void FindTypeDestroys(int marker, TypeSet set) {
    if (marker_ == marker)
      return;
    marker_ = marker;
    set.Add(this);
    for (Class c = this; c != null; c = c.parent_) {
      if (c != this && c.marker_ == marker)
        break;
      foreach (Field f in c.fields_)
        if (!f.IsConstOrStatic())
          f.Type().FindVarDestroys(marker, set);
    }
    foreach (Class c in subclasses_)
      c.FindTypeDestroys(marker, set);
  }

  public override TypeSet TypeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet();
      FindTypeDestroys(Control.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  public Temporaries NewTemporaries() {
    Temporaries ^t = new Temporaries();
    Temporaries ret = t;
    temporaries_.Add(t);
    return ret;
  }

  public void StaticInit() {
    foreach (Field f in fields_) {
      StaticField sf = f as StaticField;
      if (sf != null)
        sf.Init();
    }
  }

  public override string EmitTypeName() { return name_; }

  int EmitAccess(SourceWriter w, int old_access, int new_access) {
    new_access = (new_access & Attribute.Public) != 0 ? Attribute.Public : Attribute.Protected;

    if (new_access != old_access) {
      switch (new_access) {
        case Attribute.Protected:
          w.Indent(-1);
          w.WriteLine("protected:");
          break;
        case Attribute.Public:
          w.Indent(-1);
          w.WriteLine("public:");
          break;
        default:
          Debug.Assert(false);
          break;
      }
    }

    return new_access;
  }

  public void EmitInitializers(SourceWriter w) {
    foreach (Field f in fields_)
      if (!f.IsConstOrStatic())
        f.EmitInitializer(w);
  }

  // Return true if this top-level class must inherit from Object.
  bool ObjectInherit() {
    if (object_inherit_)
      return true;
    foreach (Class c in subclasses_)
      if (c.ObjectInherit())
        return true;
    return false;
  }

  public void EmitDeclaration(SourceWriter w) {
    if (emitted_ || IsExtern())
      return;

    // C++ requires a parent class to appear before its subclasses in a source file.
    parent_.EmitDeclaration(w);

    emitted_ = true;

    w.Write("class {0} ", name_);
    if (parent_ != null)
      w.Write(": public {0} ",
              parent_ == GObject.type_ && !ObjectInherit() ? "_Object" : parent_.name_);
    w.OpenBrace();

    int access = 0;

    if (fields_.Count > 0) {
      foreach (Field f in fields_) {
        access = EmitAccess(w, access, f.attributes_);
        f.EmitDeclaration(w);
      }
      w.WriteLine("");
    }

    if (subclasses_.Count > 0) {
      access = EmitAccess(w, access, Attribute.Protected);
      w.IWrite("{0}(Dummy *dummy) ", name_);
      if (parent_ != GObject.type_)
        w.Write(": {0}(dummy) ", parent_.name_);
      w.WriteLine("{ }");
      w.WriteLine("");
    }

    // If we have more than one constructor, emit an _Init() method which constructors can
    // call to initialize instance variables.
    if (constructors_.Count > 1) {
      access = EmitAccess(w, access, Attribute.Protected);
      w.IWriteLine("void _Init();");
      w.WriteLine("");
    }

    foreach (Constructor c in constructors_) {
      access = EmitAccess(w, access, c.attributes_);
      c.EmitDeclaration(w);
    }

    if (virtual_) {
      access = EmitAccess(w, access, Attribute.Public);
      w.IWrite("virtual ~{0}()", name_);
      w.WriteLine(" { }");
      w.WriteLine("");
    }

    if (need_destroy_) {
      access = EmitAccess(w, access, Attribute.Public);
      w.IWriteLine("GEL_OBJECT({0})", name_);
      w.WriteLine("");
    }

    foreach (Method m in methods_) {
      access = EmitAccess(w, access, m.attributes_);
      m.EmitDeclaration(w);
    }

    w.SubIndent();
    w.WriteLine("};");
    w.WriteLine("");
  }

  public void Emit(SourceWriter w) {
    if (IsExtern())
      return;

    if (fields_.Count > 0) {
      foreach (Field f in fields_)
        f.Emit(w);
      w.WriteLine("");
    }

    if (constructors_.Count > 1) {
      w.IWrite("void {0}::_Init() ", name_);
      w.OpenBrace();
      EmitInitializers(w);
      w.CloseBrace();
      w.WriteLine("");
    }

    foreach (Constructor c in constructors_)
      c.Emit(w);

    foreach (Method m in methods_)
      m.Emit(w);

    if (Gel.print_type_sets_)
      Console.WriteLine("~{0}: {1}", name_, TypeDestroys());
  }
}

class ClassPtr {
  public readonly Class class_;

  public ClassPtr(Class c) { class_ = c; }
}

class ValueList {
  public ArrayList list_;
  public ValueList(ArrayList list) { list_ = list; }

  public GValue Object(int i) { return ((RValue) list_[i]).Get(); }
  public bool Bool(int i) { return ((GBool) list_[i]).b_; }
  public int Int(int i) { return ((GInt) list_[i]).i_; }
  public char Char(int i) { return ((GChar) list_[i]).c_; }
  public string GetString(int i) { return ((GString) list_[i]).s_; }
}

class Internal : Class {
  static NonOwningArrayList /* of Internal */ ^all_ = new NonOwningArrayList();

  protected Internal(string name) : base(name) { }

  public static Internal Find(string name) {
    foreach (Internal p in all_)
      if (p.name_ == name)
        return p;
    return null;
  }

  static void Add(Internal p) { all_.Add(p); }

  public static void Init() {
    Add(GObject.type_);
    Add(GArray.array_class_);
    Add(GBool.type_);
    Add(GChar.type_);
    Add(GDouble.type_);
    Add(GFloat.type_);
    Add(GInt.type_);
    Add(GString.type_);
    Add(GStringBuilder.type_);
    Add(PoolClass.instance_);
    Add(DebugClass.instance_);
    Add(EnvironmentClass.instance_);

    Add(ConsoleClass.instance_);
    Add(FileClass.instance_);
    Add(PathClass.instance_);
    Add(GStreamReader.type_);
  }
}

class ObjectClass : Internal {
  public Method equals_;
  public Method get_hash_code_;
  public Method to_string_;

  public ObjectClass() : base("Object") { }

  public override void Add(Method ^m) {
    switch (m.name_) {
      case "Equals": equals_ = m; break;
      case "GetHashCode": get_hash_code_ = m; break;
      case "ToString": to_string_ = m; break;
    }
    base.Add(m);
  }
}

class ArrayClass : Internal {
  public ArrayClass() : base("Array") { }
}

abstract class SimpleType : Internal {
  protected SimpleType(string name) : base(name) { }

  public override bool IsOwned() { return false; }
  public override bool IsReference() { return false; }
  public override bool IsValue() { return true; }

  public override string EmitExprType() { return EmitType(); }
  public override string EmitType() { Debug.Assert(false); return null; }
}

abstract class IntegralType : SimpleType {
  protected IntegralType(string name) : base(name) { }
}

class BoolClass : IntegralType {
  public BoolClass() : base("Bool") { }

  static GBool ^default_ = new GBool(false);
  public override SimpleValue DefaultValue() { return default_; }

  public override string ToString() { return "bool"; }

  public override string EmitType() { return "bool"; }
}

class CharClass : IntegralType {
  public CharClass() : base("Char") { }

  static GChar ^default_ = new GChar('\0');

  public override SimpleValue DefaultValue() { return default_; }

  public override bool CanConvert1(GType t) { return t == GInt.type_; }

  public override string ToString() { return "char"; }

  public override RValue ^InvokeStatic(Method m, ValueList args) {
    switch (m.name_) {
      case "IsDigit": return new GBool(Char.IsDigit(args.Char(0)));
      case "IsLetter": return new GBool(Char.IsLetter(args.Char(0)));
      case "IsWhiteSpace": return new GBool(Char.IsWhiteSpace(args.Char(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "wchar_t"; }
}

class IntClass : IntegralType {
  public IntClass() : base("Int") { }

  static GInt ^default_ = new GInt(0);

  public override SimpleValue DefaultValue() { return default_; }

  public override bool CanConvert1(GType t) {
    return t == GFloat.type_ || t == GDouble.type_;
  }

  protected override bool CanConvertExplicit1(GType t) {
    return t == GChar.type_;
  }

  public override string ToString() { return "int"; }

  public override RValue ^InvokeStatic(Method m, ValueList args) {
    switch (m.name_) {
      case "Parse": return new GInt(int.Parse(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "int"; }
}

class FloatClass : SimpleType {
  public FloatClass() : base("Single") { }

  static GFloat ^default_ = new GFloat(0.0f);

  public override SimpleValue DefaultValue() { return default_; }

  public override bool CanConvert1(GType t) {
    return t == GDouble.type_;
  }

  protected override bool CanConvertExplicit1(GType t) {
    return t == GInt.type_;
  }

  public override string ToString() { return "float"; }

  public override string EmitType() { return "float"; }
}

class DoubleClass : SimpleType {
  public DoubleClass() : base("Double") { }

  static GDouble ^default_ = new GDouble(0.0d);

  public override SimpleValue DefaultValue() { return default_; }

  protected override bool CanConvertExplicit1(GType t) {
    return t == GInt.type_ || t == GFloat.type_;
  }

  public override string ToString() { return "double"; }

  public override string EmitType() { return "double"; }
}

class StringClass : Internal {
  public StringClass() : base("String") { }

  public override bool IsOwned() { return false; }
  public override bool IsValue() { return true; }

  public override string ToString() { return "string"; }

  public override string EmitType() {
    return "_Ref<String>";
  }

  public override string EmitReturnType() {
    return EmitType();
  }

  public override string EmitGenericType() {
    return EmitType();
  }

  public override RValue ^InvokeStatic(Method m, ValueList args) {
    switch (m.name_) {
      case "Format": return new GString(String.Format(args.GetString(0), args.Object(1)));
      default: Debug.Assert(false); return null;
    }
  }
}

class StringBuilderClass : Internal {
  public StringBuilderClass() : base("StringBuilder") { }
  public override GValue ^New() { return new GStringBuilder(); }
}

class GStringBuilder : GValue {
  readonly StringBuilder ^b_ = new StringBuilder();

  public static readonly StringBuilderClass ^type_ = new StringBuilderClass();

  public override GType Type() { return type_; }

  public override RValue ^Invoke(Method m, ValueList args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "Append": b_.Append(args.Char(0)); return null;
      case "ToString": return new GString(b_.ToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class PoolClass : Internal {
  public PoolClass() : base("Pool") { }

  public static PoolClass ^instance_ = new PoolClass();
}

class DebugClass : Internal {
  public DebugClass() : base("Debug") { }
  public static readonly DebugClass ^instance_ = new DebugClass();
  
  public override RValue ^InvokeStatic(Method m, ValueList args) {
    switch (m.name_) {
      case "Assert": Debug.Assert(args.Bool(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

class EnvironmentClass : Internal {
  public EnvironmentClass() : base("Environment") { }
  public static readonly EnvironmentClass ^instance_ = new EnvironmentClass();

  public override RValue ^InvokeStatic(Method m, ValueList args) {
    switch (m.name_) {
      case "Exit": Environment.Exit(args.Int(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

// built-in I/O classes

class ConsoleClass : Internal {
  public ConsoleClass() : base("Console") { }

  public override RValue ^InvokeStatic(Method m, ValueList args) {
    switch (m.name_) {
      case "Write":
        switch (m.parameters_.Count) {
          case 1: Console.Write(args.Object(0)); return null;
          case 2: Console.Write(args.GetString(0), args.Object(1)); return null;
          case 3: Console.Write(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      case "WriteLine":
        switch (m.parameters_.Count) {
          case 1: Console.WriteLine(args.Object(0)); return null;
          case 2: Console.WriteLine(args.GetString(0), args.Object(1)); return null;
          case 3: Console.WriteLine(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly ConsoleClass ^instance_ = new ConsoleClass();
}

class FileClass : Internal {
  public FileClass() : base("File") { }

  public override RValue ^InvokeStatic(Method m, ValueList args) {
    switch (m.name_) {
      case "Delete": File.Delete(args.GetString(0)); return null;
      case "Exists": return new GBool(File.Exists(args.ToString()));
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly FileClass ^instance_ = new FileClass();
}

class PathClass : Internal {
  public PathClass() : base("Path") { }

  public override RValue ^InvokeStatic(Method m, ValueList args) {
    switch (m.name_) {
      case "GetTempFileName": return new GString(Path.GetTempFileName());
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly PathClass ^instance_ = new PathClass();
}

class StreamReaderClass : Internal {
  public StreamReaderClass() : base("StreamReader") { }
  public override GValue ^New() { return new GStreamReader(); }
}

class GStreamReader : GValue {
  StreamReader ^reader_;

  public static readonly StreamReaderClass ^type_ = new StreamReaderClass();

  public override GType Type() { return type_; }

  public override RValue ^Invoke(Method m, ValueList args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StreamReader": reader_ = new StreamReader(args.GetString(0)); return null;
      case "Read": return new GInt(reader_.Read());
      case "Peek": return new GInt(reader_.Peek());
      default: Debug.Assert(false); return null;
    }
  }
}

class Program {
  ArrayList /* of string */ ^gel_import_ = new ArrayList();
  ArrayList /* of string */ ^cpp_import_ = new ArrayList();

  static Scanner ^scanner_;

  NonOwningArrayList ^classes_ = new NonOwningArrayList();
  ArrayList ^own_classes_ = new ArrayList();

  public bool crt_alloc_;
  public bool debug_;
  public bool safe_ = true;

  public Control prev_;   // previous node in control flow graph, used during graph construction

  public void Import(string s) {
    ArrayList a = null;
    string extension = Path.GetExtension(s);
    switch (extension) {
      case ".gel": a = gel_import_; break;
      case ".cpp": a = cpp_import_; break;
      default:
        new Syntax().Error("can't import file with extension {0}", extension);
        Environment.Exit(0);
        break;
    }
    foreach (string i in a)
      if (i == s)
        return;   // already imported
    a.Add(s);
  }

  public void FindAndImport(string s) {
    // First look relative to the importing file.
    string dir = Path.GetDirectoryName(Gel.CurrentFile());
    string s1 = Path.Combine(dir, s);
    if (!File.Exists(s1)) {
      // Now look relative to the GEL2 directory.
      s1 = Path.Combine(Gel.gel_directory_, s);
      if (!File.Exists(s1)) {
        new Syntax().Error("import not found: ", s);
        Environment.Exit(0);
      }
    }
    Import(s1);
  }
  
  public void Add(Class c) {
    c.SetProgram(this);
    classes_.Add(c);
  }

  public void AddOwn(Class ^c) {
    own_classes_.Add(c);
  }

  public Class FindClass(string name) {
    foreach (Class c in classes_)
      if (c.name_ == name)
        return c;
    return null;
  }

  public string CurrentFile() {
    return scanner_.filename_;
  }

  public int Line() {
    return scanner_.Line();
  }

  string Builtin(string module) {
    string file = String.Format("{0}.gel", module);
    return Path.Combine(Gel.gel_directory_, file);
  }

  public bool Parse() {
    Parser ^parser = new Parser();
    for (int i = 0; i < gel_import_.Count; ++i) {
      string file = (string) gel_import_[i];
      scanner_ = new Scanner(file);
      parser.yyParse(scanner_);
      if (i == 0) {
        Import(Builtin("internal"));
        Import(Builtin("library"));
      }
    }
    return true;
  }

  public bool Resolve() {
    foreach (Class c in classes_)
      if (!c.ResolveAll(this))
        return false;

    return true;
  }

  public bool Check() {
    Context ^ctx = new Context(this);
    bool ok = true;

    // Make a first checking pass where we check only constant fields.
    foreach (Class c in classes_)
      ok &= c.Check1(ctx);

    foreach (Class c in classes_)
      ok &= c.Check(ctx);

    return ok;
  }

  Method FindMain() {
    NonOwningArrayList ^methods = new NonOwningArrayList();
    foreach (Class c in classes_) {
      c.GetMainMethod(methods);
    }
    if (methods.Count == 0) {
      Console.WriteLine("no Main() method found");
      return null;
    }
    if (methods.Count > 1) {
      Console.WriteLine("error: found more than one Main() method");
      return null;
    }
    return (Method) methods[0];
  }

  public void Eval(ArrayList /* of string */ args) {
    Method m = FindMain();
    if (m == null)
      return;
    ArrayList ^a = new ArrayList();
    if (m.parameters_.Count > 0) {   // Main() takes a string[] argument
      GArray ^arr = new GArray(new ArrayType(GString.type_), args.Count);
      for (int i = 0 ; i < args.Count ; ++i)
        arr.Set(i, new GString((string) args[i]));
      a.Add(arr);
    }
    foreach (Class c in classes_)
      c.StaticInit();
    m.Invoke(null, a);
  }

  void EmitMain(SourceWriter w, Method main) {
    bool args = main.parameters_.Count > 0;
    w.Write("int main({0}) ", args ? "int argc, char *argv[]" : "");
    w.OpenBrace();
    w.IWriteLine("return gel_runmain({0}::Main{1});", main.GetClass().name_, args ? ", argc, argv" : "");
    w.CloseBrace();
  }

  public bool Emit(SourceWriter w) {
    Method main = FindMain();
    if (main == null)
      return false;

    w.WriteLine("#define MEMORY_OWN 1");
    if (safe_)
      w.WriteLine("#define MEMORY_SAFE 1");
    if (crt_alloc_)
      w.WriteLine("#define MEMORY_CRT 1");

    foreach (string f in cpp_import_)
      w.WriteLine("#include {0}", GString.EmitString(f));

    // We undefine NULL since Gel code may legitimately define fields or variables with that name.
    // Generated code uses 0, not NULL, to indicate the null pointer.
    w.WriteLine("#undef NULL");

    w.WriteLine("");

    // Forward-declare all classes since C++ requires a class to be declared before its name can
    // be used as a type.
    foreach (Class c in classes_)
      if (!(c.HasAttribute(Attribute.Extern)))
        w.WriteLine("class {0};", c.name_);
    w.WriteLine("");

    foreach (Class c in classes_)
      c.EmitDeclaration(w);

    foreach (Class c in classes_)
      c.Emit(w);

    EmitMain(w, main);
    return true;
  }

  // Emit C++ code.
  public bool Generate(string basename) {
    string cpp_file = basename + ".cpp";
    StreamWriter ^w = new StreamWriter(cpp_file);
    bool ok = Emit(new SourceWriter(w));
    w.Close();
    return ok;
  }

  static string[] ^vsdirs = { "Microsoft Visual Studio 8",
                            "Microsoft Visual Studio .NET 2003",
                            "Microsoft Visual Studio .NET 2002" };

  string VsVars(int i) {
    return String.Format("C:\\Program Files\\{0}\\Common7\\Tools\\vsvars32.bat", vsdirs[i]);
  }

  string FindVsVars() {
    for (int i = 0; i < vsdirs.Length; ++i) {
      string f = VsVars(i);
      if (File.Exists(f))
        return f;
    }

    Console.WriteLine("Error: unable to find vsvars32.bat at any of the following locations:");
    Console.WriteLine("");
    for (int i = 0; i < vsdirs.Length; ++i)
      Console.WriteLine(VsVars(i));
    Console.WriteLine("");
    Console.WriteLine("Your Visual Studio installation may be invalid.  Aborting compilation.");
    return null;
  }

  // Report compilation error. Print error message from a file
  void ReportCompilationError(string error_msg_file) {
      Console.WriteLine(
        "Error: unable to compile generated C++ code.  You may have found a bug in the GEL2 compiler.");
      Console.WriteLine("C++ compiler output follows:");
      Console.WriteLine("");
      Console.WriteLine((new StreamReader(error_msg_file)).ReadToEnd());
  }

  void UnixCppCompile(string basename) {
    string command_out = Path.GetTempFileName();
    string dbg_options = debug_ ? "-g -DDEBUG" : "-O2 -DNDEBUG";
    StringBuilder ^sb = new StringBuilder();
    // -o basename, use basename as the executable name
    // -Werror, make all warnings into hard errors
    sb.AppendFormat("/usr/bin/g++ -o {0} -Werror {1} {2}.cpp",
                    basename, dbg_options, basename);

    // Append redirection of output
    sb.AppendFormat(" > {0} 2>&1", command_out);
 
    string sh_cmd = sb.ToString();

    if (Gel.verbose_) 
      Console.WriteLine(sh_cmd);
  
    if (Process.System(sh_cmd) !=0) {
      ReportCompilationError(command_out);
    }
    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".o");
  }

  // Run vsvars32.bat and the run the given command, redirecting output to a file.
  // We must always redirect output since vsvars32 prints a message "Setting environment..."
  // which we don't want users to see.
  int VsRun(string vsvars, string command, string output) {
    command = String.Format("(\"{0}\" & {1}) > \"{2}\"", 
                            vsvars, command, output);
    return Process.System(command);
  }

  void VsCppCompile(string basename) {
    string vsvars = FindVsVars();
    if (vsvars == null)
      return;
    string command_out = Path.GetTempFileName();

    string options = debug_ ?
      //  /MDd - runtime library: multithreaded debug DLL
      //  /Od - optimization: disabled
      //  /ZI - debug information format: Program Database for Edit & Continue
      "/MDd /Od /ZI /D \"_DEBUG\"" :

      //  /MD - runtime library: multithreaded DLL
      //  /O2 - optimization: Maximize Speed
      //  /GL - optimization: Whole Program Optimization
      "/MD /O2 /GL /D \"NDEBUG\"";

    StringBuilder ^sb = new StringBuilder();
    //  /WX - treat warnings as errors
    sb.AppendFormat("cl /nologo /WX {0} {1}.cpp", options, basename);
    string mode = debug_ ? "debug" : "release";
    if (!crt_alloc_)
      sb.AppendFormat(" {0}\\{1}\\dlmalloc.obj", Gel.gel_directory_, mode);
    sb.Append(" user32.lib shell32.lib shlwapi.lib");
    string command = sb.ToString();
    if (Gel.verbose_)
      Console.WriteLine(command);

    if (VsRun(vsvars, command, command_out) != 0) {
      ReportCompilationError(command_out);
    } else {
      // Run the manifest tool to embed the linker-generated manifest into the executable file;
      // this allows the executable to find the C runtime DLL even when the manifest file is absent.
      string mt_command = String.Format("mt -nologo -manifest {0}.exe.manifest -outputresource:\"{0}.exe;#1\"",
                              basename);
      if (Gel.verbose_)
        Console.WriteLine(mt_command);
      if (VsRun(vsvars, mt_command, command_out) != 0)
        Console.WriteLine("warning: could not run manifest tool");
    }

    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".obj");
    File.Delete(basename + ".exe.manifest");
  }

  // Invoke the C++ compiler to generate a native executable.
  void CppCompile(string basename) {
    if (Environment.OSVersion.Platform == PlatformID.Win32NT) 
      VsCppCompile(basename);
    else
      UnixCppCompile(basename);
  }

  public void Compile(string output, bool cpp_only) {
    if (output == null)
      output = Path.GetFileNameWithoutExtension((string) gel_import_[0]);
    if (Generate(output) && !cpp_only)
      CppCompile(output);
  }
}

class Scanner : yyInput {
  public readonly string filename_;

  int line_;
  public int Line() { return line_; }

  StreamReader ^sr_;
  int token_;
  object ^ value_;

  int next_token_ = -1;
  object ^ next_value_;

  public Scanner (string filename) {
    filename_ = filename;
    sr_ = new StreamReader(filename);
    line_ = 1;
  }

  public override int GetToken () {
    return token_;
  }

  public override object ^ GetValue () {
    return take value_;
  }

  int Read() {
    int i = sr_.Read();
    if (i == '\n')
      ++line_;
    return i;
  }

  bool Read(out char c) {
    int i = Read();
    c = (char) i;
    return i != -1;
  }

  char Peek() {
    return (char) sr_.Peek();
  }

  string ReadWord(char first) {
    StringBuilder ^sb = new StringBuilder();
    if (first != '\0')
      sb.Append(first);
    while (true) {
      char c = Peek();
      if (!Char.IsLetter(c) && !Char.IsDigit(c) && c != '_')
        break;
      sb.Append(c);
      Read();
    }
    return sb.ToString();
  }

  // Read to the end of the current line.
  string ReadLine() {
    StringBuilder ^sb = new StringBuilder();
    char c;
    while (Read(out c)) {
      if (c == '\n')
        break;
      sb.Append(c);
    }
    return sb.ToString();
  }

  // Read a comment delimited by /* ... */, assuming we've already read the opening /*.
  // Returns true on success, or false on EOF.
  bool ReadDelimitedComment() {
    char prev = (char) 0;
    while (true) {
      char c;
      if (!Read(out c)) {
        Console.WriteLine("warning: unterminated comment at end of file");
        return false;
      }
      if (c == '/' && prev == '*')
        return true;
      prev = c;
    }
  }

  // Preprocess input, handling whitespace, comments and directives; return the first
  // character not eaten by preprocessing, or -1 on EOF.
  int GetChar() {
    while (true) {
      int i = Read();
      if (i == -1)
        return -1;   // end of input
      if (i == 0)
        continue;   // end of this file; move on
      char c = (char) i;

      if (c == '\n' && Peek() == '#') {
        Read();
        string directive = ReadWord('\0');
        if (directive == "line") {
          ReadLine();
          continue;
        }
        Console.WriteLine("error: unknown preprocessing directive {0}", directive);
        Environment.Exit(0);
      }

      if (Char.IsWhiteSpace(c))
        continue;

      if (c == '/') {
        switch (Peek()) {
          case '/':  // single-line comment
            Read();
            int line = line_;
            string s = ReadLine();
            if (Gel.error_test_ && s.StartsWith(" error"))
              Gel.expected_error_lines_.Add(line);
            continue;

          case '*':  // comment delimited by /* ... */
            Read();   // move past opening '*'
            if (!ReadDelimitedComment())
              return (char) 0;
            continue;
        }
      }

      return c;
    }
  }

  bool IsDigit(char c, bool hex) {
    if (Char.IsDigit(c))
      return true;
    if (!hex)
      return false;
    return (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');
  }

  // Read a number, possibly including a decimal point and/or exponent.
  string ReadNumber(char first, bool hex, out bool real) {
    bool dot = false, exp = false;
    StringBuilder ^sb = new StringBuilder();
    sb.Append(first);
    if (first == '.')
      dot = true;

    while (true) {
      bool need_digit = false;
      char c = Peek();
      if (c == '.' && !hex && !dot && !exp) {
        sb.Append(c);
        Read();
        dot = true;
        c = Peek();
        need_digit = true;
      }
      else if ((c == 'e' || c == 'E') && !hex && !exp) {
        sb.Append(c);
        Read();
        exp = true;
        c = Peek();
        if (c == '+' || c == '-') {
          sb.Append(c);
          Read();
          c = Peek();
        }
        need_digit = true;
      }
      if (!IsDigit(c, hex)) {
        if (!need_digit)
          break;
        real = false;
        return null;
      }
      sb.Append(c);
      Read();
    }

    real = dot || exp;
    return sb.ToString();
  }

  int ParseNumber(char first, out object ^val) {
    bool hex = false;
    if (first == '0') {
      char p = Peek();
      if (p == 'x' || p == 'X') {
        Read();
        hex = true;
      }
    }
    bool real;
    string s = ReadNumber(first, hex, out real);
    if (s == null) {
      val = null;
      return Parser.SCAN_ERROR;
    }
    if (!hex) {
      switch (Peek()) {
        case 'F':
        case 'f':
          Read();
          val = Single.Parse(s);
          return Parser.FLOAT_LITERAL;
        case 'D':
        case 'd':
          Read();
          real = true;
        break;
    }
    }
    if (real) {
      val = Double.Parse(s);
      return Parser.DOUBLE_LITERAL;
    }
    val = int.Parse(s, hex ? NumberStyles.HexNumber : NumberStyles.Integer);
    return Parser.INT_LITERAL;
  }

  int ParseWord(char first, out object ^val) {
    string s = ReadWord(first);

    val = null;
    switch (s) {
      case "abstract": return Parser.ABSTRACT;
      case "as": return Parser.AS;
      case "base": return Parser.BASE;
      case "bool": return Parser.BOOL;
      case "break": return Parser.BREAK;
      case "case": return Parser.CASE;
      case "char": return Parser.CHAR;
      case "class": return Parser.CLASS;
      case "const": return Parser.CONST_TOKEN;
      case "continue": return Parser.CONTINUE;
      case "default": return Parser.DEFAULT;
      case "do": return Parser.DO;
      case "double": return Parser.DOUBLE;
      case "else": return Parser.ELSE;
      case "extern": return Parser.EXTERN;
      case "false": return Parser.FALSE_TOKEN;
      case "float": return Parser.FLOAT;
      case "for": return Parser.FOR;
      case "foreach": return Parser.FOREACH;
      case "if": return Parser.IF;
      case "import": return Parser.IMPORT;
      case "in": return Parser.IN_TOKEN;
      case "int": return Parser.INT;
      case "is": return Parser.IS;
      case "new": return Parser.NEW;
      case "null": return Parser.NULL;
      case "object": return Parser.OBJECT;
      case "out": return Parser.OUT_TOKEN;
      case "override": return Parser.OVERRIDE;
      case "pool": return Parser.POOL;
      case "private": return Parser.PRIVATE;
      case "protected": return Parser.PROTECTED;
      case "public": return Parser.PUBLIC;
      case "readonly": return Parser.READONLY;
      case "ref": return Parser.REF;
      case "return": return Parser.RETURN;
      case "short": return Parser.SHORT;
      case "static": return Parser.STATIC;
      case "string": return Parser.STRING;
      case "switch": return Parser.SWITCH;
      case "take": return Parser.TAKE;
      case "this": return Parser.THIS_TOKEN;
      case "true": return Parser.TRUE_TOKEN;
      case "virtual": return Parser.VIRTUAL;
      case "void": return Parser.VOID_TOKEN;
      case "while": return Parser.WHILE;
      default:
        val = s;
        return Parser.ID;
    }
  }

  bool ParseEscape(ref char c) {
    if (!Read(out c))
      return false;
    switch (c) {
      case '\'':
      case '\"':
      case '\\':
        break;
      case '0': c = '\0'; break;
      case 'n': c = '\n'; break;
      case 'r': c = '\r'; break;
      case 't': c = '\t'; break;
      default: return false;
    }
    return true;
  }

  int ParseChar(out object ^val) {
    val = null;
    char c;
    if (!Read(out c))
      return Parser.SCAN_ERROR;
    if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
    char d;
    if (!Read(out d) || d != '\'')
      return Parser.SCAN_ERROR;
    val = c;
    return Parser.CHAR_LITERAL;
  }

  int ParseString(out object ^val) {
    val = null;
    StringBuilder ^sb = new StringBuilder();
    while (true) {
      char c;
      if (!Read(out c))
        return Parser.SCAN_ERROR;
      if (c == '"')
        break;
      if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
      sb.Append(c);
    }
    val = sb.ToString();
    return Parser.STRING_LITERAL;
  }

  int ReadToken(out object ^val) {
    val = null;

    int i = GetChar();
    if (i == -1)
      return -1;
    char c = (char) i;

    if (Char.IsDigit(c) || c == '.' && Char.IsDigit(Peek()))
      return ParseNumber(c, out val);

    if (Char.IsLetter(c) || c == '_')
      return ParseWord(c, out val);

    if (c == '\'')
      return ParseChar(out val);

    if (c == '"')
      return ParseString(out val);

    char peek = Peek();
    int token = 0;
    switch (c.ToString() + peek.ToString()) {
      case "++": token = Parser.PLUS_PLUS; break;
      case "--": token = Parser.MINUS_MINUS; break;
      case "&&": token = Parser.OP_AND; break;
      case "||": token = Parser.OP_OR; break;
      case "==": token = Parser.OP_EQUAL; break;
      case "!=": token = Parser.OP_NE; break;
      case "<=": token = Parser.OP_LE; break;
      case "<<": token = Parser.OP_LEFT_SHIFT; break;
      case ">=": token = Parser.OP_GE; break;
      case ">>": token = Parser.OP_RIGHT_SHIFT; break;
      case "*=": token = Parser.STAR_EQUAL; break;
      case "/=": token = Parser.SLASH_EQUAL; break;
      case "%=": token = Parser.PERCENT_EQUAL; break;
      case "+=": token = Parser.PLUS_EQUAL; break;
      case "-=": token = Parser.MINUS_EQUAL; break;
      case "&=": token = Parser.AND_EQUAL; break;
      case "|=": token = Parser.OR_EQUAL; break;

      // Return [] as a single token; this lets the parser distinguish the cases
      // "foo[] a;" and "foo[x] = 4" as soon as it reads the first token after the identifier "foo".
      case "[]": token = Parser.ARRAY_TYPE; break;
    }
    if (token != 0) {
      Read();
    } else token = c;

    val = token;
    return token;
  }

  public override bool Advance () {
    if (next_token_ != -1) {
      token_ = next_token_;
      value_ = take next_value_;
      next_token_ = -1;
    } else {
      token_ = ReadToken(out value_);
      if (token_ == -1) return false;
    }

    if (token_ == ')') {
      // We need to read one token ahead to determine whether this close parenthesis
      // ends a type cast.  See e.g. the discussion in the Cast Expressions section
      // of the C# specification.
      next_token_ = ReadToken(out next_value_);
      switch (next_token_) {
        case -1:  // end of file
          break;
        case '!':
        case '(':
        case Parser.ID:
        case Parser.INT_LITERAL:
        case Parser.CHAR_LITERAL:
        case Parser.STRING_LITERAL:
          token_ = Parser.CAST_CLOSE_PAREN;
          break;
        default:
          if (next_token_ >= Parser.FIRST_KEYWORD && next_token_ <= Parser.LAST_KEYWORD &&
              next_token_ != Parser.AS && next_token_ != Parser.IS)
            token_ = Parser.CAST_CLOSE_PAREN;
          break;
      }
    }
    return true;
  }

  public override void Fatal() {
    new Syntax().Error("irrecoverable syntax error");
    Environment.Exit(1);
  }

}

class Gel {
  public static bool verbose_;

  public static bool error_test_;
  public static bool print_type_sets_;

  public static readonly ArrayList /* of int */ ^expected_error_lines_ = new ArrayList();
  public static readonly ArrayList /* of int */ ^error_lines_ = new ArrayList();

  public static Program ^program_;

  public static readonly string gel_directory_ = GetLibraryPath();

  static string GetLibraryPath() {
    return Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName); 
  }

  public static string CurrentFile() {
    return program_ == null ? "" : program_.CurrentFile();
  }

  public static int Line() {
    return program_ == null ? 0 : program_.Line();
  }

  public static void Exit() { Environment.Exit(0); }

  // Given two sorted ArrayLists a, b of ints, return an ArrayList containing all ints which appear
  // in [a] but not in [b].
  ArrayList ^Diff(ArrayList a, ArrayList b) {
    ArrayList ^ret = new ArrayList();
    int bi = 0;
    foreach (int i in a) {
      while (bi < b.Count && (int) b[bi] < i)
        ++bi;
      if (bi >= b.Count || (int) b[bi] > i)
        ret.Add(i);
    }
    return ret;
  }

  void WriteLineNumbers(ArrayList a) {
    for (int i = 0; i < a.Count; ++i) {
      if (i > 0)
        Console.Write(", ");
      Console.Write(a[i]);
    }
    Console.WriteLine("");
  }

  void ErrorTestReport() {
    Console.WriteLine("");
    ArrayList ^e = Diff(error_lines_, expected_error_lines_);
    if (e.Count > 0) {
      Console.Write("unexpected error at line ");
      WriteLineNumbers(e);
    }
    ArrayList ^e2 = Diff(expected_error_lines_, error_lines_);
    if (e2.Count > 0) {
      Console.Write("expected error at line ");
      WriteLineNumbers(e2);
    }
    if (e.Count == 0 && e2.Count == 0)
      Console.WriteLine("all errors expected");
  }

  void Usage() {
    Console.WriteLine("usage: gel <source-file> ... [args]");
    Console.WriteLine("       gel -c [-d] [-o <name>] [-u] [-v] [-cpp] <source-file> ...");
    Console.WriteLine("");
    Console.WriteLine("   -c: compile to native executable");
    Console.WriteLine("   -d: debug mode: disable optimizations, link with debug build of C runtime");
    Console.WriteLine("   -o: specify output filename");
    Console.WriteLine("   -u: unsafe: skip reference count checks");
    Console.WriteLine("   -v: verbose: display command used to invoke C++ compiler");
    Console.WriteLine(" -cpp: compile to C++ only");
  }

  public void Run(string[] args) {
    if (args.Length < 1) {
      Usage();
      return;
    }

    Internal.Init();

    program_ = new Program();
    bool compile = false;
    bool cpp_only = false;
    string output = null;
    int i;
    for (i = 0; i < args.Length && args[i].StartsWith("-"); ++i)
      switch (args[i]) {
        case "-c": compile = true; break;
        case "-d": program_.debug_ = true; break;
        case "-e": error_test_ = true; break;
        case "-o":
          if (++i >= args.Length) {
            Usage();
            return;
          }
          output = Path.GetFileNameWithoutExtension(args[i]);
          break;
        case "-u": program_.safe_ = false; break;
        case "-v": verbose_ = true; break;
        case "-cpp": cpp_only = true; break;
        case "-crt": program_.crt_alloc_ = true; break;
        case "-typeset": print_type_sets_ = true; break;
        default:
          Console.WriteLine("unrecognized option: {0}", args[i]);
          return;
      }

    for (; i < args.Length ; ++i)
      if (args[i].EndsWith(".gel"))
        program_.Import(args[i]);
      else {
        if (args[i] == "-")   // marker indicating end of source files
          ++i;
        break;
      }

    ArrayList ^program_args = new ArrayList();
    if (compile) {
      if (i < args.Length) {
        Console.WriteLine("file to compile has unrecognized extension: {0}", args[i]);
        return;
      }
    } else {
      for (; i < args.Length; ++i)
        program_args.Add(args[i]);
    }

    if (!program_.Parse())
      return;

    bool ok = program_.Resolve() && program_.Check();
    if (error_test_)
      ErrorTestReport();
    if (!ok)
      return;

    if (compile)
      program_.Compile(output, cpp_only);
    else program_.Eval(program_args);
  }

  public static void Main(string[] args) {
    new Gel().Run(args);
  }
}
/*
Copyright (c) 2006 Google Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

class Syntax_2 {
  public readonly string file_;
  public readonly int line_;

  public Syntax_2() { file_ = Gel_2.CurrentFile(); line_ = Gel_2.Line(); }

  static void Report(string file, int line, string type) {
    Console.Write("{0}({1}): ", file, line);
    Console.Write("{0}: ", type);
    if (Gel_2.error_test_)
      Gel_2.error_lines_.Add(line);
  }

  public void Error(string message) {
    Report(file_, line_, "error");
    Console.WriteLine(message);
  }

  public void Error(string format, object arg) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg);
  }

  public void Error(string format, object arg1, object arg2) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2);
  }

  public void Error(string format, object arg1, object arg2, object arg3) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2, arg3);
  }

  public void Warning(string message) {
    Report(file_, line_, "warning");
    Console.WriteLine(message);
  }
}

abstract class TypeExpr_2 : Syntax_2 {
  public abstract GType_2 Resolve(Program_2 program);
  public abstract TypeExpr_2 ^Copy();
}

class ConversionContext_2 {
  public const int Other = 0,
                   AssignVar = 1,
                   MethodArg = 2;
}

// GEL2 includes the following kinds of types:
// - simple types (int, bool, char, float, double): SimpleType_2
// - owned types (including array types): ArrayType_2 or Class_2 with Owned() => true
// - owning types: Owning_2
// - string: GString_2
// - null type: NullType_2
// - void: VoidType_2

abstract class GType_2 {
  public virtual bool IsOwned() { return false; }

  // A reference type is an owned, owning, string or null type.
  public virtual bool IsReference() { return true; }

  // A value type is a simple or string type.
  public virtual bool IsValue() { return false; }

  public virtual Class_2 Parent() { return GObject_2.type_; }
  
  // If_2 this is an owning type T ^ then return T; otherwise return this.
  public virtual GType_2 BaseType() { return this; }

  // Return_2 the set of types which may be destroyed when a variable of this type
  // is destroyed.
  public virtual TypeSet_2 VarDestroys() { return TypeSet_2.empty_; }

  // Return_2 the set of types which may be destroyed when a value of this concrete type
  // is destroyed.
  public virtual TypeSet_2 TypeDestroys() { return TypeSet_2.empty_; }

  public virtual void FindVarDestroys(int marker, TypeSet_2 set) { }

  public virtual void FindTypeDestroys(int marker, TypeSet_2 set) { }

  public virtual bool IsSubtype(GType_2 type) {
    for (GType_2 t = this; t != null ; t = t.Parent())
      if (type.Equals(t))
        return true;
    return false;
  }

  public virtual Owning_2 OwningType() { Debug.Assert(false); return null; }

  protected virtual bool CanConvertOwnership(GType_2 t, int context) {
    bool from_owning = this is Owning_2;
    bool to_owning = t is Owning_2;
    if (IsValue() && t.BaseType() == GObject_2.type_) {
      Debug.Assert(!from_owning);
      // boxing conversion yields an owning pointer; string->object conversion may
      // yield an owning or non-owning pointer
      return to_owning || context == ConversionContext_2.MethodArg || this == GString_2.type_;
    }
    if (BaseType() == GObject_2.type_ && t.IsValue()) {
      Debug.Assert(!to_owning);
      return true;  // an unboxing or object->string conversion, OK in any context
    }
    return from_owning == to_owning ||
           from_owning && !to_owning &&
             (context == ConversionContext_2.AssignVar || context == ConversionContext_2.MethodArg);
  }

  // Ensure that this class will inherit from Object in generated C++ code.
  public virtual void SetObjectInherit() { }

  // Return_2 true if there is a non-subtyping implicit conversion from this to t.
  public virtual bool CanConvert1(GType_2 t) { return false; }

  // Return_2 true if there is a non-subtyping explicit conversion from this to t.
  protected virtual bool CanConvertExplicit1(GType_2 t) { return false; }

  // Return_2 true if this type can be converted to type [to].
  public bool CanConvert(GType_2 to, int context, bool is_explicit, bool subtype_only) {
    if (!CanConvertOwnership(to, context))
      return false;

    GType_2 from_base = BaseType();
    GType_2 to_base = to.BaseType();
    if (from_base.Equals(to_base))
      return true;   // identity conversion

    // If_2 we ever perform a conversion to C ^, then C must have a vtable so that we can call
    // a virtual destructor when an owning pointer is destroyed.
    if (to is Owning_2 && this != Null_2.type_)
      to_base.SetVirtual();

    // If_2 we ever perform an explicit conversion from a class, that class must
    // have a vtable so that every instance of the class will have run-time type information.
    if (is_explicit)
      from_base.SetVirtual();

    // If_2 we ever convert between C and Object, then C must derive from Object in generated code.
    if (from_base == GObject_2.type_)
      to_base.SetObjectInherit();
    else if (to_base == GObject_2.type_)
      from_base.SetObjectInherit();

    return from_base.IsSubtype(to_base) ||
           !subtype_only && from_base.CanConvert1(to_base) ||
           is_explicit && (to_base.IsSubtype(from_base) ||
                           !subtype_only && from_base.CanConvertExplicit1(to_base));
  }

  public bool CanConvert(GType_2 t, int context) { return CanConvert(t, context, false, false); }
  public bool CanConvert(GType_2 t) { return CanConvert(t, ConversionContext_2.Other); }

  public bool CanConvertExplicit(GType_2 t, bool subtype_only) {
    return CanConvert(t, ConversionContext_2.Other, true, subtype_only);
  }

  public bool CheckConvert(Syntax_2 caller, GType_2 t, int context) {
    if (!CanConvert(t, context)) {
      caller.Error("can't convert {0} to {1}", this, t);
      return false;
    }
    return true;
  }

  public bool CheckConvert(Syntax_2 caller, GType_2 t) {
    return CheckConvert(caller, t, ConversionContext_2.Other);
  }

  // Return_2 a type to which the types [this] and t can both be implicitly converted.
  public GType_2 CommonType(Syntax_2 caller, GType_2 t) {
    if (CanConvert(t))
      return t;
    if (t.CanConvert(this))
      return this;
    caller.Error("incompatible types: {0} and {1}", this, t);
    return null;
  }

  public abstract SimpleValue_2 DefaultValue_2();

  static ArrayList ^empty_array_ = new ArrayList();
  public virtual ArrayList /* of Member_2 */ Members() { return empty_array_; }

  public Member_2 GetMatchingMember(Member_2 m1) {
    foreach (Member_2 m in Members())
      if (m.MatchSignature(m1))
        return m;
    return null;
  }

  // Find a match for m in this type or its ancestors, ignoring private members and
  // optionally ignoring overrides.
  public Member_2 FindMatchingMember(Member_2 m, bool override_ok) {
    for (GType_2 t = this ; t != null ; t = t.Parent()) {
      Member_2 m1 = t.GetMatchingMember(m);
      if (m1 != null && !m1.IsPrivate() && (override_ok || !m1.IsOverride()))
        return m1;
    }
    return null;
  }

  int Score(bool accessible, int mismatches) {
    return (accessible ? 0 : 100) + mismatches;
  }

  public Member_2 Lookup(Syntax_2 caller, Class_2 from_class, bool through_base,
                       int kind, string name, ArrayList /* of Argument_2 */ arguments, bool report_error) {
    Member_2 m1 = null;   // the best match we've found so far
    bool found_any = false;
    bool accessible = false;
    int score = -1;

    GType_2 this_type = BaseType();
    GType_2 t;
    for (t = this_type; t != null; t = (kind == MemberKind_2.Constructor_2 ? null : t.Parent())) {
      foreach (Member_2 m in t.Members())
        if (Member_2.MatchKind(m.Kind(), kind) && m.name_ == name && !m.IsOverride()) {
          found_any = true;
          int mismatches = 0;
          if (arguments != null && !m.IsApplicable(arguments, out mismatches))
            continue; // wrong argument count
          bool new_accessible = m.IsAccessible(from_class, this_type, through_base);
          int new_score = Score(new_accessible, mismatches);
          if (new_score == 0 && score == 0) {
            if (report_error)
              caller.Error("{0}: ambiguous {1} call", name, Member_2.ToString(kind));
            return null;
          }
          if (score == -1 || new_score < score) {
            m1 = m;
            score = new_score;
            accessible = new_accessible;
          }
        }
      if (score == 0)
        break;
    }

    if (score != 0) {
      if (report_error) {
        string k = Member_2.ToString(kind);
        if (!found_any)
          caller.Error("{0}: {1} not found", name, k);
        else if (score == -1) {
          string a = String.Format("{0} argument{1}", arguments.Count, arguments.Count == 1 ? "" : "s");
          caller.Error("{0}: no {1} overload takes {2}", name, k, a);
        } else if (!accessible)
          caller.Error("{0}: can't access {1} {2}",
                       name, m1.IsProtected() ? "protected" : "private", k);
        else {
          caller.Error("{0}: the best overloaded {1} match has some invalid arguments", name, k);
          m1.ReportMismatches(caller, arguments);
        }
      }
      return null;
    }

    // If_2 we've found a member of the Object class, then we're using this class as an object,
    // so in generated code it must ultimately inherit from Object, not _Object.
    if (t == GObject_2.type_)
      this_type.SetObjectInherit();

    if (through_base) {
      // As_2 a special case, whenever we're accessing through base we find the member which will
      // actually be invoked; this is not necessarily the same as the member we've just found
      // if the member is virtual.
      m1 = FindMatchingMember(m1, true);
      Debug.Assert(m1 != null);
    }

    return m1;
  }

  public virtual void SetVirtual() { }

  // Emit the name of the C++ class we use to hold instances of this type.
  public virtual string EmitTypeName() { Debug.Assert(false); return null; }

  // Return_2 a C++ type of the form "T<U>".  If_2 U ends with a '>', we emit an
  // extra space to avoid emitting the token >>, which will cause GCC to complain.
  public static string ConstructType(string generic, string type) {
    return String.Format("{0}<{1}{2}>", generic, type,
                         type.EndsWith(">") ? " " : "");
  }

  string EmitNonOwningPointer(string name) {
    if (Gel_2.program_.safe_)
      return ConstructType(this == GObject_2.type_ ? "_PtrRef" : "_Ptr", name);
    return String.Format("{0} *", name);
  }

  // Emit a C++ type used for variables holding instances of this type.
  public virtual string EmitType() {
    return EmitNonOwningPointer(EmitTypeName());
  }

  // Emit a C++ type used for expressions holding instances of this type.
  public virtual string EmitExprType() {
    return EmitTypeName() + " *";
  }

  public virtual string EmitReturnType() {
    return EmitExprType();
  }

  public virtual string EmitGenericType() {
    return IsReference() ? EmitNonOwningPointer("Object") : EmitType();
  }
}

class TypeSet_2 {
  NonOwningArrayList /* of GType_2 */ ^types_ = new NonOwningArrayList();

  public static readonly TypeSet_2 ^empty_ = new TypeSet_2();

  public void Add(GType_2 type) {
    for (int i = 0; i < types_.Count; ++i) {
      GType_2 t = (GType_2) types_[i];
      if (type.IsSubtype(t))
        return;
      if (t.IsSubtype(type)) {
        types_[i++] = type;
        while (i < types_.Count) {
          t = (GType_2) types_[i];
          if (t.IsSubtype(type))
            types_.RemoveAt(i);
          else ++i;
        }
        return;
      }
    }
    types_.Add(type);
  }

  public void Add(TypeSet_2 set) {
    foreach (GType_2 t in set.types_)
      Add(t);
  }

  public bool Contains(GType_2 type) {
    foreach (GType_2 t in types_)
      if (type.IsSubtype(t))
        return true;
    return false;
  }

  public bool IsObject() {
    return types_.Count > 0 && types_[0] == GObject_2.type_;
  }

  public override string ToString() {
    StringBuilder ^sb = new StringBuilder();
    sb.Append("{");
    foreach (GType_2 t in types_)
      sb.AppendFormat(" {0}", t.ToString());
    sb.Append(" }");
    return sb.ToString();
  }
}

class VoidType_2 : GType_2 {
  public override bool IsReference() { Debug.Assert(false); return false; }

  public override SimpleValue_2 DefaultValue_2() { Debug.Assert(false); return null; }

  public override string ToString() { return "void"; }

  public override string EmitExprType() { return "void"; }
  public override string EmitType() { return "void"; }
}

class Void_2 {
  public static readonly GType_2 ^type_ = new VoidType_2();
}

// an RValue_2, a Location_2 containing an RValue_2, or a LocationRef_2 pointing to a Location_2 containing an RValue_2
abstract class ValueOrLocation_2 {
  public abstract GValue_2 Get();
}

// a GValue_2 or a reference to a GValue_2
abstract class RValue_2 : ValueOrLocation_2 {
  public abstract RValue_2 ^CopyRef();
}

abstract class GValue_2 : RValue_2 {
  public override GValue_2 Get() { return this; }

  public abstract GType_2 Type();

  public override RValue_2 ^CopyRef() { return new Reference_2(this); }

  public virtual RValue_2 ^Get(Field_2 field) { Debug.Assert(false); return null; }
  public virtual RValue_2 ^Take_2(Field_2 field) { Debug.Assert(false); return null; }

  public virtual RValue_2 ^ConvertExplicit(ref RValue_2 ^this_own, GType_2 t) {
    // try implicit conversion
    RValue_2 ^v = Convert(ref this_own, t);
    if (v != this || Type().IsSubtype(t) )
      return v;

    Console.WriteLine("type cast failed: object of type {0} is not a {1}", Type(), t);
    Gel_2.Exit();
    return null;
  }

  // Implicitly convert this value to type t.
  public virtual RValue_2 ^Convert(ref RValue_2 ^this_own, GType_2 t) {
    return take this_own;
  }

  public virtual bool DefaultEquals(object o) { return Equals(o); }
  public virtual int DefaultHashCode() { return GetHashCode(); }
  public virtual string DefaultToString() { return ToString(); }

  public virtual RValue_2 ^Invoke(Method_2 m, ValueList_2 args) {
    switch (m.name_) {
      case "Equals": return new GBool_2(DefaultEquals(args.Object(0)));
      case "GetHashCode": return new GInt_2(DefaultHashCode());
      case "ToString": return new GString_2(DefaultToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class Reference_2 : RValue_2 {
  public readonly GValue_2 value_;    // a reference value, never a SimpleValue_2

  public Reference_2(GValue_2 v) { value_ = v; }

  public override GValue_2 Get() { return value_; }

  public override RValue_2 ^CopyRef() { return new Reference_2(value_); }
}

abstract class SimpleValue_2 : GValue_2 {
  public abstract SimpleValue_2 ^Copy();
  public override RValue_2 ^CopyRef() { return Copy(); }
  public abstract string Emit();
}

class GBool_2 : SimpleValue_2 {
  public readonly bool b_;

  public GBool_2(bool b) { b_ = b; }

  public override bool Equals(object o) {
    GBool_2 b = o as GBool_2;
    return b != null && b.b_ == b_;
  }

  public override int GetHashCode() { return b_.GetHashCode(); }

  public override SimpleValue_2 ^Copy() { return new GBool_2(b_); }

  public static readonly BoolClass_2 ^type_ = new BoolClass_2();

  public override GType_2 Type() { return type_; }

  public override string ToString() { return b_.ToString(); }

  public override string Emit() { return b_ ? "true" : "false"; }
}

class GInt_2 : SimpleValue_2 {
  public readonly int i_;

  public GInt_2(int i) { i_ = i; }

  public static readonly IntClass_2 ^type_ = new IntClass_2();

  public override GType_2 Type() { return type_; }

  public override bool Equals(object o) {
    GInt_2 i = o as GInt_2;
    return i != null && i.i_ == i_;
  }

  public override int GetHashCode() { return i_.GetHashCode(); }

  public override SimpleValue_2 ^Copy() { return new GInt_2(i_); }

  public override RValue_2 ^Convert(ref RValue_2 ^this_own, GType_2 t) {
    if (t == GFloat_2.type_)
      return new GFloat_2(i_);
    if (t == GDouble_2.type_)
      return new GDouble_2(i_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_2 ^ConvertExplicit(ref RValue_2 ^this_own, GType_2 t) {
    return t == GChar_2.type_ ? new GChar_2((char) i_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return i_.ToString(); }

  public override string Emit() { return i_.ToString(); }
}

class GFloat_2 : SimpleValue_2 {
  public readonly float f_;

  public GFloat_2(float f) { f_ = f; }

  public static readonly FloatClass_2 ^type_ = new FloatClass_2();

  public override GType_2 Type() { return type_; }

  public override bool Equals(object o) {
    GFloat_2 f = o as GFloat_2;
    return f != null && f.f_ == f_;
  }

  public override int GetHashCode() { return f_.GetHashCode(); }

  public override SimpleValue_2 ^Copy() { return new GFloat_2(f_); }

  public override RValue_2 ^Convert(ref RValue_2 ^this_own, GType_2 t) {
    if (t == GDouble_2.type_)
      return new GDouble_2(f_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_2 ^ConvertExplicit(ref RValue_2 ^this_own, GType_2 t) {
    return t == GInt_2.type_ ? new GInt_2((int) f_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return f_.ToString(); }

  public override string Emit() {
    string s = f_.ToString();
    return s + (s.IndexOf('.') == -1 ? ".0f" : "f");
  }
}

class GDouble_2 : SimpleValue_2 {
  public readonly double d_;

  public GDouble_2(double d) { d_ = d; }

  public static readonly DoubleClass_2 ^type_ = new DoubleClass_2();

  public override GType_2 Type() { return type_; }

  public override bool Equals(object o) {
    GDouble_2 d = o as GDouble_2;
    return d != null && d.d_ == d_;
  }

  public override int GetHashCode() { return d_.GetHashCode(); }

  public override SimpleValue_2 ^Copy() { return new GDouble_2(d_); }

  public override RValue_2 ^ConvertExplicit(ref RValue_2 ^this_own, GType_2 t) {
    if (t == GInt_2.type_)
      return new GInt_2((int) d_);
    if (t == GFloat_2.type_)
      return new GFloat_2((float) d_);
    return base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return d_.ToString(); }

  public override string Emit() {
    string s = d_.ToString();
    if (s.IndexOf('.') == -1)
      s = s + ".0";
    return s;
  }
}

class GChar_2 : SimpleValue_2 {
  public readonly char c_;

  public GChar_2(char c) { c_ = c; }

  public static readonly CharClass_2 ^type_ = new CharClass_2();

  public override GType_2 Type() { return type_; }

  public override bool Equals(object o) {
    GChar_2 c = o as GChar_2;
    return c != null && c.c_ == c_;
  }

  public override int GetHashCode() { return c_.GetHashCode(); }

  public override SimpleValue_2 ^Copy() { return new GChar_2(c_); }

  public override RValue_2 ^Convert(ref RValue_2 ^this_own, GType_2 t) {
    return t == GInt_2.type_ ? new GInt_2(c_) : base.Convert(ref this_own, t);
  }

  public override string ToString() { return c_.ToString(); }

  public static string Emit(char c) {
    switch (c) {
      case '\0': return "\\0";
      case '\n': return "\\n";
      case '\r': return "\\r";
      case '\t': return "\\t";
      case '\'': return "\\'";
      case '\"': return "\\\"";
      case '\\': return "\\\\";
    }
    if (c < 32) {
      Debug.Assert(false); return null;
    }
    return c.ToString();
  }

  public override string Emit() {
    return String.Format("'{0}'", Emit(c_));
  }
}

abstract class LocationOrRef_2 : ValueOrLocation_2 {
  public abstract Location_2 GetLoc();
}

class Location_2 : LocationOrRef_2 {
  public RValue_2 ^value_;

  public Location_2(RValue_2 ^val) { value_ = val; }

  public override GValue_2 Get() { return value_.Get(); }

  public override Location_2 GetLoc() { return this; }
}

// We allocate a LocationRef_2 when we need an owning reference to a Location_2 which we don't own.
class LocationRef_2 : LocationOrRef_2 {
  public readonly Location_2 location_;

  public LocationRef_2(Location_2 loc) { location_ = loc; }

  public override GValue_2 Get() { return location_.Get(); }

  public override Location_2 GetLoc() { return location_; }
}

class MapNode_2 {
  public readonly MapNode_2 ^next_;
  public readonly object key_;
  public ValueOrLocation_2 ^value_;   // (must appear after next_ so it will be destroyed first)

  public MapNode_2(object key, ValueOrLocation_2 ^value, MapNode_2 ^next) {
    key_ = key; value_ = value; next_ = next;
  }
}

class Map_2 {
  MapNode_2 ^nodes_;

  protected MapNode_2 Find1(object key) {
    for (MapNode_2 n = nodes_; n != null; n = n.next_)
      if (n.key_ == key)
        return n;
    return null;
  }

  protected virtual MapNode_2 Find(object key) {
    MapNode_2 n = Find1(key);
    Debug.Assert(n != null);
    return n;
  }

  public RValue_2 ^Get(object key) {
    return Find(key).value_.Get().CopyRef();
  }

  public RValue_2 ^Take_2(object key) {
    MapNode_2 n = Find(key);
    LocationOrRef_2 l = n.value_ as LocationOrRef_2;
    if (l != null)
      return take l.GetLoc().value_;
    return (RValue_2) take n.value_;
  }

  public void Set(object key, RValue_2 ^val) {
    MapNode_2 n = Find(key);
    LocationOrRef_2 l = n.value_ as LocationOrRef_2;
    if (l != null)
      l.GetLoc().value_ = val;
    else n.value_ = val;
  }

  public void Add(object key, ValueOrLocation_2 ^val) {
    nodes_ = new MapNode_2(key, val, take nodes_);
  }

  public Location_2 GetLocation(object key) {
    MapNode_2 n = Find(key);
    LocationOrRef_2 l = n.value_ as LocationOrRef_2;
    if (l != null)
      return l.GetLoc();
    Location_2 ^loc1 = new Location_2((RValue_2) take n.value_);
    Location_2 loc = loc1;
    n.value_ = loc1;
    return loc;
  }
}

class GObject_2 : GValue_2 {
  public readonly Class_2 class_;   // the class of this object

  Map_2 ^map_ = new Map_2();

  public GObject_2(Class_2 cl) {
    class_ = cl;
    while (cl != null) {
      foreach (Field_2 f in cl.fields_)
        map_.Add(f, f.Type().DefaultValue_2().Copy() );
      cl = cl.Parent();
    }
  }

  // the type of this object
  public override GType_2 Type() { return class_; }

  public override RValue_2 ^Get(Field_2 field) { return map_.Get(field); }
  public override RValue_2 ^Take_2(Field_2 field) { return map_.Take_2(field); }
  public void Set(Field_2 field, RValue_2 ^val) { map_.Set(field, val); }
  public Location_2 GetLocation(Field_2 field) { return map_.GetLocation(field); }

  public override int DefaultHashCode() { return base.GetHashCode(); }
  public override int GetHashCode() {
    GInt_2 ^i = (GInt_2) Invocation_2.InvokeMethod(this, GObject_2.type_.get_hash_code_, new ArrayList(), true);
    return i.i_;
  }

  public override bool DefaultEquals(object o) { return base.Equals(o); }
  public override bool Equals(object o) {
    GValue_2 v = o as GValue_2;
    if (v == null)
      return false;

    ArrayList ^args = new ArrayList();
    args.Add(v.CopyRef());
    GBool_2 ^b = (GBool_2) Invocation_2.InvokeMethod(this, GObject_2.type_.equals_, args, true);
    return b.b_;
  }

  public override string DefaultToString() { return String.Format("<object {0}>", class_.name_); }
  public override string ToString() {
    GString_2 ^s = (GString_2) Invocation_2.InvokeMethod(this, GObject_2.type_.to_string_, new ArrayList(), true);
    return s.s_;
  }

  // the Object class
  public static readonly ObjectClass_2 ^type_ = new ObjectClass_2();
}

class NullType_2 : GType_2 {
  public override string ToString() { return "null_type"; }

  public override SimpleValue_2 DefaultValue_2() { Debug.Assert(false); return null; }

  public override bool IsSubtype(GType_2 t1) {
    return t1.IsReference();
  }

  protected override bool CanConvertOwnership(GType_2 t, int context) {
    return true;    // conversion from null type to owning type is okay
  }

  public override string EmitType() { Debug.Assert(false); return null; }
}

class Null_2 : SimpleValue_2 {
  public Null_2() { }

  public static readonly NullType_2 ^type_ = new NullType_2();

  public override GType_2 Type() { return type_; }

  public override bool Equals(object o) {
    return o is Null_2;
  }

  public override SimpleValue_2 ^Copy() { return new Null_2(); }

  public override int GetHashCode() { return 0; }

  public static readonly Null_2 ^Instance = new Null_2();

  public override string ToString() { return ""; }

  public override string Emit() { return "0"; }
}

class Owning_2 : GType_2 {
  GType_2 base_type_;

  public Owning_2(GType_2 type) {
    base_type_ = type;
  }

  public override Class_2 Parent() { Debug.Assert(false); return null; }

  public override SimpleValue_2 DefaultValue_2() { return Null_2.Instance; }

  public override GType_2 BaseType() { return base_type_; }

  public override TypeSet_2 VarDestroys() { return base_type_.TypeDestroys(); }

  public override void FindVarDestroys(int marker, TypeSet_2 set) {
    base_type_.FindTypeDestroys(marker, set);
  }

  public override bool Equals(object o) {
    Owning_2 t = o as Owning_2;
    return t != null && t.base_type_.Equals(base_type_);
  }

  public override int GetHashCode() { return base_type_.GetHashCode() * 87; }

  public override string ToString() { return base_type_.ToString() + " ^"; }

  public override string EmitTypeName() {
    return base_type_.EmitTypeName();
  }

  string EmitType(string name) {
    return ConstructType(base_type_ == GObject_2.type_ ? "_OwnRef" : "_Own", name);
  }

  public override string EmitType() {
    // We represent an object ^ using a _OwnRef<Object>.
    // We represent a Foo ^ using an _Own<Foo>.
    return EmitType(EmitTypeName());
  }

  public override string EmitGenericType() {
    // We represent an object ^ [] using an _Array<_OwnRef<Object>>.
    // We represent a Foo ^ [] using an _Array<_Own<Object>>.
    return EmitType("Object");
  }
}

class OwningExpr_2 : TypeExpr_2 {
  readonly TypeExpr_2 ^expr_;

  public OwningExpr_2(TypeExpr_2 ^expr) { expr_ = expr; }

  public override TypeExpr_2 ^Copy() { return new OwningExpr_2(expr_.Copy()); }

  public override GType_2 Resolve(Program_2 program) {
    GType_2 t = expr_.Resolve(program);
    if (t == null)
        return null;
    if (t.IsValue()) {
      Error("^ cannot be applied to primitive types or strings");
      return null;
    }
    return t.OwningType();
  }
}

class GString_2 : SimpleValue_2 {
  public readonly string s_;

  public GString_2(string s) { s_ = s; }

  public static readonly StringClass_2 ^type_ = new StringClass_2();

  public override GType_2 Type() { return type_; }

  public override bool Equals(object o) {
    GString_2 s = o as GString_2;
    return s != null && s.s_ == s_;
  }

  public override SimpleValue_2 ^Copy() { return new GString_2(s_); }

  public override int GetHashCode() { return s_.GetHashCode(); }

  public override string ToString() { return s_; }

  public override RValue_2 ^Invoke(Method_2 m, ValueList_2 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StartsWith": return new GBool_2(s_.StartsWith(args.GetString(0)));
      case "EndsWith": return new GBool_2(s_.EndsWith(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public static string EmitStringConst(string s) {
    return String.Format("L{0}", EmitString(s));
  }

  public static string EmitString(string s) {
    StringBuilder ^sb = new StringBuilder();
    sb.Append('"');
    for (int i = 0; i < s.Length; ++i)
      sb.Append(GChar_2.Emit(s[i]));
    sb.Append('"');
    return sb.ToString();
  }

  public override string Emit() {
    string s = String.Format("new String({0})", EmitStringConst(s_));
    s = String.Format("_Ref<String>({0}).Get()", s);
    return s;
  }
}

abstract class Ownable_2 : GType_2 {
  Owning_2 ^owning_type_;

  public override Owning_2 OwningType() {
    if (owning_type_ == null)
      owning_type_ = new Owning_2(this);
    return owning_type_;
  }
}

class ArrayType_2 : Ownable_2 {
  GType_2 element_type_;

  public ArrayType_2(GType_2 type) {
    element_type_ = type;

    // Any type used generically must inherit from Object in C++ code.
    type.BaseType().SetObjectInherit();
  }

  public override bool IsOwned() { return true; }

  public override Class_2 Parent() { return GArray_2.array_class_; }

  public override SimpleValue_2 DefaultValue_2() { return Null_2.Instance; }

  public GType_2 ElementType() { return element_type_; }

  public override bool Equals(object o) {
    ArrayType_2 t = o as ArrayType_2;
    return (t != null && t.element_type_.Equals(element_type_));
  }

  public override TypeSet_2 TypeDestroys() { return element_type_.VarDestroys(); }

  public override void FindTypeDestroys(int marker, TypeSet_2 set) {
    element_type_.FindVarDestroys(marker, set);
  }

  public override int GetHashCode() { return element_type_.GetHashCode() * 77; }

  public override string EmitTypeName() {
    return ConstructType("_Array", element_type_.EmitGenericType());  
  }

  public override string ToString() {
    return element_type_.ToString() + "[]";
  }
}

class ArrayTypeExpr_2 : TypeExpr_2 {
  readonly TypeExpr_2 ^expr_;
  GType_2 ^type_;

  public ArrayTypeExpr_2(TypeExpr_2 ^expr) { expr_ = expr; }

  public override TypeExpr_2 ^Copy() { return new ArrayTypeExpr_2(expr_.Copy()); }

  public override GType_2 Resolve(Program_2 program) {
    GType_2 t = expr_.Resolve(program);
    return t == null ? null : (type_ = new ArrayType_2(t));
  }
}

class GArray_2 : GValue_2 {
  ArrayType_2 type_;

  ValueOrLocation_2^[] ^elements_;   // each element is a GValue_2 or a Location_2

  public override GType_2 Type() { return type_; }

  public GArray_2(ArrayType_2 type, int count) {
    type_ = type;
    elements_ = new ValueOrLocation_2^[count];
    for (int i = 0 ; i < count ; ++i)
      elements_[i] = type_.ElementType().DefaultValue_2().Copy();
  }

  void CheckIndex(int index) {
    if (index < 0 || index >= elements_.Length) {
      Console.WriteLine("error: array access out of bounds");
      Gel_2.Exit();
    }
  }

  public RValue_2 ^Get(int index) {
    CheckIndex(index);
    return elements_[index].Get().CopyRef();
  }

  public RValue_2 ^Take_2(int index) {
    CheckIndex(index);
    Location_2 loc = elements_[index] as Location_2;
    if (loc != null)
      return take loc.value_;
    return (RValue_2) (take elements_[index]);
  }

  public void Set(int index, RValue_2 ^val) {
    CheckIndex(index);
    Location_2 loc = elements_[index] as Location_2;
    if (loc != null)
      loc.value_ = val;
    else elements_[index] = val;
  }

  public Location_2 GetLocation(int index) {
    CheckIndex(index);
    Location_2 loc = elements_[index] as Location_2;
    if (loc != null)
      return loc;
    Location_2 ^loc1 = new Location_2((RValue_2) take elements_[index]);
    loc = loc1;
    elements_[index] = loc1;
    return loc;
  }

  public static readonly ArrayClass_2 ^array_class_ = new ArrayClass_2();

  public override RValue_2 ^Invoke(Method_2 m, ValueList_2 args) {
    if (m.GetClass() != array_class_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "CopyTo":
        GArray_2 a = (GArray_2) args.Object(0);
        if (!type_.Equals(a.type_)) {
          Console.WriteLine("error: can't copy between arrays of different types");
          Gel_2.Exit();
        }
        if (a.type_.ElementType() is Owning_2) {
          Console.WriteLine("error: can't copy to owning array");
          Gel_2.Exit();
        }
        // should check for index out of bounds here!
        int dest = args.Int(1);
        for (int i = 0 ; i < elements_.Length ; ++i)
          a.Set(dest + i, Get(i));
        return null;
      case "get_Length":
        return new GInt_2(elements_.Length);
      default:
        Debug.Assert(false); return null;
    }
  }
}

// A control graph object representing temporary variables destroyed when a top-level
// expression completes evaluation. 
class Temporaries_2 : Node_2 {
  NonOwningArrayList /* of GType_2 */ ^types_ = new NonOwningArrayList();
  TypeSet_2 ^destroys_;

  public void Add(GType_2 t) {
    Debug.Assert(t is Owning_2);
    types_.Add(t.BaseType());
  }

  public override TypeSet_2 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_2();
    foreach (GType_2 t in types_)
        destroys_.Add(t.TypeDestroys());
    }
    return destroys_;
  }
}

class Context_2 {
  public readonly Program_2 program_;   // containing program
  public readonly Class_2 class_;       // containing class
  public readonly Method_2 method_;     // containing method
  public readonly Escapable_2 escape_;  // containing switch, while, do, for, or foreach
  public readonly Loop_2 loop_;         // containing while, do, for, or foreach
  public Local_2 var_;    // chain of local variable declarations

  // subexpressions of the current top-level expression possibly yielding temporary objects
  NonOwningArrayList /* of Expression_2 */ ^temporaries_ = new NonOwningArrayList();

  public Context_2(Program_2 program) { program_ = program; }

  public Context_2(Class_2 cl) { program_ = cl.GetProgram(); class_ = cl; }

  // Copy a context; new variable declarations in either copy will not be visible in the other.
  public Context_2(Context_2 cx) {
    program_ = cx.program_;
    class_ = cx.class_;
    method_ = cx.method_;
    escape_ = cx.escape_;
    loop_ = cx.loop_;
    var_ = cx.var_;
  }

  public Context_2(Context_2 cx, Class_2 c) : this(cx) { class_ = c; }

  public Context_2(Context_2 cx, Method_2 m) : this(cx) { method_ = m; }

  public Context_2(Context_2 cx, Loop_2 l) : this(cx) {
    escape_ = l;
    loop_ = l;
  }

  public Context_2(Context_2 cx, Switch_2 s) : this(cx) { escape_ = s; }

  public bool IsStatic() { return method_ == null || method_.IsStatic(); }

  public void SetVar(Local_2 var) {
    var_ = var;
  }

  public Local_2 FindVar(string name) {
    for (Local_2 v = var_; v != null; v = v.next_)
      if (v.name_ == name)
        return v;
    return null;
  }

  public Control_2 Prev() { return program_.prev_; }

  public void SetPrev(Control_2 c) {
    Debug.Assert(c != null);
    program_.prev_ = c;
  }

  public void ClearPrev() { program_.prev_ = null; }

  // Called when we begin type-checking a top-level expression.
  public void EnterExpression() {
    Debug.Assert(temporaries_.Count == 0);
  }

  public void AddTemporary(Expression_2 e) {
    temporaries_.Add(e);
  }

  // Called when we've finished type-checking a top-level expression.
  public void FinishExpression() {
    Temporaries_2 t = null;
    foreach (Expression_2 e in temporaries_)
      if (!e.LosesOwnership()) {
        if (t == null)
          t = class_.NewTemporaries();
        t.Add(e.TemporaryType());
      }
    if (t != null)
      t.AddControl(this);
    temporaries_.Clear();
  }
}

class Env_2 : Map_2 {
  public readonly GValue_2 this_;
  readonly Env_2 next_;

  public Env_2(GValue_2 _this) { this_ = _this; next_ = null; }
  public Env_2(Env_2 next) { this_ = next.this_; next_ = next; }

  protected override MapNode_2 Find(object key) {
    for (Env_2 e = this; e != null; e = e.next_) {
      MapNode_2 n = e.Find1(key);
      if (n != null)
        return n;
    }
    Debug.Assert(false);
    return null;
  }

  public static readonly Env_2 ^static_ = new Env_2((GValue_2) null);
}

class TypeLiteral_2 : TypeExpr_2 {
  public readonly GType_2 type_;

  public TypeLiteral_2(GType_2 type) { type_ = type; }

  public override GType_2 Resolve(Program_2 program) {
    return type_;
  }

  public override TypeExpr_2 ^Copy() { return new TypeLiteral_2(type_); }
}

class TypeName_2 : TypeExpr_2 {
  string name_;

  public TypeName_2(string name) { name_ = name; }

  public override GType_2 Resolve(Program_2 program) {
    GType_2 type = program.FindClass(name_);
    if (type == null)
      Error("unknown type: {0}", name_);
    return type;
  }

  public override TypeExpr_2 ^Copy() { return new TypeName_2(name_); }
}

abstract class Traverser_2 {
  // Handle a graph item found in a depth first search; returns one of the exit codes below.
  public abstract int Handle(Control_2 control);

  public const int Continue_2 = 0,  // continue searching, including children of this node
                   Cut = 1,       // continue searching, excluding children of this node
                   Abort = 2;     // abort the search

}

// an item in the control graph: either a Node_2 or Joiner_2
abstract class Control_2 : Syntax_2 {
  public int marker_ = 0;    // marker for depth first search of control flow graph

  static int marker_value_ = 0;
  public static int GetMarkerValue() { return ++marker_value_; }

  // A node representing unreachability.  We could represent this using null, but it's
  // clearer to have this be explicit. 
  public static readonly Node_2 ^unreachable_ = new Node_2();

  // A helper function for Traverse.  If_2 we return true then we should cut the
  // traversal at this point.
  protected bool Visit(Traverser_2 traverser, int marker, out bool ok) {
    ok = true;
    if (marker_ == marker)
      return true;  // we've already seen this node
    marker_ = marker;
    int code = traverser.Handle(this);
    if (code == Traverser_2.Abort)
      ok = false;
    return (code != Traverser_2.Continue_2);
  }

  // Perform a depth-first search of the graph starting with this item, calling the
  // given Traverser_2 for each Node_2 found.  Returns false if the search was aborted.
  public abstract bool Traverse(Traverser_2 traverser, int marker);
}

// A node in the control graph.
class Node_2 : Control_2 {
  public Control_2 prev_;   // previous item in graph

  // add this node to the control graph
  public bool AddControl(Context_2 ctx) {
    Control_2 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      prev_ = prev;
      ctx.SetPrev(this);
      return true;
    }
    else return false;
  }

  // If_2 this node calls a method or constructor then return it; otherwise return null.
  // implementers: LValue_2, Invocation_2, New_2, Assign_2, Constructor_2
  public virtual Method_2 Calls() { return null; }

  // Return_2 the set of types which this node may destroy.
  // implementers: Assign_2, RefOutArgument_2, Scoped_2, Temporaries_2
  public virtual TypeSet_2 NodeDestroys() { return TypeSet_2.empty_; }

  // Return_2 true if this node assigns a value to the given Local_2.
  // implementers: Assign_2, RefOutArgument_2, VariableDeclaration_2, Method_2, ForEach_2
  public virtual bool Sets(Local_2 local) { return false; }

  // Return_2 true if this node takes ownership from the given local.
  // implementers: Name_2
  public virtual bool Takes(Local_2 local) { return false; }

  public bool CanDestroy(GType_2 type) {
    Method_2 m = Calls();
    if (m != null && m.Destroys().Contains(type))
      return true;
    return NodeDestroys().Contains(type);
  }

  public override bool Traverse(Traverser_2 traverser, int marker) {
    Node_2 n = this;
    Control_2 prev = null;

    // Traverse nodes iteratively until we come to a Join; this efficiently avoids
    // making a recursive call on each successive node.
    while (n != null) {
      bool ok;
      if (n.Visit(traverser, marker, out ok))
        return ok;
      prev = n.prev_;
      n = prev as Node_2;
    }
    Debug.Assert(prev != null);  // a Traverser_2 must end traversal before we run off the end
    return prev.Traverse(traverser, marker);
  }
}

class Joiner_2 : Control_2 {
  NonOwningArrayList /* of Control_2 */ ^prev_ = new NonOwningArrayList();

  public void Join(Control_2 c) {
    Debug.Assert(c != null);
    if (c == unreachable_)
      return;
    if (prev_.Count == 0 || c != prev_[0])
      prev_.Add(c);
  }

  // add this joiner to the control graph
  public void AddControl(Context_2 ctx) {
    Control_2 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      Join(prev);
      ctx.SetPrev(this);
    }
  }

  // Once we've finished merging paths into a Joiner_2, if the Joiner_2 points to only a single path
  // then as an optimization we can discard the Joiner_2 and just use that path instead.
  public Control_2 Combine() {
    switch (prev_.Count) {
      case 0:
        prev_ = null;
        return unreachable_;
      case 1:
        Control_2 c = (Control_2) prev_[0];
        prev_ = null;
        return c;
      default: return this;
    }
  }

  public override bool Traverse(Traverser_2 traverser, int marker) {
    bool ok;
    if (Visit(traverser, marker, out ok))
      return ok;

    foreach (Control_2 p in prev_)
      if (!p.Traverse(traverser, marker))
        return false;  // aborted
    return true;
  }
}

class ExprKind_2 {
  public const int Value = 0,

  // either a local variable, or an expression whose value is derived from local variables
                   Local_2 = 1,

                   Field_2 = 2,
                   Property_2 = 3,
                   Indexer_2 = 4,
                   Type = 5;
}

class SourceWriter_2 {
  public readonly StreamWriter writer_;
  int indent_ = 0;

  public SourceWriter_2(StreamWriter writer) { writer_ = writer; }

  public void AddIndent() { ++indent_; }
  public void SubIndent() { --indent_; }

  public void Indent(int adjust) {
    for (int i = 0; i < 2 * indent_ + adjust; ++i)
      writer_.Write(' ');
  }

  public void Indent() { Indent(0); }

  public void Write(string s) { writer_.Write(s); }
  public void Write(string s, object arg) { writer_.Write(s, arg); }
  public void Write(string s, object arg1, object arg2) { writer_.Write(s, arg1, arg2); }
  public void Write(string s, object arg1, object arg2, object arg3) { writer_.Write(s, arg1, arg2, arg3); }

  public void IWrite(string s) { Indent(); Write(s); }
  public void IWrite(string s, object arg) { Indent(); Write(s, arg); }
  public void IWrite(string s, object arg1, object arg2) { Indent(); Write(s, arg1, arg2); }
  public void IWrite(string s, object arg1, object arg2, object arg3) { Indent(); Write(s, arg1, arg2, arg3); }

  public void WriteLine(string s) { writer_.WriteLine(s); }
  public void WriteLine(string s, object arg) { writer_.WriteLine(s, arg); }
  public void WriteLine(string s, object arg1, object arg2) { writer_.WriteLine(s, arg1, arg2); }
  public void WriteLine(string s, object arg1, object arg2, object arg3) { writer_.WriteLine(s, arg1, arg2, arg3); }

  public void IWriteLine(string s) { Indent(); WriteLine(s); }
  public void IWriteLine(string s, object arg) { Indent(); WriteLine(s, arg); }
  public void IWriteLine(string s, object arg1, object arg2) { Indent(); WriteLine(s, arg1, arg2); }
  public void IWriteLine(string s, object arg1, object arg2, object arg3) { Indent(); WriteLine(s, arg1, arg2, arg3); }

  public void OpenBrace() { WriteLine("{"); AddIndent(); }
  public void CloseBrace() { SubIndent(); IWriteLine("}"); }
}

class Usage_2 {
  public const int Used = 0, LosesOwnership = 1, Unused = 2;
}

abstract class Expression_2 : Node_2 {
  protected int usage_ = Usage_2.Used;

  // start_ and end_ mark the points in the control graph where this expression is evaluated and used,
  // respectively.  If_2 this expression's type is owned, we use this information to determine whether
  // we need to emit a reference count for this expression.
  Control_2 start_;
  Control_2 end_;

  public abstract GType_2 Check(Context_2 ctx);

  public GType_2 CheckTop(Context_2 ctx) {
    ctx.EnterExpression();
    GType_2 t = Check(ctx);
    ctx.FinishExpression();
    return t;
  }

  public GType_2 CheckAndHold(Context_2 ctx) {
    GType_2 t = Check(ctx);
    if (t != null)
      HoldRef(ctx);
    return t;
  }

  // A fancier checking protocol implemented by lvalues and used by certain callers.
  public virtual GType_2 Check(Context_2 ctx, bool read, bool write, bool type_ok) {
    return Check(ctx);
  }

  public virtual int Kind() { return ExprKind_2.Value; }
  public virtual bool IsRefOutParameter() { return false; }

  public virtual bool IsTrueLiteral() { return false; }
  public virtual bool IsFalseLiteral() { return false; }

  // If_2 this expression is a local variable (possibly cast to a different type),
  // then return that local; otherwise return null.
  public virtual Local_2 GetLocal() { return null; }

  // Return_2 the type of an expression yielding a temporary object.
  // (It might be convenient to generalize this to be able to return any expression's type.)
  public virtual GType_2 TemporaryType() { Debug.Assert(false); return null; }

  public void HoldRef(Context_2 ctx) {
    start_ = ctx.Prev();
    Debug.Assert(start_ != null);
  }

  public void ReleaseRef(Context_2 ctx) {
    end_ = ctx.Prev();
    Debug.Assert(end_ != null);
  }

  public abstract RValue_2 ^Eval(Env_2 env);

  public bool Check(Context_2 ctx, GType_2 t2) {
    GType_2 t = Check(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public bool CheckTop(Context_2 ctx, GType_2 t2) {
    GType_2 t = CheckTop(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public RValue_2 ^Eval(Env_2 env, GType_2 t) {
    RValue_2 ^r = Eval(env);
    GValue_2 v = r.Get();
    return v.Convert(ref r, t);
  }

  public bool EvalBool(Env_2 env) { return ((GBool_2) Eval(env)).b_; }

  public int EvalInt(Env_2 env) {
    RValue_2 ^r = Eval(env, GInt_2.type_);
    GInt_2 i = (GInt_2) r;
    return i.i_;
  }

  public double EvalDouble(Env_2 env) { return ((GDouble_2) Eval(env, GDouble_2.type_)).d_; }
  public float EvalFloat(Env_2 env) { return ((GFloat_2) Eval(env, GFloat_2.type_)).f_; }
  public string EvalString(Env_2 env) { return ((GString_2) Eval(env)).s_; }

  public virtual bool IsConstant() {
    return false;
  }

  public bool CheckConstant() {
    if (IsConstant())
      return true;
    Error("expression must be a constant");
    return false;
  }

  public bool LosesOwnership() { return usage_ == Usage_2.LosesOwnership; }

  public virtual void LoseOwnership() {
    usage_ = Usage_2.LosesOwnership;
  }

  public void SetUnused() {
    Debug.Assert(usage_ == Usage_2.Used);
    usage_ = Usage_2.Unused;
  }

  protected static string EmitAllocate(string type, string args, bool lose_ownership) {
    // If_2 an allocated object never loses ownership then it can be stack allocated.  We
    // can't emit "&Foo(...)" since standard C++ doesn't allow us to take the address
    // of a temporary (both GCC and Visual C++ will allow this, but will emit a warning).
    // So instead we call a function _Addr() to get the address.
    return String.Format(
      !lose_ownership ? "{0}({1})._Addr<{0} *>()" : "new {0}({1})",
      type, args);
  }

  public void CheckLoseOwnership(GType_2 from, GType_2 to) {
    if (to is Owning_2)
      LoseOwnership();
  }

  public abstract string Emit();    // return a C++ expression representing this GEL2 expression

  public bool NeedsRef(GType_2 type) {
    return Gel_2.program_.safe_ && type.IsOwned() && ExpressionTraverser_2.NeedRef(start_, end_, this, type);
  }

  // Emit this expression, adding a reference-counting _Ptr wrapper if needed.
  public string EmitRef(GType_2 type) {
    string s = Emit();
    if (NeedsRef(type))
      s = String.Format("{0}({1}).Get()", type.EmitType(), s);
    return s;
  }

  // Emit an implicit conversion from type [source] to type [dest].
  public static string EmitImplicit(GType_2 source, GType_2 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (!source.IsReference() && dest == GObject_2.type_) {   // a boxing conversion
      Class_2 c = (Class_2) source;
      return EmitAllocate(c.name_, val, loses_ownership);
    }

    if (source == GInt_2.type_ && dest == GFloat_2.type_)
      // an implicit conversion in GEL2, but C++ compilers may warn if we don't use a cast
      return String.Format("static_cast<float>({0})", val);
    
    return val;
  }

  // Emit this expression, converting implicitly from type [source] to type [dest].
  public string Emit(GType_2 source, GType_2 dest) {
    return EmitImplicit(source, dest, Emit(), LosesOwnership());
  }

  public string EmitRef(GType_2 source, GType_2 dest) {
    return EmitImplicit(source, dest, EmitRef(source), LosesOwnership());
  }

  public static string EmitExplicit(GType_2 source, GType_2 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (source.CanConvert(dest)) {
      string v = EmitImplicit(source, dest, val, loses_ownership);
      if (v != val)
        return v;

      // There's nothing to do, but we emit a static_cast anyway since a GEL2 programmer
      // may use a type cast for method call disambiguation; we want to pass such casts onward.
      return String.Format("static_cast<{0} >({1})", dest.EmitExprType(), val);
    }

    if (source.IsReference() && dest.IsReference()) {
      string s = String.Format("_Cast<{0} *>({1})", dest.EmitTypeName(), val);
      ArrayType_2 at = dest as ArrayType_2;
      if (at != null) {
        GType_2 element_type = at.ElementType();
        if (element_type.IsReference())
          s = String.Format("({0})->CheckType(&typeid({1}))", s, element_type.EmitType());
      }
      return s;
    }

    if (source == GObject_2.type_ && !dest.IsReference())  // unboxing conversion
      return String.Format("_Unbox<{0} *>({1})->Value()", ((Class_2) dest).name_, val);

    if (!source.IsReference() && !dest.IsReference())
      return String.Format("static_cast<{0}>({1})", dest.EmitType(), val);

    Debug.Assert(false);
    return null;
  }

  public string EmitExplicit(GType_2 source, GType_2 dest) {
    return EmitExplicit(source, dest, Emit(), LosesOwnership());
  }

  public virtual string EmitArrow(GType_2 t, Member_2 m) {
    return String.Format("({0})->", EmitRef(t));
  }

  // Emit this expression as a local or field initializer, implicitly casting to [type].
  public void EmitAsInitializer(SourceWriter_2 w, GType_2 initializer_type, GType_2 type) {
    // For_2 owning variables, we must emit an initializer of the form "Foo var(val)" since
    // _Own has no copy constructor and hence GCC won't allow "Foo var = val".  For_2 other
    // variables either form is valid, but we emit the second form since it looks clearer.
    w.Write(type is Owning_2 ? "({0})" : " = {0}", Emit(initializer_type, type));
  }

  // Given a value retrieved from a variable, emit an accessor call if needed.
  protected string OwnSuffix(GType_2 t) {
    if (t is Owning_2)
      return LosesOwnership() ? ".Take_2()" : ".Get()";
    if (t == GString_2.type_ || Gel_2.program_.safe_ && t.IsReference() )
      return ".Get()";
    return "";
  }

  // Given a value returned from a function call, emit a wrapper and/or accessor call if needed.
  protected string Hold(GType_2 t, string s) {
    if (t == GString_2.type_)
      return s + ".Get()";
    if (t is Owning_2)
      switch (usage_) {
        case Usage_2.Used:  // does not lose ownership; we need a freeing wrapper
          return String.Format("{0}({1}).Get()", t.EmitType(), s);
        case Usage_2.LosesOwnership:
          return s;
        case Usage_2.Unused:  // a top-level owning expression
          return "delete " + s;
        default: Debug.Assert(false); break;
      }
    return s;
  }
}

class Literal_2 : Expression_2 {
  public readonly SimpleValue_2 ^value_;

  public Literal_2(SimpleValue_2 ^v) { value_ = v; }

  public override bool IsTrueLiteral() {
    GBool_2 b = value_ as GBool_2;
    return b != null && b.b_;
  }

  public override bool IsFalseLiteral() {
    GBool_2 b = value_ as GBool_2;
    return b != null && !b.b_;
  }

  public override GType_2 Check(Context_2 ctx) { return value_.Type(); }

  public override RValue_2 ^Eval(Env_2 env) { return value_.Copy(); }

  public override bool IsConstant() { return true; }

  public override string Emit() { return value_.Emit(); }
}

// An LValue_2 is an expression which can be assigned to: a Name_2, Dot_2, or Sub_2.
//
// In the control graph, an LValue_2 represents a read; if an LValue_2 is written then
// some other node (e.g. an Assign_2) will appear representing the write.
abstract class LValue_2 : Expression_2 {
  public override GType_2 Check(Context_2 ctx) {
    return Check(ctx, true, false, false);
  }

  public abstract override GType_2 Check(Context_2 ctx, bool read, bool write, bool type_ok);

  public abstract GType_2 StorageType();

  public virtual bool IsLocal() { return false; }
  public virtual bool IsLocal(Local_2 l) { return false; }

  public abstract PropertyOrIndexer_2 GetPropertyOrIndexer();

  public override Method_2 Calls() {
    PropertyOrIndexer_2 pi = GetPropertyOrIndexer();
    return pi == null ? null : pi.Getter();
  }

  public virtual void ReleaseAll(Context_2 ctx) { }

  // For_2 LValues, evaluation proceeds in two stages: the caller first calls Eval1(), then
  // passes the resulting values to EvalGet(), EvalSet() and/or EvalLocation().  This_2 lets
  // us evaluate the left side of an assignment expression before evaluating the right side,
  // and also lets us get and then set an indexer without evaluating its expression twice.

  public abstract void Eval1(Env_2 env, out RValue_2 ^v1, out RValue_2 ^v2);
  public abstract RValue_2 ^EvalGet(Env_2 env, RValue_2 ^v1, RValue_2 ^v2);
  public abstract void EvalSet(Env_2 env, RValue_2 ^v1, RValue_2 ^v2, RValue_2 ^val);
  public abstract Location_2 EvalLocation(Env_2 env, RValue_2 ^v1, RValue_2 ^v2);

  public override RValue_2 ^Eval(Env_2 env) {
    RValue_2 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalGet(env, val1, val2);
  }

  public void EvalSet(Env_2 env, RValue_2 ^v) {
    RValue_2 ^val1, val2;
    Eval1(env, out val1, out val2);
    EvalSet(env, val1, val2, v);
  }

  public Location_2 EvalLocation(Env_2 env) {
    RValue_2 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalLocation(env, val1, val2);
  }

  public abstract string EmitSet(string val);

  public abstract string EmitLocation();
}

class Name_2 : LValue_2 {
  public readonly string name_;

  protected Local_2 local_;
  protected LMember_2 field_;  // a field or property

  public Name_2(string n) { name_ = n; }

  public override bool IsLocal() { return local_ != null; }
  public override bool IsLocal(Local_2 l) { return local_ == l; }
  public override bool IsRefOutParameter() { return local_ is RefOutParameter_2; }

  public override bool IsConstant() {
    Debug.Assert(local_ != null || field_ != null);   // make sure we were already type checked
    return field_ is ConstField_2;
  }

  public override GType_2 Check(Context_2 ctx, bool read, bool write, bool type_ok) {
    local_ = ctx.FindVar(name_);
    if (local_ != null) {
      // For_2 reads, we add this Name_2 node to the flow graph; for writes,
      // the caller must add a node which defines this Name_2.
      if (read)
        if (AddControl(ctx))
          local_.AddUse(this);
      if (write)
        local_.SetMutable();
      return local_.ReadType();
    }

    GType_2 cl = type_ok ? ctx.program_.FindClass(name_) : null;
    field_ = (LMember_2) ctx.class_.Lookup(this, ctx.class_, false, MemberKind_2.Field_2, name_, null, cl == null);
    if (field_ != null) {
      if (!field_.CheckAccess(this, ctx, write, true, !ctx.IsStatic()))
        return null;
      if (read) {
        // Only property reads have side effects we need to register in the control graph.
        if (field_ is Property_2)
          AddControl(ctx);
      }
      return field_.Type().BaseType();
    }

    return cl;
  }

  public override int Kind() {
    if (local_ != null)
      return ExprKind_2.Local_2;
    if (field_ is Field_2)
      return ExprKind_2.Field_2;
    if (field_ is Property_2)
      return ExprKind_2.Property_2;
    Debug.Assert(field_ == null);
    return ExprKind_2.Type;
  }

  public override Local_2 GetLocal() { return local_; }

  public override GType_2 StorageType() { return local_ != null ? local_.Type() : field_.Type(); }

  public override bool Takes(Local_2 local) {
    return local_ == local && LosesOwnership() && local.Type() is Owning_2;
  }

  public override PropertyOrIndexer_2 GetPropertyOrIndexer() { return field_ as Property_2; }

  public override void Eval1(Env_2 env, out RValue_2 ^v1, out RValue_2 ^v2) { v1 = v2 = null; }

  public override RValue_2 ^EvalGet(Env_2 env, RValue_2 ^v1, RValue_2 ^v2) {
    if (LosesOwnership() && StorageType() is Owning_2)
      return local_ != null ? env.Take_2(local_) : field_.Take_2(env.this_);
    else return local_ != null ? env.Get(local_) : field_.Get(env.this_);
  }

  public override void EvalSet(Env_2 env, RValue_2 ^v1, RValue_2 ^v2, RValue_2 ^val) {
    if (local_ != null)
      env.Set(local_, val);
    else field_.Set((GObject_2) env.this_, val);
  }

  public override Location_2 EvalLocation(Env_2 env, RValue_2 ^v1, RValue_2 ^v2) {
    return local_ != null ? env.GetLocation(local_) : field_.GetLocation((GObject_2) env.this_);
  }

  public override string Emit() {
    if (local_ != null) {
      string s = local_.Emit();
      return local_.IsWrapper() ? s + OwnSuffix(local_.Type()) : s;
    }
    if (field_ != null)
      return field_.Emit() + OwnSuffix(field_.Type());
    return name_;
  }

  public override string EmitSet(string val) {
    if (local_ != null)
      return String.Format("{0} = {1}", local_.Emit(), val);
    Debug.Assert(field_ != null);
    return field_.EmitSet(val);
  }

  public override string EmitLocation() {
    if (local_ != null)
      return "&" + local_.Emit();
    if (field_ != null)
      return "&" + field_.Emit();
    return "&" + name_;
  }
}

class Parenthesized_2 : Expression_2 {
  Expression_2 ^expr_;

  public Parenthesized_2(Expression_2 ^e) { expr_ = e; }

  public override GType_2 Check(Context_2 ctx) { return expr_.Check(ctx); }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_2 ^Eval(Env_2 env) { return expr_.Eval(env); }

  public override string Emit() { return String.Format("({0})", expr_.Emit()); }
}

class PredefinedType_2 : Expression_2 {
  Class_2 type_;

  public PredefinedType_2(Class_2 type) { type_ = type; }

  public override GType_2 Check(Context_2 ctx) { Debug.Assert(false); return null; }

  public override GType_2 Check(Context_2 ctx, bool read, bool write, bool type_ok) {
    Debug.Assert(type_ok);
    return type_;
  }

  public override int Kind() {
    return ExprKind_2.Type;
  }

  public override RValue_2 ^Eval(Env_2 env) { Debug.Assert(false); return null; }

  public override string Emit() { return type_.name_; }
}

class Dot_2 : LValue_2 {
  Expression_2 ^expr_;  // set to null for a static invocation
  GType_2 expr_type_;
  string name_;

  LMember_2 field_;

  public Dot_2(Expression_2 ^expr, string name) { expr_ = expr; name_ = name; }

  public override bool IsConstant() {
    Debug.Assert(field_ != null);   // make sure we were already type checked
    return field_ is ConstField_2;
  }

  public override GType_2 Check(Context_2 ctx, bool read, bool write, bool type_ok) {
    expr_type_ = expr_.Check(ctx, true, false, true);
    if (expr_type_ == null)
      return null;
    bool is_static = (expr_.Kind() == ExprKind_2.Type);
    if (is_static)
      expr_ = null;
    else expr_.HoldRef(ctx);

    field_ = (LMember_2) expr_type_.Lookup(this, ctx.class_, expr_ is Base_2,
                                         MemberKind_2.Field_2, name_, null, true);
    if (field_ == null)
      return null;

    if (!field_.CheckAccess(this, ctx, write, is_static, !is_static))
      return null;

    if (read) {
      // Only property reads have side effects we need to register in the control graph.
      // (For_2 writes the caller, such as Assign_2, will add its own node.)
      if (field_ is Property_2)
        AddControl(ctx);
      if (expr_ != null)
        expr_.ReleaseRef(ctx);
    }

    return field_.Type().BaseType();
  }

  public override void ReleaseAll(Context_2 ctx) {
    if (expr_ != null)
      expr_.ReleaseRef(ctx);
  }

  public override int Kind() {
    if (field_ is Field_2)
      return ExprKind_2.Field_2;
    if (field_ is Property_2)
      return ExprKind_2.Property_2;
    Debug.Assert(false);
    return 0;
  }

  public override GType_2 StorageType() { return field_.Type(); }

  public override PropertyOrIndexer_2 GetPropertyOrIndexer() { return field_ as Property_2; }

  public override void Eval1(Env_2 env, out RValue_2 ^v1, out RValue_2 ^v2) {
    v1 = v2 = null;
    if (expr_ != null) {  // instance field
      v1 = expr_.Eval(env);
      if (v1 is Null_2) {
        Error("attempted to access field of null object");
        Gel_2.Exit();
      }
    }
  }

  public override RValue_2 ^EvalGet(Env_2 env, RValue_2 ^v1, RValue_2 ^v2) {
    GValue_2 obj = v1 == null ? null : v1.Get();
    return LosesOwnership() && field_.Type() is Owning_2 ? field_.Take_2(obj) : field_.Get(obj);
  }

  public override void EvalSet(Env_2 env, RValue_2 ^v1, RValue_2 ^v2, RValue_2 ^val) {
    GObject_2 obj = v1 == null ? null : (GObject_2) v1.Get();
    field_.Set(obj, val);
  }

  public override Location_2 EvalLocation(Env_2 env, RValue_2 ^v1, RValue_2 ^v2) {
    return field_.GetLocation((GObject_2) v1);
  }

  string EmitPrefix() {
    return expr_ != null ?
      expr_.EmitArrow(expr_type_, field_) :  // instance access
      field_.GetClass().name_ + "::";   // static access
  }

  public override string Emit() {
    string s = EmitPrefix() + field_.Emit();
    GType_2 t = field_.Type();
    return field_ is Property_2 ? Hold(t, s) : s + OwnSuffix(t);
  }

  public override string EmitSet(string val) {
    return EmitPrefix() + field_.EmitSet(val);
  }

  public override string EmitLocation() {
    return "&" + EmitPrefix() + field_.Emit();
  }
}

class Mode_2 {
  public const int In = 0,
                   Ref = 1,
                   Out = 2;

  public static string ToString(int mode) {
    switch (mode) {
      case In: return "";
      case Ref: return "ref ";
      case Out: return "out ";
      default: Debug.Assert(false); return null;
    }
  }
}

abstract class Argument_2 : Node_2 {
  protected GType_2 type_;

  public GType_2 Type() { return type_; }

  public abstract int GetMode();
  public string TypeString() { return Mode_2.ToString(GetMode()) + type_.ToString(); }

  public abstract bool Check(Context_2 ctx);
  public abstract void FinishCall(Context_2 ctx);

  public abstract void AddEval(ArrayList a, Env_2 env, GType_2 t);

  public abstract string Emit(GType_2 t);
}

class InArgument_2 : Argument_2 {
  public readonly Expression_2 ^expr_;

  public InArgument_2(Expression_2 ^expr) { expr_ = expr; }
  public InArgument_2(GType_2 type) { type_ = type; }

  public override int GetMode() { return 0; }

  public override bool Check(Context_2 ctx) {
    if (type_ == null)
      type_ = expr_.CheckAndHold(ctx);
    return type_ != null;
  }

  public override void FinishCall(Context_2 ctx) {
    expr_.ReleaseRef(ctx);
  }

  public override void AddEval(ArrayList a, Env_2 env, GType_2 t) {
    a.Add(expr_.Eval(env, t));
  }

  public override string Emit(GType_2 t) {
    return expr_.EmitRef(type_, t);
  }
}

class RefOutArgument_2 : Argument_2 {
  public readonly int mode_;
  public readonly LValue_2 ^lvalue_;

  public RefOutArgument_2(int mode, LValue_2 ^lvalue) { mode_ = mode; lvalue_ = lvalue; }

  public override int GetMode() { return mode_; }

  public override bool Check(Context_2 ctx) {
    type_ = lvalue_.Check(ctx, mode_ == Mode_2.Ref, true, false);
    if (type_ == null)
      return false;
    if (lvalue_.Kind() == ExprKind_2.Indexer_2) {
      Error("can't pass indexer as ref or out argument");
      return false;
    }
    return true;
  }

  public override void FinishCall(Context_2 ctx) {
    AddControl(ctx);
  }

  public override bool Sets(Local_2 local) { return lvalue_.IsLocal(local); }

  public override TypeSet_2 NodeDestroys() { return lvalue_.StorageType().VarDestroys(); }

  public GType_2 StorageType() { return lvalue_.StorageType(); }

  public override void AddEval(ArrayList a, Env_2 env, GType_2 t) {
    a.Add(new LocationRef_2(lvalue_.EvalLocation(env)));
  }

  public override string Emit(GType_2 t) { return lvalue_.EmitLocation(); }
}

class Invocation_2 : Expression_2 {
  Expression_2 ^obj_;    // may be null
  GType_2 obj_type_;
  string name_;
  ArrayList /* of Argument_2 */ ^arguments_;

  Method_2 method_;

  public Invocation_2(Expression_2 ^obj, string name, ArrayList ^arguments) {
    obj_ = obj; name_ = name; arguments_ = arguments;
  }

  public static Method_2 CheckInvoke(Node_2 caller, Context_2 ctx, bool through_base, GType_2 type,
                                   string name, ArrayList /* of Argument_2 */ arguments,
                                   int kind) {
    foreach (Argument_2 arg in arguments)
      if (!arg.Check(ctx))
        return null;

    // Add the caller to the graph; this node represents the invocation itself.
    caller.AddControl(ctx);

    // Now we can release temporary expressions and add control graph nodes representing
    // assignments to ref and out parameters.
    foreach (Argument_2 arg in arguments)
      arg.FinishCall(ctx);

    Method_2 m = (Method_2) type.Lookup(caller, ctx.class_, through_base, kind, name, arguments, true);
    if (m != null)
      for (int i = 0; i < m.parameters_.Count; ++i) {
        Parameter_2 p = m.Param(i);
        if (p.GetMode() == Mode_2.In) {
          InArgument_2 a = (InArgument_2) arguments[i];
          a.expr_.CheckLoseOwnership(a.Type(), p.Type());
        }
      }
    return m;
  }

  public override GType_2 Check(Context_2 ctx) {
    GType_2 t;
    bool is_class = false;  // true when calling a static method using a class name

    if (obj_ == null)
      t = ctx.class_;
    else {
      t = obj_type_ = obj_.Check(ctx, true, false, true);
      if (t == null)
        return null;
      if (obj_.Kind() == ExprKind_2.Type)
        is_class = true;
      else obj_.HoldRef(ctx);
    }

    method_ = CheckInvoke(this, ctx, obj_ is Base_2, t, name_, arguments_, MemberKind_2.Method_2);
    if (method_ == null)
      return null;

    if (method_ is Constructor_2) {
      Error("can't call constructor directly");
      return null;
    }

    if (obj_ == null) {
      if (!method_.IsStatic() && ctx.IsStatic()) {
        Error("can't call instance method in static context");
        return null;
      }
    } else {
      obj_.ReleaseRef(ctx);
      if (is_class) {
        if (!method_.IsStatic()) {
          Error("can't invoke non-static method through class name");
          return null;
        }
      } else {
        if (method_.IsStatic()) {
          Error("can't invoke static method through object");
          return null;
        }
      }
    }

    GType_2 ret = method_.ReturnType();
    if (ret is Owning_2)
      ctx.AddTemporary(this);
    return ret;
  }

  public override GType_2 TemporaryType() { return method_.ReturnType(); }

  public override Method_2 Calls() { return method_; }

  public static RValue_2 ^InvokeMethod(GValue_2 obj, Method_2 m, ArrayList /* of RValue_2 */ values,
                                    bool virtual_ok) {
    if (m.IsVirtual() && virtual_ok) {
      GType_2 t = obj.Type();
      m = (Method_2) t.FindMatchingMember(m, true);
      Debug.Assert(m != null);
    }
    return m.Invoke(obj, values);
  }

  public static RValue_2 ^CallMethod(Env_2 env, GValue_2 obj,
                                  Method_2 m, ArrayList /* of Argument_2 */ args,
                                  bool virtual_ok) {
    ArrayList /* of ValueOrLocation_2 */ ^values = new ArrayList();
    int i;
    for (i = 0 ; i < args.Count ; ++i) {
      Argument_2 a = (Argument_2) args[i];
      a.AddEval(values, env, m.Param(i).Type());
    }
    return InvokeMethod(obj, m, values, virtual_ok);
  }

  public RValue_2 ^Eval(Env_2 env, Expression_2 obj, Method_2 m, ArrayList /* of Argument_2 */ args) {
    RValue_2 ^r;
    GValue_2 v;
    if (m.IsStatic())
      v = null;
    else {
      if (obj == null)
        v = env.this_;
      else {
        r = obj.Eval(env);
        v = r.Get();
        if (v is Null_2) {
          Error("attempted to call method on null object");
          Gel_2.Exit();
        }
      }
    }

    return CallMethod(env, v, m, args, !(obj is Base_2));
  }

  public override RValue_2 ^Eval(Env_2 env) {
    return Eval(env, obj_, method_, arguments_);
  }

  public static string EmitArguments(Method_2 m, ArrayList /* of Argument_2 */ arguments) {
    StringBuilder ^sb = new StringBuilder();
    Debug.Assert(m.parameters_.Count == arguments.Count);
    for (int i = 0; i < arguments.Count; ++i) {
      if (i > 0)
        sb.Append(", ");
      Argument_2 a = (Argument_2)arguments[i];
      sb.Append(a.Emit(m.Param(i).Type()));
    }
    return sb.ToString();
  }

  public override string Emit() {
    StringBuilder ^sb = new StringBuilder();
    if (obj_ != null) {
      if (method_.IsStatic())
        sb.AppendFormat("{0}::", obj_.Emit());
      else if (obj_type_.IsReference())
        sb.Append(obj_.EmitArrow(obj_type_, method_));
      else sb.AppendFormat("({0})->", obj_.Emit(obj_type_, GObject_2.type_));   // box values
    }
    sb.AppendFormat("{0} ({1})", method_.name_, EmitArguments(method_, arguments_));
    return Hold(method_.ReturnType(), sb.ToString());
  }
}

// an expression of the form a[b]
class Sub_2 : LValue_2 {
  readonly Expression_2 ^base_;
  GType_2 base_type_;
  readonly Expression_2 ^index_;
  GType_2 index_type_;

  GType_2 element_type_;    // for array accesses; null for indexers
  Indexer_2 indexer_;

  public Sub_2(Expression_2 ^base_exp, Expression_2 ^index) { base_ = base_exp; index_ = index; }

  public override GType_2 Check(Context_2 ctx, bool read, bool write, bool type_ok) {
    base_type_ = base_.CheckAndHold(ctx);
    if (base_type_ == null)
      return null;

    index_type_ = index_.CheckAndHold(ctx);
    if (index_type_ == null)
      return null;

    if (read)
      ReleaseAll(ctx);

    ArrayType_2 at = base_type_.BaseType() as ArrayType_2;
    if (at != null) {
      if (!index_type_.CheckConvert(this, GInt_2.type_))
        return null;
      element_type_ = at.ElementType();
      return element_type_.BaseType();
    }

    ArrayList ^arguments = new ArrayList();
    arguments.Add(new InArgument_2(index_type_));

    indexer_ = (Indexer_2) base_type_.Lookup(this, ctx.class_, base_ is Base_2,
                                           MemberKind_2.Indexer_2, null, arguments, true);
    if (indexer_ == null)
      return null;

    if (read && !indexer_.CheckAssigning(this, ctx, false) ||
        write && !indexer_.CheckAssigning(this, ctx, true))
      return null;

    if (read)
      AddControl(ctx);

    return indexer_.Type();
  }

  public override void ReleaseAll(Context_2 ctx) {
    base_.ReleaseRef(ctx);
    index_.ReleaseRef(ctx);
  }

  public override int Kind() {
    return element_type_ != null ? ExprKind_2.Field_2 : ExprKind_2.Indexer_2;
  }

  public override GType_2 StorageType() {
    return element_type_ != null ? element_type_ : indexer_.Type();
  }

  public override PropertyOrIndexer_2 GetPropertyOrIndexer() { return indexer_; }

  public override void Eval1(Env_2 env, out RValue_2 ^v1, out RValue_2 ^v2) {
    v1 = base_.Eval(env);
    if (v1 is Null_2) {
      Error("attempted array or indexer access through null");
      Gel_2.Exit();
    }
    v2 = index_.Eval(env);
  }

  int Index(RValue_2 ^v) {
    // ++ We get an ownership error if we combine the following two lines into one; why?
    v = v.Get().Convert(ref v, GInt_2.type_);
    return ((GInt_2) v).i_;
  }

  public override RValue_2 ^EvalGet(Env_2 env, RValue_2 ^v1, RValue_2 ^v2) {
    if (indexer_ == null) {
      GArray_2 arr = (GArray_2) v1.Get();
      int i = Index(v2);
      return LosesOwnership() && element_type_ is Owning_2 ? arr.Take_2(i) : arr.Get(i);
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    return Invocation_2.InvokeMethod(v1.Get(), indexer_.Getter(), args, true);
  }

  public override void EvalSet(Env_2 env, RValue_2 ^v1, RValue_2 ^v2, RValue_2 ^val) {
    if (indexer_ == null) {
      ((GArray_2) v1.Get()).Set(Index(v2), val);
      return;
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    args.Add(val);
    Invocation_2.InvokeMethod(v1.Get(), indexer_.Setter(), args, true);
  }

  public override Location_2 EvalLocation(Env_2 env, RValue_2 ^v1, RValue_2 ^v2) {
    int i = ((GInt_2) v2).i_;
    return ((GArray_2) v1).GetLocation(i);
  }

  string EmitBase() {
    return base_.EmitArrow(base_type_, indexer_);
  }

  string EmitIndex() {
    return index_.Emit(index_type_, indexer_ != null ? indexer_.parameter_.Type() : GInt_2.type_);
  }

  public override string Emit() {
    string get = String.Format("{0}get_Item({1})", EmitBase(), EmitIndex());
    if (element_type_ != null) {
      get = get + OwnSuffix(element_type_);
      if (!element_type_.IsValue())
        get = String.Format("static_cast<{0} >({1})", element_type_.EmitExprType(), get);
      return get;
    } else return Hold(indexer_.Type(), get);
  }

  public override string EmitSet(string val) {
    return String.Format(element_type_ != null ? "{0}get_Item({1}) = {2}" : "{0}set_Item({1}, {2})",
       EmitBase(), EmitIndex(), val);
  }

  public override string EmitLocation() {
    return String.Format("{0}get_location({1})", EmitBase(), EmitIndex());
  }
}

class This_2 : Expression_2 {
  public override GType_2 Check(Context_2 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access this in a static context");
      return null;
    }
    return ctx.class_;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    return new Reference_2(env.this_);
  }

  public override string Emit() { return "this"; }
}

class Base_2 : Expression_2 {
  Class_2 parent_;

  public override GType_2 Check(Context_2 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access base in a static context");
      return null;
    }
    parent_ = ctx.class_.Parent();
    if (parent_ == null) {
      Error("can't access base: class has no parent");
      return null;
    }
    return parent_;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    return new Reference_2(env.this_);
  }

  public override string Emit() { return "this"; }

  public override string EmitArrow(GType_2 t, Member_2 m) {
    return m.GetClass().name_ + "::"; 
  }
}

class New_2 : Expression_2 {
  Expression_2 ^creator_;    // either a pool or null
  TypeExpr_2 ^type_expr_;
  ArrayList /* of Expression_2 */ ^arguments_;

  Class_2 class_;
  Constructor_2 constructor_;

  public New_2(Expression_2 ^creator, TypeExpr_2 ^expr, ArrayList ^arguments) {
    creator_ = creator;
    type_expr_ = expr;
    arguments_ = arguments;
  }

  GType_2 Type() {
    return creator_ == null ? (GType_2) class_.OwningType() : class_;
  }

  public override GType_2 TemporaryType() { return Type(); }    

  public override GType_2 Check(Context_2 ctx) {
    if (creator_ != null) {
      GType_2 c = creator_.Check(ctx);
      if (c == null)
        return null;
      if (!c.BaseType().IsSubtype(PoolClass_2.instance_)) {
        Error("object creator must be a pool");
        return null;
      }
    }
    GType_2 t = type_expr_.Resolve(ctx.program_);
    if (t == null)
      return null;
    class_ = (Class_2) t;
    if (class_.HasAttribute(Attribute_2.Abstract)) {
      Error("can't instantiate abstract class");
      return null;
    }
    if (creator_ != null) {
      class_.NeedDestroy(); // every pool-allocated class needs the _Destroy1 and _Destroy2 methods
      class_.SetVirtual();  // every pool-allocated class must be virtual
    }

    constructor_ = (Constructor_2) Invocation_2.CheckInvoke(this, ctx, false, class_,
                                      class_.name_, arguments_, MemberKind_2.Constructor_2);
    if (constructor_ == null)
      return null;

    GType_2 type = Type();
    if (type is Owning_2)
      ctx.AddTemporary(this);
    return type;
  }

  public override Method_2 Calls() { return constructor_; }

  public override RValue_2 ^Eval(Env_2 env) {
    GValue_2 ^obj = class_.New_2();
    Invocation_2.CallMethod(env, obj, constructor_, arguments_, false);
    return obj;
  }

  public override string Emit() {
    string args = Invocation_2.EmitArguments(constructor_, arguments_);

    return creator_ == null ?
      EmitAllocate(class_.name_, args, LosesOwnership()) :
      String.Format("new ({0}->Alloc(sizeof({1}))) {1}({2})", creator_.Emit(), class_.name_, args);
  }
}

class ArrayInitializer_2 : Expression_2 {
  public readonly ArrayList /* of Expression_2 */ ^initializers_;

  public ArrayInitializer_2(ArrayList ^initializers) { initializers_ = initializers; }

  public override GType_2 Check(Context_2 ctx) {
    Error("only static fields may have array initializers");
    return null;
  }

  public bool CheckElements(Context_2 ctx, GType_2 element_type) {
    foreach (Expression_2 e in initializers_)
      if (!e.CheckConstant() || !e.Check(ctx, element_type))
        return false;
    return true;
  }

  public override RValue_2 ^Eval(Env_2 env) { Debug.Assert(false); return null; }

  public GArray_2 ^Eval(ArrayType_2 type) {
    GArray_2 ^a = new GArray_2(type, initializers_.Count);
    for (int i = 0; i < initializers_.Count; ++i) {
      Expression_2 e = (Expression_2) initializers_[i];
      a.Set(i, e.Eval(Env_2.static_, type.ElementType()));
    }
    return a;
  }

  public override string Emit() { Debug.Assert(false); return null; }

  public void Emit(SourceWriter_2 w) {
    int count = initializers_.Count;
    int per_row = 12;

    w.Write("{ ");
    if (count > per_row) {    // format onto multiple rows
      w.WriteLine("");
      w.AddIndent();
      w.Indent();
    }
    for (int i = 0; i < count; ++i) {
      if (i > 0) {
        w.Write(", ");
        if (i % per_row == 0) {
          w.WriteLine("");
          w.Indent();
        }
      }
      Expression_2 e = (Expression_2) initializers_[i];
      SimpleValue_2 ^v = (SimpleValue_2) e.Eval(Env_2.static_);
      w.Write(v.Emit());
    }
    if (count > per_row) {
      w.SubIndent();
      w.WriteLine("");
    }
    w.Write(" }");
  }
}

class NewArray_2 : Expression_2 {
  TypeExpr_2 ^element_type_expr_;
  int dimensions_;
  ArrayType_2 ^array_type_;

  Expression_2 ^count_;

  public NewArray_2(TypeExpr_2 ^element_type_expr, int dimensions, Expression_2 ^count) {
    element_type_expr_ = element_type_expr;
    dimensions_ = dimensions;
    count_ = count;
  }

  GType_2 Type() {
    return (GType_2) array_type_.OwningType();
  }

  public override GType_2 TemporaryType() { return Type(); }

  public override GType_2 Check(Context_2 ctx) {
    if (element_type_expr_ is ArrayTypeExpr_2) {
      Error("syntax error in new expression");
      return null;
    }
    for (int i = 0; i < dimensions_; ++i)
      element_type_expr_ = new ArrayTypeExpr_2(take element_type_expr_);
    GType_2 element_type = element_type_expr_.Resolve(ctx.program_);
    if (element_type == null)
      return null;
    array_type_ = new ArrayType_2(element_type);

    if (!count_.Check(ctx, GInt_2.type_))
      return null;

    GType_2 t = Type();
    if (t is Owning_2)
      ctx.AddTemporary(this);
    return t;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    return new GArray_2(array_type_, count_.EvalInt(env));
  }

  public override string Emit() {
    GType_2 t = array_type_.ElementType();
    string array_type = GType_2.ConstructType(
      t is Owning_2 ? "_Array" : "_CopyableArray",
      t.EmitGenericType());
    string args = String.Format("&typeid({0}), {1}", t.EmitType(), count_.Emit());
    return EmitAllocate(array_type, args, LosesOwnership());
  }
}

abstract class Unary_2 : Expression_2 {
  protected Expression_2 ^exp_;

  protected Unary_2(Expression_2 ^e) { exp_ = e; }

  public override bool IsConstant() { return exp_.IsConstant(); }
}

// unary minus operator
class Minus_2 : Unary_2 {
  GType_2 type_;

  public Minus_2(Expression_2 ^e) : base(e) { }

  public override GType_2 Check(Context_2 ctx) {
    type_ = exp_.Check(ctx);
    if (type_ != GInt_2.type_ && type_ != GFloat_2.type_ && type_ != GDouble_2.type_) {
      Error("- operator cannot be applied to value of type {0}", type_);
      return null;
    }
    return type_;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    if (type_ == GInt_2.type_) {
    int i = exp_.EvalInt(env);
    return new GInt_2(-i);
  }
    if (type_ == GFloat_2.type_) {
      float f = exp_.EvalFloat(env);
      return new GFloat_2(-f);
    }
    if (type_ == GDouble_2.type_) {
      double d = exp_.EvalDouble(env);
      return new GDouble_2(-d);
    }
    Debug.Assert(false);
    return null;
  }

  public override string Emit() { return "-" + exp_.Emit(); }
}

class Not_2 : Unary_2 {
  public Not_2(Expression_2 ^e) : base(e) { }

  public override GType_2 Check(Context_2 ctx) {
    return exp_.Check(ctx, GBool_2.type_) ? GBool_2.type_ : null;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    bool b = exp_.EvalBool(env);
    return new GBool_2(!b);
  }

  public override string Emit() { return "!" + exp_.Emit(); }
}

// the bitwise complement (~) operator
class Complement_2 : Unary_2 {
  public Complement_2(Expression_2 ^e) : base(e) { }

  public override GType_2 Check(Context_2 ctx) {
    return exp_.Check(ctx, GInt_2.type_) ? GInt_2.type_ : null;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    int i = exp_.EvalInt(env);
    return new GInt_2(~i);
  }

  public override string Emit() { return "~" + exp_.Emit(); }
}

class IncDec_2 : Expression_2 {
  bool pre_;    // true for pre-increment/decrement; false for post-increment/decrement
  bool inc_;
  LValue_2 ^lvalue_;

  public IncDec_2(bool pre, bool inc, LValue_2 ^lvalue) { pre_ = pre; inc_ = inc; lvalue_ = lvalue; }

  public override GType_2 Check(Context_2 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    GType_2 t = lvalue_.Check(ctx, true, true, false);
    if (t == null)
      return null;
    if (lvalue_.Kind() == ExprKind_2.Indexer_2) {
      Error("++ and -- can't yet operate on indexers");
      return null;
    }
    if (t != GInt_2.type_) {
      Error("++ and -- can operate only on integers");
      return null;
    }
    return GInt_2.type_;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    Location_2 loc = lvalue_.EvalLocation(env);
    GInt_2 ^i = (GInt_2) take loc.value_;
    loc.value_ = new GInt_2(inc_ ? i.i_ + 1 : i.i_ - 1);
    return pre_ ? ((GInt_2) loc.value_).Copy() : i;
  }

  string EmitOp() { return inc_ ? "++" : "--"; }

  public override string Emit() {
    return pre_ ? EmitOp() + lvalue_.Emit() : lvalue_.Emit() + EmitOp();
  }
}

abstract class Conversion_2 : Expression_2 {
  protected Expression_2 ^expr_;
  protected TypeExpr_2 ^type_expr_;

  protected GType_2 from_base_;
  protected GType_2 to_type_, to_base_;

  protected Conversion_2(Expression_2 ^expr, TypeExpr_2 ^type_expr) {
    expr_ = expr; type_expr_ = type_expr;
  }

  protected bool CheckConversion(Context_2 ctx, bool subtype_only) {
    GType_2 from = expr_.Check(ctx);
    if (from == null)
      return false;
    from_base_ = from.BaseType();

    to_base_ = type_expr_.Resolve(ctx.program_);
    if (to_base_ == null)
      return false;
    if (!to_base_.IsValue() &&
       (from is Owning_2 || from_base_.IsValue()))
      to_type_ = to_base_.OwningType();
    else to_type_ = to_base_;

    if (!from.CanConvertExplicit(to_type_, subtype_only)) {
      Error("can't convert from {0} to {1}", from_base_, to_base_);
      return false;
    }
    return true;
  }
}

class Cast_2 : Conversion_2 {
  public Cast_2(Expression_2 ^expr, TypeExpr_2 ^type_expr) : base(expr, type_expr) { }

  public override Local_2 GetLocal() { return expr_.GetLocal(); }
  
  public override GType_2 Check(Context_2 ctx) {
    return CheckConversion(ctx, false) ? to_type_ : null;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_2.Local_2 ? ExprKind_2.Local_2 : ExprKind_2.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_2 ^Eval(Env_2 env) {
    RValue_2 ^r = expr_.Eval(env);
    return r.Get().ConvertExplicit(ref r, to_base_);
  }

  public override string Emit() {
    return expr_.EmitExplicit(from_base_, to_type_);
  }
}

class Binary_2 : Expression_2 {
  int op_;
  Expression_2 ^left_, right_;
  GType_2 left_type_, right_type_;
  GType_2 type_;

  const int CONCATENATE = 0;

  public Binary_2(Expression_2 ^left, int op, Expression_2 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public static GType_2 Promote(Syntax_2 caller, GType_2 left, int op, GType_2 right) {
    if (left.CanConvert(GInt_2.type_) && right.CanConvert(GInt_2.type_))
      return GInt_2.type_;
    if (left.CanConvert(GFloat_2.type_) && right.CanConvert(GFloat_2.type_))
      return GFloat_2.type_;
    if (left.CanConvert(GDouble_2.type_) && right.CanConvert(GDouble_2.type_))
      return GDouble_2.type_;
    caller.Error("can't apply operator {0} to operands of type {1} and {2}", OpName(op), left, right);
    return null;
  }

  bool CheckIntArgs() {
    if (left_type_.CheckConvert(this, GInt_2.type_) && right_type_.CheckConvert(this, GInt_2.type_)) {
      type_ = GInt_2.type_;
      return true;
    }
    return false;
  }

  public override GType_2 Check(Context_2 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);

    if (op_ == '+' && (left_type_ == GString_2.type_ || right_type_ == GString_2.type_)) {
      op_ = CONCATENATE;

      // If_2 we'll be calling ToString() on a class, ensure that it will inherit from
      // Object in generated code.
      if (left_type_ != GString_2.type_)
        left_type_.CanConvert(GObject_2.type_);
      if (right_type_ != GString_2.type_)
        right_type_.CanConvert(GObject_2.type_);

      return GString_2.type_;
    }

    switch (op_) {
      case '*':
      case '/':
      case '+':
      case '-':
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_;

      case '%':
      case Parser.OP_LEFT_SHIFT:
      case Parser.OP_RIGHT_SHIFT:
        return CheckIntArgs() ? GInt_2.type_ : null;

      case '&':
      case '|':
        if (left_type_ == GBool_2.type_ && right_type_ == GBool_2.type_)
          type_ = GBool_2.type_;
        else {
          if (!CheckIntArgs())
            return null;
          type_ = GInt_2.type_;
        }
        return type_;

      case '<':
      case Parser.OP_LE:
      case '>':
      case Parser.OP_GE:
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_ == null ? null : GBool_2.type_;

      default:
        Debug.Assert(false);
        return null;
    }
  }

  public static GBool_2 ^BoolOp(bool x, int op, bool y) {
    switch (op) {
      case '&': return new GBool_2(x & y);
      case '|': return new GBool_2(x | y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_2 ^IntOp(int x, int op, int y) {
    switch (op) {
      case '*': return new GInt_2(x * y);
      case '/': return new GInt_2(x / y);
      case '%': return new GInt_2(x % y);
      case '+': return new GInt_2(x + y);
      case '-': return new GInt_2(x - y);
      case Parser.OP_LEFT_SHIFT: return new GInt_2(x << y);
      case Parser.OP_RIGHT_SHIFT: return new GInt_2(x >> y);
      case '&': return new GInt_2(x & y);
      case '|': return new GInt_2(x | y);
      case '<': return new GBool_2(x < y);
      case Parser.OP_LE: return new GBool_2(x <= y);
      case '>': return new GBool_2(x > y);
      case Parser.OP_GE: return new GBool_2(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_2 ^FloatOp(float x, int op, float y) {
    switch (op) {
      case '*': return new GFloat_2(x * y);
      case '/': return new GFloat_2(x / y);
      case '+': return new GFloat_2(x + y);
      case '-': return new GFloat_2(x - y);
      case '<': return new GBool_2(x < y);
      case Parser.OP_LE: return new GBool_2(x <= y);
      case '>': return new GBool_2(x > y);
      case Parser.OP_GE: return new GBool_2(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_2 ^DoubleOp(double x, int op, double y) {
    switch (op) {
      case '*': return new GDouble_2(x * y);
      case '/': return new GDouble_2(x / y);
      case '+': return new GDouble_2(x + y);
      case '-': return new GDouble_2(x - y);
      case '<': return new GBool_2(x < y);
      case Parser.OP_LE: return new GBool_2(x <= y);
      case '>': return new GBool_2(x > y);
      case Parser.OP_GE: return new GBool_2(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public override RValue_2 ^Eval(Env_2 env) {
    if (op_ == CONCATENATE)
      return new GString_2(left_.Eval(env).ToString() + right_.Eval(env).ToString());

    if (type_ == GBool_2.type_)
      return BoolOp(left_.EvalBool(env), op_, right_.EvalBool(env));
    if (type_ == GInt_2.type_)
      return IntOp(left_.EvalInt(env), op_, right_.EvalInt(env));
    if (type_ == GFloat_2.type_)
      return FloatOp(left_.EvalFloat(env), op_, right_.EvalFloat(env));
    if (type_ == GDouble_2.type_)
      return DoubleOp(left_.EvalDouble(env), op_, right_.EvalDouble(env));

    Debug.Assert(false);
    return null;
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  static string OpName(int op) {
    switch (op) {
      case Parser.OP_LEFT_SHIFT: return "<<";
      case Parser.OP_RIGHT_SHIFT: return ">>";
      case Parser.OP_LE: return "<=";
      case Parser.OP_GE: return ">=";
      default: return ((char) op).ToString();
    }
  }

  public override string Emit() {
    if (op_ == CONCATENATE)
      return Hold(GString_2.type_,
        String.Format("String::_Concat({0}, {1})",
          left_.EmitRef(left_type_, GObject_2.type_), right_.Emit(right_type_, GObject_2.type_)));

    return String.Format("{0} {1} {2}",
      left_.EmitRef(left_type_), OpName(op_), right_.Emit() );
  }
}

class Equality_2 : Expression_2 {
  bool equal_;    // true for ==, false for !=
  Expression_2 ^left_, right_;
  GType_2 left_type_, right_type_, type_;

  public Equality_2(Expression_2 ^left, int op, Expression_2 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_EQUAL: equal_ = true; break;
      case Parser.OP_NE: equal_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_2 Check(Context_2 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);
    if (left_type_.IsReference() != right_type_.IsReference()) {
      Error("can't compare types {0} and {1}", left_type_, right_type_);
      return null;
    }
    type_ = left_type_.BaseType().CommonType(this, right_type_.BaseType());
    return type_ == null ? null : GBool_2.type_;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    RValue_2 ^left = left_.Eval(env, type_);
    RValue_2 ^right = right_.Eval(env, type_);
    bool eq = left.Get().DefaultEquals(right.Get());
    return new GBool_2(equal_ ? eq : !eq);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    string emit_left = left_.EmitRef(left_type_);
    string emit_right = right_.Emit();
    if (type_ == GString_2.type_)
      return String.Format("{0}String::_Equals({1}, {2})",
                           equal_ ? "" : "!", emit_left, emit_right);
    return String.Format("{0} {1} {2}", emit_left, equal_ ? "==" : "!=", emit_right);
  }
}

class Is_2 : Conversion_2 {
  public Is_2(Expression_2 ^expr, TypeExpr_2 ^type_expr) : base(expr, type_expr) { }

  public override GType_2 Check(Context_2 ctx) {
    return CheckConversion(ctx, true) ? GBool_2.type_ : null;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    RValue_2 ^r = expr_.Eval(env);
    GValue_2 v = r.Get();
    return new GBool_2(!(v is Null_2) && v.Type().IsSubtype(to_base_));
  }

  public override string Emit() {
    if (from_base_.IsReference()) {
      Class_2 c = (Class_2) to_base_;
      return String.Format("dynamic_cast<{0} *>({1}) != 0", c.name_, expr_.Emit());
    }
    return to_base_ == from_base_ || to_base_ == GObject_2.type_ ? "true" : "false";
  }
}

class As_2 : Conversion_2 {
  public As_2(Expression_2 ^expr, TypeExpr_2 ^type_expr) : base(expr, type_expr) { }

  public override Local_2 GetLocal() { return expr_.GetLocal(); }

  public override GType_2 Check(Context_2 ctx) {
    if (!CheckConversion(ctx, true))
      return null;
    if (!to_base_.IsReference()) {
      Error("as operator must convert to reference type");
      return null;
    }
    return to_type_;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_2.Local_2 ? ExprKind_2.Local_2 : ExprKind_2.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_2 ^Eval(Env_2 env) {
    RValue_2 ^r = expr_.Eval(env);
    return r.Get().Type().IsSubtype(to_base_) ? r : Null_2.Instance.Copy();
  }

  public override string Emit() {
    if (from_base_.CanConvert(to_base_))
      return expr_.Emit(from_base_, to_base_);
    Class_2 c = (Class_2) to_base_;
    return String.Format("dynamic_cast<{0} *>({1})", c.name_, expr_.Emit());
  }
}

// a && or || operator
class LogicalOp_2 : Expression_2 {
  bool and_;  // true => &&, false => ||
  Expression_2 ^left_, right_;
  Joiner_2 ^join_ = new Joiner_2();

  public LogicalOp_2(Expression_2 ^left, int op, Expression_2 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_AND: and_ = true; break;
      case Parser.OP_OR: and_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_2 Check(Context_2 ctx) {
    if (!left_.Check(ctx, GBool_2.type_))
      return null;

    join_.Join(ctx.Prev());
    if (!right_.Check(ctx, GBool_2.type_))
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    return GBool_2.type_;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    bool left = left_.EvalBool(env);
    bool b = and_ ? left && right_.EvalBool(env) : left || right_.EvalBool(env);
    return new GBool_2(b);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    return String.Format("{0} {1} {2}", left_.Emit(), and_ ? "&&" : "||", right_.Emit());
  }

}

// the ?: operator
class Conditional_2 : Expression_2 {
  Expression_2 ^condition_;
  Expression_2 ^if_true_, if_false_;

  GType_2 true_type_, false_type_;
  GType_2 type_;
  Joiner_2 ^join_ = new Joiner_2();

  public Conditional_2(Expression_2 ^condition, Expression_2 ^if_true, Expression_2 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override GType_2 Check(Context_2 ctx) {
    if (!condition_.Check(ctx, GBool_2.type_))
      return null;

    Control_2 c = ctx.Prev();

    true_type_ = if_true_.Check(ctx);
    if (true_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    false_type_ = if_false_.Check(ctx);
    if (false_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    type_ = true_type_.CommonType(this, false_type_);
    return type_;
  }

  public override int Kind() {
    return if_true_.Kind() == ExprKind_2.Local_2 && if_false_.Kind() == ExprKind_2.Local_2 ? ExprKind_2.Local_2 : ExprKind_2.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    if_true_.LoseOwnership();
    if_false_.LoseOwnership();
  }

  public override RValue_2 ^Eval(Env_2 env) {
    return condition_.EvalBool(env) ? if_true_.Eval(env, type_) : if_false_.Eval(env, type_);
  }

  public override string Emit() {
    return String.Format("{0} ? {1} : {2}", condition_.Emit(),
                         if_true_.Emit(true_type_, type_), if_false_.Emit(false_type_, type_));
  }
}

class Assign_2 : Expression_2 {
  LValue_2 ^left_;
  Expression_2 ^right_;

  GType_2 left_type_, right_type_;

  public Assign_2(LValue_2 ^left, Expression_2 ^right) {
    left_ = left; right_ = right;
  }

  public static bool CheckAssign(Syntax_2 caller, GType_2 left_type, Expression_2 right, GType_2 right_type) {
    if (!right_type.CheckConvert(caller, left_type,
      right.Kind() == ExprKind_2.Local_2 ? ConversionContext_2.AssignVar : ConversionContext_2.Other))
      return false;
    right.CheckLoseOwnership(right_type, left_type);
    return true;
  }

  public override GType_2 Check(Context_2 ctx) {
    left_type_ = left_.Check(ctx, false, true, false);
    if (left_type_ == null)
      return null;

    right_type_ = right_.Check(ctx, true, false, false);
    if (right_type_ == null || !CheckAssign(this, left_.StorageType(), right_, right_type_))
      return null;
    right_.HoldRef(ctx);

    AddControl(ctx);
    left_.ReleaseAll(ctx);
    right_.ReleaseRef(ctx);
    return left_type_;
  }

  public override Method_2 Calls() {
    PropertyOrIndexer_2 pi = left_.GetPropertyOrIndexer();
    return pi == null ? null : pi.Setter();
  }

  public override bool Sets(Local_2 local) { return left_.IsLocal(local); }

  public override TypeSet_2 NodeDestroys() {
    return left_.GetPropertyOrIndexer() != null ? TypeSet_2.empty_ : left_.StorageType().VarDestroys();
  }

  public override RValue_2 ^Eval(Env_2 env) {
    RValue_2 ^v1, v2;
    left_.Eval1(env, out v1, out v2);
    RValue_2 ^val = right_.Eval(env, left_type_);
    RValue_2 ^ret = val.CopyRef();
    left_.EvalSet(env, v1, v2, val);
    return ret;
  }

  public override string Emit() {
    return left_.EmitSet(right_.EmitRef(right_type_, left_type_));
  }
}

// a compound assignment operator such as += or -=
class CompoundAssign_2 : Expression_2 {
  LValue_2 ^left_;
  int op_;
  Expression_2 ^right_;

  GType_2 type_;

  public CompoundAssign_2(LValue_2 ^left, int op, Expression_2 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public override GType_2 Check(Context_2 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    type_ = left_.Check(ctx, true, true, false);
    if (type_ == null)
      return null;
    if (left_.Kind() == ExprKind_2.Indexer_2) {
      Error("compound assignments don't yet work on indexers");
      return null;
    }
    if (type_ == GBool_2.type_ && (op_ == '&' || op_ == '|')) {
      if (!right_.Check(ctx, GBool_2.type_))
        return null;
      return type_;
    }
    if (type_ != GInt_2.type_ && type_ != GFloat_2.type_ && type_ != GDouble_2.type_) {
      Error("compound assignment operator {0}= can't operate on object of type {1}", (char) op_, type_);
      return null;
    }
    if (!right_.Check(ctx, type_))
      return null;
    return type_;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    Location_2 loc = left_.EvalLocation(env);
    if (type_ == GBool_2.type_) {
      bool x = ((GBool_2) loc.value_).b_;
      bool y = right_.EvalBool(env);
      loc.value_ = Binary_2.BoolOp(x, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GInt_2.type_) {
      GInt_2 x = (GInt_2) loc.value_;
      int y = right_.EvalInt(env);
      loc.value_ = Binary_2.IntOp(x.i_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GFloat_2.type_) {
      GFloat_2 x = (GFloat_2) loc.value_;
      float y = right_.EvalFloat(env);
      loc.value_ = Binary_2.FloatOp(x.f_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GDouble_2.type_) {
      GDouble_2 x = (GDouble_2) loc.value_;
      double y = right_.EvalDouble(env);
      loc.value_ = Binary_2.DoubleOp(x.d_, op_, y);
      return loc.value_.CopyRef();
    } else {
      Debug.Assert(false);
      return null;
    }
  }

  public override string Emit() {
    return String.Format("{0} {1}= {2}", left_.Emit(), (char) op_, right_.Emit());
  }
}

class Take_2 : Expression_2 {
  LValue_2 ^exp_;
  Owning_2 type_;

  public Take_2(LValue_2 ^exp) { exp_ = exp; }

  public override GType_2 Check(Context_2 ctx) {
    GType_2 t = exp_.Check(ctx);
    if (t == null)
      return null;
    type_ = exp_.StorageType() as Owning_2;
    if (type_ == null) {
      Error("take must be applied to owning pointer");
      return null;
    }
    exp_.LoseOwnership();
    ctx.AddTemporary(this);
    return type_;
  }

  public override GType_2 TemporaryType() { return type_; }

  public override RValue_2 ^Eval(Env_2 env) {
    RValue_2 ^v = exp_.Eval(env);
    exp_.EvalSet(env, Null_2.Instance.Copy());
    return v;
  }

  public override string Emit() {
    return Hold(exp_.StorageType(), exp_.Emit());
  }
}

abstract class Statement_2 : Node_2 {
  public abstract bool Check(Context_2 ctx);
  public abstract RValue_2 ^Eval(Env_2 env);

  public abstract void Emit(SourceWriter_2 w);

  public virtual void EmitEmbedded(SourceWriter_2 w) {
    w.WriteLine("");
    w.AddIndent();
    w.Indent();
    Emit(w);
    w.SubIndent();
  }

  public virtual void EmitInExistingBlock(SourceWriter_2 w) {
    w.Indent();
    Emit(w);
  }
}

class StatementList_2 {
  public readonly ArrayList /* of Statement_2 */ ^statements_ = new ArrayList();

  public void Add(Statement_2 ^s) { statements_.Add(s); }

  public bool Check(Context_2 ctx) {
    bool ok = true;
    foreach (Statement_2 s in statements_)
      ok &= s.Check(ctx);
    return ok;
  }

  public RValue_2 ^Eval(Env_2 env) {
    foreach (Statement_2 s in statements_) {
      RValue_2 ^v = s.Eval(env);
      if (v != null)
        return v;
    }
    return null;
  }

  public void Emit(SourceWriter_2 w) {
    foreach (Statement_2 s in statements_) {
      w.Indent();
      s.Emit(w);
    }
  }
}

class EmptyStatement_2 : InlineStatement_2 {
  public EmptyStatement_2() { }

  public override bool Check(Context_2 ctx) { return true; }
  public override RValue_2 ^Eval(Env_2 env) { return null; }
  public override void EmitInline(SourceWriter_2 w) { }

  public static readonly EmptyStatement_2 ^instance_ = new EmptyStatement_2();
}

// A Scoped_2 is a statement defining one or more local variables.  If_2 a Scoped_2 appears in the
// control graph, then it destroys those variables when traversed.
abstract class Scoped_2 : Statement_2 {
  protected Local_2 start_;   // the first local outside this statement
  protected Local_2 top_;     // the top local defined inside this statement

  TypeSet_2 ^destroys_;

  protected void SetStartVar(Context_2 ctx) { start_ = top_ = ctx.var_; }
  protected void SetTopVar(Context_2 ctx) { top_ = ctx.var_; }

  public Local_2 GetStart() { return start_; }
  public Local_2 GetTop() { return top_; }

  public override TypeSet_2 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_2();
    for (Local_2 l = top_; l != start_; l = l.next_)
        destroys_.Add(l.Type().VarDestroys());
    }
    return destroys_;
  }
}

class Block_2 : Scoped_2 {
  public readonly StatementList_2 ^list_;

  public Block_2(StatementList_2 ^list) { list_ = list; }

  public bool Absent() { return list_ == null; }

  public override bool Check(Context_2 ctx) {
    Context_2 ^ctx1 = new Context_2(ctx);   // don't pass declarations outside block
    SetStartVar(ctx1);

    if (!list_.Check(ctx1))
      return false;

    SetTopVar(ctx1);

    // Add this Block_2 to the control graph; this represents the destruction of variables
    // within the block at block exit.
    AddControl(ctx1);

    return true;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    return list_.Eval(new Env_2(env));
  }

  public static Block_2 ^EmptyBlock() { return new Block_2(new StatementList_2()); }

  public override void Emit(SourceWriter_2 w) {
    w.OpenBrace();
    list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitEmbedded(SourceWriter_2 w) {
    w.Write(" ");
    Emit(w);
  }

  public override void EmitInExistingBlock(SourceWriter_2 w) {
    list_.Emit(w);
  }
}

class MemberKind_2 {
  public const int
    Field_2 = 0,
    Method_2 = 1,
    Property_2 = 2,
    Indexer_2 = 3,
    Constructor_2 = 4;
}

class Named_2 : Node_2 {
  public readonly TypeExpr_2 ^type_expr_;   // may be null for certain objects such as constructors
  protected GType_2 type_;

  public readonly string name_;

  public Named_2(TypeExpr_2 ^type_expr, string name) {
    type_expr_ = type_expr;
    name_ = name;
  }

  public GType_2 Type() { return type_; }

  public virtual bool Resolve(Program_2 program) {
    if (type_expr_ == null || type_ != null)
      return true;
    type_ = type_expr_.Resolve(program);
    return type_ != null;
  }
}

abstract class Member_2 : Named_2 {
  protected Class_2 class_;    // containing class

  public readonly int attributes_;

  protected Member_2(int attributes, TypeExpr_2 ^type_expr, string name) : base(type_expr, name) {
    attributes_ = attributes;
  }

  public abstract int Kind();

  public static string ToString(int kind) {
    switch (kind) {
      case MemberKind_2.Field_2: return "field";
      case MemberKind_2.Method_2: return "method";
      case MemberKind_2.Property_2: return "property";
      case MemberKind_2.Indexer_2: return "indexer";
      case MemberKind_2.Constructor_2: return "constructor";
      default: Debug.Assert(false); return null;
    }
  }

  public string KindString() { return ToString(Kind()); }

  protected abstract int ValidAttributes();

  public Class_2 GetClass() { return class_; }
  public void SetClass(Class_2 cl) { class_ = cl; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public bool IsOverride() { return HasAttribute(Attribute_2.Override); }

  public bool IsProtected() { return HasAttribute(Attribute_2.Protected); }

  public bool IsPublic() { return HasAttribute(Attribute_2.Public); }

  public bool IsPrivate() { return !HasAttribute(Attribute_2.Public | Attribute_2.Protected); }

  public bool IsVirtual() {
    return HasAttribute(Attribute_2.Virtual | Attribute_2.Abstract | Attribute_2.Override);
  }

  static ArrayList ^empty_ = new ArrayList();

  public virtual ArrayList /* of Parameter_2 */ Parameters() { return empty_; }

  public Parameter_2 Param(int i) {
    return (Parameter_2) Parameters()[i];
  }

  public bool IsAccessible(Class_2 from_class, GType_2 through_type, bool through_base) {
    if (IsPublic())
      return true;

    // In GEL2 (as in C# and C++), a class [from_class] can access a protected member of
    // a class C only if [from_class] is a subtype of C and the access is
    // through a subtype of [from_class].  See e.g. C# 3.5.3 "Protected Access for Instance Members".
    if (IsProtected())
      return through_base || from_class.IsSubtype(class_) && through_type.IsSubtype(from_class);

    // default private access
    return from_class == class_;
  }

  public static bool MatchKind(int kind1, int kind2) {
    return kind1 == kind2 ||
           kind1 == MemberKind_2.Field_2 && kind2 == MemberKind_2.Property_2 ||
           kind1 == MemberKind_2.Property_2 && kind2 == MemberKind_2.Field_2;
  }

  public bool MatchSignature(Member_2 m) {
    if (!MatchKind(Kind(), m.Kind()))
      return false;

    if (name_ != m.name_ || Parameters().Count != m.Parameters().Count)
      return false;

    int i = 0;
    foreach (Parameter_2 p in m.Parameters()) {
      Parameter_2 q = Param(i);
      if (!p.Match(q))
        return false;
      ++i;
    }
    return true;
  }

  public bool IsApplicable(ArrayList arguments, out int mismatches) {
    mismatches = 0;
    if (Parameters().Count != arguments.Count)
      return false;
    int i = 0;
    foreach (Argument_2 a in arguments) {
      if (!Param(i).CanReceive(a))
        ++mismatches;
      ++i;
    }
    return true;
  }

  public void ReportMismatches(Syntax_2 caller, ArrayList arguments) {
    Debug.Assert(Parameters().Count == arguments.Count);
    int i = 0;
    foreach (Argument_2 a in arguments) {
      Parameter_2 p = Param(i);
      if (!p.CanReceive(a))
        caller.Error("argument {0}: can't convert from {1} to {2}", i + 1, a.TypeString(), p.TypeString());
      ++i;
    }
  }

  protected virtual void AddOverride(Member_2 m) { }

  bool CheckOverride(Context_2 ctx) {
    Class_2 parent = ctx.class_.Parent();
    Member_2 m = parent != null ? parent.FindMatchingMember(this, false) : null;
    if (m != null) {
      if (this is Field_2) {
        Error("can't define field with same name as field/property in superclass");
        return false;
      }
      if (m is Field_2) {
        Error("can't define property with same name as field in superclass");
        return false;
      }
      if (!HasAttribute(Attribute_2.Override)) {
        Error("must use override keyword to override superclass {0}", KindString());
        return false;
      }
      if (HasAttribute(Attribute_2.Virtual)) {
        Error("{0} with override or abstract keyword cannot be marked virtual", KindString());
        return false;
      }
      if (!m.IsVirtual()) {
        Error("attempting to override non-virtual {0}", KindString());
        return false;
      }
      if (!m.Type().Equals(Type())) {
        Error("can't override {0} with different return type", KindString());
        return false;
      }
      if (m.IsPublic() != IsPublic()) {
        Error("override {0} must have same accessibility as {0} it overrides", KindString());
        return false;
      }
      m.AddOverride(this);
    } else if (HasAttribute(Attribute_2.Override)) {
      Error("can't find {0} to override", KindString());
      return false;
    }
    return true;
  }

  bool CheckAccessibility() {
    int n = 0;
    if ((attributes_ & Attribute_2.Private) != 0)
      ++n;
    if ((attributes_ & Attribute_2.Protected) != 0)
      ++n;
    if ((attributes_ & Attribute_2.Public) != 0)
      ++n;
    if (n > 1) {
      Error("only one access level (private, protected, public) may be specified");
      return false;
    }

    if (IsVirtual() && IsPrivate()) {
      Error("a virtual or abstract {0} may not be private", KindString());
      return false;
    }

    return true;
  }

  public virtual bool Check(Context_2 ctx) {
    if (!AttributeUtil_2.CheckOnly(attributes_, ValidAttributes())) {
      Error("illegal {0} attribute", KindString());
      return false;
    }

    if (HasAttribute(Attribute_2.Abstract) && !ctx.class_.HasAttribute(Attribute_2.Abstract)) {
      Error("an abstract {0} can be defined only in an abstract class", KindString());
      return false;
    }

    if (name_ == class_.name_ && !(this is Constructor_2)) {
      Error("{0} cannot have same name as enclosing class", KindString());
      return false;
    }

    if (class_.GetMatchingMember(this) != this) {
      Error("{0} {1} appears twice in same class", KindString(), name_ != null ? name_ : "");
      return false;
    }

    return CheckOverride(ctx) && CheckAccessibility();
  }
}

// a member which represents a storage location: a field, property, or indexer
abstract class LMember_2 : Member_2 {
  protected LMember_2(int attributes, TypeExpr_2 ^type_expr, string name)
    : base(attributes, type_expr, name) { }

  public bool IsConstOrStatic() {
    return HasAttribute(Attribute_2.Const | Attribute_2.Static);
  }

  protected bool CheckStatic(Syntax_2 caller, bool static_ok, bool instance_ok) {
    if (!static_ok && IsConstOrStatic()) {
      caller.Error("{0} {1} is static", KindString(), name_);
      return false;
    }
    if (!instance_ok && !IsConstOrStatic()) {
      caller.Error("{0} {1} is not static", KindString(), name_);
      return false;
    }
    return true;
  }

  public abstract bool CheckAssigning(Syntax_2 caller, Context_2 ctx, bool assigning);

  public bool CheckAccess(Syntax_2 caller, Context_2 ctx, bool assigning, bool static_ok, bool instance_ok) {
    return CheckStatic(caller, static_ok, instance_ok) && CheckAssigning(caller, ctx, assigning);
  }

  public abstract Location_2 GetLocation(GObject_2 obj);

  // These methods are for fields and properties; indexers have their own versions which take
  // an extra index argument.
  public virtual RValue_2 ^Get(GValue_2 obj) { Debug.Assert(false); return null; }
  public virtual RValue_2 ^Take_2(GValue_2 obj) { Debug.Assert(false); return null; }
  public virtual void Set(GObject_2 obj, RValue_2 ^val)  { Debug.Assert(false); }

  public virtual string Emit()  { Debug.Assert(false); return null; }
  public virtual string EmitSet(string val)  { Debug.Assert(false); return null; }
}

class Field_2 : LMember_2 {
  protected Expression_2 ^initializer_;    // or null if none
  protected GType_2 initializer_type_;

  public Field_2(int attributes, TypeExpr_2 ^type_expr, string name, Expression_2 ^initializer)
  : base(attributes, type_expr, name) {
    initializer_ = initializer;
  }

  // Create a field for an internal class.  Such fields will never be type checked.
  public Field_2(GType_2 type, string name) : this(Attribute_2.Public | Attribute_2.ReadOnly, null, name, null) {
    type_ = type;
  }

  public static Field_2 ^New_2(int attributes, TypeExpr_2 ^type_expr, string name, Expression_2 ^initializer) {
    if ((attributes & Attribute_2.Static) != 0)
      return new StaticField_2(attributes, type_expr, name, initializer);
    if ((attributes & Attribute_2.Const) != 0)
      return new ConstField_2(attributes, type_expr, name, initializer);
    return new Field_2(attributes, type_expr, name, initializer);
  }

  public override int Kind() { return MemberKind_2.Field_2; }

  public Expression_2 Initializer() { return initializer_; }

  protected virtual bool CheckInitializer(Context_2 ctx) {
    if (initializer_ == null)
      return true;

    ctx.EnterExpression();
    initializer_type_ = initializer_.Check(ctx);
    bool b = initializer_type_ != null &&
             Assign_2.CheckAssign(this, type_, initializer_, initializer_type_);
    ctx.FinishExpression();
    return b;
  }

  protected override int ValidAttributes() {
    return Attribute_2.Const | Attribute_2.Private | Attribute_2.Protected | Attribute_2.Public |
           Attribute_2.ReadOnly | Attribute_2.Static;
  }

  public override bool Check(Context_2 ctx) {
    if (!base.Check(ctx))
      return false;

    // We build up a small control graph even when checking field initializers; we do this
    // since expression-checking code uses the graph to determine when temporary
    // ref counts are needed.
    prev_ = unreachable_;
    ctx.SetPrev(this);

    bool b = CheckInitializer(ctx);

    ctx.ClearPrev();
    return b;
  }

  public override bool CheckAssigning(Syntax_2 caller, Context_2 ctx, bool assigning) {
    if (assigning) {
      if (HasAttribute(Attribute_2.Const)) {
        caller.Error("can't assign to const field");
        return false;
      }
      if (HasAttribute(Attribute_2.ReadOnly) &&
          (ctx.class_ != class_ || !(ctx.method_ is Constructor_2)) ) {
        caller.Error("readonly field {0} can only be assigned in constructor", name_);
        return false;
      }
    }
    return true;
  }

  public override RValue_2 ^Get(GValue_2 obj) { return obj.Get(this); }
  public override RValue_2 ^Take_2(GValue_2 obj) { return obj.Take_2(this); }
  public override void Set(GObject_2 obj, RValue_2 ^val) { obj.Set(this, val); }
  public override Location_2 GetLocation(GObject_2 obj) { return obj.GetLocation(this); }

  protected void WriteField(SourceWriter_2 w, bool declaration) {
    w.Indent();
    if (declaration && IsConstOrStatic())
      w.Write("static ");
    w.Write("{0} ", type_.EmitType());
    if (this is ConstField_2)
      w.Write("const ");
    if (!declaration)
      w.Write("{0}::", class_.name_);
    w.Write(name_);
  }

  protected void WriteDeclaration(SourceWriter_2 w) { WriteField(w, true); }
  protected void WriteDefinition(SourceWriter_2 w) { WriteField(w, false); }

  public virtual void EmitDeclaration(SourceWriter_2 w) {
    WriteDeclaration(w);
    w.WriteLine(";");
  }

  public void EmitInitializer(SourceWriter_2 w) {
    w.IWrite("{0} = ", name_);
    if (initializer_ != null)
      w.Write(initializer_.Emit(initializer_type_, type_));
    else w.Write(type_.DefaultValue_2().Emit());
    w.WriteLine(";");
  }

  public virtual void Emit(SourceWriter_2 w) { }

  public override string Emit() { return name_; }

  public override string EmitSet(string val) {
    return String.Format("{0} = {1}", name_, val);
  }
}

class StaticField_2 : Field_2 {
  protected Location_2 ^loc_;

  public StaticField_2(int attributes, TypeExpr_2 ^type_expr, string name, Expression_2 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_2 ctx) {
    if (!base.Check(ctx))
      return false;
    loc_ = new Location_2(Type().DefaultValue_2().Copy());
    return true;
  }

  protected override bool CheckInitializer(Context_2 ctx) {
    ArrayInitializer_2 ai = initializer_ as ArrayInitializer_2;
    if (ai != null) {
      GType_2 type = type_;
      Owning_2 o = type as Owning_2;
      type = (o != null) ? o.BaseType() : null;
      ArrayType_2 at = type as ArrayType_2;
      if (at == null) {
        Error("only owning arrays may have initializers");
        return false;
      }
      return ai.CheckElements(ctx, at.ElementType());
    }

    return base.CheckInitializer(ctx);
  }

  public virtual void Init() {
    ArrayInitializer_2 ai = initializer_ as ArrayInitializer_2;
    if (ai != null)
      loc_.value_ = ai.Eval((ArrayType_2) type_.BaseType());
    else if (initializer_ != null)
      loc_.value_ = initializer_.Eval(Env_2.static_, type_);
  }

  public override RValue_2 ^Get(GValue_2 obj) { return loc_.Get().CopyRef(); }
  public override RValue_2 ^Take_2(GValue_2 obj) { return take loc_.value_; }
  public override void Set(GObject_2 obj, RValue_2 ^val) { loc_.value_ = val; }
  public override Location_2 GetLocation(GObject_2 obj) { return loc_; }

  public override void Emit(SourceWriter_2 w) {
    ArrayInitializer_2 ai = initializer_ as ArrayInitializer_2;
    if (ai != null) {
      GType_2 element_type = ((ArrayType_2) type_.BaseType()).ElementType();
      string varname = String.Format("_{0}_{1}", class_.name_, name_);
      w.Write("{0} {1}[] = ", element_type.EmitGenericType(), varname);
      ai.Emit(w);
      w.WriteLine(";");
      WriteDefinition(w);
      w.Write("(new {0}", GType_2.ConstructType("_StaticArray", element_type.EmitGenericType()));
      w.Write("(&typeid({0}), {1}, {2}))", element_type.EmitType(), ai.initializers_.Count, varname);
    } else {
      WriteDefinition(w);
      if (initializer_ != null)
        initializer_.EmitAsInitializer(w, initializer_type_, type_);
    }
    w.WriteLine(";");
    w.WriteLine("");
  }
}

class ConstField_2 : Field_2 {
  protected SimpleValue_2 ^value_;

  public ConstField_2(int attributes, TypeExpr_2 ^type_expr, string name, Expression_2 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_2 ctx) {
    if (!base.Check(ctx))
      return false;
    return initializer_.CheckConstant();
  }

  SimpleValue_2 ^Get() {
    if (value_ == DefaultValue_2.instance_) {
      Error("circular dependency among constant fields");
      Gel_2.Exit();
    }
    if (value_ == null) {
      value_ = new DefaultValue_2();    // marker used to catch circular const references
      value_ = (SimpleValue_2)initializer_.Eval(Env_2.static_, type_);
    }
    return value_.Copy();
  }

  public override RValue_2 ^Get(GValue_2 obj) {
    return Get();
  }

  public override void Set(GObject_2 obj, RValue_2 ^val) { Debug.Assert(false); }
  public override Location_2 GetLocation(GObject_2 obj) { Debug.Assert(false); return null; }

  public override void EmitDeclaration(SourceWriter_2 w) {
    WriteDeclaration(w);
    if (type_ is IntegralType_2)
      w.Write(" = {0}", Get().Emit());
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_2 w) {
    WriteDefinition(w);
    if (!(type_ is IntegralType_2)) {
      w.WriteLine(" = {0};", Get().Emit());
    }
    w.WriteLine(";");
  }
}

class ExpressionTraverser_2 : Traverser_2 {
  readonly Control_2 start_;
  Local_2 local_;
  GType_2 type_;
  bool assign_;
  bool destroy_;

  public ExpressionTraverser_2(Control_2 start, Local_2 local, GType_2 type) {
    start_ = start; local_ = local; type_ = type;
  }

  public override int Handle(Control_2 control) {
    if (control == start_)
      return Cut;
    Node_2 node = control as Node_2;
    if (node != null) {
      if (!destroy_ && node.CanDestroy(type_))
        destroy_ = true;
      else if (local_ != null && node.Sets(local_))
        assign_ = true;
    }
    return Continue_2;
  }

  // Return_2 true if the given expression needs a reference count while we evaluate
  // the control graph nodes between [start] and [end].
  // A local variable needs a ref count if it is assigned to and the object
  // the variable previously pointed to might possibly be destroyed.
  // Any other expression needs a ref count if the object it evaluates to
  // might possibly be destroyed.
  public static bool NeedRef(Control_2 start, Control_2 end, Expression_2 expr, GType_2 type) {
    Debug.Assert(start != null && end != null);
    if (start == end || !type.IsOwned() || expr is This_2 || expr is Base_2)
      return false;
    Local_2 local = expr.GetLocal();
    ExpressionTraverser_2 ^et = new ExpressionTraverser_2(start, local, type);
    end.Traverse(et, Control_2.GetMarkerValue());
    return et.destroy_ && (local == null || et.assign_);
  }
}

abstract class LocalHandler_2 {
  public abstract bool Handle(Local_2 local, Node_2 node, Name_2 use);
}

class LocalChecker_2 : LocalHandler_2 {
  public override bool Handle(Local_2 local, Node_2 node, Name_2 use) {
    if (node == Control_2.unreachable_) {
      if (use != null)
        use.Error("variable {0} may be used before it is assigned a value", use.name_);
      else
        local.Error("out parameter {0} must be assigned before leaving method", local.name_);
      return false;
    }
    if (node.Takes(local)) {
      Name_2 name = (Name_2) node;
      name.Error("can't transfer ownership from {0}: value may be used again", name.name_);
      return false;
    }
    return true;
  }
}

class LocalRefAnalyzer_2 : LocalHandler_2 {
  public override bool Handle(Local_2 local, Node_2 node, Name_2 use) {
    Debug.Assert(node != Control_2.unreachable_);
    if (node.CanDestroy(local.Type())) {
      local.NeedsRef();
      return false;   // abort search
    }
    return true;
  }
}

class LocalTraverser_2 : Traverser_2 {
  readonly Local_2 local_;
  readonly LocalHandler_2 handler_;
  Name_2 use_;

  public LocalTraverser_2(Local_2 local, LocalHandler_2 handler) {
    local_ = local;
    handler_ = handler;
  }

  public void SetUse(Name_2 use) { use_ = use; }

  public override int Handle(Control_2 control) {
    Node_2 node = control as Node_2;
    if (node == null)
      return Continue_2;

    if (node.Sets(local_))
      return Cut;

    return handler_.Handle(local_, node, use_) ? Continue_2 : Abort;
  }
}

class Local_2 : Named_2 {
  protected Expression_2 ^initializer_;    // or null if none
  protected GType_2 initializer_type_;

  public Local_2 next_;    // next variable upward in scope chain

  NonOwningArrayList /* of Name_2 */ ^uses_ = new NonOwningArrayList();    // all uses of this variable

  protected bool mutable_;   // true if this local may ever change after it's first initialized

  protected bool needs_ref_;    // true if this variable needs a reference count in emitted code

  public Expression_2 Initializer() { return initializer_; }

  public void NeedsRef() { needs_ref_ = true; }

  public virtual string Emit() { return name_; }

  // Return_2 true if we represent this local using a smart pointer wrapper (i.e.
  // _Ptr, _Own, _OwnRef or _Ref).
  public virtual bool IsWrapper() {
    return type_ is Owning_2 || type_ == GString_2.type_ || needs_ref_;
  }

  public Local_2(TypeExpr_2 ^type_expr, string name, Expression_2 ^initializer) : base(type_expr, name) {
    initializer_ = initializer;
    next_ = null;
  }

  public bool Check(Context_2 ctx) {
    Local_2 decl = ctx.FindVar(name_);
    if (decl != null) {
      Error("error: variable already defined");
      return false;
    }

    if (initializer_ != null) {
      ctx.EnterExpression();
      initializer_type_ = initializer_.Check(ctx);
      bool ok = initializer_type_ != null &&
                Assign_2.CheckAssign(this, type_, initializer_, initializer_type_);

      // Add this Local_2 to the control graph.  We need to do this before calling
      // FinishExpression since the Local_2 will be initialized before temporaries 
      // are destroyed.
      AddControl(ctx);

      ctx.FinishExpression();
      if (!ok)
        return false;
    }

    next_ = ctx.var_;
    ctx.SetVar(this);

    ctx.method_.AddVar(this);
    return true;
  }

  public override bool Sets(Local_2 local) {
    return this == local && initializer_ != null;
  }

  public virtual GType_2 ReadType() {
    return type_;
  }

  public void AddUse(Name_2 name) {
    uses_.Add(name);
  }

  public void SetMutable() { mutable_ = true; }

  // Traverse the control graph nodes where this local is live, calling the given
  // LocalHandler_2's Handle method on each node.
  public bool Traverse(Method_2 method, LocalHandler_2 h) {
    LocalTraverser_2 ^t = new LocalTraverser_2(this, h);
    int marker = Control_2.GetMarkerValue();
    foreach (Name_2 name in uses_) {
      t.SetUse(name);
      if (!name.prev_.Traverse(t, marker))
        return false;
    }

    Parameter_2 p = this as Parameter_2;
    if (p != null && p.GetMode() == Mode_2.Out) {
      t.SetUse(null);
      if (!method.exit_.Traverse(t, marker))
        return false;
    }
    return true;
  }

  // check variable usage once control flow graph is complete
  public bool CheckUsage(Method_2 method) {
    return Traverse(method, new LocalChecker_2());
  }

  // Determine whether this Local_2 needs a reference count.  This_2 can happen only after
  // we've built up a control graph for all methods.
  public void ComputeRef(Method_2 method) {
    // For_2 now, a variable of type object always needs a reference count since it may
    // contain a string and we don't yet detect string destruction in the graph traversal.
    if (type_ == GObject_2.type_)
      NeedsRef();
    else if (type_.IsOwned())
      Traverse(method, new LocalRefAnalyzer_2());
  }

  public void EvalInit(Env_2 env) {
    env.Add(this, initializer_ != null ? initializer_.Eval(env, type_) : null);
  }

  protected virtual string EmitDeclarationType() {
    return IsWrapper() ? type_.EmitType() : type_.EmitExprType();
  }

  public virtual string EmitDeclarationName() { return name_; }

  public void EmitDeclaration(SourceWriter_2 w) {
    w.Write("{0} {1}", EmitDeclarationType(), EmitDeclarationName());
  }

  public void EmitInitializer(SourceWriter_2 w) {
    if (initializer_ != null)
      initializer_.EmitAsInitializer(w, initializer_type_, type_);
  }
}

class Parameter_2 : Local_2 {
  public Parameter_2(TypeExpr_2 ^type_expr, string name) : base(type_expr, name, null) { }

  // We represent some parameters using both a C++ parameter and a C++ local, which
  // have different types; we call these dual parameters.  For_2 such parameters
  // param_name_ is the C++ parameter name.
  string param_name_;

  public static Parameter_2 ^New_2(int mode, TypeExpr_2 ^type_expr, string name) {
    return mode == 0 ? new Parameter_2(type_expr, name) :
                               new RefOutParameter_2(mode, type_expr, name);
  }

  public virtual int GetMode() { return 0; }
  public string TypeString() { return Mode_2.ToString(GetMode()) + type_.ToString(); }

  public virtual Parameter_2 ^Copy() {
    return new Parameter_2(new TypeLiteral_2(type_), name_);
  }

  public virtual bool CanReceive(Argument_2 a) {
    return a.GetMode() == 0 && a.Type().CanConvert(type_, ConversionContext_2.MethodArg);
  }

  public bool Match(Parameter_2 p) {
    return GetMode() == p.GetMode() && type_.Equals(p.type_);
  }

  public override bool IsWrapper() {
    return type_ is Owning_2 || type_ == GString_2.type_ || mutable_ && needs_ref_;
  }

  public void CheckParameterUsage(Method_2 method) {
    if (type_ is Owning_2 && !(this is RefOutParameter_2)) {
      // We need both a C++ parameter and a C++ local: the parameter type can't be
      // _Own<>, since _Own has no public copy constructor and GCC doesn't allow passing
      // by value when a class's copy constructor is private.
      string n = name_;
      do {
        n = "_" + n;
      } while (method.HasLocal(n));
      param_name_ = n;
    }
  }

  protected override string EmitDeclarationType() {
    // For_2 owning parameters the declaration type is the expression type since we can't
    // pass _Own<> by value.
    return type_ is Owning_2 ? type_.EmitExprType() : base.EmitDeclarationType();
  }

  public override string EmitDeclarationName() {
    return param_name_ != null ? param_name_ : name_;
  }

  public void EmitExtraDeclaration(SourceWriter_2 w) {
    if (param_name_ != null)
      w.IWriteLine("{0} {1}({2});", type_.EmitType(), name_, param_name_);
  }
}

class RefOutParameter_2 : Parameter_2 {
  public readonly int mode_;
  public override int GetMode() { return mode_; }

  public RefOutParameter_2(int mode, TypeExpr_2 ^type_expr, string name) : base(type_expr, name) {
    mode_ = mode;
    mutable_ = true;
  }

  public override Parameter_2 ^Copy() { Debug.Assert(false); return null; }

  public override bool CanReceive(Argument_2 a) {
    if (mode_ != a.GetMode())
      return false;
    RefOutArgument_2 ra = (RefOutArgument_2) a;
    return type_.Equals(ra.StorageType());
  }

  public override GType_2 ReadType() {
    // If_2 a ref parameter has an owning type, we require the user to use the take operator to take
    // ownership of the value, since taking ownership has the visible side effect of clearing the
    // value the ref parameter points to.
    return mode_ == Mode_2.Ref ? type_.BaseType() : type_;
  }

  public override string Emit() {
    return "(*" + name_ + ")";
  }

  protected override string EmitDeclarationType() {
    return type_.EmitType() + " *";
  }
}

abstract class InlineStatement_2 : Statement_2 {
  public abstract void EmitInline(SourceWriter_2 w);

  public override void Emit(SourceWriter_2 w) {
    EmitInline(w);
    w.WriteLine(";");
  }
}

class VariableDeclaration_2 : InlineStatement_2 {
  ArrayList /* of Local_2 */ ^locals_ = new ArrayList();

  public VariableDeclaration_2(TypeExpr_2 ^type_expr, string name, Expression_2 ^initializer) {
    locals_.Add(new Local_2(type_expr, name, initializer));
  }

  public void Add(string name, Expression_2 ^initializer) {
    TypeExpr_2 ^t = ((Local_2) locals_[0]).type_expr_.Copy();
    locals_.Add(new Local_2(t, name, initializer));
  }

  public override bool Check(Context_2 ctx) {
    // local variables are not resolved during the Resolve phase, so we must resolve them here
    foreach (Local_2 l in locals_)
      if (!l.Resolve(ctx.program_) || !l.Check(ctx))
        return false;

    return true;
  }

  // Return_2 the type of all variables in this VariableDeclaration_2.
  public GType_2 Type() { return ((Local_2) locals_[0]).Type(); }

  public override RValue_2 ^Eval(Env_2 env) {
    foreach (Local_2 l in locals_)
      l.EvalInit(env);
    return null;
  }

  void Emit(SourceWriter_2 w, bool in_line) {
    if (in_line)
      Debug.Assert(locals_.Count == 1);

    foreach (Local_2 l in locals_) {
      l.EmitDeclaration(w);
      l.EmitInitializer(w);
      if (!in_line)
        w.WriteLine(";");
    }
  }

  public override void EmitInline(SourceWriter_2 w) { Emit(w, true); }
  public override void Emit(SourceWriter_2 w) { Emit(w, false); }
}

class ExpressionStatement_2 : InlineStatement_2 {
  Expression_2 ^exp_;

  public ExpressionStatement_2(Expression_2 ^e) {
    exp_ = e;
  }

  public override bool Check(Context_2 ctx) {
    if (exp_.CheckTop(ctx) == null)
      return false;
    exp_.SetUnused();
    return true;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    exp_.Eval(env);   // discard expression value
    return null;
  }

  public override void EmitInline(SourceWriter_2 w) {
    w.Write(exp_.Emit());
  }

}

class If_2 : Statement_2 {
  Expression_2 ^condition_;
  Statement_2 ^if_true_;
  Statement_2 ^if_false_;
  Joiner_2 ^join_ = new Joiner_2();

  public If_2(Expression_2 ^condition, Statement_2 ^if_true, Statement_2 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override bool Check(Context_2 ctx) {
    if (!condition_.Check(ctx, GBool_2.type_))
      return false;

    Control_2 c = ctx.Prev();

    if (!if_true_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    if (if_false_ != null && !if_false_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());
    return true;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    if (condition_.EvalBool(env))
      return if_true_.Eval(env);
    else
      return if_false_ != null ? if_false_.Eval(env) : null;
  }

  public override void Emit(SourceWriter_2 w) {
    w.Write("if ({0})", condition_.Emit());
    if_true_.EmitEmbedded(w);
    if (if_false_ != null) {
      w.IWrite("else");
      if_false_.EmitEmbedded(w);
    }
  }

}

class DefaultValue_2 : SimpleValue_2 {
  public DefaultValue_2() { }
  public static readonly DefaultValue_2 ^instance_ = new DefaultValue_2();

  public override SimpleValue_2 ^Copy() { Debug.Assert(false); return null; }
  public override GType_2 Type()  { Debug.Assert(false); return null; }
  public override string Emit() { Debug.Assert(false); return null; }
}

// A section in a switch statement.
//
// In GEL2, unlike C# and C++, local variables declared in a switch section are visible only
// in that section.  There doesn't seem to be much point in allowing sections to share locals
// since GEL2 (like C#) doesn't allow control to fall through from one section to the next.  This_2 also
// makes compiling to C++ slightly easier since C++ doesn't allow local variables in switch sections
// other than the last to have initializers (see e.g. C++ Primer, 4th ed., 6.6.5 "Variable Definitions
// inside a switch").

class SwitchSection_2 : Node_2 {
  ArrayList /* of Expression_2 */ ^cases_;     // null represents default:
  public readonly Block_2 ^block_;

  ArrayList /* of GValue_2 */ ^values_ = new ArrayList();

  public SwitchSection_2(ArrayList ^cases, StatementList_2 ^statements) {
    cases_ = cases;
    block_ = new Block_2(statements);
  }

  public bool Check(Context_2 ctx, GType_2 switch_type, OwningHashtable all_values, out bool is_default) {
    is_default = false;
    foreach (Expression_2 e in cases_) {
      GValue_2 ^v;
      if (e == null) {
        is_default = true;
        v = new DefaultValue_2();
      } else {
        if (!e.Check(ctx, switch_type) || !e.CheckConstant())
          return false;
        v = (GValue_2) e.Eval(Env_2.static_, switch_type);
      }
      if (all_values.ContainsKey(v)) {
        Error("switch statement cannot contain the same value twice");
        return false;
      }
      all_values.Set(v, null);
      values_.Add(v);
    }
    return block_.Check(ctx);
  }

  public bool Match(GValue_2 v) {
    foreach (GValue_2 val in values_)
      if (val.Equals(v))
        return true;
    return false;
  }

  public void Emit(SourceWriter_2 w) {
    foreach (Expression_2 c in cases_)
      if (c == null)
        w.IWriteLine("default:");
      else w.IWriteLine("case {0}:", c.Emit());
    w.Indent();
    block_.Emit(w);
  }

  public void EmitString(SourceWriter_2 w) {
    w.IWrite("if (");
    for (int i = 0 ; i < values_.Count ; ++i) {
      if (i > 0) {
        w.WriteLine(" ||");
        w.IWrite("    ");
      }
      w.Write("_s->_Equals({0})", 
              GString_2.EmitStringConst(((GString_2) values_[i]).s_));
    }
    w.Write(") ");
    block_.Emit(w);
  }
}

abstract class Escapable_2 : Scoped_2 {
  public readonly Joiner_2 ^exit_ = new Joiner_2();
}

class Switch_2 : Escapable_2 {
  Expression_2 ^expr_;
  GType_2 type_;
  ArrayList /* of SwitchSection_2 */ ^sections_;
  SwitchSection_2 default_;    // or null if no default section

  public Switch_2(Expression_2 ^expr, ArrayList ^sections) { expr_ = expr; sections_ = sections; }

  public override bool Check(Context_2 ctx) {
    SetStartVar(ctx);
    type_ = expr_.CheckTop(ctx);
    if (type_ == null)
      return false;
    if (type_ != GInt_2.type_ && type_ != GChar_2.type_ && type_ != GString_2.type_) {
      Error("switch expression must be of type int, char or string");
      return false;
    }
    Context_2 ^ctx1 = new Context_2(ctx, this);
    OwningHashtable ^values = new OwningHashtable();
    Control_2 c = ctx1.Prev();
    foreach (SwitchSection_2 s in sections_) {
      bool is_default;
      ctx1.SetPrev(c);
      if (!s.Check(ctx1, type_, values, out is_default))
        return false;
      if (is_default)
        default_ = s;
      if (ctx1.Prev() != unreachable_) {
        s.Error("switch case may not fall through to following case");
        return false;
      }
    }
    if (default_ == null)
      exit_.Join(c);
    ctx1.SetPrev(exit_.Combine());
    return true;
  }

  SwitchSection_2 FindSection(GValue_2 v) {
    foreach (SwitchSection_2 s in sections_)
      if (s.Match(v))
        return s;
    return default_;
  }

  RValue_2 ^CatchBreak(RValue_2 ^v) {
    return v is BreakValue_2 ? null : v;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    RValue_2 ^v = expr_.Eval(env);
    if (v == null)
      return null;
    SwitchSection_2 s = FindSection(v.Get());
    if (s == null)
      return null;
    return CatchBreak(s.block_.Eval(env));
  }

  public override void Emit(SourceWriter_2 w) {
    if (type_ == GString_2.type_) {
      // For_2 now, we implement a switch on strings using a sequence of if statements.  We wrap
      // the sequence in a dummy switch statement so that break statements will work properly.
      // If_2 the switch statement has just a default: label then the Microsoft C++ compiler issues
      // a warning, and if it has just a case 0: label then the compiler doesn't realize that the
      // case will always be executed, which may lead to warnings about not all code paths returning
      // a value.  So we use both default: and case 0:, which seems to work fine.
      w.Write("switch (0) ");
      w.OpenBrace();
      w.IWriteLine("case 0:");
      w.IWriteLine("default:");
      w.IWriteLine("StringPtr _s = {0};", expr_.Emit());
      foreach (SwitchSection_2 s in sections_)
        if (s != default_)
          s.EmitString(w);
      if (default_ != null)
        default_.block_.Emit(w);
      w.CloseBrace();
    } else {
      w.Write("switch ({0}) ", expr_.Emit());
      w.OpenBrace();

      foreach (SwitchSection_2 s in sections_)
        s.Emit(w);

      w.CloseBrace();
    }
  }
}

abstract class Loop_2 : Escapable_2 {
  public readonly Joiner_2 ^loop_ = new Joiner_2();
}

abstract class ForOrWhile_2 : Loop_2 {
  protected Expression_2 ^condition_;
  protected Statement_2 ^statement_;

  protected ForOrWhile_2(Expression_2 ^condition, Statement_2 ^statement) {
    condition_ = condition; statement_ = statement;
  }

  protected abstract InlineStatement_2 Initializer();
  protected abstract InlineStatement_2 Iterator();

  public override bool Check(Context_2 prev_ctx) {
    Context_2 ^ctx = new Context_2(prev_ctx, this);   // initializer may declare new local variable
    SetStartVar(ctx);
    if (!Initializer().Check(ctx))
      return false;
    SetTopVar(ctx);

    loop_.AddControl(ctx);

    if (!condition_.CheckTop(ctx, GBool_2.type_))
      return false;

    if (!condition_.IsTrueLiteral())  // we may exit the loop at this point
      exit_.Join(ctx.Prev());  

    if (!statement_.Check(ctx))
      return false;

    if (!Iterator().Check(ctx))
      return false;

    loop_.Join(ctx.Prev());  // loop back to top

    ctx.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy any local defined in an initializer above.
    AddControl(ctx);

    return true;
  }

  public override RValue_2 ^Eval(Env_2 outer_env) {
    Env_2 ^env = new Env_2(outer_env);   // initializer may declare new local
    for (Initializer().Eval(env); condition_.EvalBool(env); Iterator().Eval(env)) {
      RValue_2 ^v = statement_.Eval(env);
      if (v is BreakValue_2)
        break;
      if (v is ContinueValue_2)
        continue;
      if (v != null)
        return v;
    }
    return null;
  }
}

class While_2 : ForOrWhile_2 {
  public While_2(Expression_2 ^condition, Statement_2 ^statement) : base(condition, statement) { }

  protected override InlineStatement_2 Initializer()  { return EmptyStatement_2.instance_; }
  protected override InlineStatement_2 Iterator()  { return EmptyStatement_2.instance_; }

  public override void Emit(SourceWriter_2 w) {
    w.Write("while ({0})", condition_.Emit());
    statement_.EmitEmbedded(w);
  }
}

class For_2 : ForOrWhile_2 {
  InlineStatement_2 ^initializer_;
  InlineStatement_2 ^iterator_;

  public For_2(InlineStatement_2 ^initializer, Expression_2 ^condition, InlineStatement_2 ^iterator,
             Statement_2 ^statement)
    : base(condition != null ? condition : new Literal_2(new GBool_2(true)),
           statement) {
    initializer_ = initializer != null ? initializer : new EmptyStatement_2();
    iterator_ = iterator != null ? iterator : new EmptyStatement_2();
  }

  protected override InlineStatement_2 Initializer()  { return initializer_; }
  protected override InlineStatement_2 Iterator()  { return iterator_; }

  public override void Emit(SourceWriter_2 w) {
    w.Write("for (");
    initializer_.EmitInline(w);
    w.Write("; {0}; ", condition_.Emit());
    iterator_.EmitInline(w);
    w.Write(")");
    statement_.EmitEmbedded(w);
  }
}

class Do_2 : Loop_2 {
  Statement_2 ^statement_;
  Expression_2 ^condition_;

  Joiner_2 ^join_ = new Joiner_2();

  public Do_2(Statement_2 ^statement, Expression_2 ^condition) {
    statement_ = statement;
    condition_ = condition;
  }

  public override bool Check(Context_2 ctx) {
    join_.AddControl(ctx);

    Context_2 ^ctx1 = new Context_2(ctx, this);
    SetStartVar(ctx);

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx.Prev());  // continue statements jump here
    ctx.SetPrev(loop_.Combine());

    if (!condition_.CheckTop(ctx, GBool_2.type_))
      return false;

    if (!condition_.IsFalseLiteral())
      join_.Join(ctx.Prev());   // loop back to top
    if (!condition_.IsTrueLiteral())
      exit_.Join(ctx.Prev());   // fall through to exit
    ctx.SetPrev(exit_.Combine());

    return true;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    do {
      RValue_2 ^v = statement_.Eval(env);
      if (v is BreakValue_2)
        break;
      if (v is ContinueValue_2)
        continue;
      if (v != null)
        return v;
    } while (condition_.EvalBool(env));
    return null;
  }

  public override void Emit(SourceWriter_2 w) {
    w.IWrite("do");
    statement_.EmitEmbedded(w);
    w.IWriteLine("while ({0});", condition_.Emit());
  }
}

// A helper class for ForEach_2: a node defining a single variable in the control graph.
class Definer_2 : Node_2 {
  Local_2 local_;

  public Definer_2(Local_2 local) { local_ = local; }

  public override bool Sets(Local_2 local) {
    return local_ == local;
  }
}

class ForEach_2 : Loop_2 {
  Local_2 ^local_;
  Expression_2 ^expr_;
  GType_2 expr_type_;
  Statement_2 ^statement_;

  Property_2 count_;
  Indexer_2 indexer_;

  Definer_2 ^definer_;

  public ForEach_2(TypeExpr_2 ^type_expr, string name, Expression_2 ^expr, Statement_2 ^statement) {
    local_ = new Local_2(type_expr, name, null);
    expr_ = expr;
    statement_ = statement;
  }

  public override bool Check(Context_2 ctx) {
    if (!local_.Resolve(ctx.program_))
      return false;

    expr_type_ = expr_.CheckTop(ctx);
    if (expr_type_ == null)
      return false;

    count_ = expr_type_.Lookup(this, ctx.class_, false, MemberKind_2.Property_2, "Count", null, false) as Property_2;
    if (count_ == null) {
      Error("object enumerable by foreach must have an accessible property Count");
      return false;
    }
    if (count_.Type() != GInt_2.type_) {
      Error("object enumerable by foreach must have a property Count of type int");
      return false;
    }

    ArrayList ^args = new ArrayList();
    args.Add(new InArgument_2(GInt_2.type_));
    indexer_ = (Indexer_2) expr_type_.Lookup(this, ctx.class_, false, MemberKind_2.Indexer_2, null, args, false);
    if (indexer_ == null) {
      Error("object enumerable by foreach must have an accessible indexer on integers");
      return false;
    }
    if (!indexer_.CheckAssigning(this, ctx, false))
      return false;

    GType_2 indexer_type = indexer_.Type();
    GType_2 iterator_type = local_.Type();
    if (!indexer_type.CanConvertExplicit(iterator_type, false)) {
      Error("enumeration type {0} is not explicitly convertible to iteration variable type {1}",
        indexer_type, iterator_type);
      return false;
    }

    Context_2 ^ctx1 = new Context_2(ctx, this);

    SetStartVar(ctx1);
    if (!local_.Check(ctx1))   // will add local to scope chain
      return false;
    SetTopVar(ctx1);

    // Add a control graph node representing the creation of the local above.
    definer_ = new Definer_2(local_);
    definer_.AddControl(ctx1);

    loop_.AddControl(ctx1);   // continue statements jump here

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx1.Prev());   // loop back to top

    exit_.Join(loop_);  // any loop iteration may exit

    ctx1.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy the local variable created above.
    AddControl(ctx1);

    return true;
  }

  public override RValue_2 ^Eval(Env_2 outer_env) {
    RValue_2 ^r = expr_.Eval(outer_env);
    GValue_2 e = r.Get();
    if (e is Null_2) {
      Error("foreach: can't iterate over null object");
      Gel_2.Exit();
    }

    int count = ((GInt_2) count_.Get(e)).i_;

    Env_2 ^env = new Env_2(outer_env);
    env.Add(local_, null);
    for (int i = 0 ; i < count ; ++i) {
      RValue_2 ^v = indexer_.Get(e, new GInt_2(i));
      env.Set(local_, v.Get().ConvertExplicit(ref v, local_.Type()));
      RValue_2 ^s = statement_.Eval(env);
      if (s is BreakValue_2)
        break;
      if (s is ContinueValue_2)
        continue;
      if (s != null)
        return s;
    }
    return null;
  }

  public override void Emit(SourceWriter_2 w) {
    w.OpenBrace();
    w.IWriteLine("{0} _collection = {1};", expr_type_.BaseType().EmitType(), expr_.Emit());
    w.IWriteLine("int _count = _collection->get_Count();");
    w.IWrite("for (int _i = 0 ; _i < _count ; ++_i) ");
    w.OpenBrace();
    w.Indent();
    local_.EmitDeclaration(w);
    w.WriteLine(" = {0}; ",
      Expression_2.EmitExplicit(indexer_.Type(), local_.Type(), "_collection->get_Item(_i)", true));
    statement_.EmitInExistingBlock(w);
    w.CloseBrace();
    w.CloseBrace();
  }
}

class BreakValue_2 : GValue_2 {
  public BreakValue_2() { }

  public static readonly BreakValue_2 ^instance_ = new BreakValue_2();

  public override GType_2 Type()  { Debug.Assert(false); return null; }
}

abstract class BreakOrContinue_2 : Scoped_2 {
  protected void Link(Context_2 ctx, Scoped_2 target, Joiner_2 joiner) {
    // When traversed in the control graph, we destroy all variables in the scopes we are exiting,
    // excluding variables defined in the containing Escapable_2 or Loop_2.
    start_ = target.GetTop();
    SetTopVar(ctx);

    prev_ = ctx.Prev();
    if (prev_ != unreachable_)
      joiner.Join(this);

    ctx.SetPrev(unreachable_);
  }
}

class Break_2 : BreakOrContinue_2 {
  public override bool Check(Context_2 ctx) {
    Escapable_2 e = ctx.escape_;
    if (e == null) {
      Error("break statement must appear inside a while, do, for, foreach or switch statement");
      return false;
    }
    Link(ctx, e, e.exit_);
    return true;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    return new BreakValue_2();
  }

  public override void Emit(SourceWriter_2 w) {
    w.WriteLine("break;");
  }
}

class ContinueValue_2 : GValue_2 {
  public ContinueValue_2() { }

  public static readonly ContinueValue_2 ^instance_ = new ContinueValue_2();

  public override GType_2 Type()  { Debug.Assert(false); return null; }
}

class Continue_2 : BreakOrContinue_2 {
  public override bool Check(Context_2 ctx) {
    Loop_2 l = ctx.loop_;
    if (l == null) {
      Error("continue statement must appear inside a while, do, for or foreach statement");
      return false;
    }
    Link(ctx, l, l.loop_);
    return true;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    return new ContinueValue_2();
  }

  public override void Emit(SourceWriter_2 w) {
    w.WriteLine("continue;");
  }
}

class Return_2 : Statement_2 {
  Expression_2 ^exp_;    // null if no return value
  GType_2 exp_type_;
  GType_2 type_;

  public Return_2(Expression_2 ^exp) {
    exp_ = exp;
  }

  public override bool Check(Context_2 ctx) {
    if (exp_ == null) {
      if (ctx.method_.ReturnType() != Void_2.type_) {
        Error("error: returning value from function returning void");
        return false;
      }
    } else {
      type_ = ctx.method_.ReturnType();
      ctx.EnterExpression();
      exp_type_ = exp_.CheckAndHold(ctx);
      if (exp_type_ == null ||
          !exp_type_.CheckConvert(this, type_,
            exp_.IsRefOutParameter() ? ConversionContext_2.AssignVar : ConversionContext_2.Other))
        return false;
      exp_.CheckLoseOwnership(exp_type_, type_);
      ctx.FinishExpression();
      exp_.ReleaseRef(ctx);
    }

    ctx.method_.JoinReturn(ctx);
    ctx.SetPrev(unreachable_);
    return true;
  }

  public override RValue_2 ^Eval(Env_2 env) {
    return exp_ != null ? exp_.Eval(env, type_)
                        : Null_2.Instance.Copy();    // an arbitrary value
  }

  public override void Emit(SourceWriter_2 w) {
    if (exp_ != null && exp_.NeedsRef(exp_type_)) {
      // If_2 exp_ needs a reference count, that reference count needs to survive the destruction
      // of temporaries, so we can't simply emit a temporary reference count wrapper.  For_2 example,
      // when compiling the expression "return (new Foo()).Fun();", if Fun() returns a Foo then we
      // need a wrapper, and we can't generate "return _Ptr<Fun>(Foo().Fun()).Get()" since the _Ptr<Fun>
      // wrapper will be destroyed before the temporary Foo() object is destroyed.  So we need to
      // use an extra variable here.
      w.OpenBrace();
      w.IWriteLine("{0} __ret = {1};", exp_type_.EmitType(), exp_.Emit());
      w.IWriteLine("return __ret.Get();");
      w.CloseBrace();
    } else {
      w.Write("return ");
      if (exp_ != null)
        w.Write(exp_.Emit(exp_type_, type_));
      w.WriteLine(";");
    }
  }
}

class Attribute_2 {
  public const int Abstract = 1,
  Const = 2,
  Extern = 4,
  Override = 8,
  Private = 16,
  Protected = 32,
  Public = 64,
  ReadOnly = 128,
  Ref = 256,
  Static = 512,
  Virtual = 1024,
  Setter = 2048;
}

class AttributeUtil_2 {
  public static bool CheckOnly(int a, int allowed) {
    return (a & ~allowed) == 0;
  }
}

class MethodTraverser_2 : Traverser_2 {
  Method_2 method_;

  public MethodTraverser_2(Method_2 method) { method_ = method; }

  public override int Handle(Control_2 control) {
    if (control == Control_2.unreachable_)
      return Cut;

    Node_2 node = control as Node_2;
    if (node != null) {
      Method_2 c = node.Calls();
      if (c != null)
        method_.calls_.Add(c);
      method_.internal_destroys_.Add(node.NodeDestroys());
    }

    return Continue_2;
  }
}

class Method_2 : Member_2 {
  public readonly ArrayList /* of Parameter_2 */ ^parameters_;

  protected Block_2 ^body_;

  public Joiner_2 ^exit_ = new Joiner_2();

  // all parameters and locals defined in this method
  readonly NonOwningArrayList /* of Local_2 */ ^locals_ = new NonOwningArrayList();

  NonOwningArrayList /* of Method_2 */ ^overrides_;   // list of all overrides (virtual methods only)

  // methods called from this method
  public readonly NonOwningArrayList /* of Method_2 */ ^calls_ = new NonOwningArrayList();

  // Types destroyed inside this method, not including types destroyed through
  // calls to other methods.
  public readonly TypeSet_2 ^internal_destroys_ = new TypeSet_2();

  // Types destroyed inside this method or in any methods called by this method.
  TypeSet_2 ^destroys_;

  TypeSet_2 ^parameter_destroys_;

  // A marker used when performing a depth-first search of the method graph to compute destroys_.
  int method_marker_;

  public Method_2(int attributes, TypeExpr_2 ^return_type_expr,
                string name, ArrayList /* of Parameter_2 */ ^parameters, Block_2 ^body)
    : base(attributes, return_type_expr, name) {
    parameters_ = parameters;
    body_ = body;
  }

  public override int Kind() { return MemberKind_2.Method_2; }

  public GType_2 ReturnType() { return type_; }

  public override ArrayList Parameters() {
    return parameters_;
  }

  public bool IsExtern() { return class_.IsExtern(); }

  public bool IsStatic() {
    return HasAttribute(Attribute_2.Static);
  }

  public override bool Resolve(Program_2 program) {
    if (!base.Resolve(program))
      return false;
    foreach (Parameter_2 p in parameters_)
      if (!p.Resolve(program))
        return false;
    return true;
  }

  public void AddVar(Local_2 v) {
    locals_.Add(v);
  }

  public override bool Sets(Local_2 local) {
    foreach (Parameter_2 p in parameters_)
      if (p == local && p.GetMode() != Mode_2.Out)
        return true;
    return false;
  }

  public void JoinReturn(Context_2 ctx) {
    exit_.Join(ctx.Prev());
  }

  public const int kValidAttributes =
    Attribute_2.Abstract | Attribute_2.Override |
    Attribute_2.Private | Attribute_2.Protected | Attribute_2.Public |
    Attribute_2.Static | Attribute_2.Virtual | Attribute_2.Setter;

  protected override int ValidAttributes() {
    return kValidAttributes;
  }

  // overridden by Constructor_2 subclass
  protected virtual bool CheckEntry(Context_2 ctx) { return true; }

  // overridden by Constructor_2 subclass
  public override bool Check(Context_2 prev_ctx) {
    if (!base.Check(prev_ctx))
      return false;

    bool abstract_or_extern = HasAttribute(Attribute_2.Abstract) || IsExtern();

    if (body_.Absent()) {
      if (!abstract_or_extern) {
        Error("a method without a body must be abstract or extern");
        return false;
      }
      return true;
    } 

    if (abstract_or_extern) {
      Error("an abstract or extern method cannot have a body");
      return false;
    }

    Context_2 ^ctx = new Context_2(prev_ctx, this);

    prev_ = unreachable_;
    ctx.SetPrev(this);    // begin the control graph with this Method_2

    foreach (Parameter_2 p in parameters_)
      if (!p.Check(ctx))
        return false;

    if (!CheckEntry(ctx))
      return false;

    if (!body_.Check(ctx))
      return false;

    if (!(this is Constructor_2) && type_ != Void_2.type_ && ctx.Prev() != unreachable_) {
      Error("method must return a value");
      return false;
    }
    JoinReturn(ctx);

    ctx.ClearPrev();  // control graph is complete

    // Traverse the control graph to build calls_ and internal_destroys_.
    MethodTraverser_2 ^mt = new MethodTraverser_2(this);
    exit_.Traverse(mt, Control_2.GetMarkerValue());

    bool ok = true;
    foreach (Local_2 v in locals_)    // for all locals and parameters
      ok &= v.CheckUsage(this);

    foreach (Parameter_2 p in parameters_)
      p.CheckParameterUsage(this);

    return ok;
  }

  // Determine whether each local variable needs a reference count.
  protected void ComputeRefs() {
    foreach (Local_2 v in locals_)
      v.ComputeRef(this);
  }

  // Return_2 true if this method has a local or parameter with the given name.
  public bool HasLocal(string name) {
    foreach (Local_2 l in locals_)
      if (l.name_ == name)
        return true;
    return false;
  }

  public override TypeSet_2 NodeDestroys() {
    if (parameter_destroys_ == null) {
      parameter_destroys_ = new TypeSet_2();
    foreach (Parameter_2 p in parameters_)
        parameter_destroys_.Add(p.Type().VarDestroys());
    }
    return parameter_destroys_;
  }

  protected override void AddOverride(Member_2 m) {
    if (overrides_ == null)
      overrides_ = new NonOwningArrayList();
    overrides_.Add((Method_2) m);
  }

  bool Visit(int marker, TypeSet_2 set) {
    if (method_marker_ == marker)
      return true;

    method_marker_ = marker;
    set.Add(internal_destroys_);
    if (set.IsObject())
      return false;   // we already have object; no point in traversing further

    foreach (Method_2 m in calls_)
      if (!m.Visit(marker, set))
        return false;

    if (overrides_ != null)
      foreach (Method_2 m in overrides_)
        if (!m.Visit(marker, set))
          return false;

    return true;
  }

  public TypeSet_2 Destroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_2();
      Visit(Control_2.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  // overridden by Constructor_2 subclass
  public virtual RValue_2 ^Eval(Env_2 env) {
    return body_.Eval(env);
  }

  public RValue_2 ^Invoke(GValue_2 obj, ArrayList /* of ValueOrLocation_2 */ values) {
    if (body_.Absent()) { // an external method
      ValueList_2 ^list = new ValueList_2(values);
      if (IsStatic())
        return class_.InvokeStatic(this, list);   // let the class handle it
      return obj.Invoke(this, list);   // let the object handle it
    }

    Env_2 ^env = new Env_2(obj);
    Debug.Assert(values.Count == parameters_.Count);
    for (int i = 0 ; i < values.Count ; ++i)
      env.Add((Parameter_2) parameters_[i], (ValueOrLocation_2) values.Take(i));

    return Eval(env);
  }

  protected void EmitParameterNames(SourceWriter_2 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      w.Write(Param(i).EmitDeclarationName());
    }
    w.Write(")");
  }

  protected void EmitParameters(SourceWriter_2 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      Param(i).EmitDeclaration(w);
    }
    w.Write(") ");
  }

  void EmitAttributes(SourceWriter_2 w, bool declaration) {
    w.Indent();
    if (!IsStatic() && !IsVirtual())
      return;

    if (!declaration)
      w.Write("/* ");
    if (IsStatic())
      w.Write("static ");
    if (IsVirtual())
      w.Write("virtual ");
    if (!declaration)
      w.Write("*/ ");
  }

  void EmitSignature(SourceWriter_2 w, bool declaration) {
    EmitAttributes(w, declaration);
    w.Write("{0} ", type_.EmitReturnType());
    if (!declaration)
      w.Write("{0}::", class_.name_);
    if (HasAttribute(Attribute_2.Setter))
      w.Write("_");
    w.Write(name_);
    EmitParameters(w);
  }

  public virtual void EmitDeclaration(SourceWriter_2 w) {
    ComputeRefs();
    EmitSignature(w, true);
    if (body_.Absent())
      w.Write("= 0");
    w.WriteLine(";");

    if (HasAttribute(Attribute_2.Setter)) {
      w.WriteLine("");
      EmitAttributes(w, true);
      w.Write("{0} ", Param(parameters_.Count - 1).Type().EmitType());
      w.Write(name_);
      EmitParameters(w);
      w.OpenBrace();
      w.IWrite("_{0}", name_);
      EmitParameterNames(w);
      w.WriteLine(";");
      w.IWriteLine("return value;");
      w.CloseBrace();
    }
  }

  protected void EmitExtraDeclarations(SourceWriter_2 w) {
    foreach (Parameter_2 p in parameters_)
      p.EmitExtraDeclaration(w);
  }

  public virtual void Emit(SourceWriter_2 w) {
    if (!body_.Absent()) {
      EmitSignature(w, false);
      w.OpenBrace();
      EmitExtraDeclarations(w);
      body_.list_.Emit(w);
      w.CloseBrace();
      w.WriteLine("");
    }
    if (Gel_2.print_type_sets_)
      Console.WriteLine("{0}.{1}: {2}", class_.name_, name_, Destroys());
  }
}

class Constructor_2 : Method_2 {
  bool call_base_;
  ArrayList /* of Argument_2 */ ^initializer_params_;

  Constructor_2 initializer_;

  bool invoked_;  // true if another constructor invokes this one using : base() or : this()

  public Constructor_2(int attributes, string name, ArrayList ^parameters,
                     bool call_base, ArrayList ^initializer_params, Block_2 ^body)
    : base(attributes, null, name, parameters, body) {
    call_base_ = call_base;
    initializer_params_ = initializer_params;
  }

  public Constructor_2(int attributes, string name, ArrayList ^parameters, Block_2 ^body)
    : this(attributes, name, parameters, true, new ArrayList(), body) { }

  public override int Kind() { return MemberKind_2.Constructor_2; }

  protected override int ValidAttributes() {
    return Attribute_2.Private | Attribute_2.Protected | Attribute_2.Public;
  }

  public override bool Check(Context_2 ctx) {
    if (name_ != class_.name_) {
      Error("constructor name must match class name");
      return false;
    }
    return base.Check(ctx);
  }

  protected override bool CheckEntry(Context_2 ctx) {
    Class_2 c = call_base_ ? class_.Parent() : class_;
    if (c != null || initializer_params_.Count > 0) {
      initializer_ = (Constructor_2) Invocation_2.CheckInvoke(this, ctx, call_base_, c,
                                      c.name_, initializer_params_, MemberKind_2.Constructor_2);
      if (initializer_ == null)
        return false;
      if (initializer_ == this) {
        Error("constructor initializer invokes itself");
        return false;
      }
      initializer_.invoked_ = true;
    }
    return true;
  }

  // A Constructor_2 node in the control graph represents the call to the base constructor;
  // this node gets added when we call Invocation_2.CheckInvoke() above.
  public override Method_2 Calls() { return initializer_; }

  public override RValue_2 ^Eval(Env_2 env) {
    if (initializer_ == null || initializer_.class_ != class_) {
      // run instance variable initializers
      foreach (Field_2 f in class_.fields_)
        if (!f.IsConstOrStatic() && f.Initializer() != null)
          ((GObject_2) env.this_).Set(f, f.Initializer().Eval(Env_2.static_, f.Type()));
    }
    if (initializer_ != null)
      Invocation_2.CallMethod(env, env.this_, initializer_, initializer_params_, false);
    return body_.Eval(env);
  }

  void EmitInitializerArgs(SourceWriter_2 w) {
    w.WriteLine("({0});", Invocation_2.EmitArguments(initializer_, initializer_params_));
  }

  void EmitConstructorBody(SourceWriter_2 w) {
    w.OpenBrace();
    EmitExtraDeclarations(w);
    if (call_base_) {
      if (class_.constructors_.Count > 1)
        w.IWriteLine("_Init();");
      else class_.EmitInitializers(w);

      Class_2 parent = class_.Parent();
      if (parent != GObject_2.type_) {
        w.IWrite("{0}::_Construct", parent.name_);
        EmitInitializerArgs(w);
      }
    } else {
      w.IWrite("_Construct");
      EmitInitializerArgs(w);
    }

    body_.list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitDeclaration(SourceWriter_2 w) {
    ComputeRefs();

    // If_2 we're invoked by some other constructor then we need to declare a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void _Construct");
      EmitParameters(w);
      w.WriteLine(";");
    }

    // Now declare the actual C++ constructor.
    w.IWrite(name_);
    EmitParameters(w);
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_2 w) {
    // If_2 we're invoked by some other constructor then we need to emit a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void {0}::_Construct", name_);
      EmitParameters(w);
      EmitConstructorBody(w);
      w.WriteLine("");
    }

    // Now emit the actual C++ constructor.
    w.IWrite("{0}::{1}", name_, name_);
    EmitParameters(w);
    Class_2 parent = class_.Parent();
    if (parent != GObject_2.type_)
      w.Write(": {0}((Dummy *) 0) ", parent.name_);

    if (invoked_) {   // call the _Construct method we just generated
      w.Write("{ _Construct");
      EmitParameterNames(w);
      w.WriteLine("; }");
    } else EmitConstructorBody(w);
    w.WriteLine("");
  }
}

abstract class PropertyOrIndexer_2 : LMember_2 {
  // If_2 a get accessor is not declared at all, then get_block_ will be null; if it is
  // declared, but has an empty body ("get;") then get_block_ will be a Block_2 whose list_ is
  // null.  We need to distinguish these cases since for abstract or extern properties the
  // presence of a get accessor with an empty body indicates that a property is readable.
  // (set_block_ works similarly.)
  Block_2 ^get_block_, set_block_;

  protected Method_2 getter_, setter_;

  protected PropertyOrIndexer_2(int attributes, TypeExpr_2 ^type_expr, string name,
                              string id1, Block_2 ^block1, string id2, Block_2 ^block2)
    : base(attributes, type_expr, name) {
    StoreAccessor(id1, block1);
    if (id2 != null)
      StoreAccessor(id2, block2);
    if (id1 == id2)
      Error("can't have two {0} accessors", id1);
  }

  void StoreAccessor(string id, Block_2 ^block) {
    // Note that we don't have scanner tokens GET and SET since these are not keywords in GEL2.
    switch (id) {
      case "get": get_block_ = block; return;
      case "set": set_block_ = block; return;
    }
    Error("expected get or set");
  }

  public Method_2 Getter() { return getter_; }
  public Method_2 Setter() { return setter_; }

  protected abstract string BaseName();

  ArrayList ^CopyParameters() {
    ArrayList ^a = new ArrayList();
    foreach (Parameter_2 p in Parameters())
      a.Add(p.Copy());
    return a;
  }

  public override bool Check(Context_2 ctx) {
    if (!base.Check(ctx))
      return false;

    if (get_block_ != null) {
      Method_2 ^m = new Method_2(attributes_, new TypeLiteral_2(type_), "get_" + BaseName(), CopyParameters(), take get_block_);
      getter_ = m;
      class_.Add(m);
      if (!getter_.Resolve(ctx.program_) || !getter_.Check(ctx))
        return false;
    }

    if (set_block_ != null) {
      ArrayList ^set_params = CopyParameters();
      set_params.Add(new Parameter_2(new TypeLiteral_2(type_), "value"));
      Method_2 ^m = new Method_2(attributes_ | Attribute_2.Setter,
                           new TypeLiteral_2(Void_2.type_), "set_" + BaseName(), set_params, take set_block_);
      setter_ = m;
      class_.Add(m);
      if (!setter_.Resolve(ctx.program_) || !setter_.Check(ctx))
        return false;
    }

    return true;
  }

  public override bool CheckAssigning(Syntax_2 caller, Context_2 ctx, bool assigning) {
    if (assigning && set_block_ == null && setter_ == null) {
      caller.Error("can't assign to read-only {0}", KindString());
      return false;
    }
    if (!assigning && get_block_ == null && getter_ == null) {
      caller.Error("can't read from write-only {0}", KindString());
      return false;
    }
    return true;
  }

  public override Location_2 GetLocation(GObject_2 obj) { Debug.Assert(false); return null; }
}

class Property_2 : PropertyOrIndexer_2 {
  public Property_2(int attributes, TypeExpr_2 ^type_expr, string name,
                  string id1, Block_2 ^block1, string id2, Block_2 ^block2)
    : base(attributes, type_expr, name, id1, block1, id2, block2) { }

  public override int Kind() { return MemberKind_2.Property_2; }

  protected override int ValidAttributes() {
    return Method_2.kValidAttributes;
  }

  protected override string BaseName() { return name_; }

  public override RValue_2 ^Get(GValue_2 obj) {
    return Invocation_2.InvokeMethod(obj, getter_, new ArrayList(), true);
  }

  public override void Set(GObject_2 obj, RValue_2 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(val);
    Invocation_2.InvokeMethod(obj, setter_, a, true);
  }

  public override string Emit() {
    return String.Format("get_{0}()", name_);
  }

  public override string EmitSet(string val) {
    return String.Format("set_{0}({1})", name_, val);
  }
}

class Indexer_2 : PropertyOrIndexer_2 {
  public readonly Parameter_2 parameter_;

  ArrayList /* of Parameter_2 */ ^parameters_;

  public Indexer_2(int attributes, TypeExpr_2 ^type_expr, Parameter_2 ^parameter,
                 string id1, Block_2 ^block1, string id2, Block_2 ^block2)
    : base(attributes, type_expr, null, id1, block1, id2, block2) {
    parameter_ = parameter;

    parameters_ = new ArrayList();
    parameters_.Add(parameter);
  }

  public override int Kind() { return MemberKind_2.Indexer_2; }

  public override bool Resolve(Program_2 program) {
    return base.Resolve(program) && parameter_.Resolve(program);
  }

  protected override int ValidAttributes() {
    return Attribute_2.Abstract | Attribute_2.Override |
    Attribute_2.Private | Attribute_2.Protected | Attribute_2.Public | Attribute_2.Virtual;
  }

  protected override string BaseName() { return "Item"; }

  public override bool Check(Context_2 ctx) {
    if (parameter_ is RefOutParameter_2) {
      Error("indexer parameter may not be ref or out");
      return false;
    }

    return base.Check(ctx);
  }

  public override ArrayList /* of Parameter_2 */ Parameters() {
    return parameters_; 
  }

  public RValue_2 ^Get(GValue_2 obj, RValue_2 ^index) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    return Invocation_2.InvokeMethod(obj, getter_, a, true);
  }

  public void Set(GObject_2 obj, RValue_2 ^index, RValue_2 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    a.Add(val);
    Invocation_2.InvokeMethod(obj, setter_, a, true);
  }
}

class Class_2 : Ownable_2 {
  Syntax_2 ^syntax_ = new Syntax_2();
  Program_2 program_;   // containing program
  int attributes_;
  public readonly string name_;
  string parent_name_;    // or null if not specified

  Class_2 parent_;

  public readonly NonOwningArrayList /* of Field_2 */ ^fields_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Method_2 */ ^methods_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Property_2 */ ^properties_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Indexer_2 */ ^indexers_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Constructor_2 */ ^constructors_ = new NonOwningArrayList();

  public readonly ArrayList /* of Member_2 */ ^members_ = new ArrayList();

  public readonly ArrayList /* of Temporaries_2 */ ^temporaries_ = new ArrayList();

  public readonly NonOwningArrayList /* of Class_2 */ ^subclasses_ = new NonOwningArrayList();
  bool emitted_;

  // If_2 virtual_ is true, then this class needs a vtable; we set this for a class C
  // in any of the following cases:
  // - the program converts some type T to C ^ (for then a C ^ may hold a T, and when
  // the owning pointer is destroyed we need to know which destructor to call)
  // - the program explicitly converts from C to some other type (so we need RTTI for C)
  bool virtual_;
  
  // If_2 object_inherit_ is true, then this class must derive from Object in generated C++
  // code; we set this for a class C in any of the following cases:
  // - a member lookup in C yields a member in Object
  // - the program converts from C to Object or from Object to C
  // - the class is used in a generic context, i.e. in the type C [] or C ^ [].  All such types
  //   use the generic compiled classes Array<Object> / Array<_Own<Object>>, and so in this case we need
  //   to be able to cast between C and Object.
  //
  // If_2 object_inherit_ is true then this class and all its superclasses will have vtables since
  // the C++ Object class has a vtable.
  bool object_inherit_;

  bool need_destroy_;  // true if we need to emit _Destroy methods for this class

  // The set of types which may be destroyed when an instance of this class is destroyed.
  TypeSet_2 ^destroys_;

  // A marker used in performing a depth-first search to construct the destroys_ type set.
  int marker_;

  protected Class_2(string name) { name_ = name; }

  public static Class_2 New_2(int attributes, string name, string parent_name) {
    Class_2 c = Internal_2.Find(name);
    if (c == null) {
      Class_2 ^c1 = new Class_2(name);
      c = c1;
      Gel_2.program_.AddOwn(c1);
    }

    c.attributes_ = attributes;
    c.parent_name_ = parent_name;

    return c;
  }

  public override bool IsOwned() { return true; }

  public Program_2 GetProgram() { return program_; }
  public void SetProgram(Program_2 p) { program_ = p; }

  public bool IsExtern() { return HasAttribute(Attribute_2.Extern); }

  public override Class_2 Parent() { return parent_; }

  public override string ToString() { return name_; }

  public override ArrayList Members() { return members_; }

  public override SimpleValue_2 DefaultValue_2() { return Null_2.Instance; }

  public override void SetVirtual() { virtual_ = true; }
  public override void SetObjectInherit() { object_inherit_ = true;  }
  public void NeedDestroy() { need_destroy_ = true; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public virtual GValue_2 ^New_2() { return new GObject_2(this); }
  public virtual RValue_2 ^InvokeStatic(Method_2 m, ValueList_2 args) { Debug.Assert(false); return null; }

  public void Add(Field_2 ^f) { f.SetClass(this); fields_.Add(f); members_.Add(f);  }

  public virtual void Add(Method_2 ^m) { m.SetClass(this); methods_.Add(m); members_.Add(m);  }

  public void Add(Property_2 ^p) { p.SetClass(this); properties_.Add(p); members_.Add(p);  }

  public void Add(Indexer_2 ^i) { i.SetClass(this); indexers_.Add(i); members_.Add(i); }

  public void AddConstructor(Constructor_2 ^c) { c.SetClass(this); constructors_.Add(c); members_.Add(c);  }

  public NonOwningArrayList /* of Member_2 */ ^FindAbstractMembers() {
    NonOwningArrayList /* of Member_2 */ ^a;
    if (parent_ != null)  {
      a = parent_.FindAbstractMembers();

      // remove members overridden in this class
      int i = 0;
      while (i < a.Count) {
        Member_2 m = (Member_2) a[i];
        Member_2 n = GetMatchingMember(m);
        if (n != null) {
          Debug.Assert(n.HasAttribute(Attribute_2.Abstract | Attribute_2.Override));
          a.RemoveAt(i);
        } else ++i;
      }
    } else a = new NonOwningArrayList();

    // add abstract members from this class
    foreach (Member_2 m in members_) {
      if (m.HasAttribute(Attribute_2.Abstract))
        a.Add(m);
    }

    return a;
  }

  public bool ResolveAll(Program_2 program) {
    if (parent_name_ != null) {
      parent_ = program.FindClass(parent_name_);
      if (parent_ == null) {
        syntax_.Error("can't find parent class {0}", parent_name_);
        return false;
      }
    } else if (this == GObject_2.type_)
      parent_ = null;
    else parent_ = GObject_2.type_;
    if (parent_ != null)
      parent_.subclasses_.Add(this);

    foreach (Member_2 m in members_)
      if (!m.Resolve(program))
        return false;

    if (!IsExtern() && constructors_.Count == 0)
      // add a default constructor
      AddConstructor(new Constructor_2(Attribute_2.Public, name_, new ArrayList(), Block_2.EmptyBlock()));

    return true;
  }

  // In our first checking pass we check all constant fields since we may need to evaluate them
  // in the course of checking other code.
  public bool Check1(Context_2 prev_ctx) {
    if (!AttributeUtil_2.CheckOnly(attributes_,
         Attribute_2.Abstract | Attribute_2.Extern | Attribute_2.Public)) {
      syntax_.Error("illegal class attribute");
      return false;
    }

    if (prev_ctx.program_.FindClass(name_) != this) {
      syntax_.Error("can't have two classes named {0}", name_);
      return false;
    }

    Context_2 ^ctx = new Context_2(prev_ctx, this);
    bool ok = true;
    foreach (Field_2 f in fields_) {
      ConstField_2 cf = f as ConstField_2;
      if (cf != null)
        ok &= cf.Check(ctx);
    }
    return ok;
  }

  public bool Check(Context_2 prev_ctx) {
    Context_2 ^ctx = new Context_2(prev_ctx, this);

    bool ok = true;

    foreach (Member_2 m in members_)
      if (m is Field_2 && !(m is ConstField_2) || m is Method_2)
        ok &= m.Check(ctx);

    // We need to check properties and indexers separately since they add methods to the members_
    // array as they are checked.
    foreach (Property_2 p in properties_)
      ok &= p.Check(ctx);
    foreach (Indexer_2 i in indexers_)
      ok &= i.Check(ctx);

    if (!HasAttribute(Attribute_2.Abstract)) {
      NonOwningArrayList ^a = FindAbstractMembers();
      if (a.Count > 0) {
        foreach (Member_2 m in a)
          syntax_.Error("class does not define inherited abstract {0} {1}", m.KindString(), m.name_);
        ok = false;
      }
    }

    return ok;
  }

  public void GetMainMethod(NonOwningArrayList /* of Method_2 */ result) {
    foreach (Method_2 m in methods_)
      if (m.name_ == "Main" && m.IsPublic() && m.IsStatic() && m.ReturnType() == Void_2.type_) {
        int c = m.parameters_.Count;
        if (c > 1)
          continue;
        if (c == 1) {
          Parameter_2 p = m.Param(0);
          if (p.GetMode() != 0 || !p.Type().Equals(new ArrayType_2(GString_2.type_)) )
            continue;
        }
        result.Add(m);
      }
  }

  public override void FindTypeDestroys(int marker, TypeSet_2 set) {
    if (marker_ == marker)
      return;
    marker_ = marker;
    set.Add(this);
    for (Class_2 c = this; c != null; c = c.parent_) {
      if (c != this && c.marker_ == marker)
        break;
      foreach (Field_2 f in c.fields_)
        if (!f.IsConstOrStatic())
          f.Type().FindVarDestroys(marker, set);
    }
    foreach (Class_2 c in subclasses_)
      c.FindTypeDestroys(marker, set);
  }

  public override TypeSet_2 TypeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_2();
      FindTypeDestroys(Control_2.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  public Temporaries_2 NewTemporaries() {
    Temporaries_2 ^t = new Temporaries_2();
    Temporaries_2 ret = t;
    temporaries_.Add(t);
    return ret;
  }

  public void StaticInit() {
    foreach (Field_2 f in fields_) {
      StaticField_2 sf = f as StaticField_2;
      if (sf != null)
        sf.Init();
    }
  }

  public override string EmitTypeName() { return name_; }

  int EmitAccess(SourceWriter_2 w, int old_access, int new_access) {
    new_access = (new_access & Attribute_2.Public) != 0 ? Attribute_2.Public : Attribute_2.Protected;

    if (new_access != old_access) {
      switch (new_access) {
        case Attribute_2.Protected:
          w.Indent(-1);
          w.WriteLine("protected:");
          break;
        case Attribute_2.Public:
          w.Indent(-1);
          w.WriteLine("public:");
          break;
        default:
          Debug.Assert(false);
          break;
      }
    }

    return new_access;
  }

  public void EmitInitializers(SourceWriter_2 w) {
    foreach (Field_2 f in fields_)
      if (!f.IsConstOrStatic())
        f.EmitInitializer(w);
  }

  // Return_2 true if this top-level class must inherit from Object.
  bool ObjectInherit() {
    if (object_inherit_)
      return true;
    foreach (Class_2 c in subclasses_)
      if (c.ObjectInherit())
        return true;
    return false;
  }

  public void EmitDeclaration(SourceWriter_2 w) {
    if (emitted_ || IsExtern())
      return;

    // C++ requires a parent class to appear before its subclasses in a source file.
    parent_.EmitDeclaration(w);

    emitted_ = true;

    w.Write("class {0} ", name_);
    if (parent_ != null)
      w.Write(": public {0} ",
              parent_ == GObject_2.type_ && !ObjectInherit() ? "_Object" : parent_.name_);
    w.OpenBrace();

    int access = 0;

    if (fields_.Count > 0) {
      foreach (Field_2 f in fields_) {
        access = EmitAccess(w, access, f.attributes_);
        f.EmitDeclaration(w);
      }
      w.WriteLine("");
    }

    if (subclasses_.Count > 0) {
      access = EmitAccess(w, access, Attribute_2.Protected);
      w.IWrite("{0}(Dummy *dummy) ", name_);
      if (parent_ != GObject_2.type_)
        w.Write(": {0}(dummy) ", parent_.name_);
      w.WriteLine("{ }");
      w.WriteLine("");
    }

    // If_2 we have more than one constructor, emit an _Init() method which constructors can
    // call to initialize instance variables.
    if (constructors_.Count > 1) {
      access = EmitAccess(w, access, Attribute_2.Protected);
      w.IWriteLine("void _Init();");
      w.WriteLine("");
    }

    foreach (Constructor_2 c in constructors_) {
      access = EmitAccess(w, access, c.attributes_);
      c.EmitDeclaration(w);
    }

    if (virtual_) {
      access = EmitAccess(w, access, Attribute_2.Public);
      w.IWrite("virtual ~{0}()", name_);
      w.WriteLine(" { }");
      w.WriteLine("");
    }

    if (need_destroy_) {
      access = EmitAccess(w, access, Attribute_2.Public);
      w.IWriteLine("GEL_OBJECT({0})", name_);
      w.WriteLine("");
    }

    foreach (Method_2 m in methods_) {
      access = EmitAccess(w, access, m.attributes_);
      m.EmitDeclaration(w);
    }

    w.SubIndent();
    w.WriteLine("};");
    w.WriteLine("");
  }

  public void Emit(SourceWriter_2 w) {
    if (IsExtern())
      return;

    if (fields_.Count > 0) {
      foreach (Field_2 f in fields_)
        f.Emit(w);
      w.WriteLine("");
    }

    if (constructors_.Count > 1) {
      w.IWrite("void {0}::_Init() ", name_);
      w.OpenBrace();
      EmitInitializers(w);
      w.CloseBrace();
      w.WriteLine("");
    }

    foreach (Constructor_2 c in constructors_)
      c.Emit(w);

    foreach (Method_2 m in methods_)
      m.Emit(w);

    if (Gel_2.print_type_sets_)
      Console.WriteLine("~{0}: {1}", name_, TypeDestroys());
  }
}

class ClassPtr_2 {
  public readonly Class_2 class_;

  public ClassPtr_2(Class_2 c) { class_ = c; }
}

class ValueList_2 {
  public ArrayList list_;
  public ValueList_2(ArrayList list) { list_ = list; }

  public GValue_2 Object(int i) { return ((RValue_2) list_[i]).Get(); }
  public bool Bool(int i) { return ((GBool_2) list_[i]).b_; }
  public int Int(int i) { return ((GInt_2) list_[i]).i_; }
  public char Char(int i) { return ((GChar_2) list_[i]).c_; }
  public string GetString(int i) { return ((GString_2) list_[i]).s_; }
}

class Internal_2 : Class_2 {
  static NonOwningArrayList /* of Internal_2 */ ^all_ = new NonOwningArrayList();

  protected Internal_2(string name) : base(name) { }

  public static Internal_2 Find(string name) {
    foreach (Internal_2 p in all_)
      if (p.name_ == name)
        return p;
    return null;
  }

  static void Add(Internal_2 p) { all_.Add(p); }

  public static void Init() {
    Add(GObject_2.type_);
    Add(GArray_2.array_class_);
    Add(GBool_2.type_);
    Add(GChar_2.type_);
    Add(GDouble_2.type_);
    Add(GFloat_2.type_);
    Add(GInt_2.type_);
    Add(GString_2.type_);
    Add(GStringBuilder_2.type_);
    Add(PoolClass_2.instance_);
    Add(DebugClass_2.instance_);
    Add(EnvironmentClass_2.instance_);

    Add(ConsoleClass_2.instance_);
    Add(FileClass_2.instance_);
    Add(PathClass_2.instance_);
    Add(GStreamReader_2.type_);
  }
}

class ObjectClass_2 : Internal_2 {
  public Method_2 equals_;
  public Method_2 get_hash_code_;
  public Method_2 to_string_;

  public ObjectClass_2() : base("Object") { }

  public override void Add(Method_2 ^m) {
    switch (m.name_) {
      case "Equals": equals_ = m; break;
      case "GetHashCode": get_hash_code_ = m; break;
      case "ToString": to_string_ = m; break;
    }
    base.Add(m);
  }
}

class ArrayClass_2 : Internal_2 {
  public ArrayClass_2() : base("Array") { }
}

abstract class SimpleType_2 : Internal_2 {
  protected SimpleType_2(string name) : base(name) { }

  public override bool IsOwned() { return false; }
  public override bool IsReference() { return false; }
  public override bool IsValue() { return true; }

  public override string EmitExprType() { return EmitType(); }
  public override string EmitType() { Debug.Assert(false); return null; }
}

abstract class IntegralType_2 : SimpleType_2 {
  protected IntegralType_2(string name) : base(name) { }
}

class BoolClass_2 : IntegralType_2 {
  public BoolClass_2() : base("Bool") { }

  static GBool_2 ^default_ = new GBool_2(false);
  public override SimpleValue_2 DefaultValue_2() { return default_; }

  public override string ToString() { return "bool"; }

  public override string EmitType() { return "bool"; }
}

class CharClass_2 : IntegralType_2 {
  public CharClass_2() : base("Char") { }

  static GChar_2 ^default_ = new GChar_2('\0');

  public override SimpleValue_2 DefaultValue_2() { return default_; }

  public override bool CanConvert1(GType_2 t) { return t == GInt_2.type_; }

  public override string ToString() { return "char"; }

  public override RValue_2 ^InvokeStatic(Method_2 m, ValueList_2 args) {
    switch (m.name_) {
      case "IsDigit": return new GBool_2(Char.IsDigit(args.Char(0)));
      case "IsLetter": return new GBool_2(Char.IsLetter(args.Char(0)));
      case "IsWhiteSpace": return new GBool_2(Char.IsWhiteSpace(args.Char(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "wchar_t"; }
}

class IntClass_2 : IntegralType_2 {
  public IntClass_2() : base("Int") { }

  static GInt_2 ^default_ = new GInt_2(0);

  public override SimpleValue_2 DefaultValue_2() { return default_; }

  public override bool CanConvert1(GType_2 t) {
    return t == GFloat_2.type_ || t == GDouble_2.type_;
  }

  protected override bool CanConvertExplicit1(GType_2 t) {
    return t == GChar_2.type_;
  }

  public override string ToString() { return "int"; }

  public override RValue_2 ^InvokeStatic(Method_2 m, ValueList_2 args) {
    switch (m.name_) {
      case "Parse": return new GInt_2(int.Parse(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "int"; }
}

class FloatClass_2 : SimpleType_2 {
  public FloatClass_2() : base("Single") { }

  static GFloat_2 ^default_ = new GFloat_2(0.0f);

  public override SimpleValue_2 DefaultValue_2() { return default_; }

  public override bool CanConvert1(GType_2 t) {
    return t == GDouble_2.type_;
  }

  protected override bool CanConvertExplicit1(GType_2 t) {
    return t == GInt_2.type_;
  }

  public override string ToString() { return "float"; }

  public override string EmitType() { return "float"; }
}

class DoubleClass_2 : SimpleType_2 {
  public DoubleClass_2() : base("Double") { }

  static GDouble_2 ^default_ = new GDouble_2(0.0d);

  public override SimpleValue_2 DefaultValue_2() { return default_; }

  protected override bool CanConvertExplicit1(GType_2 t) {
    return t == GInt_2.type_ || t == GFloat_2.type_;
  }

  public override string ToString() { return "double"; }

  public override string EmitType() { return "double"; }
}

class StringClass_2 : Internal_2 {
  public StringClass_2() : base("String") { }

  public override bool IsOwned() { return false; }
  public override bool IsValue() { return true; }

  public override string ToString() { return "string"; }

  public override string EmitType() {
    return "_Ref<String>";
  }

  public override string EmitReturnType() {
    return EmitType();
  }

  public override string EmitGenericType() {
    return EmitType();
  }

  public override RValue_2 ^InvokeStatic(Method_2 m, ValueList_2 args) {
    switch (m.name_) {
      case "Format": return new GString_2(String.Format(args.GetString(0), args.Object(1)));
      default: Debug.Assert(false); return null;
    }
  }
}

class StringBuilderClass_2 : Internal_2 {
  public StringBuilderClass_2() : base("StringBuilder") { }
  public override GValue_2 ^New_2() { return new GStringBuilder_2(); }
}

class GStringBuilder_2 : GValue_2 {
  readonly StringBuilder ^b_ = new StringBuilder();

  public static readonly StringBuilderClass_2 ^type_ = new StringBuilderClass_2();

  public override GType_2 Type() { return type_; }

  public override RValue_2 ^Invoke(Method_2 m, ValueList_2 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "Append": b_.Append(args.Char(0)); return null;
      case "ToString": return new GString_2(b_.ToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class PoolClass_2 : Internal_2 {
  public PoolClass_2() : base("Pool") { }

  public static PoolClass_2 ^instance_ = new PoolClass_2();
}

class DebugClass_2 : Internal_2 {
  public DebugClass_2() : base("Debug") { }
  public static readonly DebugClass_2 ^instance_ = new DebugClass_2();
  
  public override RValue_2 ^InvokeStatic(Method_2 m, ValueList_2 args) {
    switch (m.name_) {
      case "Assert": Debug.Assert(args.Bool(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

class EnvironmentClass_2 : Internal_2 {
  public EnvironmentClass_2() : base("Environment") { }
  public static readonly EnvironmentClass_2 ^instance_ = new EnvironmentClass_2();

  public override RValue_2 ^InvokeStatic(Method_2 m, ValueList_2 args) {
    switch (m.name_) {
      case "Exit": Environment.Exit(args.Int(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

// built-in I/O classes

class ConsoleClass_2 : Internal_2 {
  public ConsoleClass_2() : base("Console") { }

  public override RValue_2 ^InvokeStatic(Method_2 m, ValueList_2 args) {
    switch (m.name_) {
      case "Write":
        switch (m.parameters_.Count) {
          case 1: Console.Write(args.Object(0)); return null;
          case 2: Console.Write(args.GetString(0), args.Object(1)); return null;
          case 3: Console.Write(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      case "WriteLine":
        switch (m.parameters_.Count) {
          case 1: Console.WriteLine(args.Object(0)); return null;
          case 2: Console.WriteLine(args.GetString(0), args.Object(1)); return null;
          case 3: Console.WriteLine(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly ConsoleClass_2 ^instance_ = new ConsoleClass_2();
}

class FileClass_2 : Internal_2 {
  public FileClass_2() : base("File") { }

  public override RValue_2 ^InvokeStatic(Method_2 m, ValueList_2 args) {
    switch (m.name_) {
      case "Delete": File.Delete(args.GetString(0)); return null;
      case "Exists": return new GBool_2(File.Exists(args.ToString()));
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly FileClass_2 ^instance_ = new FileClass_2();
}

class PathClass_2 : Internal_2 {
  public PathClass_2() : base("Path") { }

  public override RValue_2 ^InvokeStatic(Method_2 m, ValueList_2 args) {
    switch (m.name_) {
      case "GetTempFileName": return new GString_2(Path.GetTempFileName());
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly PathClass_2 ^instance_ = new PathClass_2();
}

class StreamReaderClass_2 : Internal_2 {
  public StreamReaderClass_2() : base("StreamReader") { }
  public override GValue_2 ^New_2() { return new GStreamReader_2(); }
}

class GStreamReader_2 : GValue_2 {
  StreamReader ^reader_;

  public static readonly StreamReaderClass_2 ^type_ = new StreamReaderClass_2();

  public override GType_2 Type() { return type_; }

  public override RValue_2 ^Invoke(Method_2 m, ValueList_2 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StreamReader": reader_ = new StreamReader(args.GetString(0)); return null;
      case "Read": return new GInt_2(reader_.Read());
      case "Peek": return new GInt_2(reader_.Peek());
      default: Debug.Assert(false); return null;
    }
  }
}

class Program_2 {
  ArrayList /* of string */ ^gel_import_ = new ArrayList();
  ArrayList /* of string */ ^cpp_import_ = new ArrayList();

  static Scanner_2 ^scanner_;

  NonOwningArrayList ^classes_ = new NonOwningArrayList();
  ArrayList ^own_classes_ = new ArrayList();

  public bool crt_alloc_;
  public bool debug_;
  public bool safe_ = true;

  public Control_2 prev_;   // previous node in control flow graph, used during graph construction

  public void Import(string s) {
    ArrayList a = null;
    string extension = Path.GetExtension(s);
    switch (extension) {
      case ".gel": a = gel_import_; break;
      case ".cpp": a = cpp_import_; break;
      default:
        new Syntax_2().Error("can't import file with extension {0}", extension);
        Environment.Exit(0);
        break;
    }
    foreach (string i in a)
      if (i == s)
        return;   // already imported
    a.Add(s);
  }

  public void FindAndImport(string s) {
    // First look relative to the importing file.
    string dir = Path.GetDirectoryName(Gel_2.CurrentFile());
    string s1 = Path.Combine(dir, s);
    if (!File.Exists(s1)) {
      // Now look relative to the GEL2 directory.
      s1 = Path.Combine(Gel_2.gel_directory_, s);
      if (!File.Exists(s1)) {
        new Syntax_2().Error("import not found: ", s);
        Environment.Exit(0);
      }
    }
    Import(s1);
  }
  
  public void Add(Class_2 c) {
    c.SetProgram(this);
    classes_.Add(c);
  }

  public void AddOwn(Class_2 ^c) {
    own_classes_.Add(c);
  }

  public Class_2 FindClass(string name) {
    foreach (Class_2 c in classes_)
      if (c.name_ == name)
        return c;
    return null;
  }

  public string CurrentFile() {
    return scanner_.filename_;
  }

  public int Line() {
    return scanner_.Line();
  }

  string Builtin(string module) {
    string file = String.Format("{0}.gel", module);
    return Path.Combine(Gel_2.gel_directory_, file);
  }

  public bool Parse() {
    Parser ^parser = new Parser();
    for (int i = 0; i < gel_import_.Count; ++i) {
      string file = (string) gel_import_[i];
      scanner_ = new Scanner_2(file);
      parser.yyParse(scanner_);
      if (i == 0) {
        Import(Builtin("internal"));
        Import(Builtin("library"));
      }
    }
    return true;
  }

  public bool Resolve() {
    foreach (Class_2 c in classes_)
      if (!c.ResolveAll(this))
        return false;

    return true;
  }

  public bool Check() {
    Context_2 ^ctx = new Context_2(this);
    bool ok = true;

    // Make a first checking pass where we check only constant fields.
    foreach (Class_2 c in classes_)
      ok &= c.Check1(ctx);

    foreach (Class_2 c in classes_)
      ok &= c.Check(ctx);

    return ok;
  }

  Method_2 FindMain() {
    NonOwningArrayList ^methods = new NonOwningArrayList();
    foreach (Class_2 c in classes_) {
      c.GetMainMethod(methods);
    }
    if (methods.Count == 0) {
      Console.WriteLine("no Main() method found");
      return null;
    }
    if (methods.Count > 1) {
      Console.WriteLine("error: found more than one Main() method");
      return null;
    }
    return (Method_2) methods[0];
  }

  public void Eval(ArrayList /* of string */ args) {
    Method_2 m = FindMain();
    if (m == null)
      return;
    ArrayList ^a = new ArrayList();
    if (m.parameters_.Count > 0) {   // Main() takes a string[] argument
      GArray_2 ^arr = new GArray_2(new ArrayType_2(GString_2.type_), args.Count);
      for (int i = 0 ; i < args.Count ; ++i)
        arr.Set(i, new GString_2((string) args[i]));
      a.Add(arr);
    }
    foreach (Class_2 c in classes_)
      c.StaticInit();
    m.Invoke(null, a);
  }

  void EmitMain(SourceWriter_2 w, Method_2 main) {
    bool args = main.parameters_.Count > 0;
    w.Write("int main({0}) ", args ? "int argc, char *argv[]" : "");
    w.OpenBrace();
    w.IWriteLine("return gel_runmain({0}::Main{1});", main.GetClass().name_, args ? ", argc, argv" : "");
    w.CloseBrace();
  }

  public bool Emit(SourceWriter_2 w) {
    Method_2 main = FindMain();
    if (main == null)
      return false;

    w.WriteLine("#define MEMORY_OWN 1");
    if (safe_)
      w.WriteLine("#define MEMORY_SAFE 1");
    if (crt_alloc_)
      w.WriteLine("#define MEMORY_CRT 1");

    foreach (string f in cpp_import_)
      w.WriteLine("#include {0}", GString_2.EmitString(f));

    // We undefine NULL since Gel_2 code may legitimately define fields or variables with that name.
    // Generated code uses 0, not NULL, to indicate the null pointer.
    w.WriteLine("#undef NULL");

    w.WriteLine("");

    // Forward-declare all classes since C++ requires a class to be declared before its name can
    // be used as a type.
    foreach (Class_2 c in classes_)
      if (!(c.HasAttribute(Attribute_2.Extern)))
        w.WriteLine("class {0};", c.name_);
    w.WriteLine("");

    foreach (Class_2 c in classes_)
      c.EmitDeclaration(w);

    foreach (Class_2 c in classes_)
      c.Emit(w);

    EmitMain(w, main);
    return true;
  }

  // Emit C++ code.
  public bool Generate(string basename) {
    string cpp_file = basename + ".cpp";
    StreamWriter ^w = new StreamWriter(cpp_file);
    bool ok = Emit(new SourceWriter_2(w));
    w.Close();
    return ok;
  }

  static string[] ^vsdirs = { "Microsoft Visual Studio 8",
                            "Microsoft Visual Studio .NET 2003",
                            "Microsoft Visual Studio .NET 2002" };

  string VsVars(int i) {
    return String.Format("C:\\Program_2 Files\\{0}\\Common7\\Tools\\vsvars32.bat", vsdirs[i]);
  }

  string FindVsVars() {
    for (int i = 0; i < vsdirs.Length; ++i) {
      string f = VsVars(i);
      if (File.Exists(f))
        return f;
    }

    Console.WriteLine("Error: unable to find vsvars32.bat at any of the following locations:");
    Console.WriteLine("");
    for (int i = 0; i < vsdirs.Length; ++i)
      Console.WriteLine(VsVars(i));
    Console.WriteLine("");
    Console.WriteLine("Your Visual Studio installation may be invalid.  Aborting compilation.");
    return null;
  }

  // Report compilation error. Print error message from a file
  void ReportCompilationError(string error_msg_file) {
      Console.WriteLine(
        "Error: unable to compile generated C++ code.  You may have found a bug in the GEL2 compiler.");
      Console.WriteLine("C++ compiler output follows:");
      Console.WriteLine("");
      Console.WriteLine((new StreamReader(error_msg_file)).ReadToEnd());
  }

  void UnixCppCompile(string basename) {
    string command_out = Path.GetTempFileName();
    string dbg_options = debug_ ? "-g -DDEBUG" : "-O2 -DNDEBUG";
    StringBuilder ^sb = new StringBuilder();
    // -o basename, use basename as the executable name
    // -Werror, make all warnings into hard errors
    sb.AppendFormat("/usr/bin/g++ -o {0} -Werror {1} {2}.cpp",
                    basename, dbg_options, basename);

    // Append redirection of output
    sb.AppendFormat(" > {0} 2>&1", command_out);
 
    string sh_cmd = sb.ToString();

    if (Gel_2.verbose_) 
      Console.WriteLine(sh_cmd);
  
    if (Process.System(sh_cmd) !=0) {
      ReportCompilationError(command_out);
    }
    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".o");
  }

  // Run vsvars32.bat and the run the given command, redirecting output to a file.
  // We must always redirect output since vsvars32 prints a message "Setting environment..."
  // which we don't want users to see.
  int VsRun(string vsvars, string command, string output) {
    command = String.Format("(\"{0}\" & {1}) > \"{2}\"", 
                            vsvars, command, output);
    return Process.System(command);
  }

  void VsCppCompile(string basename) {
    string vsvars = FindVsVars();
    if (vsvars == null)
      return;
    string command_out = Path.GetTempFileName();

    string options = debug_ ?
      //  /MDd - runtime library: multithreaded debug DLL
      //  /Od - optimization: disabled
      //  /ZI - debug information format: Program_2 Database for Edit & Continue_2
      "/MDd /Od /ZI /D \"_DEBUG\"" :

      //  /MD - runtime library: multithreaded DLL
      //  /O2 - optimization: Maximize Speed
      //  /GL - optimization: Whole Program_2 Optimization
      "/MD /O2 /GL /D \"NDEBUG\"";

    StringBuilder ^sb = new StringBuilder();
    //  /WX - treat warnings as errors
    sb.AppendFormat("cl /nologo /WX {0} {1}.cpp", options, basename);
    string mode = debug_ ? "debug" : "release";
    if (!crt_alloc_)
      sb.AppendFormat(" {0}\\{1}\\dlmalloc.obj", Gel_2.gel_directory_, mode);
    sb.Append(" user32.lib shell32.lib shlwapi.lib");
    string command = sb.ToString();
    if (Gel_2.verbose_)
      Console.WriteLine(command);

    if (VsRun(vsvars, command, command_out) != 0) {
      ReportCompilationError(command_out);
    } else {
      // Run the manifest tool to embed the linker-generated manifest into the executable file;
      // this allows the executable to find the C runtime DLL even when the manifest file is absent.
      string mt_command = String.Format("mt -nologo -manifest {0}.exe.manifest -outputresource:\"{0}.exe;#1\"",
                              basename);
      if (Gel_2.verbose_)
        Console.WriteLine(mt_command);
      if (VsRun(vsvars, mt_command, command_out) != 0)
        Console.WriteLine("warning: could not run manifest tool");
    }

    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".obj");
    File.Delete(basename + ".exe.manifest");
  }

  // Invoke the C++ compiler to generate a native executable.
  void CppCompile(string basename) {
    if (Environment.OSVersion.Platform == PlatformID.Win32NT) 
      VsCppCompile(basename);
    else
      UnixCppCompile(basename);
  }

  public void Compile(string output, bool cpp_only) {
    if (output == null)
      output = Path.GetFileNameWithoutExtension((string) gel_import_[0]);
    if (Generate(output) && !cpp_only)
      CppCompile(output);
  }
}

class Scanner_2 : yyInput {
  public readonly string filename_;

  int line_;
  public int Line() { return line_; }

  StreamReader ^sr_;
  int token_;
  object ^ value_;

  int next_token_ = -1;
  object ^ next_value_;

  public Scanner_2 (string filename) {
    filename_ = filename;
    sr_ = new StreamReader(filename);
    line_ = 1;
  }

  public override int GetToken () {
    return token_;
  }

  public override object ^ GetValue () {
    return take value_;
  }

  int Read() {
    int i = sr_.Read();
    if (i == '\n')
      ++line_;
    return i;
  }

  bool Read(out char c) {
    int i = Read();
    c = (char) i;
    return i != -1;
  }

  char Peek() {
    return (char) sr_.Peek();
  }

  string ReadWord(char first) {
    StringBuilder ^sb = new StringBuilder();
    if (first != '\0')
      sb.Append(first);
    while (true) {
      char c = Peek();
      if (!Char.IsLetter(c) && !Char.IsDigit(c) && c != '_')
        break;
      sb.Append(c);
      Read();
    }
    return sb.ToString();
  }

  // Read to the end of the current line.
  string ReadLine() {
    StringBuilder ^sb = new StringBuilder();
    char c;
    while (Read(out c)) {
      if (c == '\n')
        break;
      sb.Append(c);
    }
    return sb.ToString();
  }

  // Read a comment delimited by /* ... */, assuming we've already read the opening /*.
  // Returns true on success, or false on EOF.
  bool ReadDelimitedComment() {
    char prev = (char) 0;
    while (true) {
      char c;
      if (!Read(out c)) {
        Console.WriteLine("warning: unterminated comment at end of file");
        return false;
      }
      if (c == '/' && prev == '*')
        return true;
      prev = c;
    }
  }

  // Preprocess input, handling whitespace, comments and directives; return the first
  // character not eaten by preprocessing, or -1 on EOF.
  int GetChar() {
    while (true) {
      int i = Read();
      if (i == -1)
        return -1;   // end of input
      if (i == 0)
        continue;   // end of this file; move on
      char c = (char) i;

      if (c == '\n' && Peek() == '#') {
        Read();
        string directive = ReadWord('\0');
        if (directive == "line") {
          ReadLine();
          continue;
        }
        Console.WriteLine("error: unknown preprocessing directive {0}", directive);
        Environment.Exit(0);
      }

      if (Char.IsWhiteSpace(c))
        continue;

      if (c == '/') {
        switch (Peek()) {
          case '/':  // single-line comment
            Read();
            int line = line_;
            string s = ReadLine();
            if (Gel_2.error_test_ && s.StartsWith(" error"))
              Gel_2.expected_error_lines_.Add(line);
            continue;

          case '*':  // comment delimited by /* ... */
            Read();   // move past opening '*'
            if (!ReadDelimitedComment())
              return (char) 0;
            continue;
        }
      }

      return c;
    }
  }

  bool IsDigit(char c, bool hex) {
    if (Char.IsDigit(c))
      return true;
    if (!hex)
      return false;
    return (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');
  }

  // Read a number, possibly including a decimal point and/or exponent.
  string ReadNumber(char first, bool hex, out bool real) {
    bool dot = false, exp = false;
    StringBuilder ^sb = new StringBuilder();
    sb.Append(first);
    if (first == '.')
      dot = true;

    while (true) {
      bool need_digit = false;
      char c = Peek();
      if (c == '.' && !hex && !dot && !exp) {
        sb.Append(c);
        Read();
        dot = true;
        c = Peek();
        need_digit = true;
      }
      else if ((c == 'e' || c == 'E') && !hex && !exp) {
        sb.Append(c);
        Read();
        exp = true;
        c = Peek();
        if (c == '+' || c == '-') {
          sb.Append(c);
          Read();
          c = Peek();
        }
        need_digit = true;
      }
      if (!IsDigit(c, hex)) {
        if (!need_digit)
          break;
        real = false;
        return null;
      }
      sb.Append(c);
      Read();
    }

    real = dot || exp;
    return sb.ToString();
  }

  int ParseNumber(char first, out object ^val) {
    bool hex = false;
    if (first == '0') {
      char p = Peek();
      if (p == 'x' || p == 'X') {
        Read();
        hex = true;
      }
    }
    bool real;
    string s = ReadNumber(first, hex, out real);
    if (s == null) {
      val = null;
      return Parser.SCAN_ERROR;
    }
    if (!hex) {
      switch (Peek()) {
        case 'F':
        case 'f':
          Read();
          val = Single.Parse(s);
          return Parser.FLOAT_LITERAL;
        case 'D':
        case 'd':
          Read();
          real = true;
        break;
    }
    }
    if (real) {
      val = Double.Parse(s);
      return Parser.DOUBLE_LITERAL;
    }
    val = int.Parse(s, hex ? NumberStyles.HexNumber : NumberStyles.Integer);
    return Parser.INT_LITERAL;
  }

  int ParseWord(char first, out object ^val) {
    string s = ReadWord(first);

    val = null;
    switch (s) {
      case "abstract": return Parser.ABSTRACT;
      case "as": return Parser.AS;
      case "base": return Parser.BASE;
      case "bool": return Parser.BOOL;
      case "break": return Parser.BREAK;
      case "case": return Parser.CASE;
      case "char": return Parser.CHAR;
      case "class": return Parser.CLASS;
      case "const": return Parser.CONST_TOKEN;
      case "continue": return Parser.CONTINUE;
      case "default": return Parser.DEFAULT;
      case "do": return Parser.DO;
      case "double": return Parser.DOUBLE;
      case "else": return Parser.ELSE;
      case "extern": return Parser.EXTERN;
      case "false": return Parser.FALSE_TOKEN;
      case "float": return Parser.FLOAT;
      case "for": return Parser.FOR;
      case "foreach": return Parser.FOREACH;
      case "if": return Parser.IF;
      case "import": return Parser.IMPORT;
      case "in": return Parser.IN_TOKEN;
      case "int": return Parser.INT;
      case "is": return Parser.IS;
      case "new": return Parser.NEW;
      case "null": return Parser.NULL;
      case "object": return Parser.OBJECT;
      case "out": return Parser.OUT_TOKEN;
      case "override": return Parser.OVERRIDE;
      case "pool": return Parser.POOL;
      case "private": return Parser.PRIVATE;
      case "protected": return Parser.PROTECTED;
      case "public": return Parser.PUBLIC;
      case "readonly": return Parser.READONLY;
      case "ref": return Parser.REF;
      case "return": return Parser.RETURN;
      case "short": return Parser.SHORT;
      case "static": return Parser.STATIC;
      case "string": return Parser.STRING;
      case "switch": return Parser.SWITCH;
      case "take": return Parser.TAKE;
      case "this": return Parser.THIS_TOKEN;
      case "true": return Parser.TRUE_TOKEN;
      case "virtual": return Parser.VIRTUAL;
      case "void": return Parser.VOID_TOKEN;
      case "while": return Parser.WHILE;
      default:
        val = s;
        return Parser.ID;
    }
  }

  bool ParseEscape(ref char c) {
    if (!Read(out c))
      return false;
    switch (c) {
      case '\'':
      case '\"':
      case '\\':
        break;
      case '0': c = '\0'; break;
      case 'n': c = '\n'; break;
      case 'r': c = '\r'; break;
      case 't': c = '\t'; break;
      default: return false;
    }
    return true;
  }

  int ParseChar(out object ^val) {
    val = null;
    char c;
    if (!Read(out c))
      return Parser.SCAN_ERROR;
    if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
    char d;
    if (!Read(out d) || d != '\'')
      return Parser.SCAN_ERROR;
    val = c;
    return Parser.CHAR_LITERAL;
  }

  int ParseString(out object ^val) {
    val = null;
    StringBuilder ^sb = new StringBuilder();
    while (true) {
      char c;
      if (!Read(out c))
        return Parser.SCAN_ERROR;
      if (c == '"')
        break;
      if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
      sb.Append(c);
    }
    val = sb.ToString();
    return Parser.STRING_LITERAL;
  }

  int ReadToken(out object ^val) {
    val = null;

    int i = GetChar();
    if (i == -1)
      return -1;
    char c = (char) i;

    if (Char.IsDigit(c) || c == '.' && Char.IsDigit(Peek()))
      return ParseNumber(c, out val);

    if (Char.IsLetter(c) || c == '_')
      return ParseWord(c, out val);

    if (c == '\'')
      return ParseChar(out val);

    if (c == '"')
      return ParseString(out val);

    char peek = Peek();
    int token = 0;
    switch (c.ToString() + peek.ToString()) {
      case "++": token = Parser.PLUS_PLUS; break;
      case "--": token = Parser.MINUS_MINUS; break;
      case "&&": token = Parser.OP_AND; break;
      case "||": token = Parser.OP_OR; break;
      case "==": token = Parser.OP_EQUAL; break;
      case "!=": token = Parser.OP_NE; break;
      case "<=": token = Parser.OP_LE; break;
      case "<<": token = Parser.OP_LEFT_SHIFT; break;
      case ">=": token = Parser.OP_GE; break;
      case ">>": token = Parser.OP_RIGHT_SHIFT; break;
      case "*=": token = Parser.STAR_EQUAL; break;
      case "/=": token = Parser.SLASH_EQUAL; break;
      case "%=": token = Parser.PERCENT_EQUAL; break;
      case "+=": token = Parser.PLUS_EQUAL; break;
      case "-=": token = Parser.MINUS_EQUAL; break;
      case "&=": token = Parser.AND_EQUAL; break;
      case "|=": token = Parser.OR_EQUAL; break;

      // Return_2 [] as a single token; this lets the parser distinguish the cases
      // "foo[] a;" and "foo[x] = 4" as soon as it reads the first token after the identifier "foo".
      case "[]": token = Parser.ARRAY_TYPE; break;
    }
    if (token != 0) {
      Read();
    } else token = c;

    val = token;
    return token;
  }

  public override bool Advance () {
    if (next_token_ != -1) {
      token_ = next_token_;
      value_ = take next_value_;
      next_token_ = -1;
    } else {
      token_ = ReadToken(out value_);
      if (token_ == -1) return false;
    }

    if (token_ == ')') {
      // We need to read one token ahead to determine whether this close parenthesis
      // ends a type cast.  See e.g. the discussion in the Cast_2 Expressions section
      // of the C# specification.
      next_token_ = ReadToken(out next_value_);
      switch (next_token_) {
        case -1:  // end of file
          break;
        case '!':
        case '(':
        case Parser.ID:
        case Parser.INT_LITERAL:
        case Parser.CHAR_LITERAL:
        case Parser.STRING_LITERAL:
          token_ = Parser.CAST_CLOSE_PAREN;
          break;
        default:
          if (next_token_ >= Parser.FIRST_KEYWORD && next_token_ <= Parser.LAST_KEYWORD &&
              next_token_ != Parser.AS && next_token_ != Parser.IS)
            token_ = Parser.CAST_CLOSE_PAREN;
          break;
      }
    }
    return true;
  }

  public override void Fatal() {
    new Syntax_2().Error("irrecoverable syntax error");
    Environment.Exit(1);
  }

}

class Gel_2 {
  public static bool verbose_;

  public static bool error_test_;
  public static bool print_type_sets_;

  public static readonly ArrayList /* of int */ ^expected_error_lines_ = new ArrayList();
  public static readonly ArrayList /* of int */ ^error_lines_ = new ArrayList();

  public static Program_2 ^program_;

  public static readonly string gel_directory_ = GetLibraryPath();

  static string GetLibraryPath() {
    return Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName); 
  }

  public static string CurrentFile() {
    return program_ == null ? "" : program_.CurrentFile();
  }

  public static int Line() {
    return program_ == null ? 0 : program_.Line();
  }

  public static void Exit() { Environment.Exit(0); }

  // Given two sorted ArrayLists a, b of ints, return an ArrayList containing all ints which appear
  // in [a] but not in [b].
  ArrayList ^Diff(ArrayList a, ArrayList b) {
    ArrayList ^ret = new ArrayList();
    int bi = 0;
    foreach (int i in a) {
      while (bi < b.Count && (int) b[bi] < i)
        ++bi;
      if (bi >= b.Count || (int) b[bi] > i)
        ret.Add(i);
    }
    return ret;
  }

  void WriteLineNumbers(ArrayList a) {
    for (int i = 0; i < a.Count; ++i) {
      if (i > 0)
        Console.Write(", ");
      Console.Write(a[i]);
    }
    Console.WriteLine("");
  }

  void ErrorTestReport() {
    Console.WriteLine("");
    ArrayList ^e = Diff(error_lines_, expected_error_lines_);
    if (e.Count > 0) {
      Console.Write("unexpected error at line ");
      WriteLineNumbers(e);
    }
    ArrayList ^e2 = Diff(expected_error_lines_, error_lines_);
    if (e2.Count > 0) {
      Console.Write("expected error at line ");
      WriteLineNumbers(e2);
    }
    if (e.Count == 0 && e2.Count == 0)
      Console.WriteLine("all errors expected");
  }

  void Usage_2() {
    Console.WriteLine("usage: gel <source-file> ... [args]");
    Console.WriteLine("       gel -c [-d] [-o <name>] [-u] [-v] [-cpp] <source-file> ...");
    Console.WriteLine("");
    Console.WriteLine("   -c: compile to native executable");
    Console.WriteLine("   -d: debug mode: disable optimizations, link with debug build of C runtime");
    Console.WriteLine("   -o: specify output filename");
    Console.WriteLine("   -u: unsafe: skip reference count checks");
    Console.WriteLine("   -v: verbose: display command used to invoke C++ compiler");
    Console.WriteLine(" -cpp: compile to C++ only");
  }

  public void Run(string[] args) {
    if (args.Length < 1) {
      Usage_2();
      return;
    }

    Internal_2.Init();

    program_ = new Program_2();
    bool compile = false;
    bool cpp_only = false;
    string output = null;
    int i;
    for (i = 0; i < args.Length && args[i].StartsWith("-"); ++i)
      switch (args[i]) {
        case "-c": compile = true; break;
        case "-d": program_.debug_ = true; break;
        case "-e": error_test_ = true; break;
        case "-o":
          if (++i >= args.Length) {
            Usage_2();
            return;
          }
          output = Path.GetFileNameWithoutExtension(args[i]);
          break;
        case "-u": program_.safe_ = false; break;
        case "-v": verbose_ = true; break;
        case "-cpp": cpp_only = true; break;
        case "-crt": program_.crt_alloc_ = true; break;
        case "-typeset": print_type_sets_ = true; break;
        default:
          Console.WriteLine("unrecognized option: {0}", args[i]);
          return;
      }

    for (; i < args.Length ; ++i)
      if (args[i].EndsWith(".gel"))
        program_.Import(args[i]);
      else {
        if (args[i] == "-")   // marker indicating end of source files
          ++i;
        break;
      }

    ArrayList ^program_args = new ArrayList();
    if (compile) {
      if (i < args.Length) {
        Console.WriteLine("file to compile has unrecognized extension: {0}", args[i]);
        return;
      }
    } else {
      for (; i < args.Length; ++i)
        program_args.Add(args[i]);
    }

    if (!program_.Parse())
      return;

    bool ok = program_.Resolve() && program_.Check();
    if (error_test_)
      ErrorTestReport();
    if (!ok)
      return;

    if (compile)
      program_.Compile(output, cpp_only);
    else program_.Eval(program_args);
  }

  public static void Main_2(string[] args) {
    new Gel_2().Run(args);
  }
}
/*
Copyright (c) 2006 Google Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

class Syntax_3 {
  public readonly string file_;
  public readonly int line_;

  public Syntax_3() { file_ = Gel_3.CurrentFile(); line_ = Gel_3.Line(); }

  static void Report(string file, int line, string type) {
    Console.Write("{0}({1}): ", file, line);
    Console.Write("{0}: ", type);
    if (Gel_3.error_test_)
      Gel_3.error_lines_.Add(line);
  }

  public void Error(string message) {
    Report(file_, line_, "error");
    Console.WriteLine(message);
  }

  public void Error(string format, object arg) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg);
  }

  public void Error(string format, object arg1, object arg2) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2);
  }

  public void Error(string format, object arg1, object arg2, object arg3) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2, arg3);
  }

  public void Warning(string message) {
    Report(file_, line_, "warning");
    Console.WriteLine(message);
  }
}

abstract class TypeExpr_3 : Syntax_3 {
  public abstract GType_3 Resolve(Program_3 program);
  public abstract TypeExpr_3 ^Copy();
}

class ConversionContext_3 {
  public const int Other = 0,
                   AssignVar = 1,
                   MethodArg = 2;
}

// GEL2 includes the following kinds of types:
// - simple types (int, bool, char, float, double): SimpleType_3
// - owned types (including array types): ArrayType_3 or Class_3 with Owned() => true
// - owning types: Owning_3
// - string: GString_3
// - null type: NullType_3
// - void: VoidType_3

abstract class GType_3 {
  public virtual bool IsOwned() { return false; }

  // A reference type is an owned, owning, string or null type.
  public virtual bool IsReference() { return true; }

  // A value type is a simple or string type.
  public virtual bool IsValue() { return false; }

  public virtual Class_3 Parent() { return GObject_3.type_; }
  
  // If_3 this is an owning type T ^ then return T; otherwise return this.
  public virtual GType_3 BaseType() { return this; }

  // Return_3 the set of types which may be destroyed when a variable of this type
  // is destroyed.
  public virtual TypeSet_3 VarDestroys() { return TypeSet_3.empty_; }

  // Return_3 the set of types which may be destroyed when a value of this concrete type
  // is destroyed.
  public virtual TypeSet_3 TypeDestroys() { return TypeSet_3.empty_; }

  public virtual void FindVarDestroys(int marker, TypeSet_3 set) { }

  public virtual void FindTypeDestroys(int marker, TypeSet_3 set) { }

  public virtual bool IsSubtype(GType_3 type) {
    for (GType_3 t = this; t != null ; t = t.Parent())
      if (type.Equals(t))
        return true;
    return false;
  }

  public virtual Owning_3 OwningType() { Debug.Assert(false); return null; }

  protected virtual bool CanConvertOwnership(GType_3 t, int context) {
    bool from_owning = this is Owning_3;
    bool to_owning = t is Owning_3;
    if (IsValue() && t.BaseType() == GObject_3.type_) {
      Debug.Assert(!from_owning);
      // boxing conversion yields an owning pointer; string->object conversion may
      // yield an owning or non-owning pointer
      return to_owning || context == ConversionContext_3.MethodArg || this == GString_3.type_;
    }
    if (BaseType() == GObject_3.type_ && t.IsValue()) {
      Debug.Assert(!to_owning);
      return true;  // an unboxing or object->string conversion, OK in any context
    }
    return from_owning == to_owning ||
           from_owning && !to_owning &&
             (context == ConversionContext_3.AssignVar || context == ConversionContext_3.MethodArg);
  }

  // Ensure that this class will inherit from Object in generated C++ code.
  public virtual void SetObjectInherit() { }

  // Return_3 true if there is a non-subtyping implicit conversion from this to t.
  public virtual bool CanConvert1(GType_3 t) { return false; }

  // Return_3 true if there is a non-subtyping explicit conversion from this to t.
  protected virtual bool CanConvertExplicit1(GType_3 t) { return false; }

  // Return_3 true if this type can be converted to type [to].
  public bool CanConvert(GType_3 to, int context, bool is_explicit, bool subtype_only) {
    if (!CanConvertOwnership(to, context))
      return false;

    GType_3 from_base = BaseType();
    GType_3 to_base = to.BaseType();
    if (from_base.Equals(to_base))
      return true;   // identity conversion

    // If_3 we ever perform a conversion to C ^, then C must have a vtable so that we can call
    // a virtual destructor when an owning pointer is destroyed.
    if (to is Owning_3 && this != Null_3.type_)
      to_base.SetVirtual();

    // If_3 we ever perform an explicit conversion from a class, that class must
    // have a vtable so that every instance of the class will have run-time type information.
    if (is_explicit)
      from_base.SetVirtual();

    // If_3 we ever convert between C and Object, then C must derive from Object in generated code.
    if (from_base == GObject_3.type_)
      to_base.SetObjectInherit();
    else if (to_base == GObject_3.type_)
      from_base.SetObjectInherit();

    return from_base.IsSubtype(to_base) ||
           !subtype_only && from_base.CanConvert1(to_base) ||
           is_explicit && (to_base.IsSubtype(from_base) ||
                           !subtype_only && from_base.CanConvertExplicit1(to_base));
  }

  public bool CanConvert(GType_3 t, int context) { return CanConvert(t, context, false, false); }
  public bool CanConvert(GType_3 t) { return CanConvert(t, ConversionContext_3.Other); }

  public bool CanConvertExplicit(GType_3 t, bool subtype_only) {
    return CanConvert(t, ConversionContext_3.Other, true, subtype_only);
  }

  public bool CheckConvert(Syntax_3 caller, GType_3 t, int context) {
    if (!CanConvert(t, context)) {
      caller.Error("can't convert {0} to {1}", this, t);
      return false;
    }
    return true;
  }

  public bool CheckConvert(Syntax_3 caller, GType_3 t) {
    return CheckConvert(caller, t, ConversionContext_3.Other);
  }

  // Return_3 a type to which the types [this] and t can both be implicitly converted.
  public GType_3 CommonType(Syntax_3 caller, GType_3 t) {
    if (CanConvert(t))
      return t;
    if (t.CanConvert(this))
      return this;
    caller.Error("incompatible types: {0} and {1}", this, t);
    return null;
  }

  public abstract SimpleValue_3 DefaultValue_3();

  static ArrayList ^empty_array_ = new ArrayList();
  public virtual ArrayList /* of Member_3 */ Members() { return empty_array_; }

  public Member_3 GetMatchingMember(Member_3 m1) {
    foreach (Member_3 m in Members())
      if (m.MatchSignature(m1))
        return m;
    return null;
  }

  // Find a match for m in this type or its ancestors, ignoring private members and
  // optionally ignoring overrides.
  public Member_3 FindMatchingMember(Member_3 m, bool override_ok) {
    for (GType_3 t = this ; t != null ; t = t.Parent()) {
      Member_3 m1 = t.GetMatchingMember(m);
      if (m1 != null && !m1.IsPrivate() && (override_ok || !m1.IsOverride()))
        return m1;
    }
    return null;
  }

  int Score(bool accessible, int mismatches) {
    return (accessible ? 0 : 100) + mismatches;
  }

  public Member_3 Lookup(Syntax_3 caller, Class_3 from_class, bool through_base,
                       int kind, string name, ArrayList /* of Argument_3 */ arguments, bool report_error) {
    Member_3 m1 = null;   // the best match we've found so far
    bool found_any = false;
    bool accessible = false;
    int score = -1;

    GType_3 this_type = BaseType();
    GType_3 t;
    for (t = this_type; t != null; t = (kind == MemberKind_3.Constructor_3 ? null : t.Parent())) {
      foreach (Member_3 m in t.Members())
        if (Member_3.MatchKind(m.Kind(), kind) && m.name_ == name && !m.IsOverride()) {
          found_any = true;
          int mismatches = 0;
          if (arguments != null && !m.IsApplicable(arguments, out mismatches))
            continue; // wrong argument count
          bool new_accessible = m.IsAccessible(from_class, this_type, through_base);
          int new_score = Score(new_accessible, mismatches);
          if (new_score == 0 && score == 0) {
            if (report_error)
              caller.Error("{0}: ambiguous {1} call", name, Member_3.ToString(kind));
            return null;
          }
          if (score == -1 || new_score < score) {
            m1 = m;
            score = new_score;
            accessible = new_accessible;
          }
        }
      if (score == 0)
        break;
    }

    if (score != 0) {
      if (report_error) {
        string k = Member_3.ToString(kind);
        if (!found_any)
          caller.Error("{0}: {1} not found", name, k);
        else if (score == -1) {
          string a = String.Format("{0} argument{1}", arguments.Count, arguments.Count == 1 ? "" : "s");
          caller.Error("{0}: no {1} overload takes {2}", name, k, a);
        } else if (!accessible)
          caller.Error("{0}: can't access {1} {2}",
                       name, m1.IsProtected() ? "protected" : "private", k);
        else {
          caller.Error("{0}: the best overloaded {1} match has some invalid arguments", name, k);
          m1.ReportMismatches(caller, arguments);
        }
      }
      return null;
    }

    // If_3 we've found a member of the Object class, then we're using this class as an object,
    // so in generated code it must ultimately inherit from Object, not _Object.
    if (t == GObject_3.type_)
      this_type.SetObjectInherit();

    if (through_base) {
      // As_3 a special case, whenever we're accessing through base we find the member which will
      // actually be invoked; this is not necessarily the same as the member we've just found
      // if the member is virtual.
      m1 = FindMatchingMember(m1, true);
      Debug.Assert(m1 != null);
    }

    return m1;
  }

  public virtual void SetVirtual() { }

  // Emit the name of the C++ class we use to hold instances of this type.
  public virtual string EmitTypeName() { Debug.Assert(false); return null; }

  // Return_3 a C++ type of the form "T<U>".  If_3 U ends with a '>', we emit an
  // extra space to avoid emitting the token >>, which will cause GCC to complain.
  public static string ConstructType(string generic, string type) {
    return String.Format("{0}<{1}{2}>", generic, type,
                         type.EndsWith(">") ? " " : "");
  }

  string EmitNonOwningPointer(string name) {
    if (Gel_3.program_.safe_)
      return ConstructType(this == GObject_3.type_ ? "_PtrRef" : "_Ptr", name);
    return String.Format("{0} *", name);
  }

  // Emit a C++ type used for variables holding instances of this type.
  public virtual string EmitType() {
    return EmitNonOwningPointer(EmitTypeName());
  }

  // Emit a C++ type used for expressions holding instances of this type.
  public virtual string EmitExprType() {
    return EmitTypeName() + " *";
  }

  public virtual string EmitReturnType() {
    return EmitExprType();
  }

  public virtual string EmitGenericType() {
    return IsReference() ? EmitNonOwningPointer("Object") : EmitType();
  }
}

class TypeSet_3 {
  NonOwningArrayList /* of GType_3 */ ^types_ = new NonOwningArrayList();

  public static readonly TypeSet_3 ^empty_ = new TypeSet_3();

  public void Add(GType_3 type) {
    for (int i = 0; i < types_.Count; ++i) {
      GType_3 t = (GType_3) types_[i];
      if (type.IsSubtype(t))
        return;
      if (t.IsSubtype(type)) {
        types_[i++] = type;
        while (i < types_.Count) {
          t = (GType_3) types_[i];
          if (t.IsSubtype(type))
            types_.RemoveAt(i);
          else ++i;
        }
        return;
      }
    }
    types_.Add(type);
  }

  public void Add(TypeSet_3 set) {
    foreach (GType_3 t in set.types_)
      Add(t);
  }

  public bool Contains(GType_3 type) {
    foreach (GType_3 t in types_)
      if (type.IsSubtype(t))
        return true;
    return false;
  }

  public bool IsObject() {
    return types_.Count > 0 && types_[0] == GObject_3.type_;
  }

  public override string ToString() {
    StringBuilder ^sb = new StringBuilder();
    sb.Append("{");
    foreach (GType_3 t in types_)
      sb.AppendFormat(" {0}", t.ToString());
    sb.Append(" }");
    return sb.ToString();
  }
}

class VoidType_3 : GType_3 {
  public override bool IsReference() { Debug.Assert(false); return false; }

  public override SimpleValue_3 DefaultValue_3() { Debug.Assert(false); return null; }

  public override string ToString() { return "void"; }

  public override string EmitExprType() { return "void"; }
  public override string EmitType() { return "void"; }
}

class Void_3 {
  public static readonly GType_3 ^type_ = new VoidType_3();
}

// an RValue_3, a Location_3 containing an RValue_3, or a LocationRef_3 pointing to a Location_3 containing an RValue_3
abstract class ValueOrLocation_3 {
  public abstract GValue_3 Get();
}

// a GValue_3 or a reference to a GValue_3
abstract class RValue_3 : ValueOrLocation_3 {
  public abstract RValue_3 ^CopyRef();
}

abstract class GValue_3 : RValue_3 {
  public override GValue_3 Get() { return this; }

  public abstract GType_3 Type();

  public override RValue_3 ^CopyRef() { return new Reference_3(this); }

  public virtual RValue_3 ^Get(Field_3 field) { Debug.Assert(false); return null; }
  public virtual RValue_3 ^Take_3(Field_3 field) { Debug.Assert(false); return null; }

  public virtual RValue_3 ^ConvertExplicit(ref RValue_3 ^this_own, GType_3 t) {
    // try implicit conversion
    RValue_3 ^v = Convert(ref this_own, t);
    if (v != this || Type().IsSubtype(t) )
      return v;

    Console.WriteLine("type cast failed: object of type {0} is not a {1}", Type(), t);
    Gel_3.Exit();
    return null;
  }

  // Implicitly convert this value to type t.
  public virtual RValue_3 ^Convert(ref RValue_3 ^this_own, GType_3 t) {
    return take this_own;
  }

  public virtual bool DefaultEquals(object o) { return Equals(o); }
  public virtual int DefaultHashCode() { return GetHashCode(); }
  public virtual string DefaultToString() { return ToString(); }

  public virtual RValue_3 ^Invoke(Method_3 m, ValueList_3 args) {
    switch (m.name_) {
      case "Equals": return new GBool_3(DefaultEquals(args.Object(0)));
      case "GetHashCode": return new GInt_3(DefaultHashCode());
      case "ToString": return new GString_3(DefaultToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class Reference_3 : RValue_3 {
  public readonly GValue_3 value_;    // a reference value, never a SimpleValue_3

  public Reference_3(GValue_3 v) { value_ = v; }

  public override GValue_3 Get() { return value_; }

  public override RValue_3 ^CopyRef() { return new Reference_3(value_); }
}

abstract class SimpleValue_3 : GValue_3 {
  public abstract SimpleValue_3 ^Copy();
  public override RValue_3 ^CopyRef() { return Copy(); }
  public abstract string Emit();
}

class GBool_3 : SimpleValue_3 {
  public readonly bool b_;

  public GBool_3(bool b) { b_ = b; }

  public override bool Equals(object o) {
    GBool_3 b = o as GBool_3;
    return b != null && b.b_ == b_;
  }

  public override int GetHashCode() { return b_.GetHashCode(); }

  public override SimpleValue_3 ^Copy() { return new GBool_3(b_); }

  public static readonly BoolClass_3 ^type_ = new BoolClass_3();

  public override GType_3 Type() { return type_; }

  public override string ToString() { return b_.ToString(); }

  public override string Emit() { return b_ ? "true" : "false"; }
}

class GInt_3 : SimpleValue_3 {
  public readonly int i_;

  public GInt_3(int i) { i_ = i; }

  public static readonly IntClass_3 ^type_ = new IntClass_3();

  public override GType_3 Type() { return type_; }

  public override bool Equals(object o) {
    GInt_3 i = o as GInt_3;
    return i != null && i.i_ == i_;
  }

  public override int GetHashCode() { return i_.GetHashCode(); }

  public override SimpleValue_3 ^Copy() { return new GInt_3(i_); }

  public override RValue_3 ^Convert(ref RValue_3 ^this_own, GType_3 t) {
    if (t == GFloat_3.type_)
      return new GFloat_3(i_);
    if (t == GDouble_3.type_)
      return new GDouble_3(i_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_3 ^ConvertExplicit(ref RValue_3 ^this_own, GType_3 t) {
    return t == GChar_3.type_ ? new GChar_3((char) i_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return i_.ToString(); }

  public override string Emit() { return i_.ToString(); }
}

class GFloat_3 : SimpleValue_3 {
  public readonly float f_;

  public GFloat_3(float f) { f_ = f; }

  public static readonly FloatClass_3 ^type_ = new FloatClass_3();

  public override GType_3 Type() { return type_; }

  public override bool Equals(object o) {
    GFloat_3 f = o as GFloat_3;
    return f != null && f.f_ == f_;
  }

  public override int GetHashCode() { return f_.GetHashCode(); }

  public override SimpleValue_3 ^Copy() { return new GFloat_3(f_); }

  public override RValue_3 ^Convert(ref RValue_3 ^this_own, GType_3 t) {
    if (t == GDouble_3.type_)
      return new GDouble_3(f_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_3 ^ConvertExplicit(ref RValue_3 ^this_own, GType_3 t) {
    return t == GInt_3.type_ ? new GInt_3((int) f_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return f_.ToString(); }

  public override string Emit() {
    string s = f_.ToString();
    return s + (s.IndexOf('.') == -1 ? ".0f" : "f");
  }
}

class GDouble_3 : SimpleValue_3 {
  public readonly double d_;

  public GDouble_3(double d) { d_ = d; }

  public static readonly DoubleClass_3 ^type_ = new DoubleClass_3();

  public override GType_3 Type() { return type_; }

  public override bool Equals(object o) {
    GDouble_3 d = o as GDouble_3;
    return d != null && d.d_ == d_;
  }

  public override int GetHashCode() { return d_.GetHashCode(); }

  public override SimpleValue_3 ^Copy() { return new GDouble_3(d_); }

  public override RValue_3 ^ConvertExplicit(ref RValue_3 ^this_own, GType_3 t) {
    if (t == GInt_3.type_)
      return new GInt_3((int) d_);
    if (t == GFloat_3.type_)
      return new GFloat_3((float) d_);
    return base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return d_.ToString(); }

  public override string Emit() {
    string s = d_.ToString();
    if (s.IndexOf('.') == -1)
      s = s + ".0";
    return s;
  }
}

class GChar_3 : SimpleValue_3 {
  public readonly char c_;

  public GChar_3(char c) { c_ = c; }

  public static readonly CharClass_3 ^type_ = new CharClass_3();

  public override GType_3 Type() { return type_; }

  public override bool Equals(object o) {
    GChar_3 c = o as GChar_3;
    return c != null && c.c_ == c_;
  }

  public override int GetHashCode() { return c_.GetHashCode(); }

  public override SimpleValue_3 ^Copy() { return new GChar_3(c_); }

  public override RValue_3 ^Convert(ref RValue_3 ^this_own, GType_3 t) {
    return t == GInt_3.type_ ? new GInt_3(c_) : base.Convert(ref this_own, t);
  }

  public override string ToString() { return c_.ToString(); }

  public static string Emit(char c) {
    switch (c) {
      case '\0': return "\\0";
      case '\n': return "\\n";
      case '\r': return "\\r";
      case '\t': return "\\t";
      case '\'': return "\\'";
      case '\"': return "\\\"";
      case '\\': return "\\\\";
    }
    if (c < 32) {
      Debug.Assert(false); return null;
    }
    return c.ToString();
  }

  public override string Emit() {
    return String.Format("'{0}'", Emit(c_));
  }
}

abstract class LocationOrRef_3 : ValueOrLocation_3 {
  public abstract Location_3 GetLoc();
}

class Location_3 : LocationOrRef_3 {
  public RValue_3 ^value_;

  public Location_3(RValue_3 ^val) { value_ = val; }

  public override GValue_3 Get() { return value_.Get(); }

  public override Location_3 GetLoc() { return this; }
}

// We allocate a LocationRef_3 when we need an owning reference to a Location_3 which we don't own.
class LocationRef_3 : LocationOrRef_3 {
  public readonly Location_3 location_;

  public LocationRef_3(Location_3 loc) { location_ = loc; }

  public override GValue_3 Get() { return location_.Get(); }

  public override Location_3 GetLoc() { return location_; }
}

class MapNode_3 {
  public readonly MapNode_3 ^next_;
  public readonly object key_;
  public ValueOrLocation_3 ^value_;   // (must appear after next_ so it will be destroyed first)

  public MapNode_3(object key, ValueOrLocation_3 ^value, MapNode_3 ^next) {
    key_ = key; value_ = value; next_ = next;
  }
}

class Map_3 {
  MapNode_3 ^nodes_;

  protected MapNode_3 Find1(object key) {
    for (MapNode_3 n = nodes_; n != null; n = n.next_)
      if (n.key_ == key)
        return n;
    return null;
  }

  protected virtual MapNode_3 Find(object key) {
    MapNode_3 n = Find1(key);
    Debug.Assert(n != null);
    return n;
  }

  public RValue_3 ^Get(object key) {
    return Find(key).value_.Get().CopyRef();
  }

  public RValue_3 ^Take_3(object key) {
    MapNode_3 n = Find(key);
    LocationOrRef_3 l = n.value_ as LocationOrRef_3;
    if (l != null)
      return take l.GetLoc().value_;
    return (RValue_3) take n.value_;
  }

  public void Set(object key, RValue_3 ^val) {
    MapNode_3 n = Find(key);
    LocationOrRef_3 l = n.value_ as LocationOrRef_3;
    if (l != null)
      l.GetLoc().value_ = val;
    else n.value_ = val;
  }

  public void Add(object key, ValueOrLocation_3 ^val) {
    nodes_ = new MapNode_3(key, val, take nodes_);
  }

  public Location_3 GetLocation(object key) {
    MapNode_3 n = Find(key);
    LocationOrRef_3 l = n.value_ as LocationOrRef_3;
    if (l != null)
      return l.GetLoc();
    Location_3 ^loc1 = new Location_3((RValue_3) take n.value_);
    Location_3 loc = loc1;
    n.value_ = loc1;
    return loc;
  }
}

class GObject_3 : GValue_3 {
  public readonly Class_3 class_;   // the class of this object

  Map_3 ^map_ = new Map_3();

  public GObject_3(Class_3 cl) {
    class_ = cl;
    while (cl != null) {
      foreach (Field_3 f in cl.fields_)
        map_.Add(f, f.Type().DefaultValue_3().Copy() );
      cl = cl.Parent();
    }
  }

  // the type of this object
  public override GType_3 Type() { return class_; }

  public override RValue_3 ^Get(Field_3 field) { return map_.Get(field); }
  public override RValue_3 ^Take_3(Field_3 field) { return map_.Take_3(field); }
  public void Set(Field_3 field, RValue_3 ^val) { map_.Set(field, val); }
  public Location_3 GetLocation(Field_3 field) { return map_.GetLocation(field); }

  public override int DefaultHashCode() { return base.GetHashCode(); }
  public override int GetHashCode() {
    GInt_3 ^i = (GInt_3) Invocation_3.InvokeMethod(this, GObject_3.type_.get_hash_code_, new ArrayList(), true);
    return i.i_;
  }

  public override bool DefaultEquals(object o) { return base.Equals(o); }
  public override bool Equals(object o) {
    GValue_3 v = o as GValue_3;
    if (v == null)
      return false;

    ArrayList ^args = new ArrayList();
    args.Add(v.CopyRef());
    GBool_3 ^b = (GBool_3) Invocation_3.InvokeMethod(this, GObject_3.type_.equals_, args, true);
    return b.b_;
  }

  public override string DefaultToString() { return String.Format("<object {0}>", class_.name_); }
  public override string ToString() {
    GString_3 ^s = (GString_3) Invocation_3.InvokeMethod(this, GObject_3.type_.to_string_, new ArrayList(), true);
    return s.s_;
  }

  // the Object class
  public static readonly ObjectClass_3 ^type_ = new ObjectClass_3();
}

class NullType_3 : GType_3 {
  public override string ToString() { return "null_type"; }

  public override SimpleValue_3 DefaultValue_3() { Debug.Assert(false); return null; }

  public override bool IsSubtype(GType_3 t1) {
    return t1.IsReference();
  }

  protected override bool CanConvertOwnership(GType_3 t, int context) {
    return true;    // conversion from null type to owning type is okay
  }

  public override string EmitType() { Debug.Assert(false); return null; }
}

class Null_3 : SimpleValue_3 {
  public Null_3() { }

  public static readonly NullType_3 ^type_ = new NullType_3();

  public override GType_3 Type() { return type_; }

  public override bool Equals(object o) {
    return o is Null_3;
  }

  public override SimpleValue_3 ^Copy() { return new Null_3(); }

  public override int GetHashCode() { return 0; }

  public static readonly Null_3 ^Instance = new Null_3();

  public override string ToString() { return ""; }

  public override string Emit() { return "0"; }
}

class Owning_3 : GType_3 {
  GType_3 base_type_;

  public Owning_3(GType_3 type) {
    base_type_ = type;
  }

  public override Class_3 Parent() { Debug.Assert(false); return null; }

  public override SimpleValue_3 DefaultValue_3() { return Null_3.Instance; }

  public override GType_3 BaseType() { return base_type_; }

  public override TypeSet_3 VarDestroys() { return base_type_.TypeDestroys(); }

  public override void FindVarDestroys(int marker, TypeSet_3 set) {
    base_type_.FindTypeDestroys(marker, set);
  }

  public override bool Equals(object o) {
    Owning_3 t = o as Owning_3;
    return t != null && t.base_type_.Equals(base_type_);
  }

  public override int GetHashCode() { return base_type_.GetHashCode() * 87; }

  public override string ToString() { return base_type_.ToString() + " ^"; }

  public override string EmitTypeName() {
    return base_type_.EmitTypeName();
  }

  string EmitType(string name) {
    return ConstructType(base_type_ == GObject_3.type_ ? "_OwnRef" : "_Own", name);
  }

  public override string EmitType() {
    // We represent an object ^ using a _OwnRef<Object>.
    // We represent a Foo ^ using an _Own<Foo>.
    return EmitType(EmitTypeName());
  }

  public override string EmitGenericType() {
    // We represent an object ^ [] using an _Array<_OwnRef<Object>>.
    // We represent a Foo ^ [] using an _Array<_Own<Object>>.
    return EmitType("Object");
  }
}

class OwningExpr_3 : TypeExpr_3 {
  readonly TypeExpr_3 ^expr_;

  public OwningExpr_3(TypeExpr_3 ^expr) { expr_ = expr; }

  public override TypeExpr_3 ^Copy() { return new OwningExpr_3(expr_.Copy()); }

  public override GType_3 Resolve(Program_3 program) {
    GType_3 t = expr_.Resolve(program);
    if (t == null)
        return null;
    if (t.IsValue()) {
      Error("^ cannot be applied to primitive types or strings");
      return null;
    }
    return t.OwningType();
  }
}

class GString_3 : SimpleValue_3 {
  public readonly string s_;

  public GString_3(string s) { s_ = s; }

  public static readonly StringClass_3 ^type_ = new StringClass_3();

  public override GType_3 Type() { return type_; }

  public override bool Equals(object o) {
    GString_3 s = o as GString_3;
    return s != null && s.s_ == s_;
  }

  public override SimpleValue_3 ^Copy() { return new GString_3(s_); }

  public override int GetHashCode() { return s_.GetHashCode(); }

  public override string ToString() { return s_; }

  public override RValue_3 ^Invoke(Method_3 m, ValueList_3 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StartsWith": return new GBool_3(s_.StartsWith(args.GetString(0)));
      case "EndsWith": return new GBool_3(s_.EndsWith(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public static string EmitStringConst(string s) {
    return String.Format("L{0}", EmitString(s));
  }

  public static string EmitString(string s) {
    StringBuilder ^sb = new StringBuilder();
    sb.Append('"');
    for (int i = 0; i < s.Length; ++i)
      sb.Append(GChar_3.Emit(s[i]));
    sb.Append('"');
    return sb.ToString();
  }

  public override string Emit() {
    string s = String.Format("new String({0})", EmitStringConst(s_));
    s = String.Format("_Ref<String>({0}).Get()", s);
    return s;
  }
}

abstract class Ownable_3 : GType_3 {
  Owning_3 ^owning_type_;

  public override Owning_3 OwningType() {
    if (owning_type_ == null)
      owning_type_ = new Owning_3(this);
    return owning_type_;
  }
}

class ArrayType_3 : Ownable_3 {
  GType_3 element_type_;

  public ArrayType_3(GType_3 type) {
    element_type_ = type;

    // Any type used generically must inherit from Object in C++ code.
    type.BaseType().SetObjectInherit();
  }

  public override bool IsOwned() { return true; }

  public override Class_3 Parent() { return GArray_3.array_class_; }

  public override SimpleValue_3 DefaultValue_3() { return Null_3.Instance; }

  public GType_3 ElementType() { return element_type_; }

  public override bool Equals(object o) {
    ArrayType_3 t = o as ArrayType_3;
    return (t != null && t.element_type_.Equals(element_type_));
  }

  public override TypeSet_3 TypeDestroys() { return element_type_.VarDestroys(); }

  public override void FindTypeDestroys(int marker, TypeSet_3 set) {
    element_type_.FindVarDestroys(marker, set);
  }

  public override int GetHashCode() { return element_type_.GetHashCode() * 77; }

  public override string EmitTypeName() {
    return ConstructType("_Array", element_type_.EmitGenericType());  
  }

  public override string ToString() {
    return element_type_.ToString() + "[]";
  }
}

class ArrayTypeExpr_3 : TypeExpr_3 {
  readonly TypeExpr_3 ^expr_;
  GType_3 ^type_;

  public ArrayTypeExpr_3(TypeExpr_3 ^expr) { expr_ = expr; }

  public override TypeExpr_3 ^Copy() { return new ArrayTypeExpr_3(expr_.Copy()); }

  public override GType_3 Resolve(Program_3 program) {
    GType_3 t = expr_.Resolve(program);
    return t == null ? null : (type_ = new ArrayType_3(t));
  }
}

class GArray_3 : GValue_3 {
  ArrayType_3 type_;

  ValueOrLocation_3^[] ^elements_;   // each element is a GValue_3 or a Location_3

  public override GType_3 Type() { return type_; }

  public GArray_3(ArrayType_3 type, int count) {
    type_ = type;
    elements_ = new ValueOrLocation_3^[count];
    for (int i = 0 ; i < count ; ++i)
      elements_[i] = type_.ElementType().DefaultValue_3().Copy();
  }

  void CheckIndex(int index) {
    if (index < 0 || index >= elements_.Length) {
      Console.WriteLine("error: array access out of bounds");
      Gel_3.Exit();
    }
  }

  public RValue_3 ^Get(int index) {
    CheckIndex(index);
    return elements_[index].Get().CopyRef();
  }

  public RValue_3 ^Take_3(int index) {
    CheckIndex(index);
    Location_3 loc = elements_[index] as Location_3;
    if (loc != null)
      return take loc.value_;
    return (RValue_3) (take elements_[index]);
  }

  public void Set(int index, RValue_3 ^val) {
    CheckIndex(index);
    Location_3 loc = elements_[index] as Location_3;
    if (loc != null)
      loc.value_ = val;
    else elements_[index] = val;
  }

  public Location_3 GetLocation(int index) {
    CheckIndex(index);
    Location_3 loc = elements_[index] as Location_3;
    if (loc != null)
      return loc;
    Location_3 ^loc1 = new Location_3((RValue_3) take elements_[index]);
    loc = loc1;
    elements_[index] = loc1;
    return loc;
  }

  public static readonly ArrayClass_3 ^array_class_ = new ArrayClass_3();

  public override RValue_3 ^Invoke(Method_3 m, ValueList_3 args) {
    if (m.GetClass() != array_class_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "CopyTo":
        GArray_3 a = (GArray_3) args.Object(0);
        if (!type_.Equals(a.type_)) {
          Console.WriteLine("error: can't copy between arrays of different types");
          Gel_3.Exit();
        }
        if (a.type_.ElementType() is Owning_3) {
          Console.WriteLine("error: can't copy to owning array");
          Gel_3.Exit();
        }
        // should check for index out of bounds here!
        int dest = args.Int(1);
        for (int i = 0 ; i < elements_.Length ; ++i)
          a.Set(dest + i, Get(i));
        return null;
      case "get_Length":
        return new GInt_3(elements_.Length);
      default:
        Debug.Assert(false); return null;
    }
  }
}

// A control graph object representing temporary variables destroyed when a top-level
// expression completes evaluation. 
class Temporaries_3 : Node_3 {
  NonOwningArrayList /* of GType_3 */ ^types_ = new NonOwningArrayList();
  TypeSet_3 ^destroys_;

  public void Add(GType_3 t) {
    Debug.Assert(t is Owning_3);
    types_.Add(t.BaseType());
  }

  public override TypeSet_3 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_3();
    foreach (GType_3 t in types_)
        destroys_.Add(t.TypeDestroys());
    }
    return destroys_;
  }
}

class Context_3 {
  public readonly Program_3 program_;   // containing program
  public readonly Class_3 class_;       // containing class
  public readonly Method_3 method_;     // containing method
  public readonly Escapable_3 escape_;  // containing switch, while, do, for, or foreach
  public readonly Loop_3 loop_;         // containing while, do, for, or foreach
  public Local_3 var_;    // chain of local variable declarations

  // subexpressions of the current top-level expression possibly yielding temporary objects
  NonOwningArrayList /* of Expression_3 */ ^temporaries_ = new NonOwningArrayList();

  public Context_3(Program_3 program) { program_ = program; }

  public Context_3(Class_3 cl) { program_ = cl.GetProgram(); class_ = cl; }

  // Copy a context; new variable declarations in either copy will not be visible in the other.
  public Context_3(Context_3 cx) {
    program_ = cx.program_;
    class_ = cx.class_;
    method_ = cx.method_;
    escape_ = cx.escape_;
    loop_ = cx.loop_;
    var_ = cx.var_;
  }

  public Context_3(Context_3 cx, Class_3 c) : this(cx) { class_ = c; }

  public Context_3(Context_3 cx, Method_3 m) : this(cx) { method_ = m; }

  public Context_3(Context_3 cx, Loop_3 l) : this(cx) {
    escape_ = l;
    loop_ = l;
  }

  public Context_3(Context_3 cx, Switch_3 s) : this(cx) { escape_ = s; }

  public bool IsStatic() { return method_ == null || method_.IsStatic(); }

  public void SetVar(Local_3 var) {
    var_ = var;
  }

  public Local_3 FindVar(string name) {
    for (Local_3 v = var_; v != null; v = v.next_)
      if (v.name_ == name)
        return v;
    return null;
  }

  public Control_3 Prev() { return program_.prev_; }

  public void SetPrev(Control_3 c) {
    Debug.Assert(c != null);
    program_.prev_ = c;
  }

  public void ClearPrev() { program_.prev_ = null; }

  // Called when we begin type-checking a top-level expression.
  public void EnterExpression() {
    Debug.Assert(temporaries_.Count == 0);
  }

  public void AddTemporary(Expression_3 e) {
    temporaries_.Add(e);
  }

  // Called when we've finished type-checking a top-level expression.
  public void FinishExpression() {
    Temporaries_3 t = null;
    foreach (Expression_3 e in temporaries_)
      if (!e.LosesOwnership()) {
        if (t == null)
          t = class_.NewTemporaries();
        t.Add(e.TemporaryType());
      }
    if (t != null)
      t.AddControl(this);
    temporaries_.Clear();
  }
}

class Env_3 : Map_3 {
  public readonly GValue_3 this_;
  readonly Env_3 next_;

  public Env_3(GValue_3 _this) { this_ = _this; next_ = null; }
  public Env_3(Env_3 next) { this_ = next.this_; next_ = next; }

  protected override MapNode_3 Find(object key) {
    for (Env_3 e = this; e != null; e = e.next_) {
      MapNode_3 n = e.Find1(key);
      if (n != null)
        return n;
    }
    Debug.Assert(false);
    return null;
  }

  public static readonly Env_3 ^static_ = new Env_3((GValue_3) null);
}

class TypeLiteral_3 : TypeExpr_3 {
  public readonly GType_3 type_;

  public TypeLiteral_3(GType_3 type) { type_ = type; }

  public override GType_3 Resolve(Program_3 program) {
    return type_;
  }

  public override TypeExpr_3 ^Copy() { return new TypeLiteral_3(type_); }
}

class TypeName_3 : TypeExpr_3 {
  string name_;

  public TypeName_3(string name) { name_ = name; }

  public override GType_3 Resolve(Program_3 program) {
    GType_3 type = program.FindClass(name_);
    if (type == null)
      Error("unknown type: {0}", name_);
    return type;
  }

  public override TypeExpr_3 ^Copy() { return new TypeName_3(name_); }
}

abstract class Traverser_3 {
  // Handle a graph item found in a depth first search; returns one of the exit codes below.
  public abstract int Handle(Control_3 control);

  public const int Continue_3 = 0,  // continue searching, including children of this node
                   Cut = 1,       // continue searching, excluding children of this node
                   Abort = 2;     // abort the search

}

// an item in the control graph: either a Node_3 or Joiner_3
abstract class Control_3 : Syntax_3 {
  public int marker_ = 0;    // marker for depth first search of control flow graph

  static int marker_value_ = 0;
  public static int GetMarkerValue() { return ++marker_value_; }

  // A node representing unreachability.  We could represent this using null, but it's
  // clearer to have this be explicit. 
  public static readonly Node_3 ^unreachable_ = new Node_3();

  // A helper function for Traverse.  If_3 we return true then we should cut the
  // traversal at this point.
  protected bool Visit(Traverser_3 traverser, int marker, out bool ok) {
    ok = true;
    if (marker_ == marker)
      return true;  // we've already seen this node
    marker_ = marker;
    int code = traverser.Handle(this);
    if (code == Traverser_3.Abort)
      ok = false;
    return (code != Traverser_3.Continue_3);
  }

  // Perform a depth-first search of the graph starting with this item, calling the
  // given Traverser_3 for each Node_3 found.  Returns false if the search was aborted.
  public abstract bool Traverse(Traverser_3 traverser, int marker);
}

// A node in the control graph.
class Node_3 : Control_3 {
  public Control_3 prev_;   // previous item in graph

  // add this node to the control graph
  public bool AddControl(Context_3 ctx) {
    Control_3 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      prev_ = prev;
      ctx.SetPrev(this);
      return true;
    }
    else return false;
  }

  // If_3 this node calls a method or constructor then return it; otherwise return null.
  // implementers: LValue_3, Invocation_3, New_3, Assign_3, Constructor_3
  public virtual Method_3 Calls() { return null; }

  // Return_3 the set of types which this node may destroy.
  // implementers: Assign_3, RefOutArgument_3, Scoped_3, Temporaries_3
  public virtual TypeSet_3 NodeDestroys() { return TypeSet_3.empty_; }

  // Return_3 true if this node assigns a value to the given Local_3.
  // implementers: Assign_3, RefOutArgument_3, VariableDeclaration_3, Method_3, ForEach_3
  public virtual bool Sets(Local_3 local) { return false; }

  // Return_3 true if this node takes ownership from the given local.
  // implementers: Name_3
  public virtual bool Takes(Local_3 local) { return false; }

  public bool CanDestroy(GType_3 type) {
    Method_3 m = Calls();
    if (m != null && m.Destroys().Contains(type))
      return true;
    return NodeDestroys().Contains(type);
  }

  public override bool Traverse(Traverser_3 traverser, int marker) {
    Node_3 n = this;
    Control_3 prev = null;

    // Traverse nodes iteratively until we come to a Join; this efficiently avoids
    // making a recursive call on each successive node.
    while (n != null) {
      bool ok;
      if (n.Visit(traverser, marker, out ok))
        return ok;
      prev = n.prev_;
      n = prev as Node_3;
    }
    Debug.Assert(prev != null);  // a Traverser_3 must end traversal before we run off the end
    return prev.Traverse(traverser, marker);
  }
}

class Joiner_3 : Control_3 {
  NonOwningArrayList /* of Control_3 */ ^prev_ = new NonOwningArrayList();

  public void Join(Control_3 c) {
    Debug.Assert(c != null);
    if (c == unreachable_)
      return;
    if (prev_.Count == 0 || c != prev_[0])
      prev_.Add(c);
  }

  // add this joiner to the control graph
  public void AddControl(Context_3 ctx) {
    Control_3 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      Join(prev);
      ctx.SetPrev(this);
    }
  }

  // Once we've finished merging paths into a Joiner_3, if the Joiner_3 points to only a single path
  // then as an optimization we can discard the Joiner_3 and just use that path instead.
  public Control_3 Combine() {
    switch (prev_.Count) {
      case 0:
        prev_ = null;
        return unreachable_;
      case 1:
        Control_3 c = (Control_3) prev_[0];
        prev_ = null;
        return c;
      default: return this;
    }
  }

  public override bool Traverse(Traverser_3 traverser, int marker) {
    bool ok;
    if (Visit(traverser, marker, out ok))
      return ok;

    foreach (Control_3 p in prev_)
      if (!p.Traverse(traverser, marker))
        return false;  // aborted
    return true;
  }
}

class ExprKind_3 {
  public const int Value = 0,

  // either a local variable, or an expression whose value is derived from local variables
                   Local_3 = 1,

                   Field_3 = 2,
                   Property_3 = 3,
                   Indexer_3 = 4,
                   Type = 5;
}

class SourceWriter_3 {
  public readonly StreamWriter writer_;
  int indent_ = 0;

  public SourceWriter_3(StreamWriter writer) { writer_ = writer; }

  public void AddIndent() { ++indent_; }
  public void SubIndent() { --indent_; }

  public void Indent(int adjust) {
    for (int i = 0; i < 2 * indent_ + adjust; ++i)
      writer_.Write(' ');
  }

  public void Indent() { Indent(0); }

  public void Write(string s) { writer_.Write(s); }
  public void Write(string s, object arg) { writer_.Write(s, arg); }
  public void Write(string s, object arg1, object arg2) { writer_.Write(s, arg1, arg2); }
  public void Write(string s, object arg1, object arg2, object arg3) { writer_.Write(s, arg1, arg2, arg3); }

  public void IWrite(string s) { Indent(); Write(s); }
  public void IWrite(string s, object arg) { Indent(); Write(s, arg); }
  public void IWrite(string s, object arg1, object arg2) { Indent(); Write(s, arg1, arg2); }
  public void IWrite(string s, object arg1, object arg2, object arg3) { Indent(); Write(s, arg1, arg2, arg3); }

  public void WriteLine(string s) { writer_.WriteLine(s); }
  public void WriteLine(string s, object arg) { writer_.WriteLine(s, arg); }
  public void WriteLine(string s, object arg1, object arg2) { writer_.WriteLine(s, arg1, arg2); }
  public void WriteLine(string s, object arg1, object arg2, object arg3) { writer_.WriteLine(s, arg1, arg2, arg3); }

  public void IWriteLine(string s) { Indent(); WriteLine(s); }
  public void IWriteLine(string s, object arg) { Indent(); WriteLine(s, arg); }
  public void IWriteLine(string s, object arg1, object arg2) { Indent(); WriteLine(s, arg1, arg2); }
  public void IWriteLine(string s, object arg1, object arg2, object arg3) { Indent(); WriteLine(s, arg1, arg2, arg3); }

  public void OpenBrace() { WriteLine("{"); AddIndent(); }
  public void CloseBrace() { SubIndent(); IWriteLine("}"); }
}

class Usage_3 {
  public const int Used = 0, LosesOwnership = 1, Unused = 2;
}

abstract class Expression_3 : Node_3 {
  protected int usage_ = Usage_3.Used;

  // start_ and end_ mark the points in the control graph where this expression is evaluated and used,
  // respectively.  If_3 this expression's type is owned, we use this information to determine whether
  // we need to emit a reference count for this expression.
  Control_3 start_;
  Control_3 end_;

  public abstract GType_3 Check(Context_3 ctx);

  public GType_3 CheckTop(Context_3 ctx) {
    ctx.EnterExpression();
    GType_3 t = Check(ctx);
    ctx.FinishExpression();
    return t;
  }

  public GType_3 CheckAndHold(Context_3 ctx) {
    GType_3 t = Check(ctx);
    if (t != null)
      HoldRef(ctx);
    return t;
  }

  // A fancier checking protocol implemented by lvalues and used by certain callers.
  public virtual GType_3 Check(Context_3 ctx, bool read, bool write, bool type_ok) {
    return Check(ctx);
  }

  public virtual int Kind() { return ExprKind_3.Value; }
  public virtual bool IsRefOutParameter() { return false; }

  public virtual bool IsTrueLiteral() { return false; }
  public virtual bool IsFalseLiteral() { return false; }

  // If_3 this expression is a local variable (possibly cast to a different type),
  // then return that local; otherwise return null.
  public virtual Local_3 GetLocal() { return null; }

  // Return_3 the type of an expression yielding a temporary object.
  // (It might be convenient to generalize this to be able to return any expression's type.)
  public virtual GType_3 TemporaryType() { Debug.Assert(false); return null; }

  public void HoldRef(Context_3 ctx) {
    start_ = ctx.Prev();
    Debug.Assert(start_ != null);
  }

  public void ReleaseRef(Context_3 ctx) {
    end_ = ctx.Prev();
    Debug.Assert(end_ != null);
  }

  public abstract RValue_3 ^Eval(Env_3 env);

  public bool Check(Context_3 ctx, GType_3 t2) {
    GType_3 t = Check(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public bool CheckTop(Context_3 ctx, GType_3 t2) {
    GType_3 t = CheckTop(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public RValue_3 ^Eval(Env_3 env, GType_3 t) {
    RValue_3 ^r = Eval(env);
    GValue_3 v = r.Get();
    return v.Convert(ref r, t);
  }

  public bool EvalBool(Env_3 env) { return ((GBool_3) Eval(env)).b_; }

  public int EvalInt(Env_3 env) {
    RValue_3 ^r = Eval(env, GInt_3.type_);
    GInt_3 i = (GInt_3) r;
    return i.i_;
  }

  public double EvalDouble(Env_3 env) { return ((GDouble_3) Eval(env, GDouble_3.type_)).d_; }
  public float EvalFloat(Env_3 env) { return ((GFloat_3) Eval(env, GFloat_3.type_)).f_; }
  public string EvalString(Env_3 env) { return ((GString_3) Eval(env)).s_; }

  public virtual bool IsConstant() {
    return false;
  }

  public bool CheckConstant() {
    if (IsConstant())
      return true;
    Error("expression must be a constant");
    return false;
  }

  public bool LosesOwnership() { return usage_ == Usage_3.LosesOwnership; }

  public virtual void LoseOwnership() {
    usage_ = Usage_3.LosesOwnership;
  }

  public void SetUnused() {
    Debug.Assert(usage_ == Usage_3.Used);
    usage_ = Usage_3.Unused;
  }

  protected static string EmitAllocate(string type, string args, bool lose_ownership) {
    // If_3 an allocated object never loses ownership then it can be stack allocated.  We
    // can't emit "&Foo(...)" since standard C++ doesn't allow us to take the address
    // of a temporary (both GCC and Visual C++ will allow this, but will emit a warning).
    // So instead we call a function _Addr() to get the address.
    return String.Format(
      !lose_ownership ? "{0}({1})._Addr<{0} *>()" : "new {0}({1})",
      type, args);
  }

  public void CheckLoseOwnership(GType_3 from, GType_3 to) {
    if (to is Owning_3)
      LoseOwnership();
  }

  public abstract string Emit();    // return a C++ expression representing this GEL2 expression

  public bool NeedsRef(GType_3 type) {
    return Gel_3.program_.safe_ && type.IsOwned() && ExpressionTraverser_3.NeedRef(start_, end_, this, type);
  }

  // Emit this expression, adding a reference-counting _Ptr wrapper if needed.
  public string EmitRef(GType_3 type) {
    string s = Emit();
    if (NeedsRef(type))
      s = String.Format("{0}({1}).Get()", type.EmitType(), s);
    return s;
  }

  // Emit an implicit conversion from type [source] to type [dest].
  public static string EmitImplicit(GType_3 source, GType_3 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (!source.IsReference() && dest == GObject_3.type_) {   // a boxing conversion
      Class_3 c = (Class_3) source;
      return EmitAllocate(c.name_, val, loses_ownership);
    }

    if (source == GInt_3.type_ && dest == GFloat_3.type_)
      // an implicit conversion in GEL2, but C++ compilers may warn if we don't use a cast
      return String.Format("static_cast<float>({0})", val);
    
    return val;
  }

  // Emit this expression, converting implicitly from type [source] to type [dest].
  public string Emit(GType_3 source, GType_3 dest) {
    return EmitImplicit(source, dest, Emit(), LosesOwnership());
  }

  public string EmitRef(GType_3 source, GType_3 dest) {
    return EmitImplicit(source, dest, EmitRef(source), LosesOwnership());
  }

  public static string EmitExplicit(GType_3 source, GType_3 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (source.CanConvert(dest)) {
      string v = EmitImplicit(source, dest, val, loses_ownership);
      if (v != val)
        return v;

      // There's nothing to do, but we emit a static_cast anyway since a GEL2 programmer
      // may use a type cast for method call disambiguation; we want to pass such casts onward.
      return String.Format("static_cast<{0} >({1})", dest.EmitExprType(), val);
    }

    if (source.IsReference() && dest.IsReference()) {
      string s = String.Format("_Cast<{0} *>({1})", dest.EmitTypeName(), val);
      ArrayType_3 at = dest as ArrayType_3;
      if (at != null) {
        GType_3 element_type = at.ElementType();
        if (element_type.IsReference())
          s = String.Format("({0})->CheckType(&typeid({1}))", s, element_type.EmitType());
      }
      return s;
    }

    if (source == GObject_3.type_ && !dest.IsReference())  // unboxing conversion
      return String.Format("_Unbox<{0} *>({1})->Value()", ((Class_3) dest).name_, val);

    if (!source.IsReference() && !dest.IsReference())
      return String.Format("static_cast<{0}>({1})", dest.EmitType(), val);

    Debug.Assert(false);
    return null;
  }

  public string EmitExplicit(GType_3 source, GType_3 dest) {
    return EmitExplicit(source, dest, Emit(), LosesOwnership());
  }

  public virtual string EmitArrow(GType_3 t, Member_3 m) {
    return String.Format("({0})->", EmitRef(t));
  }

  // Emit this expression as a local or field initializer, implicitly casting to [type].
  public void EmitAsInitializer(SourceWriter_3 w, GType_3 initializer_type, GType_3 type) {
    // For_3 owning variables, we must emit an initializer of the form "Foo var(val)" since
    // _Own has no copy constructor and hence GCC won't allow "Foo var = val".  For_3 other
    // variables either form is valid, but we emit the second form since it looks clearer.
    w.Write(type is Owning_3 ? "({0})" : " = {0}", Emit(initializer_type, type));
  }

  // Given a value retrieved from a variable, emit an accessor call if needed.
  protected string OwnSuffix(GType_3 t) {
    if (t is Owning_3)
      return LosesOwnership() ? ".Take_3()" : ".Get()";
    if (t == GString_3.type_ || Gel_3.program_.safe_ && t.IsReference() )
      return ".Get()";
    return "";
  }

  // Given a value returned from a function call, emit a wrapper and/or accessor call if needed.
  protected string Hold(GType_3 t, string s) {
    if (t == GString_3.type_)
      return s + ".Get()";
    if (t is Owning_3)
      switch (usage_) {
        case Usage_3.Used:  // does not lose ownership; we need a freeing wrapper
          return String.Format("{0}({1}).Get()", t.EmitType(), s);
        case Usage_3.LosesOwnership:
          return s;
        case Usage_3.Unused:  // a top-level owning expression
          return "delete " + s;
        default: Debug.Assert(false); break;
      }
    return s;
  }
}

class Literal_3 : Expression_3 {
  public readonly SimpleValue_3 ^value_;

  public Literal_3(SimpleValue_3 ^v) { value_ = v; }

  public override bool IsTrueLiteral() {
    GBool_3 b = value_ as GBool_3;
    return b != null && b.b_;
  }

  public override bool IsFalseLiteral() {
    GBool_3 b = value_ as GBool_3;
    return b != null && !b.b_;
  }

  public override GType_3 Check(Context_3 ctx) { return value_.Type(); }

  public override RValue_3 ^Eval(Env_3 env) { return value_.Copy(); }

  public override bool IsConstant() { return true; }

  public override string Emit() { return value_.Emit(); }
}

// An LValue_3 is an expression which can be assigned to: a Name_3, Dot_3, or Sub_3.
//
// In the control graph, an LValue_3 represents a read; if an LValue_3 is written then
// some other node (e.g. an Assign_3) will appear representing the write.
abstract class LValue_3 : Expression_3 {
  public override GType_3 Check(Context_3 ctx) {
    return Check(ctx, true, false, false);
  }

  public abstract override GType_3 Check(Context_3 ctx, bool read, bool write, bool type_ok);

  public abstract GType_3 StorageType();

  public virtual bool IsLocal() { return false; }
  public virtual bool IsLocal(Local_3 l) { return false; }

  public abstract PropertyOrIndexer_3 GetPropertyOrIndexer();

  public override Method_3 Calls() {
    PropertyOrIndexer_3 pi = GetPropertyOrIndexer();
    return pi == null ? null : pi.Getter();
  }

  public virtual void ReleaseAll(Context_3 ctx) { }

  // For_3 LValues, evaluation proceeds in two stages: the caller first calls Eval1(), then
  // passes the resulting values to EvalGet(), EvalSet() and/or EvalLocation().  This_3 lets
  // us evaluate the left side of an assignment expression before evaluating the right side,
  // and also lets us get and then set an indexer without evaluating its expression twice.

  public abstract void Eval1(Env_3 env, out RValue_3 ^v1, out RValue_3 ^v2);
  public abstract RValue_3 ^EvalGet(Env_3 env, RValue_3 ^v1, RValue_3 ^v2);
  public abstract void EvalSet(Env_3 env, RValue_3 ^v1, RValue_3 ^v2, RValue_3 ^val);
  public abstract Location_3 EvalLocation(Env_3 env, RValue_3 ^v1, RValue_3 ^v2);

  public override RValue_3 ^Eval(Env_3 env) {
    RValue_3 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalGet(env, val1, val2);
  }

  public void EvalSet(Env_3 env, RValue_3 ^v) {
    RValue_3 ^val1, val2;
    Eval1(env, out val1, out val2);
    EvalSet(env, val1, val2, v);
  }

  public Location_3 EvalLocation(Env_3 env) {
    RValue_3 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalLocation(env, val1, val2);
  }

  public abstract string EmitSet(string val);

  public abstract string EmitLocation();
}

class Name_3 : LValue_3 {
  public readonly string name_;

  protected Local_3 local_;
  protected LMember_3 field_;  // a field or property

  public Name_3(string n) { name_ = n; }

  public override bool IsLocal() { return local_ != null; }
  public override bool IsLocal(Local_3 l) { return local_ == l; }
  public override bool IsRefOutParameter() { return local_ is RefOutParameter_3; }

  public override bool IsConstant() {
    Debug.Assert(local_ != null || field_ != null);   // make sure we were already type checked
    return field_ is ConstField_3;
  }

  public override GType_3 Check(Context_3 ctx, bool read, bool write, bool type_ok) {
    local_ = ctx.FindVar(name_);
    if (local_ != null) {
      // For_3 reads, we add this Name_3 node to the flow graph; for writes,
      // the caller must add a node which defines this Name_3.
      if (read)
        if (AddControl(ctx))
          local_.AddUse(this);
      if (write)
        local_.SetMutable();
      return local_.ReadType();
    }

    GType_3 cl = type_ok ? ctx.program_.FindClass(name_) : null;
    field_ = (LMember_3) ctx.class_.Lookup(this, ctx.class_, false, MemberKind_3.Field_3, name_, null, cl == null);
    if (field_ != null) {
      if (!field_.CheckAccess(this, ctx, write, true, !ctx.IsStatic()))
        return null;
      if (read) {
        // Only property reads have side effects we need to register in the control graph.
        if (field_ is Property_3)
          AddControl(ctx);
      }
      return field_.Type().BaseType();
    }

    return cl;
  }

  public override int Kind() {
    if (local_ != null)
      return ExprKind_3.Local_3;
    if (field_ is Field_3)
      return ExprKind_3.Field_3;
    if (field_ is Property_3)
      return ExprKind_3.Property_3;
    Debug.Assert(field_ == null);
    return ExprKind_3.Type;
  }

  public override Local_3 GetLocal() { return local_; }

  public override GType_3 StorageType() { return local_ != null ? local_.Type() : field_.Type(); }

  public override bool Takes(Local_3 local) {
    return local_ == local && LosesOwnership() && local.Type() is Owning_3;
  }

  public override PropertyOrIndexer_3 GetPropertyOrIndexer() { return field_ as Property_3; }

  public override void Eval1(Env_3 env, out RValue_3 ^v1, out RValue_3 ^v2) { v1 = v2 = null; }

  public override RValue_3 ^EvalGet(Env_3 env, RValue_3 ^v1, RValue_3 ^v2) {
    if (LosesOwnership() && StorageType() is Owning_3)
      return local_ != null ? env.Take_3(local_) : field_.Take_3(env.this_);
    else return local_ != null ? env.Get(local_) : field_.Get(env.this_);
  }

  public override void EvalSet(Env_3 env, RValue_3 ^v1, RValue_3 ^v2, RValue_3 ^val) {
    if (local_ != null)
      env.Set(local_, val);
    else field_.Set((GObject_3) env.this_, val);
  }

  public override Location_3 EvalLocation(Env_3 env, RValue_3 ^v1, RValue_3 ^v2) {
    return local_ != null ? env.GetLocation(local_) : field_.GetLocation((GObject_3) env.this_);
  }

  public override string Emit() {
    if (local_ != null) {
      string s = local_.Emit();
      return local_.IsWrapper() ? s + OwnSuffix(local_.Type()) : s;
    }
    if (field_ != null)
      return field_.Emit() + OwnSuffix(field_.Type());
    return name_;
  }

  public override string EmitSet(string val) {
    if (local_ != null)
      return String.Format("{0} = {1}", local_.Emit(), val);
    Debug.Assert(field_ != null);
    return field_.EmitSet(val);
  }

  public override string EmitLocation() {
    if (local_ != null)
      return "&" + local_.Emit();
    if (field_ != null)
      return "&" + field_.Emit();
    return "&" + name_;
  }
}

class Parenthesized_3 : Expression_3 {
  Expression_3 ^expr_;

  public Parenthesized_3(Expression_3 ^e) { expr_ = e; }

  public override GType_3 Check(Context_3 ctx) { return expr_.Check(ctx); }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_3 ^Eval(Env_3 env) { return expr_.Eval(env); }

  public override string Emit() { return String.Format("({0})", expr_.Emit()); }
}

class PredefinedType_3 : Expression_3 {
  Class_3 type_;

  public PredefinedType_3(Class_3 type) { type_ = type; }

  public override GType_3 Check(Context_3 ctx) { Debug.Assert(false); return null; }

  public override GType_3 Check(Context_3 ctx, bool read, bool write, bool type_ok) {
    Debug.Assert(type_ok);
    return type_;
  }

  public override int Kind() {
    return ExprKind_3.Type;
  }

  public override RValue_3 ^Eval(Env_3 env) { Debug.Assert(false); return null; }

  public override string Emit() { return type_.name_; }
}

class Dot_3 : LValue_3 {
  Expression_3 ^expr_;  // set to null for a static invocation
  GType_3 expr_type_;
  string name_;

  LMember_3 field_;

  public Dot_3(Expression_3 ^expr, string name) { expr_ = expr; name_ = name; }

  public override bool IsConstant() {
    Debug.Assert(field_ != null);   // make sure we were already type checked
    return field_ is ConstField_3;
  }

  public override GType_3 Check(Context_3 ctx, bool read, bool write, bool type_ok) {
    expr_type_ = expr_.Check(ctx, true, false, true);
    if (expr_type_ == null)
      return null;
    bool is_static = (expr_.Kind() == ExprKind_3.Type);
    if (is_static)
      expr_ = null;
    else expr_.HoldRef(ctx);

    field_ = (LMember_3) expr_type_.Lookup(this, ctx.class_, expr_ is Base_3,
                                         MemberKind_3.Field_3, name_, null, true);
    if (field_ == null)
      return null;

    if (!field_.CheckAccess(this, ctx, write, is_static, !is_static))
      return null;

    if (read) {
      // Only property reads have side effects we need to register in the control graph.
      // (For_3 writes the caller, such as Assign_3, will add its own node.)
      if (field_ is Property_3)
        AddControl(ctx);
      if (expr_ != null)
        expr_.ReleaseRef(ctx);
    }

    return field_.Type().BaseType();
  }

  public override void ReleaseAll(Context_3 ctx) {
    if (expr_ != null)
      expr_.ReleaseRef(ctx);
  }

  public override int Kind() {
    if (field_ is Field_3)
      return ExprKind_3.Field_3;
    if (field_ is Property_3)
      return ExprKind_3.Property_3;
    Debug.Assert(false);
    return 0;
  }

  public override GType_3 StorageType() { return field_.Type(); }

  public override PropertyOrIndexer_3 GetPropertyOrIndexer() { return field_ as Property_3; }

  public override void Eval1(Env_3 env, out RValue_3 ^v1, out RValue_3 ^v2) {
    v1 = v2 = null;
    if (expr_ != null) {  // instance field
      v1 = expr_.Eval(env);
      if (v1 is Null_3) {
        Error("attempted to access field of null object");
        Gel_3.Exit();
      }
    }
  }

  public override RValue_3 ^EvalGet(Env_3 env, RValue_3 ^v1, RValue_3 ^v2) {
    GValue_3 obj = v1 == null ? null : v1.Get();
    return LosesOwnership() && field_.Type() is Owning_3 ? field_.Take_3(obj) : field_.Get(obj);
  }

  public override void EvalSet(Env_3 env, RValue_3 ^v1, RValue_3 ^v2, RValue_3 ^val) {
    GObject_3 obj = v1 == null ? null : (GObject_3) v1.Get();
    field_.Set(obj, val);
  }

  public override Location_3 EvalLocation(Env_3 env, RValue_3 ^v1, RValue_3 ^v2) {
    return field_.GetLocation((GObject_3) v1);
  }

  string EmitPrefix() {
    return expr_ != null ?
      expr_.EmitArrow(expr_type_, field_) :  // instance access
      field_.GetClass().name_ + "::";   // static access
  }

  public override string Emit() {
    string s = EmitPrefix() + field_.Emit();
    GType_3 t = field_.Type();
    return field_ is Property_3 ? Hold(t, s) : s + OwnSuffix(t);
  }

  public override string EmitSet(string val) {
    return EmitPrefix() + field_.EmitSet(val);
  }

  public override string EmitLocation() {
    return "&" + EmitPrefix() + field_.Emit();
  }
}

class Mode_3 {
  public const int In = 0,
                   Ref = 1,
                   Out = 2;

  public static string ToString(int mode) {
    switch (mode) {
      case In: return "";
      case Ref: return "ref ";
      case Out: return "out ";
      default: Debug.Assert(false); return null;
    }
  }
}

abstract class Argument_3 : Node_3 {
  protected GType_3 type_;

  public GType_3 Type() { return type_; }

  public abstract int GetMode();
  public string TypeString() { return Mode_3.ToString(GetMode()) + type_.ToString(); }

  public abstract bool Check(Context_3 ctx);
  public abstract void FinishCall(Context_3 ctx);

  public abstract void AddEval(ArrayList a, Env_3 env, GType_3 t);

  public abstract string Emit(GType_3 t);
}

class InArgument_3 : Argument_3 {
  public readonly Expression_3 ^expr_;

  public InArgument_3(Expression_3 ^expr) { expr_ = expr; }
  public InArgument_3(GType_3 type) { type_ = type; }

  public override int GetMode() { return 0; }

  public override bool Check(Context_3 ctx) {
    if (type_ == null)
      type_ = expr_.CheckAndHold(ctx);
    return type_ != null;
  }

  public override void FinishCall(Context_3 ctx) {
    expr_.ReleaseRef(ctx);
  }

  public override void AddEval(ArrayList a, Env_3 env, GType_3 t) {
    a.Add(expr_.Eval(env, t));
  }

  public override string Emit(GType_3 t) {
    return expr_.EmitRef(type_, t);
  }
}

class RefOutArgument_3 : Argument_3 {
  public readonly int mode_;
  public readonly LValue_3 ^lvalue_;

  public RefOutArgument_3(int mode, LValue_3 ^lvalue) { mode_ = mode; lvalue_ = lvalue; }

  public override int GetMode() { return mode_; }

  public override bool Check(Context_3 ctx) {
    type_ = lvalue_.Check(ctx, mode_ == Mode_3.Ref, true, false);
    if (type_ == null)
      return false;
    if (lvalue_.Kind() == ExprKind_3.Indexer_3) {
      Error("can't pass indexer as ref or out argument");
      return false;
    }
    return true;
  }

  public override void FinishCall(Context_3 ctx) {
    AddControl(ctx);
  }

  public override bool Sets(Local_3 local) { return lvalue_.IsLocal(local); }

  public override TypeSet_3 NodeDestroys() { return lvalue_.StorageType().VarDestroys(); }

  public GType_3 StorageType() { return lvalue_.StorageType(); }

  public override void AddEval(ArrayList a, Env_3 env, GType_3 t) {
    a.Add(new LocationRef_3(lvalue_.EvalLocation(env)));
  }

  public override string Emit(GType_3 t) { return lvalue_.EmitLocation(); }
}

class Invocation_3 : Expression_3 {
  Expression_3 ^obj_;    // may be null
  GType_3 obj_type_;
  string name_;
  ArrayList /* of Argument_3 */ ^arguments_;

  Method_3 method_;

  public Invocation_3(Expression_3 ^obj, string name, ArrayList ^arguments) {
    obj_ = obj; name_ = name; arguments_ = arguments;
  }

  public static Method_3 CheckInvoke(Node_3 caller, Context_3 ctx, bool through_base, GType_3 type,
                                   string name, ArrayList /* of Argument_3 */ arguments,
                                   int kind) {
    foreach (Argument_3 arg in arguments)
      if (!arg.Check(ctx))
        return null;

    // Add the caller to the graph; this node represents the invocation itself.
    caller.AddControl(ctx);

    // Now we can release temporary expressions and add control graph nodes representing
    // assignments to ref and out parameters.
    foreach (Argument_3 arg in arguments)
      arg.FinishCall(ctx);

    Method_3 m = (Method_3) type.Lookup(caller, ctx.class_, through_base, kind, name, arguments, true);
    if (m != null)
      for (int i = 0; i < m.parameters_.Count; ++i) {
        Parameter_3 p = m.Param(i);
        if (p.GetMode() == Mode_3.In) {
          InArgument_3 a = (InArgument_3) arguments[i];
          a.expr_.CheckLoseOwnership(a.Type(), p.Type());
        }
      }
    return m;
  }

  public override GType_3 Check(Context_3 ctx) {
    GType_3 t;
    bool is_class = false;  // true when calling a static method using a class name

    if (obj_ == null)
      t = ctx.class_;
    else {
      t = obj_type_ = obj_.Check(ctx, true, false, true);
      if (t == null)
        return null;
      if (obj_.Kind() == ExprKind_3.Type)
        is_class = true;
      else obj_.HoldRef(ctx);
    }

    method_ = CheckInvoke(this, ctx, obj_ is Base_3, t, name_, arguments_, MemberKind_3.Method_3);
    if (method_ == null)
      return null;

    if (method_ is Constructor_3) {
      Error("can't call constructor directly");
      return null;
    }

    if (obj_ == null) {
      if (!method_.IsStatic() && ctx.IsStatic()) {
        Error("can't call instance method in static context");
        return null;
      }
    } else {
      obj_.ReleaseRef(ctx);
      if (is_class) {
        if (!method_.IsStatic()) {
          Error("can't invoke non-static method through class name");
          return null;
        }
      } else {
        if (method_.IsStatic()) {
          Error("can't invoke static method through object");
          return null;
        }
      }
    }

    GType_3 ret = method_.ReturnType();
    if (ret is Owning_3)
      ctx.AddTemporary(this);
    return ret;
  }

  public override GType_3 TemporaryType() { return method_.ReturnType(); }

  public override Method_3 Calls() { return method_; }

  public static RValue_3 ^InvokeMethod(GValue_3 obj, Method_3 m, ArrayList /* of RValue_3 */ values,
                                    bool virtual_ok) {
    if (m.IsVirtual() && virtual_ok) {
      GType_3 t = obj.Type();
      m = (Method_3) t.FindMatchingMember(m, true);
      Debug.Assert(m != null);
    }
    return m.Invoke(obj, values);
  }

  public static RValue_3 ^CallMethod(Env_3 env, GValue_3 obj,
                                  Method_3 m, ArrayList /* of Argument_3 */ args,
                                  bool virtual_ok) {
    ArrayList /* of ValueOrLocation_3 */ ^values = new ArrayList();
    int i;
    for (i = 0 ; i < args.Count ; ++i) {
      Argument_3 a = (Argument_3) args[i];
      a.AddEval(values, env, m.Param(i).Type());
    }
    return InvokeMethod(obj, m, values, virtual_ok);
  }

  public RValue_3 ^Eval(Env_3 env, Expression_3 obj, Method_3 m, ArrayList /* of Argument_3 */ args) {
    RValue_3 ^r;
    GValue_3 v;
    if (m.IsStatic())
      v = null;
    else {
      if (obj == null)
        v = env.this_;
      else {
        r = obj.Eval(env);
        v = r.Get();
        if (v is Null_3) {
          Error("attempted to call method on null object");
          Gel_3.Exit();
        }
      }
    }

    return CallMethod(env, v, m, args, !(obj is Base_3));
  }

  public override RValue_3 ^Eval(Env_3 env) {
    return Eval(env, obj_, method_, arguments_);
  }

  public static string EmitArguments(Method_3 m, ArrayList /* of Argument_3 */ arguments) {
    StringBuilder ^sb = new StringBuilder();
    Debug.Assert(m.parameters_.Count == arguments.Count);
    for (int i = 0; i < arguments.Count; ++i) {
      if (i > 0)
        sb.Append(", ");
      Argument_3 a = (Argument_3)arguments[i];
      sb.Append(a.Emit(m.Param(i).Type()));
    }
    return sb.ToString();
  }

  public override string Emit() {
    StringBuilder ^sb = new StringBuilder();
    if (obj_ != null) {
      if (method_.IsStatic())
        sb.AppendFormat("{0}::", obj_.Emit());
      else if (obj_type_.IsReference())
        sb.Append(obj_.EmitArrow(obj_type_, method_));
      else sb.AppendFormat("({0})->", obj_.Emit(obj_type_, GObject_3.type_));   // box values
    }
    sb.AppendFormat("{0} ({1})", method_.name_, EmitArguments(method_, arguments_));
    return Hold(method_.ReturnType(), sb.ToString());
  }
}

// an expression of the form a[b]
class Sub_3 : LValue_3 {
  readonly Expression_3 ^base_;
  GType_3 base_type_;
  readonly Expression_3 ^index_;
  GType_3 index_type_;

  GType_3 element_type_;    // for array accesses; null for indexers
  Indexer_3 indexer_;

  public Sub_3(Expression_3 ^base_exp, Expression_3 ^index) { base_ = base_exp; index_ = index; }

  public override GType_3 Check(Context_3 ctx, bool read, bool write, bool type_ok) {
    base_type_ = base_.CheckAndHold(ctx);
    if (base_type_ == null)
      return null;

    index_type_ = index_.CheckAndHold(ctx);
    if (index_type_ == null)
      return null;

    if (read)
      ReleaseAll(ctx);

    ArrayType_3 at = base_type_.BaseType() as ArrayType_3;
    if (at != null) {
      if (!index_type_.CheckConvert(this, GInt_3.type_))
        return null;
      element_type_ = at.ElementType();
      return element_type_.BaseType();
    }

    ArrayList ^arguments = new ArrayList();
    arguments.Add(new InArgument_3(index_type_));

    indexer_ = (Indexer_3) base_type_.Lookup(this, ctx.class_, base_ is Base_3,
                                           MemberKind_3.Indexer_3, null, arguments, true);
    if (indexer_ == null)
      return null;

    if (read && !indexer_.CheckAssigning(this, ctx, false) ||
        write && !indexer_.CheckAssigning(this, ctx, true))
      return null;

    if (read)
      AddControl(ctx);

    return indexer_.Type();
  }

  public override void ReleaseAll(Context_3 ctx) {
    base_.ReleaseRef(ctx);
    index_.ReleaseRef(ctx);
  }

  public override int Kind() {
    return element_type_ != null ? ExprKind_3.Field_3 : ExprKind_3.Indexer_3;
  }

  public override GType_3 StorageType() {
    return element_type_ != null ? element_type_ : indexer_.Type();
  }

  public override PropertyOrIndexer_3 GetPropertyOrIndexer() { return indexer_; }

  public override void Eval1(Env_3 env, out RValue_3 ^v1, out RValue_3 ^v2) {
    v1 = base_.Eval(env);
    if (v1 is Null_3) {
      Error("attempted array or indexer access through null");
      Gel_3.Exit();
    }
    v2 = index_.Eval(env);
  }

  int Index(RValue_3 ^v) {
    // ++ We get an ownership error if we combine the following two lines into one; why?
    v = v.Get().Convert(ref v, GInt_3.type_);
    return ((GInt_3) v).i_;
  }

  public override RValue_3 ^EvalGet(Env_3 env, RValue_3 ^v1, RValue_3 ^v2) {
    if (indexer_ == null) {
      GArray_3 arr = (GArray_3) v1.Get();
      int i = Index(v2);
      return LosesOwnership() && element_type_ is Owning_3 ? arr.Take_3(i) : arr.Get(i);
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    return Invocation_3.InvokeMethod(v1.Get(), indexer_.Getter(), args, true);
  }

  public override void EvalSet(Env_3 env, RValue_3 ^v1, RValue_3 ^v2, RValue_3 ^val) {
    if (indexer_ == null) {
      ((GArray_3) v1.Get()).Set(Index(v2), val);
      return;
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    args.Add(val);
    Invocation_3.InvokeMethod(v1.Get(), indexer_.Setter(), args, true);
  }

  public override Location_3 EvalLocation(Env_3 env, RValue_3 ^v1, RValue_3 ^v2) {
    int i = ((GInt_3) v2).i_;
    return ((GArray_3) v1).GetLocation(i);
  }

  string EmitBase() {
    return base_.EmitArrow(base_type_, indexer_);
  }

  string EmitIndex() {
    return index_.Emit(index_type_, indexer_ != null ? indexer_.parameter_.Type() : GInt_3.type_);
  }

  public override string Emit() {
    string get = String.Format("{0}get_Item({1})", EmitBase(), EmitIndex());
    if (element_type_ != null) {
      get = get + OwnSuffix(element_type_);
      if (!element_type_.IsValue())
        get = String.Format("static_cast<{0} >({1})", element_type_.EmitExprType(), get);
      return get;
    } else return Hold(indexer_.Type(), get);
  }

  public override string EmitSet(string val) {
    return String.Format(element_type_ != null ? "{0}get_Item({1}) = {2}" : "{0}set_Item({1}, {2})",
       EmitBase(), EmitIndex(), val);
  }

  public override string EmitLocation() {
    return String.Format("{0}get_location({1})", EmitBase(), EmitIndex());
  }
}

class This_3 : Expression_3 {
  public override GType_3 Check(Context_3 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access this in a static context");
      return null;
    }
    return ctx.class_;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    return new Reference_3(env.this_);
  }

  public override string Emit() { return "this"; }
}

class Base_3 : Expression_3 {
  Class_3 parent_;

  public override GType_3 Check(Context_3 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access base in a static context");
      return null;
    }
    parent_ = ctx.class_.Parent();
    if (parent_ == null) {
      Error("can't access base: class has no parent");
      return null;
    }
    return parent_;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    return new Reference_3(env.this_);
  }

  public override string Emit() { return "this"; }

  public override string EmitArrow(GType_3 t, Member_3 m) {
    return m.GetClass().name_ + "::"; 
  }
}

class New_3 : Expression_3 {
  Expression_3 ^creator_;    // either a pool or null
  TypeExpr_3 ^type_expr_;
  ArrayList /* of Expression_3 */ ^arguments_;

  Class_3 class_;
  Constructor_3 constructor_;

  public New_3(Expression_3 ^creator, TypeExpr_3 ^expr, ArrayList ^arguments) {
    creator_ = creator;
    type_expr_ = expr;
    arguments_ = arguments;
  }

  GType_3 Type() {
    return creator_ == null ? (GType_3) class_.OwningType() : class_;
  }

  public override GType_3 TemporaryType() { return Type(); }    

  public override GType_3 Check(Context_3 ctx) {
    if (creator_ != null) {
      GType_3 c = creator_.Check(ctx);
      if (c == null)
        return null;
      if (!c.BaseType().IsSubtype(PoolClass_3.instance_)) {
        Error("object creator must be a pool");
        return null;
      }
    }
    GType_3 t = type_expr_.Resolve(ctx.program_);
    if (t == null)
      return null;
    class_ = (Class_3) t;
    if (class_.HasAttribute(Attribute_3.Abstract)) {
      Error("can't instantiate abstract class");
      return null;
    }
    if (creator_ != null) {
      class_.NeedDestroy(); // every pool-allocated class needs the _Destroy1 and _Destroy2 methods
      class_.SetVirtual();  // every pool-allocated class must be virtual
    }

    constructor_ = (Constructor_3) Invocation_3.CheckInvoke(this, ctx, false, class_,
                                      class_.name_, arguments_, MemberKind_3.Constructor_3);
    if (constructor_ == null)
      return null;

    GType_3 type = Type();
    if (type is Owning_3)
      ctx.AddTemporary(this);
    return type;
  }

  public override Method_3 Calls() { return constructor_; }

  public override RValue_3 ^Eval(Env_3 env) {
    GValue_3 ^obj = class_.New_3();
    Invocation_3.CallMethod(env, obj, constructor_, arguments_, false);
    return obj;
  }

  public override string Emit() {
    string args = Invocation_3.EmitArguments(constructor_, arguments_);

    return creator_ == null ?
      EmitAllocate(class_.name_, args, LosesOwnership()) :
      String.Format("new ({0}->Alloc(sizeof({1}))) {1}({2})", creator_.Emit(), class_.name_, args);
  }
}

class ArrayInitializer_3 : Expression_3 {
  public readonly ArrayList /* of Expression_3 */ ^initializers_;

  public ArrayInitializer_3(ArrayList ^initializers) { initializers_ = initializers; }

  public override GType_3 Check(Context_3 ctx) {
    Error("only static fields may have array initializers");
    return null;
  }

  public bool CheckElements(Context_3 ctx, GType_3 element_type) {
    foreach (Expression_3 e in initializers_)
      if (!e.CheckConstant() || !e.Check(ctx, element_type))
        return false;
    return true;
  }

  public override RValue_3 ^Eval(Env_3 env) { Debug.Assert(false); return null; }

  public GArray_3 ^Eval(ArrayType_3 type) {
    GArray_3 ^a = new GArray_3(type, initializers_.Count);
    for (int i = 0; i < initializers_.Count; ++i) {
      Expression_3 e = (Expression_3) initializers_[i];
      a.Set(i, e.Eval(Env_3.static_, type.ElementType()));
    }
    return a;
  }

  public override string Emit() { Debug.Assert(false); return null; }

  public void Emit(SourceWriter_3 w) {
    int count = initializers_.Count;
    int per_row = 12;

    w.Write("{ ");
    if (count > per_row) {    // format onto multiple rows
      w.WriteLine("");
      w.AddIndent();
      w.Indent();
    }
    for (int i = 0; i < count; ++i) {
      if (i > 0) {
        w.Write(", ");
        if (i % per_row == 0) {
          w.WriteLine("");
          w.Indent();
        }
      }
      Expression_3 e = (Expression_3) initializers_[i];
      SimpleValue_3 ^v = (SimpleValue_3) e.Eval(Env_3.static_);
      w.Write(v.Emit());
    }
    if (count > per_row) {
      w.SubIndent();
      w.WriteLine("");
    }
    w.Write(" }");
  }
}

class NewArray_3 : Expression_3 {
  TypeExpr_3 ^element_type_expr_;
  int dimensions_;
  ArrayType_3 ^array_type_;

  Expression_3 ^count_;

  public NewArray_3(TypeExpr_3 ^element_type_expr, int dimensions, Expression_3 ^count) {
    element_type_expr_ = element_type_expr;
    dimensions_ = dimensions;
    count_ = count;
  }

  GType_3 Type() {
    return (GType_3) array_type_.OwningType();
  }

  public override GType_3 TemporaryType() { return Type(); }

  public override GType_3 Check(Context_3 ctx) {
    if (element_type_expr_ is ArrayTypeExpr_3) {
      Error("syntax error in new expression");
      return null;
    }
    for (int i = 0; i < dimensions_; ++i)
      element_type_expr_ = new ArrayTypeExpr_3(take element_type_expr_);
    GType_3 element_type = element_type_expr_.Resolve(ctx.program_);
    if (element_type == null)
      return null;
    array_type_ = new ArrayType_3(element_type);

    if (!count_.Check(ctx, GInt_3.type_))
      return null;

    GType_3 t = Type();
    if (t is Owning_3)
      ctx.AddTemporary(this);
    return t;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    return new GArray_3(array_type_, count_.EvalInt(env));
  }

  public override string Emit() {
    GType_3 t = array_type_.ElementType();
    string array_type = GType_3.ConstructType(
      t is Owning_3 ? "_Array" : "_CopyableArray",
      t.EmitGenericType());
    string args = String.Format("&typeid({0}), {1}", t.EmitType(), count_.Emit());
    return EmitAllocate(array_type, args, LosesOwnership());
  }
}

abstract class Unary_3 : Expression_3 {
  protected Expression_3 ^exp_;

  protected Unary_3(Expression_3 ^e) { exp_ = e; }

  public override bool IsConstant() { return exp_.IsConstant(); }
}

// unary minus operator
class Minus_3 : Unary_3 {
  GType_3 type_;

  public Minus_3(Expression_3 ^e) : base(e) { }

  public override GType_3 Check(Context_3 ctx) {
    type_ = exp_.Check(ctx);
    if (type_ != GInt_3.type_ && type_ != GFloat_3.type_ && type_ != GDouble_3.type_) {
      Error("- operator cannot be applied to value of type {0}", type_);
      return null;
    }
    return type_;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    if (type_ == GInt_3.type_) {
    int i = exp_.EvalInt(env);
    return new GInt_3(-i);
  }
    if (type_ == GFloat_3.type_) {
      float f = exp_.EvalFloat(env);
      return new GFloat_3(-f);
    }
    if (type_ == GDouble_3.type_) {
      double d = exp_.EvalDouble(env);
      return new GDouble_3(-d);
    }
    Debug.Assert(false);
    return null;
  }

  public override string Emit() { return "-" + exp_.Emit(); }
}

class Not_3 : Unary_3 {
  public Not_3(Expression_3 ^e) : base(e) { }

  public override GType_3 Check(Context_3 ctx) {
    return exp_.Check(ctx, GBool_3.type_) ? GBool_3.type_ : null;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    bool b = exp_.EvalBool(env);
    return new GBool_3(!b);
  }

  public override string Emit() { return "!" + exp_.Emit(); }
}

// the bitwise complement (~) operator
class Complement_3 : Unary_3 {
  public Complement_3(Expression_3 ^e) : base(e) { }

  public override GType_3 Check(Context_3 ctx) {
    return exp_.Check(ctx, GInt_3.type_) ? GInt_3.type_ : null;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    int i = exp_.EvalInt(env);
    return new GInt_3(~i);
  }

  public override string Emit() { return "~" + exp_.Emit(); }
}

class IncDec_3 : Expression_3 {
  bool pre_;    // true for pre-increment/decrement; false for post-increment/decrement
  bool inc_;
  LValue_3 ^lvalue_;

  public IncDec_3(bool pre, bool inc, LValue_3 ^lvalue) { pre_ = pre; inc_ = inc; lvalue_ = lvalue; }

  public override GType_3 Check(Context_3 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    GType_3 t = lvalue_.Check(ctx, true, true, false);
    if (t == null)
      return null;
    if (lvalue_.Kind() == ExprKind_3.Indexer_3) {
      Error("++ and -- can't yet operate on indexers");
      return null;
    }
    if (t != GInt_3.type_) {
      Error("++ and -- can operate only on integers");
      return null;
    }
    return GInt_3.type_;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    Location_3 loc = lvalue_.EvalLocation(env);
    GInt_3 ^i = (GInt_3) take loc.value_;
    loc.value_ = new GInt_3(inc_ ? i.i_ + 1 : i.i_ - 1);
    return pre_ ? ((GInt_3) loc.value_).Copy() : i;
  }

  string EmitOp() { return inc_ ? "++" : "--"; }

  public override string Emit() {
    return pre_ ? EmitOp() + lvalue_.Emit() : lvalue_.Emit() + EmitOp();
  }
}

abstract class Conversion_3 : Expression_3 {
  protected Expression_3 ^expr_;
  protected TypeExpr_3 ^type_expr_;

  protected GType_3 from_base_;
  protected GType_3 to_type_, to_base_;

  protected Conversion_3(Expression_3 ^expr, TypeExpr_3 ^type_expr) {
    expr_ = expr; type_expr_ = type_expr;
  }

  protected bool CheckConversion(Context_3 ctx, bool subtype_only) {
    GType_3 from = expr_.Check(ctx);
    if (from == null)
      return false;
    from_base_ = from.BaseType();

    to_base_ = type_expr_.Resolve(ctx.program_);
    if (to_base_ == null)
      return false;
    if (!to_base_.IsValue() &&
       (from is Owning_3 || from_base_.IsValue()))
      to_type_ = to_base_.OwningType();
    else to_type_ = to_base_;

    if (!from.CanConvertExplicit(to_type_, subtype_only)) {
      Error("can't convert from {0} to {1}", from_base_, to_base_);
      return false;
    }
    return true;
  }
}

class Cast_3 : Conversion_3 {
  public Cast_3(Expression_3 ^expr, TypeExpr_3 ^type_expr) : base(expr, type_expr) { }

  public override Local_3 GetLocal() { return expr_.GetLocal(); }
  
  public override GType_3 Check(Context_3 ctx) {
    return CheckConversion(ctx, false) ? to_type_ : null;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_3.Local_3 ? ExprKind_3.Local_3 : ExprKind_3.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_3 ^Eval(Env_3 env) {
    RValue_3 ^r = expr_.Eval(env);
    return r.Get().ConvertExplicit(ref r, to_base_);
  }

  public override string Emit() {
    return expr_.EmitExplicit(from_base_, to_type_);
  }
}

class Binary_3 : Expression_3 {
  int op_;
  Expression_3 ^left_, right_;
  GType_3 left_type_, right_type_;
  GType_3 type_;

  const int CONCATENATE = 0;

  public Binary_3(Expression_3 ^left, int op, Expression_3 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public static GType_3 Promote(Syntax_3 caller, GType_3 left, int op, GType_3 right) {
    if (left.CanConvert(GInt_3.type_) && right.CanConvert(GInt_3.type_))
      return GInt_3.type_;
    if (left.CanConvert(GFloat_3.type_) && right.CanConvert(GFloat_3.type_))
      return GFloat_3.type_;
    if (left.CanConvert(GDouble_3.type_) && right.CanConvert(GDouble_3.type_))
      return GDouble_3.type_;
    caller.Error("can't apply operator {0} to operands of type {1} and {2}", OpName(op), left, right);
    return null;
  }

  bool CheckIntArgs() {
    if (left_type_.CheckConvert(this, GInt_3.type_) && right_type_.CheckConvert(this, GInt_3.type_)) {
      type_ = GInt_3.type_;
      return true;
    }
    return false;
  }

  public override GType_3 Check(Context_3 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);

    if (op_ == '+' && (left_type_ == GString_3.type_ || right_type_ == GString_3.type_)) {
      op_ = CONCATENATE;

      // If_3 we'll be calling ToString() on a class, ensure that it will inherit from
      // Object in generated code.
      if (left_type_ != GString_3.type_)
        left_type_.CanConvert(GObject_3.type_);
      if (right_type_ != GString_3.type_)
        right_type_.CanConvert(GObject_3.type_);

      return GString_3.type_;
    }

    switch (op_) {
      case '*':
      case '/':
      case '+':
      case '-':
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_;

      case '%':
      case Parser.OP_LEFT_SHIFT:
      case Parser.OP_RIGHT_SHIFT:
        return CheckIntArgs() ? GInt_3.type_ : null;

      case '&':
      case '|':
        if (left_type_ == GBool_3.type_ && right_type_ == GBool_3.type_)
          type_ = GBool_3.type_;
        else {
          if (!CheckIntArgs())
            return null;
          type_ = GInt_3.type_;
        }
        return type_;

      case '<':
      case Parser.OP_LE:
      case '>':
      case Parser.OP_GE:
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_ == null ? null : GBool_3.type_;

      default:
        Debug.Assert(false);
        return null;
    }
  }

  public static GBool_3 ^BoolOp(bool x, int op, bool y) {
    switch (op) {
      case '&': return new GBool_3(x & y);
      case '|': return new GBool_3(x | y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_3 ^IntOp(int x, int op, int y) {
    switch (op) {
      case '*': return new GInt_3(x * y);
      case '/': return new GInt_3(x / y);
      case '%': return new GInt_3(x % y);
      case '+': return new GInt_3(x + y);
      case '-': return new GInt_3(x - y);
      case Parser.OP_LEFT_SHIFT: return new GInt_3(x << y);
      case Parser.OP_RIGHT_SHIFT: return new GInt_3(x >> y);
      case '&': return new GInt_3(x & y);
      case '|': return new GInt_3(x | y);
      case '<': return new GBool_3(x < y);
      case Parser.OP_LE: return new GBool_3(x <= y);
      case '>': return new GBool_3(x > y);
      case Parser.OP_GE: return new GBool_3(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_3 ^FloatOp(float x, int op, float y) {
    switch (op) {
      case '*': return new GFloat_3(x * y);
      case '/': return new GFloat_3(x / y);
      case '+': return new GFloat_3(x + y);
      case '-': return new GFloat_3(x - y);
      case '<': return new GBool_3(x < y);
      case Parser.OP_LE: return new GBool_3(x <= y);
      case '>': return new GBool_3(x > y);
      case Parser.OP_GE: return new GBool_3(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_3 ^DoubleOp(double x, int op, double y) {
    switch (op) {
      case '*': return new GDouble_3(x * y);
      case '/': return new GDouble_3(x / y);
      case '+': return new GDouble_3(x + y);
      case '-': return new GDouble_3(x - y);
      case '<': return new GBool_3(x < y);
      case Parser.OP_LE: return new GBool_3(x <= y);
      case '>': return new GBool_3(x > y);
      case Parser.OP_GE: return new GBool_3(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public override RValue_3 ^Eval(Env_3 env) {
    if (op_ == CONCATENATE)
      return new GString_3(left_.Eval(env).ToString() + right_.Eval(env).ToString());

    if (type_ == GBool_3.type_)
      return BoolOp(left_.EvalBool(env), op_, right_.EvalBool(env));
    if (type_ == GInt_3.type_)
      return IntOp(left_.EvalInt(env), op_, right_.EvalInt(env));
    if (type_ == GFloat_3.type_)
      return FloatOp(left_.EvalFloat(env), op_, right_.EvalFloat(env));
    if (type_ == GDouble_3.type_)
      return DoubleOp(left_.EvalDouble(env), op_, right_.EvalDouble(env));

    Debug.Assert(false);
    return null;
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  static string OpName(int op) {
    switch (op) {
      case Parser.OP_LEFT_SHIFT: return "<<";
      case Parser.OP_RIGHT_SHIFT: return ">>";
      case Parser.OP_LE: return "<=";
      case Parser.OP_GE: return ">=";
      default: return ((char) op).ToString();
    }
  }

  public override string Emit() {
    if (op_ == CONCATENATE)
      return Hold(GString_3.type_,
        String.Format("String::_Concat({0}, {1})",
          left_.EmitRef(left_type_, GObject_3.type_), right_.Emit(right_type_, GObject_3.type_)));

    return String.Format("{0} {1} {2}",
      left_.EmitRef(left_type_), OpName(op_), right_.Emit() );
  }
}

class Equality_3 : Expression_3 {
  bool equal_;    // true for ==, false for !=
  Expression_3 ^left_, right_;
  GType_3 left_type_, right_type_, type_;

  public Equality_3(Expression_3 ^left, int op, Expression_3 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_EQUAL: equal_ = true; break;
      case Parser.OP_NE: equal_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_3 Check(Context_3 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);
    if (left_type_.IsReference() != right_type_.IsReference()) {
      Error("can't compare types {0} and {1}", left_type_, right_type_);
      return null;
    }
    type_ = left_type_.BaseType().CommonType(this, right_type_.BaseType());
    return type_ == null ? null : GBool_3.type_;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    RValue_3 ^left = left_.Eval(env, type_);
    RValue_3 ^right = right_.Eval(env, type_);
    bool eq = left.Get().DefaultEquals(right.Get());
    return new GBool_3(equal_ ? eq : !eq);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    string emit_left = left_.EmitRef(left_type_);
    string emit_right = right_.Emit();
    if (type_ == GString_3.type_)
      return String.Format("{0}String::_Equals({1}, {2})",
                           equal_ ? "" : "!", emit_left, emit_right);
    return String.Format("{0} {1} {2}", emit_left, equal_ ? "==" : "!=", emit_right);
  }
}

class Is_3 : Conversion_3 {
  public Is_3(Expression_3 ^expr, TypeExpr_3 ^type_expr) : base(expr, type_expr) { }

  public override GType_3 Check(Context_3 ctx) {
    return CheckConversion(ctx, true) ? GBool_3.type_ : null;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    RValue_3 ^r = expr_.Eval(env);
    GValue_3 v = r.Get();
    return new GBool_3(!(v is Null_3) && v.Type().IsSubtype(to_base_));
  }

  public override string Emit() {
    if (from_base_.IsReference()) {
      Class_3 c = (Class_3) to_base_;
      return String.Format("dynamic_cast<{0} *>({1}) != 0", c.name_, expr_.Emit());
    }
    return to_base_ == from_base_ || to_base_ == GObject_3.type_ ? "true" : "false";
  }
}

class As_3 : Conversion_3 {
  public As_3(Expression_3 ^expr, TypeExpr_3 ^type_expr) : base(expr, type_expr) { }

  public override Local_3 GetLocal() { return expr_.GetLocal(); }

  public override GType_3 Check(Context_3 ctx) {
    if (!CheckConversion(ctx, true))
      return null;
    if (!to_base_.IsReference()) {
      Error("as operator must convert to reference type");
      return null;
    }
    return to_type_;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_3.Local_3 ? ExprKind_3.Local_3 : ExprKind_3.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_3 ^Eval(Env_3 env) {
    RValue_3 ^r = expr_.Eval(env);
    return r.Get().Type().IsSubtype(to_base_) ? r : Null_3.Instance.Copy();
  }

  public override string Emit() {
    if (from_base_.CanConvert(to_base_))
      return expr_.Emit(from_base_, to_base_);
    Class_3 c = (Class_3) to_base_;
    return String.Format("dynamic_cast<{0} *>({1})", c.name_, expr_.Emit());
  }
}

// a && or || operator
class LogicalOp_3 : Expression_3 {
  bool and_;  // true => &&, false => ||
  Expression_3 ^left_, right_;
  Joiner_3 ^join_ = new Joiner_3();

  public LogicalOp_3(Expression_3 ^left, int op, Expression_3 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_AND: and_ = true; break;
      case Parser.OP_OR: and_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_3 Check(Context_3 ctx) {
    if (!left_.Check(ctx, GBool_3.type_))
      return null;

    join_.Join(ctx.Prev());
    if (!right_.Check(ctx, GBool_3.type_))
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    return GBool_3.type_;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    bool left = left_.EvalBool(env);
    bool b = and_ ? left && right_.EvalBool(env) : left || right_.EvalBool(env);
    return new GBool_3(b);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    return String.Format("{0} {1} {2}", left_.Emit(), and_ ? "&&" : "||", right_.Emit());
  }

}

// the ?: operator
class Conditional_3 : Expression_3 {
  Expression_3 ^condition_;
  Expression_3 ^if_true_, if_false_;

  GType_3 true_type_, false_type_;
  GType_3 type_;
  Joiner_3 ^join_ = new Joiner_3();

  public Conditional_3(Expression_3 ^condition, Expression_3 ^if_true, Expression_3 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override GType_3 Check(Context_3 ctx) {
    if (!condition_.Check(ctx, GBool_3.type_))
      return null;

    Control_3 c = ctx.Prev();

    true_type_ = if_true_.Check(ctx);
    if (true_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    false_type_ = if_false_.Check(ctx);
    if (false_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    type_ = true_type_.CommonType(this, false_type_);
    return type_;
  }

  public override int Kind() {
    return if_true_.Kind() == ExprKind_3.Local_3 && if_false_.Kind() == ExprKind_3.Local_3 ? ExprKind_3.Local_3 : ExprKind_3.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    if_true_.LoseOwnership();
    if_false_.LoseOwnership();
  }

  public override RValue_3 ^Eval(Env_3 env) {
    return condition_.EvalBool(env) ? if_true_.Eval(env, type_) : if_false_.Eval(env, type_);
  }

  public override string Emit() {
    return String.Format("{0} ? {1} : {2}", condition_.Emit(),
                         if_true_.Emit(true_type_, type_), if_false_.Emit(false_type_, type_));
  }
}

class Assign_3 : Expression_3 {
  LValue_3 ^left_;
  Expression_3 ^right_;

  GType_3 left_type_, right_type_;

  public Assign_3(LValue_3 ^left, Expression_3 ^right) {
    left_ = left; right_ = right;
  }

  public static bool CheckAssign(Syntax_3 caller, GType_3 left_type, Expression_3 right, GType_3 right_type) {
    if (!right_type.CheckConvert(caller, left_type,
      right.Kind() == ExprKind_3.Local_3 ? ConversionContext_3.AssignVar : ConversionContext_3.Other))
      return false;
    right.CheckLoseOwnership(right_type, left_type);
    return true;
  }

  public override GType_3 Check(Context_3 ctx) {
    left_type_ = left_.Check(ctx, false, true, false);
    if (left_type_ == null)
      return null;

    right_type_ = right_.Check(ctx, true, false, false);
    if (right_type_ == null || !CheckAssign(this, left_.StorageType(), right_, right_type_))
      return null;
    right_.HoldRef(ctx);

    AddControl(ctx);
    left_.ReleaseAll(ctx);
    right_.ReleaseRef(ctx);
    return left_type_;
  }

  public override Method_3 Calls() {
    PropertyOrIndexer_3 pi = left_.GetPropertyOrIndexer();
    return pi == null ? null : pi.Setter();
  }

  public override bool Sets(Local_3 local) { return left_.IsLocal(local); }

  public override TypeSet_3 NodeDestroys() {
    return left_.GetPropertyOrIndexer() != null ? TypeSet_3.empty_ : left_.StorageType().VarDestroys();
  }

  public override RValue_3 ^Eval(Env_3 env) {
    RValue_3 ^v1, v2;
    left_.Eval1(env, out v1, out v2);
    RValue_3 ^val = right_.Eval(env, left_type_);
    RValue_3 ^ret = val.CopyRef();
    left_.EvalSet(env, v1, v2, val);
    return ret;
  }

  public override string Emit() {
    return left_.EmitSet(right_.EmitRef(right_type_, left_type_));
  }
}

// a compound assignment operator such as += or -=
class CompoundAssign_3 : Expression_3 {
  LValue_3 ^left_;
  int op_;
  Expression_3 ^right_;

  GType_3 type_;

  public CompoundAssign_3(LValue_3 ^left, int op, Expression_3 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public override GType_3 Check(Context_3 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    type_ = left_.Check(ctx, true, true, false);
    if (type_ == null)
      return null;
    if (left_.Kind() == ExprKind_3.Indexer_3) {
      Error("compound assignments don't yet work on indexers");
      return null;
    }
    if (type_ == GBool_3.type_ && (op_ == '&' || op_ == '|')) {
      if (!right_.Check(ctx, GBool_3.type_))
        return null;
      return type_;
    }
    if (type_ != GInt_3.type_ && type_ != GFloat_3.type_ && type_ != GDouble_3.type_) {
      Error("compound assignment operator {0}= can't operate on object of type {1}", (char) op_, type_);
      return null;
    }
    if (!right_.Check(ctx, type_))
      return null;
    return type_;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    Location_3 loc = left_.EvalLocation(env);
    if (type_ == GBool_3.type_) {
      bool x = ((GBool_3) loc.value_).b_;
      bool y = right_.EvalBool(env);
      loc.value_ = Binary_3.BoolOp(x, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GInt_3.type_) {
      GInt_3 x = (GInt_3) loc.value_;
      int y = right_.EvalInt(env);
      loc.value_ = Binary_3.IntOp(x.i_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GFloat_3.type_) {
      GFloat_3 x = (GFloat_3) loc.value_;
      float y = right_.EvalFloat(env);
      loc.value_ = Binary_3.FloatOp(x.f_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GDouble_3.type_) {
      GDouble_3 x = (GDouble_3) loc.value_;
      double y = right_.EvalDouble(env);
      loc.value_ = Binary_3.DoubleOp(x.d_, op_, y);
      return loc.value_.CopyRef();
    } else {
      Debug.Assert(false);
      return null;
    }
  }

  public override string Emit() {
    return String.Format("{0} {1}= {2}", left_.Emit(), (char) op_, right_.Emit());
  }
}

class Take_3 : Expression_3 {
  LValue_3 ^exp_;
  Owning_3 type_;

  public Take_3(LValue_3 ^exp) { exp_ = exp; }

  public override GType_3 Check(Context_3 ctx) {
    GType_3 t = exp_.Check(ctx);
    if (t == null)
      return null;
    type_ = exp_.StorageType() as Owning_3;
    if (type_ == null) {
      Error("take must be applied to owning pointer");
      return null;
    }
    exp_.LoseOwnership();
    ctx.AddTemporary(this);
    return type_;
  }

  public override GType_3 TemporaryType() { return type_; }

  public override RValue_3 ^Eval(Env_3 env) {
    RValue_3 ^v = exp_.Eval(env);
    exp_.EvalSet(env, Null_3.Instance.Copy());
    return v;
  }

  public override string Emit() {
    return Hold(exp_.StorageType(), exp_.Emit());
  }
}

abstract class Statement_3 : Node_3 {
  public abstract bool Check(Context_3 ctx);
  public abstract RValue_3 ^Eval(Env_3 env);

  public abstract void Emit(SourceWriter_3 w);

  public virtual void EmitEmbedded(SourceWriter_3 w) {
    w.WriteLine("");
    w.AddIndent();
    w.Indent();
    Emit(w);
    w.SubIndent();
  }

  public virtual void EmitInExistingBlock(SourceWriter_3 w) {
    w.Indent();
    Emit(w);
  }
}

class StatementList_3 {
  public readonly ArrayList /* of Statement_3 */ ^statements_ = new ArrayList();

  public void Add(Statement_3 ^s) { statements_.Add(s); }

  public bool Check(Context_3 ctx) {
    bool ok = true;
    foreach (Statement_3 s in statements_)
      ok &= s.Check(ctx);
    return ok;
  }

  public RValue_3 ^Eval(Env_3 env) {
    foreach (Statement_3 s in statements_) {
      RValue_3 ^v = s.Eval(env);
      if (v != null)
        return v;
    }
    return null;
  }

  public void Emit(SourceWriter_3 w) {
    foreach (Statement_3 s in statements_) {
      w.Indent();
      s.Emit(w);
    }
  }
}

class EmptyStatement_3 : InlineStatement_3 {
  public EmptyStatement_3() { }

  public override bool Check(Context_3 ctx) { return true; }
  public override RValue_3 ^Eval(Env_3 env) { return null; }
  public override void EmitInline(SourceWriter_3 w) { }

  public static readonly EmptyStatement_3 ^instance_ = new EmptyStatement_3();
}

// A Scoped_3 is a statement defining one or more local variables.  If_3 a Scoped_3 appears in the
// control graph, then it destroys those variables when traversed.
abstract class Scoped_3 : Statement_3 {
  protected Local_3 start_;   // the first local outside this statement
  protected Local_3 top_;     // the top local defined inside this statement

  TypeSet_3 ^destroys_;

  protected void SetStartVar(Context_3 ctx) { start_ = top_ = ctx.var_; }
  protected void SetTopVar(Context_3 ctx) { top_ = ctx.var_; }

  public Local_3 GetStart() { return start_; }
  public Local_3 GetTop() { return top_; }

  public override TypeSet_3 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_3();
    for (Local_3 l = top_; l != start_; l = l.next_)
        destroys_.Add(l.Type().VarDestroys());
    }
    return destroys_;
  }
}

class Block_3 : Scoped_3 {
  public readonly StatementList_3 ^list_;

  public Block_3(StatementList_3 ^list) { list_ = list; }

  public bool Absent() { return list_ == null; }

  public override bool Check(Context_3 ctx) {
    Context_3 ^ctx1 = new Context_3(ctx);   // don't pass declarations outside block
    SetStartVar(ctx1);

    if (!list_.Check(ctx1))
      return false;

    SetTopVar(ctx1);

    // Add this Block_3 to the control graph; this represents the destruction of variables
    // within the block at block exit.
    AddControl(ctx1);

    return true;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    return list_.Eval(new Env_3(env));
  }

  public static Block_3 ^EmptyBlock() { return new Block_3(new StatementList_3()); }

  public override void Emit(SourceWriter_3 w) {
    w.OpenBrace();
    list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitEmbedded(SourceWriter_3 w) {
    w.Write(" ");
    Emit(w);
  }

  public override void EmitInExistingBlock(SourceWriter_3 w) {
    list_.Emit(w);
  }
}

class MemberKind_3 {
  public const int
    Field_3 = 0,
    Method_3 = 1,
    Property_3 = 2,
    Indexer_3 = 3,
    Constructor_3 = 4;
}

class Named_3 : Node_3 {
  public readonly TypeExpr_3 ^type_expr_;   // may be null for certain objects such as constructors
  protected GType_3 type_;

  public readonly string name_;

  public Named_3(TypeExpr_3 ^type_expr, string name) {
    type_expr_ = type_expr;
    name_ = name;
  }

  public GType_3 Type() { return type_; }

  public virtual bool Resolve(Program_3 program) {
    if (type_expr_ == null || type_ != null)
      return true;
    type_ = type_expr_.Resolve(program);
    return type_ != null;
  }
}

abstract class Member_3 : Named_3 {
  protected Class_3 class_;    // containing class

  public readonly int attributes_;

  protected Member_3(int attributes, TypeExpr_3 ^type_expr, string name) : base(type_expr, name) {
    attributes_ = attributes;
  }

  public abstract int Kind();

  public static string ToString(int kind) {
    switch (kind) {
      case MemberKind_3.Field_3: return "field";
      case MemberKind_3.Method_3: return "method";
      case MemberKind_3.Property_3: return "property";
      case MemberKind_3.Indexer_3: return "indexer";
      case MemberKind_3.Constructor_3: return "constructor";
      default: Debug.Assert(false); return null;
    }
  }

  public string KindString() { return ToString(Kind()); }

  protected abstract int ValidAttributes();

  public Class_3 GetClass() { return class_; }
  public void SetClass(Class_3 cl) { class_ = cl; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public bool IsOverride() { return HasAttribute(Attribute_3.Override); }

  public bool IsProtected() { return HasAttribute(Attribute_3.Protected); }

  public bool IsPublic() { return HasAttribute(Attribute_3.Public); }

  public bool IsPrivate() { return !HasAttribute(Attribute_3.Public | Attribute_3.Protected); }

  public bool IsVirtual() {
    return HasAttribute(Attribute_3.Virtual | Attribute_3.Abstract | Attribute_3.Override);
  }

  static ArrayList ^empty_ = new ArrayList();

  public virtual ArrayList /* of Parameter_3 */ Parameters() { return empty_; }

  public Parameter_3 Param(int i) {
    return (Parameter_3) Parameters()[i];
  }

  public bool IsAccessible(Class_3 from_class, GType_3 through_type, bool through_base) {
    if (IsPublic())
      return true;

    // In GEL2 (as in C# and C++), a class [from_class] can access a protected member of
    // a class C only if [from_class] is a subtype of C and the access is
    // through a subtype of [from_class].  See e.g. C# 3.5.3 "Protected Access for Instance Members".
    if (IsProtected())
      return through_base || from_class.IsSubtype(class_) && through_type.IsSubtype(from_class);

    // default private access
    return from_class == class_;
  }

  public static bool MatchKind(int kind1, int kind2) {
    return kind1 == kind2 ||
           kind1 == MemberKind_3.Field_3 && kind2 == MemberKind_3.Property_3 ||
           kind1 == MemberKind_3.Property_3 && kind2 == MemberKind_3.Field_3;
  }

  public bool MatchSignature(Member_3 m) {
    if (!MatchKind(Kind(), m.Kind()))
      return false;

    if (name_ != m.name_ || Parameters().Count != m.Parameters().Count)
      return false;

    int i = 0;
    foreach (Parameter_3 p in m.Parameters()) {
      Parameter_3 q = Param(i);
      if (!p.Match(q))
        return false;
      ++i;
    }
    return true;
  }

  public bool IsApplicable(ArrayList arguments, out int mismatches) {
    mismatches = 0;
    if (Parameters().Count != arguments.Count)
      return false;
    int i = 0;
    foreach (Argument_3 a in arguments) {
      if (!Param(i).CanReceive(a))
        ++mismatches;
      ++i;
    }
    return true;
  }

  public void ReportMismatches(Syntax_3 caller, ArrayList arguments) {
    Debug.Assert(Parameters().Count == arguments.Count);
    int i = 0;
    foreach (Argument_3 a in arguments) {
      Parameter_3 p = Param(i);
      if (!p.CanReceive(a))
        caller.Error("argument {0}: can't convert from {1} to {2}", i + 1, a.TypeString(), p.TypeString());
      ++i;
    }
  }

  protected virtual void AddOverride(Member_3 m) { }

  bool CheckOverride(Context_3 ctx) {
    Class_3 parent = ctx.class_.Parent();
    Member_3 m = parent != null ? parent.FindMatchingMember(this, false) : null;
    if (m != null) {
      if (this is Field_3) {
        Error("can't define field with same name as field/property in superclass");
        return false;
      }
      if (m is Field_3) {
        Error("can't define property with same name as field in superclass");
        return false;
      }
      if (!HasAttribute(Attribute_3.Override)) {
        Error("must use override keyword to override superclass {0}", KindString());
        return false;
      }
      if (HasAttribute(Attribute_3.Virtual)) {
        Error("{0} with override or abstract keyword cannot be marked virtual", KindString());
        return false;
      }
      if (!m.IsVirtual()) {
        Error("attempting to override non-virtual {0}", KindString());
        return false;
      }
      if (!m.Type().Equals(Type())) {
        Error("can't override {0} with different return type", KindString());
        return false;
      }
      if (m.IsPublic() != IsPublic()) {
        Error("override {0} must have same accessibility as {0} it overrides", KindString());
        return false;
      }
      m.AddOverride(this);
    } else if (HasAttribute(Attribute_3.Override)) {
      Error("can't find {0} to override", KindString());
      return false;
    }
    return true;
  }

  bool CheckAccessibility() {
    int n = 0;
    if ((attributes_ & Attribute_3.Private) != 0)
      ++n;
    if ((attributes_ & Attribute_3.Protected) != 0)
      ++n;
    if ((attributes_ & Attribute_3.Public) != 0)
      ++n;
    if (n > 1) {
      Error("only one access level (private, protected, public) may be specified");
      return false;
    }

    if (IsVirtual() && IsPrivate()) {
      Error("a virtual or abstract {0} may not be private", KindString());
      return false;
    }

    return true;
  }

  public virtual bool Check(Context_3 ctx) {
    if (!AttributeUtil_3.CheckOnly(attributes_, ValidAttributes())) {
      Error("illegal {0} attribute", KindString());
      return false;
    }

    if (HasAttribute(Attribute_3.Abstract) && !ctx.class_.HasAttribute(Attribute_3.Abstract)) {
      Error("an abstract {0} can be defined only in an abstract class", KindString());
      return false;
    }

    if (name_ == class_.name_ && !(this is Constructor_3)) {
      Error("{0} cannot have same name as enclosing class", KindString());
      return false;
    }

    if (class_.GetMatchingMember(this) != this) {
      Error("{0} {1} appears twice in same class", KindString(), name_ != null ? name_ : "");
      return false;
    }

    return CheckOverride(ctx) && CheckAccessibility();
  }
}

// a member which represents a storage location: a field, property, or indexer
abstract class LMember_3 : Member_3 {
  protected LMember_3(int attributes, TypeExpr_3 ^type_expr, string name)
    : base(attributes, type_expr, name) { }

  public bool IsConstOrStatic() {
    return HasAttribute(Attribute_3.Const | Attribute_3.Static);
  }

  protected bool CheckStatic(Syntax_3 caller, bool static_ok, bool instance_ok) {
    if (!static_ok && IsConstOrStatic()) {
      caller.Error("{0} {1} is static", KindString(), name_);
      return false;
    }
    if (!instance_ok && !IsConstOrStatic()) {
      caller.Error("{0} {1} is not static", KindString(), name_);
      return false;
    }
    return true;
  }

  public abstract bool CheckAssigning(Syntax_3 caller, Context_3 ctx, bool assigning);

  public bool CheckAccess(Syntax_3 caller, Context_3 ctx, bool assigning, bool static_ok, bool instance_ok) {
    return CheckStatic(caller, static_ok, instance_ok) && CheckAssigning(caller, ctx, assigning);
  }

  public abstract Location_3 GetLocation(GObject_3 obj);

  // These methods are for fields and properties; indexers have their own versions which take
  // an extra index argument.
  public virtual RValue_3 ^Get(GValue_3 obj) { Debug.Assert(false); return null; }
  public virtual RValue_3 ^Take_3(GValue_3 obj) { Debug.Assert(false); return null; }
  public virtual void Set(GObject_3 obj, RValue_3 ^val)  { Debug.Assert(false); }

  public virtual string Emit()  { Debug.Assert(false); return null; }
  public virtual string EmitSet(string val)  { Debug.Assert(false); return null; }
}

class Field_3 : LMember_3 {
  protected Expression_3 ^initializer_;    // or null if none
  protected GType_3 initializer_type_;

  public Field_3(int attributes, TypeExpr_3 ^type_expr, string name, Expression_3 ^initializer)
  : base(attributes, type_expr, name) {
    initializer_ = initializer;
  }

  // Create a field for an internal class.  Such fields will never be type checked.
  public Field_3(GType_3 type, string name) : this(Attribute_3.Public | Attribute_3.ReadOnly, null, name, null) {
    type_ = type;
  }

  public static Field_3 ^New_3(int attributes, TypeExpr_3 ^type_expr, string name, Expression_3 ^initializer) {
    if ((attributes & Attribute_3.Static) != 0)
      return new StaticField_3(attributes, type_expr, name, initializer);
    if ((attributes & Attribute_3.Const) != 0)
      return new ConstField_3(attributes, type_expr, name, initializer);
    return new Field_3(attributes, type_expr, name, initializer);
  }

  public override int Kind() { return MemberKind_3.Field_3; }

  public Expression_3 Initializer() { return initializer_; }

  protected virtual bool CheckInitializer(Context_3 ctx) {
    if (initializer_ == null)
      return true;

    ctx.EnterExpression();
    initializer_type_ = initializer_.Check(ctx);
    bool b = initializer_type_ != null &&
             Assign_3.CheckAssign(this, type_, initializer_, initializer_type_);
    ctx.FinishExpression();
    return b;
  }

  protected override int ValidAttributes() {
    return Attribute_3.Const | Attribute_3.Private | Attribute_3.Protected | Attribute_3.Public |
           Attribute_3.ReadOnly | Attribute_3.Static;
  }

  public override bool Check(Context_3 ctx) {
    if (!base.Check(ctx))
      return false;

    // We build up a small control graph even when checking field initializers; we do this
    // since expression-checking code uses the graph to determine when temporary
    // ref counts are needed.
    prev_ = unreachable_;
    ctx.SetPrev(this);

    bool b = CheckInitializer(ctx);

    ctx.ClearPrev();
    return b;
  }

  public override bool CheckAssigning(Syntax_3 caller, Context_3 ctx, bool assigning) {
    if (assigning) {
      if (HasAttribute(Attribute_3.Const)) {
        caller.Error("can't assign to const field");
        return false;
      }
      if (HasAttribute(Attribute_3.ReadOnly) &&
          (ctx.class_ != class_ || !(ctx.method_ is Constructor_3)) ) {
        caller.Error("readonly field {0} can only be assigned in constructor", name_);
        return false;
      }
    }
    return true;
  }

  public override RValue_3 ^Get(GValue_3 obj) { return obj.Get(this); }
  public override RValue_3 ^Take_3(GValue_3 obj) { return obj.Take_3(this); }
  public override void Set(GObject_3 obj, RValue_3 ^val) { obj.Set(this, val); }
  public override Location_3 GetLocation(GObject_3 obj) { return obj.GetLocation(this); }

  protected void WriteField(SourceWriter_3 w, bool declaration) {
    w.Indent();
    if (declaration && IsConstOrStatic())
      w.Write("static ");
    w.Write("{0} ", type_.EmitType());
    if (this is ConstField_3)
      w.Write("const ");
    if (!declaration)
      w.Write("{0}::", class_.name_);
    w.Write(name_);
  }

  protected void WriteDeclaration(SourceWriter_3 w) { WriteField(w, true); }
  protected void WriteDefinition(SourceWriter_3 w) { WriteField(w, false); }

  public virtual void EmitDeclaration(SourceWriter_3 w) {
    WriteDeclaration(w);
    w.WriteLine(";");
  }

  public void EmitInitializer(SourceWriter_3 w) {
    w.IWrite("{0} = ", name_);
    if (initializer_ != null)
      w.Write(initializer_.Emit(initializer_type_, type_));
    else w.Write(type_.DefaultValue_3().Emit());
    w.WriteLine(";");
  }

  public virtual void Emit(SourceWriter_3 w) { }

  public override string Emit() { return name_; }

  public override string EmitSet(string val) {
    return String.Format("{0} = {1}", name_, val);
  }
}

class StaticField_3 : Field_3 {
  protected Location_3 ^loc_;

  public StaticField_3(int attributes, TypeExpr_3 ^type_expr, string name, Expression_3 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_3 ctx) {
    if (!base.Check(ctx))
      return false;
    loc_ = new Location_3(Type().DefaultValue_3().Copy());
    return true;
  }

  protected override bool CheckInitializer(Context_3 ctx) {
    ArrayInitializer_3 ai = initializer_ as ArrayInitializer_3;
    if (ai != null) {
      GType_3 type = type_;
      Owning_3 o = type as Owning_3;
      type = (o != null) ? o.BaseType() : null;
      ArrayType_3 at = type as ArrayType_3;
      if (at == null) {
        Error("only owning arrays may have initializers");
        return false;
      }
      return ai.CheckElements(ctx, at.ElementType());
    }

    return base.CheckInitializer(ctx);
  }

  public virtual void Init() {
    ArrayInitializer_3 ai = initializer_ as ArrayInitializer_3;
    if (ai != null)
      loc_.value_ = ai.Eval((ArrayType_3) type_.BaseType());
    else if (initializer_ != null)
      loc_.value_ = initializer_.Eval(Env_3.static_, type_);
  }

  public override RValue_3 ^Get(GValue_3 obj) { return loc_.Get().CopyRef(); }
  public override RValue_3 ^Take_3(GValue_3 obj) { return take loc_.value_; }
  public override void Set(GObject_3 obj, RValue_3 ^val) { loc_.value_ = val; }
  public override Location_3 GetLocation(GObject_3 obj) { return loc_; }

  public override void Emit(SourceWriter_3 w) {
    ArrayInitializer_3 ai = initializer_ as ArrayInitializer_3;
    if (ai != null) {
      GType_3 element_type = ((ArrayType_3) type_.BaseType()).ElementType();
      string varname = String.Format("_{0}_{1}", class_.name_, name_);
      w.Write("{0} {1}[] = ", element_type.EmitGenericType(), varname);
      ai.Emit(w);
      w.WriteLine(";");
      WriteDefinition(w);
      w.Write("(new {0}", GType_3.ConstructType("_StaticArray", element_type.EmitGenericType()));
      w.Write("(&typeid({0}), {1}, {2}))", element_type.EmitType(), ai.initializers_.Count, varname);
    } else {
      WriteDefinition(w);
      if (initializer_ != null)
        initializer_.EmitAsInitializer(w, initializer_type_, type_);
    }
    w.WriteLine(";");
    w.WriteLine("");
  }
}

class ConstField_3 : Field_3 {
  protected SimpleValue_3 ^value_;

  public ConstField_3(int attributes, TypeExpr_3 ^type_expr, string name, Expression_3 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_3 ctx) {
    if (!base.Check(ctx))
      return false;
    return initializer_.CheckConstant();
  }

  SimpleValue_3 ^Get() {
    if (value_ == DefaultValue_3.instance_) {
      Error("circular dependency among constant fields");
      Gel_3.Exit();
    }
    if (value_ == null) {
      value_ = new DefaultValue_3();    // marker used to catch circular const references
      value_ = (SimpleValue_3)initializer_.Eval(Env_3.static_, type_);
    }
    return value_.Copy();
  }

  public override RValue_3 ^Get(GValue_3 obj) {
    return Get();
  }

  public override void Set(GObject_3 obj, RValue_3 ^val) { Debug.Assert(false); }
  public override Location_3 GetLocation(GObject_3 obj) { Debug.Assert(false); return null; }

  public override void EmitDeclaration(SourceWriter_3 w) {
    WriteDeclaration(w);
    if (type_ is IntegralType_3)
      w.Write(" = {0}", Get().Emit());
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_3 w) {
    WriteDefinition(w);
    if (!(type_ is IntegralType_3)) {
      w.WriteLine(" = {0};", Get().Emit());
    }
    w.WriteLine(";");
  }
}

class ExpressionTraverser_3 : Traverser_3 {
  readonly Control_3 start_;
  Local_3 local_;
  GType_3 type_;
  bool assign_;
  bool destroy_;

  public ExpressionTraverser_3(Control_3 start, Local_3 local, GType_3 type) {
    start_ = start; local_ = local; type_ = type;
  }

  public override int Handle(Control_3 control) {
    if (control == start_)
      return Cut;
    Node_3 node = control as Node_3;
    if (node != null) {
      if (!destroy_ && node.CanDestroy(type_))
        destroy_ = true;
      else if (local_ != null && node.Sets(local_))
        assign_ = true;
    }
    return Continue_3;
  }

  // Return_3 true if the given expression needs a reference count while we evaluate
  // the control graph nodes between [start] and [end].
  // A local variable needs a ref count if it is assigned to and the object
  // the variable previously pointed to might possibly be destroyed.
  // Any other expression needs a ref count if the object it evaluates to
  // might possibly be destroyed.
  public static bool NeedRef(Control_3 start, Control_3 end, Expression_3 expr, GType_3 type) {
    Debug.Assert(start != null && end != null);
    if (start == end || !type.IsOwned() || expr is This_3 || expr is Base_3)
      return false;
    Local_3 local = expr.GetLocal();
    ExpressionTraverser_3 ^et = new ExpressionTraverser_3(start, local, type);
    end.Traverse(et, Control_3.GetMarkerValue());
    return et.destroy_ && (local == null || et.assign_);
  }
}

abstract class LocalHandler_3 {
  public abstract bool Handle(Local_3 local, Node_3 node, Name_3 use);
}

class LocalChecker_3 : LocalHandler_3 {
  public override bool Handle(Local_3 local, Node_3 node, Name_3 use) {
    if (node == Control_3.unreachable_) {
      if (use != null)
        use.Error("variable {0} may be used before it is assigned a value", use.name_);
      else
        local.Error("out parameter {0} must be assigned before leaving method", local.name_);
      return false;
    }
    if (node.Takes(local)) {
      Name_3 name = (Name_3) node;
      name.Error("can't transfer ownership from {0}: value may be used again", name.name_);
      return false;
    }
    return true;
  }
}

class LocalRefAnalyzer_3 : LocalHandler_3 {
  public override bool Handle(Local_3 local, Node_3 node, Name_3 use) {
    Debug.Assert(node != Control_3.unreachable_);
    if (node.CanDestroy(local.Type())) {
      local.NeedsRef();
      return false;   // abort search
    }
    return true;
  }
}

class LocalTraverser_3 : Traverser_3 {
  readonly Local_3 local_;
  readonly LocalHandler_3 handler_;
  Name_3 use_;

  public LocalTraverser_3(Local_3 local, LocalHandler_3 handler) {
    local_ = local;
    handler_ = handler;
  }

  public void SetUse(Name_3 use) { use_ = use; }

  public override int Handle(Control_3 control) {
    Node_3 node = control as Node_3;
    if (node == null)
      return Continue_3;

    if (node.Sets(local_))
      return Cut;

    return handler_.Handle(local_, node, use_) ? Continue_3 : Abort;
  }
}

class Local_3 : Named_3 {
  protected Expression_3 ^initializer_;    // or null if none
  protected GType_3 initializer_type_;

  public Local_3 next_;    // next variable upward in scope chain

  NonOwningArrayList /* of Name_3 */ ^uses_ = new NonOwningArrayList();    // all uses of this variable

  protected bool mutable_;   // true if this local may ever change after it's first initialized

  protected bool needs_ref_;    // true if this variable needs a reference count in emitted code

  public Expression_3 Initializer() { return initializer_; }

  public void NeedsRef() { needs_ref_ = true; }

  public virtual string Emit() { return name_; }

  // Return_3 true if we represent this local using a smart pointer wrapper (i.e.
  // _Ptr, _Own, _OwnRef or _Ref).
  public virtual bool IsWrapper() {
    return type_ is Owning_3 || type_ == GString_3.type_ || needs_ref_;
  }

  public Local_3(TypeExpr_3 ^type_expr, string name, Expression_3 ^initializer) : base(type_expr, name) {
    initializer_ = initializer;
    next_ = null;
  }

  public bool Check(Context_3 ctx) {
    Local_3 decl = ctx.FindVar(name_);
    if (decl != null) {
      Error("error: variable already defined");
      return false;
    }

    if (initializer_ != null) {
      ctx.EnterExpression();
      initializer_type_ = initializer_.Check(ctx);
      bool ok = initializer_type_ != null &&
                Assign_3.CheckAssign(this, type_, initializer_, initializer_type_);

      // Add this Local_3 to the control graph.  We need to do this before calling
      // FinishExpression since the Local_3 will be initialized before temporaries 
      // are destroyed.
      AddControl(ctx);

      ctx.FinishExpression();
      if (!ok)
        return false;
    }

    next_ = ctx.var_;
    ctx.SetVar(this);

    ctx.method_.AddVar(this);
    return true;
  }

  public override bool Sets(Local_3 local) {
    return this == local && initializer_ != null;
  }

  public virtual GType_3 ReadType() {
    return type_;
  }

  public void AddUse(Name_3 name) {
    uses_.Add(name);
  }

  public void SetMutable() { mutable_ = true; }

  // Traverse the control graph nodes where this local is live, calling the given
  // LocalHandler_3's Handle method on each node.
  public bool Traverse(Method_3 method, LocalHandler_3 h) {
    LocalTraverser_3 ^t = new LocalTraverser_3(this, h);
    int marker = Control_3.GetMarkerValue();
    foreach (Name_3 name in uses_) {
      t.SetUse(name);
      if (!name.prev_.Traverse(t, marker))
        return false;
    }

    Parameter_3 p = this as Parameter_3;
    if (p != null && p.GetMode() == Mode_3.Out) {
      t.SetUse(null);
      if (!method.exit_.Traverse(t, marker))
        return false;
    }
    return true;
  }

  // check variable usage once control flow graph is complete
  public bool CheckUsage(Method_3 method) {
    return Traverse(method, new LocalChecker_3());
  }

  // Determine whether this Local_3 needs a reference count.  This_3 can happen only after
  // we've built up a control graph for all methods.
  public void ComputeRef(Method_3 method) {
    // For_3 now, a variable of type object always needs a reference count since it may
    // contain a string and we don't yet detect string destruction in the graph traversal.
    if (type_ == GObject_3.type_)
      NeedsRef();
    else if (type_.IsOwned())
      Traverse(method, new LocalRefAnalyzer_3());
  }

  public void EvalInit(Env_3 env) {
    env.Add(this, initializer_ != null ? initializer_.Eval(env, type_) : null);
  }

  protected virtual string EmitDeclarationType() {
    return IsWrapper() ? type_.EmitType() : type_.EmitExprType();
  }

  public virtual string EmitDeclarationName() { return name_; }

  public void EmitDeclaration(SourceWriter_3 w) {
    w.Write("{0} {1}", EmitDeclarationType(), EmitDeclarationName());
  }

  public void EmitInitializer(SourceWriter_3 w) {
    if (initializer_ != null)
      initializer_.EmitAsInitializer(w, initializer_type_, type_);
  }
}

class Parameter_3 : Local_3 {
  public Parameter_3(TypeExpr_3 ^type_expr, string name) : base(type_expr, name, null) { }

  // We represent some parameters using both a C++ parameter and a C++ local, which
  // have different types; we call these dual parameters.  For_3 such parameters
  // param_name_ is the C++ parameter name.
  string param_name_;

  public static Parameter_3 ^New_3(int mode, TypeExpr_3 ^type_expr, string name) {
    return mode == 0 ? new Parameter_3(type_expr, name) :
                               new RefOutParameter_3(mode, type_expr, name);
  }

  public virtual int GetMode() { return 0; }
  public string TypeString() { return Mode_3.ToString(GetMode()) + type_.ToString(); }

  public virtual Parameter_3 ^Copy() {
    return new Parameter_3(new TypeLiteral_3(type_), name_);
  }

  public virtual bool CanReceive(Argument_3 a) {
    return a.GetMode() == 0 && a.Type().CanConvert(type_, ConversionContext_3.MethodArg);
  }

  public bool Match(Parameter_3 p) {
    return GetMode() == p.GetMode() && type_.Equals(p.type_);
  }

  public override bool IsWrapper() {
    return type_ is Owning_3 || type_ == GString_3.type_ || mutable_ && needs_ref_;
  }

  public void CheckParameterUsage(Method_3 method) {
    if (type_ is Owning_3 && !(this is RefOutParameter_3)) {
      // We need both a C++ parameter and a C++ local: the parameter type can't be
      // _Own<>, since _Own has no public copy constructor and GCC doesn't allow passing
      // by value when a class's copy constructor is private.
      string n = name_;
      do {
        n = "_" + n;
      } while (method.HasLocal(n));
      param_name_ = n;
    }
  }

  protected override string EmitDeclarationType() {
    // For_3 owning parameters the declaration type is the expression type since we can't
    // pass _Own<> by value.
    return type_ is Owning_3 ? type_.EmitExprType() : base.EmitDeclarationType();
  }

  public override string EmitDeclarationName() {
    return param_name_ != null ? param_name_ : name_;
  }

  public void EmitExtraDeclaration(SourceWriter_3 w) {
    if (param_name_ != null)
      w.IWriteLine("{0} {1}({2});", type_.EmitType(), name_, param_name_);
  }
}

class RefOutParameter_3 : Parameter_3 {
  public readonly int mode_;
  public override int GetMode() { return mode_; }

  public RefOutParameter_3(int mode, TypeExpr_3 ^type_expr, string name) : base(type_expr, name) {
    mode_ = mode;
    mutable_ = true;
  }

  public override Parameter_3 ^Copy() { Debug.Assert(false); return null; }

  public override bool CanReceive(Argument_3 a) {
    if (mode_ != a.GetMode())
      return false;
    RefOutArgument_3 ra = (RefOutArgument_3) a;
    return type_.Equals(ra.StorageType());
  }

  public override GType_3 ReadType() {
    // If_3 a ref parameter has an owning type, we require the user to use the take operator to take
    // ownership of the value, since taking ownership has the visible side effect of clearing the
    // value the ref parameter points to.
    return mode_ == Mode_3.Ref ? type_.BaseType() : type_;
  }

  public override string Emit() {
    return "(*" + name_ + ")";
  }

  protected override string EmitDeclarationType() {
    return type_.EmitType() + " *";
  }
}

abstract class InlineStatement_3 : Statement_3 {
  public abstract void EmitInline(SourceWriter_3 w);

  public override void Emit(SourceWriter_3 w) {
    EmitInline(w);
    w.WriteLine(";");
  }
}

class VariableDeclaration_3 : InlineStatement_3 {
  ArrayList /* of Local_3 */ ^locals_ = new ArrayList();

  public VariableDeclaration_3(TypeExpr_3 ^type_expr, string name, Expression_3 ^initializer) {
    locals_.Add(new Local_3(type_expr, name, initializer));
  }

  public void Add(string name, Expression_3 ^initializer) {
    TypeExpr_3 ^t = ((Local_3) locals_[0]).type_expr_.Copy();
    locals_.Add(new Local_3(t, name, initializer));
  }

  public override bool Check(Context_3 ctx) {
    // local variables are not resolved during the Resolve phase, so we must resolve them here
    foreach (Local_3 l in locals_)
      if (!l.Resolve(ctx.program_) || !l.Check(ctx))
        return false;

    return true;
  }

  // Return_3 the type of all variables in this VariableDeclaration_3.
  public GType_3 Type() { return ((Local_3) locals_[0]).Type(); }

  public override RValue_3 ^Eval(Env_3 env) {
    foreach (Local_3 l in locals_)
      l.EvalInit(env);
    return null;
  }

  void Emit(SourceWriter_3 w, bool in_line) {
    if (in_line)
      Debug.Assert(locals_.Count == 1);

    foreach (Local_3 l in locals_) {
      l.EmitDeclaration(w);
      l.EmitInitializer(w);
      if (!in_line)
        w.WriteLine(";");
    }
  }

  public override void EmitInline(SourceWriter_3 w) { Emit(w, true); }
  public override void Emit(SourceWriter_3 w) { Emit(w, false); }
}

class ExpressionStatement_3 : InlineStatement_3 {
  Expression_3 ^exp_;

  public ExpressionStatement_3(Expression_3 ^e) {
    exp_ = e;
  }

  public override bool Check(Context_3 ctx) {
    if (exp_.CheckTop(ctx) == null)
      return false;
    exp_.SetUnused();
    return true;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    exp_.Eval(env);   // discard expression value
    return null;
  }

  public override void EmitInline(SourceWriter_3 w) {
    w.Write(exp_.Emit());
  }

}

class If_3 : Statement_3 {
  Expression_3 ^condition_;
  Statement_3 ^if_true_;
  Statement_3 ^if_false_;
  Joiner_3 ^join_ = new Joiner_3();

  public If_3(Expression_3 ^condition, Statement_3 ^if_true, Statement_3 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override bool Check(Context_3 ctx) {
    if (!condition_.Check(ctx, GBool_3.type_))
      return false;

    Control_3 c = ctx.Prev();

    if (!if_true_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    if (if_false_ != null && !if_false_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());
    return true;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    if (condition_.EvalBool(env))
      return if_true_.Eval(env);
    else
      return if_false_ != null ? if_false_.Eval(env) : null;
  }

  public override void Emit(SourceWriter_3 w) {
    w.Write("if ({0})", condition_.Emit());
    if_true_.EmitEmbedded(w);
    if (if_false_ != null) {
      w.IWrite("else");
      if_false_.EmitEmbedded(w);
    }
  }

}

class DefaultValue_3 : SimpleValue_3 {
  public DefaultValue_3() { }
  public static readonly DefaultValue_3 ^instance_ = new DefaultValue_3();

  public override SimpleValue_3 ^Copy() { Debug.Assert(false); return null; }
  public override GType_3 Type()  { Debug.Assert(false); return null; }
  public override string Emit() { Debug.Assert(false); return null; }
}

// A section in a switch statement.
//
// In GEL2, unlike C# and C++, local variables declared in a switch section are visible only
// in that section.  There doesn't seem to be much point in allowing sections to share locals
// since GEL2 (like C#) doesn't allow control to fall through from one section to the next.  This_3 also
// makes compiling to C++ slightly easier since C++ doesn't allow local variables in switch sections
// other than the last to have initializers (see e.g. C++ Primer, 4th ed., 6.6.5 "Variable Definitions
// inside a switch").

class SwitchSection_3 : Node_3 {
  ArrayList /* of Expression_3 */ ^cases_;     // null represents default:
  public readonly Block_3 ^block_;

  ArrayList /* of GValue_3 */ ^values_ = new ArrayList();

  public SwitchSection_3(ArrayList ^cases, StatementList_3 ^statements) {
    cases_ = cases;
    block_ = new Block_3(statements);
  }

  public bool Check(Context_3 ctx, GType_3 switch_type, OwningHashtable all_values, out bool is_default) {
    is_default = false;
    foreach (Expression_3 e in cases_) {
      GValue_3 ^v;
      if (e == null) {
        is_default = true;
        v = new DefaultValue_3();
      } else {
        if (!e.Check(ctx, switch_type) || !e.CheckConstant())
          return false;
        v = (GValue_3) e.Eval(Env_3.static_, switch_type);
      }
      if (all_values.ContainsKey(v)) {
        Error("switch statement cannot contain the same value twice");
        return false;
      }
      all_values.Set(v, null);
      values_.Add(v);
    }
    return block_.Check(ctx);
  }

  public bool Match(GValue_3 v) {
    foreach (GValue_3 val in values_)
      if (val.Equals(v))
        return true;
    return false;
  }

  public void Emit(SourceWriter_3 w) {
    foreach (Expression_3 c in cases_)
      if (c == null)
        w.IWriteLine("default:");
      else w.IWriteLine("case {0}:", c.Emit());
    w.Indent();
    block_.Emit(w);
  }

  public void EmitString(SourceWriter_3 w) {
    w.IWrite("if (");
    for (int i = 0 ; i < values_.Count ; ++i) {
      if (i > 0) {
        w.WriteLine(" ||");
        w.IWrite("    ");
      }
      w.Write("_s->_Equals({0})", 
              GString_3.EmitStringConst(((GString_3) values_[i]).s_));
    }
    w.Write(") ");
    block_.Emit(w);
  }
}

abstract class Escapable_3 : Scoped_3 {
  public readonly Joiner_3 ^exit_ = new Joiner_3();
}

class Switch_3 : Escapable_3 {
  Expression_3 ^expr_;
  GType_3 type_;
  ArrayList /* of SwitchSection_3 */ ^sections_;
  SwitchSection_3 default_;    // or null if no default section

  public Switch_3(Expression_3 ^expr, ArrayList ^sections) { expr_ = expr; sections_ = sections; }

  public override bool Check(Context_3 ctx) {
    SetStartVar(ctx);
    type_ = expr_.CheckTop(ctx);
    if (type_ == null)
      return false;
    if (type_ != GInt_3.type_ && type_ != GChar_3.type_ && type_ != GString_3.type_) {
      Error("switch expression must be of type int, char or string");
      return false;
    }
    Context_3 ^ctx1 = new Context_3(ctx, this);
    OwningHashtable ^values = new OwningHashtable();
    Control_3 c = ctx1.Prev();
    foreach (SwitchSection_3 s in sections_) {
      bool is_default;
      ctx1.SetPrev(c);
      if (!s.Check(ctx1, type_, values, out is_default))
        return false;
      if (is_default)
        default_ = s;
      if (ctx1.Prev() != unreachable_) {
        s.Error("switch case may not fall through to following case");
        return false;
      }
    }
    if (default_ == null)
      exit_.Join(c);
    ctx1.SetPrev(exit_.Combine());
    return true;
  }

  SwitchSection_3 FindSection(GValue_3 v) {
    foreach (SwitchSection_3 s in sections_)
      if (s.Match(v))
        return s;
    return default_;
  }

  RValue_3 ^CatchBreak(RValue_3 ^v) {
    return v is BreakValue_3 ? null : v;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    RValue_3 ^v = expr_.Eval(env);
    if (v == null)
      return null;
    SwitchSection_3 s = FindSection(v.Get());
    if (s == null)
      return null;
    return CatchBreak(s.block_.Eval(env));
  }

  public override void Emit(SourceWriter_3 w) {
    if (type_ == GString_3.type_) {
      // For_3 now, we implement a switch on strings using a sequence of if statements.  We wrap
      // the sequence in a dummy switch statement so that break statements will work properly.
      // If_3 the switch statement has just a default: label then the Microsoft C++ compiler issues
      // a warning, and if it has just a case 0: label then the compiler doesn't realize that the
      // case will always be executed, which may lead to warnings about not all code paths returning
      // a value.  So we use both default: and case 0:, which seems to work fine.
      w.Write("switch (0) ");
      w.OpenBrace();
      w.IWriteLine("case 0:");
      w.IWriteLine("default:");
      w.IWriteLine("StringPtr _s = {0};", expr_.Emit());
      foreach (SwitchSection_3 s in sections_)
        if (s != default_)
          s.EmitString(w);
      if (default_ != null)
        default_.block_.Emit(w);
      w.CloseBrace();
    } else {
      w.Write("switch ({0}) ", expr_.Emit());
      w.OpenBrace();

      foreach (SwitchSection_3 s in sections_)
        s.Emit(w);

      w.CloseBrace();
    }
  }
}

abstract class Loop_3 : Escapable_3 {
  public readonly Joiner_3 ^loop_ = new Joiner_3();
}

abstract class ForOrWhile_3 : Loop_3 {
  protected Expression_3 ^condition_;
  protected Statement_3 ^statement_;

  protected ForOrWhile_3(Expression_3 ^condition, Statement_3 ^statement) {
    condition_ = condition; statement_ = statement;
  }

  protected abstract InlineStatement_3 Initializer();
  protected abstract InlineStatement_3 Iterator();

  public override bool Check(Context_3 prev_ctx) {
    Context_3 ^ctx = new Context_3(prev_ctx, this);   // initializer may declare new local variable
    SetStartVar(ctx);
    if (!Initializer().Check(ctx))
      return false;
    SetTopVar(ctx);

    loop_.AddControl(ctx);

    if (!condition_.CheckTop(ctx, GBool_3.type_))
      return false;

    if (!condition_.IsTrueLiteral())  // we may exit the loop at this point
      exit_.Join(ctx.Prev());  

    if (!statement_.Check(ctx))
      return false;

    if (!Iterator().Check(ctx))
      return false;

    loop_.Join(ctx.Prev());  // loop back to top

    ctx.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy any local defined in an initializer above.
    AddControl(ctx);

    return true;
  }

  public override RValue_3 ^Eval(Env_3 outer_env) {
    Env_3 ^env = new Env_3(outer_env);   // initializer may declare new local
    for (Initializer().Eval(env); condition_.EvalBool(env); Iterator().Eval(env)) {
      RValue_3 ^v = statement_.Eval(env);
      if (v is BreakValue_3)
        break;
      if (v is ContinueValue_3)
        continue;
      if (v != null)
        return v;
    }
    return null;
  }
}

class While_3 : ForOrWhile_3 {
  public While_3(Expression_3 ^condition, Statement_3 ^statement) : base(condition, statement) { }

  protected override InlineStatement_3 Initializer()  { return EmptyStatement_3.instance_; }
  protected override InlineStatement_3 Iterator()  { return EmptyStatement_3.instance_; }

  public override void Emit(SourceWriter_3 w) {
    w.Write("while ({0})", condition_.Emit());
    statement_.EmitEmbedded(w);
  }
}

class For_3 : ForOrWhile_3 {
  InlineStatement_3 ^initializer_;
  InlineStatement_3 ^iterator_;

  public For_3(InlineStatement_3 ^initializer, Expression_3 ^condition, InlineStatement_3 ^iterator,
             Statement_3 ^statement)
    : base(condition != null ? condition : new Literal_3(new GBool_3(true)),
           statement) {
    initializer_ = initializer != null ? initializer : new EmptyStatement_3();
    iterator_ = iterator != null ? iterator : new EmptyStatement_3();
  }

  protected override InlineStatement_3 Initializer()  { return initializer_; }
  protected override InlineStatement_3 Iterator()  { return iterator_; }

  public override void Emit(SourceWriter_3 w) {
    w.Write("for (");
    initializer_.EmitInline(w);
    w.Write("; {0}; ", condition_.Emit());
    iterator_.EmitInline(w);
    w.Write(")");
    statement_.EmitEmbedded(w);
  }
}

class Do_3 : Loop_3 {
  Statement_3 ^statement_;
  Expression_3 ^condition_;

  Joiner_3 ^join_ = new Joiner_3();

  public Do_3(Statement_3 ^statement, Expression_3 ^condition) {
    statement_ = statement;
    condition_ = condition;
  }

  public override bool Check(Context_3 ctx) {
    join_.AddControl(ctx);

    Context_3 ^ctx1 = new Context_3(ctx, this);
    SetStartVar(ctx);

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx.Prev());  // continue statements jump here
    ctx.SetPrev(loop_.Combine());

    if (!condition_.CheckTop(ctx, GBool_3.type_))
      return false;

    if (!condition_.IsFalseLiteral())
      join_.Join(ctx.Prev());   // loop back to top
    if (!condition_.IsTrueLiteral())
      exit_.Join(ctx.Prev());   // fall through to exit
    ctx.SetPrev(exit_.Combine());

    return true;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    do {
      RValue_3 ^v = statement_.Eval(env);
      if (v is BreakValue_3)
        break;
      if (v is ContinueValue_3)
        continue;
      if (v != null)
        return v;
    } while (condition_.EvalBool(env));
    return null;
  }

  public override void Emit(SourceWriter_3 w) {
    w.IWrite("do");
    statement_.EmitEmbedded(w);
    w.IWriteLine("while ({0});", condition_.Emit());
  }
}

// A helper class for ForEach_3: a node defining a single variable in the control graph.
class Definer_3 : Node_3 {
  Local_3 local_;

  public Definer_3(Local_3 local) { local_ = local; }

  public override bool Sets(Local_3 local) {
    return local_ == local;
  }
}

class ForEach_3 : Loop_3 {
  Local_3 ^local_;
  Expression_3 ^expr_;
  GType_3 expr_type_;
  Statement_3 ^statement_;

  Property_3 count_;
  Indexer_3 indexer_;

  Definer_3 ^definer_;

  public ForEach_3(TypeExpr_3 ^type_expr, string name, Expression_3 ^expr, Statement_3 ^statement) {
    local_ = new Local_3(type_expr, name, null);
    expr_ = expr;
    statement_ = statement;
  }

  public override bool Check(Context_3 ctx) {
    if (!local_.Resolve(ctx.program_))
      return false;

    expr_type_ = expr_.CheckTop(ctx);
    if (expr_type_ == null)
      return false;

    count_ = expr_type_.Lookup(this, ctx.class_, false, MemberKind_3.Property_3, "Count", null, false) as Property_3;
    if (count_ == null) {
      Error("object enumerable by foreach must have an accessible property Count");
      return false;
    }
    if (count_.Type() != GInt_3.type_) {
      Error("object enumerable by foreach must have a property Count of type int");
      return false;
    }

    ArrayList ^args = new ArrayList();
    args.Add(new InArgument_3(GInt_3.type_));
    indexer_ = (Indexer_3) expr_type_.Lookup(this, ctx.class_, false, MemberKind_3.Indexer_3, null, args, false);
    if (indexer_ == null) {
      Error("object enumerable by foreach must have an accessible indexer on integers");
      return false;
    }
    if (!indexer_.CheckAssigning(this, ctx, false))
      return false;

    GType_3 indexer_type = indexer_.Type();
    GType_3 iterator_type = local_.Type();
    if (!indexer_type.CanConvertExplicit(iterator_type, false)) {
      Error("enumeration type {0} is not explicitly convertible to iteration variable type {1}",
        indexer_type, iterator_type);
      return false;
    }

    Context_3 ^ctx1 = new Context_3(ctx, this);

    SetStartVar(ctx1);
    if (!local_.Check(ctx1))   // will add local to scope chain
      return false;
    SetTopVar(ctx1);

    // Add a control graph node representing the creation of the local above.
    definer_ = new Definer_3(local_);
    definer_.AddControl(ctx1);

    loop_.AddControl(ctx1);   // continue statements jump here

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx1.Prev());   // loop back to top

    exit_.Join(loop_);  // any loop iteration may exit

    ctx1.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy the local variable created above.
    AddControl(ctx1);

    return true;
  }

  public override RValue_3 ^Eval(Env_3 outer_env) {
    RValue_3 ^r = expr_.Eval(outer_env);
    GValue_3 e = r.Get();
    if (e is Null_3) {
      Error("foreach: can't iterate over null object");
      Gel_3.Exit();
    }

    int count = ((GInt_3) count_.Get(e)).i_;

    Env_3 ^env = new Env_3(outer_env);
    env.Add(local_, null);
    for (int i = 0 ; i < count ; ++i) {
      RValue_3 ^v = indexer_.Get(e, new GInt_3(i));
      env.Set(local_, v.Get().ConvertExplicit(ref v, local_.Type()));
      RValue_3 ^s = statement_.Eval(env);
      if (s is BreakValue_3)
        break;
      if (s is ContinueValue_3)
        continue;
      if (s != null)
        return s;
    }
    return null;
  }

  public override void Emit(SourceWriter_3 w) {
    w.OpenBrace();
    w.IWriteLine("{0} _collection = {1};", expr_type_.BaseType().EmitType(), expr_.Emit());
    w.IWriteLine("int _count = _collection->get_Count();");
    w.IWrite("for (int _i = 0 ; _i < _count ; ++_i) ");
    w.OpenBrace();
    w.Indent();
    local_.EmitDeclaration(w);
    w.WriteLine(" = {0}; ",
      Expression_3.EmitExplicit(indexer_.Type(), local_.Type(), "_collection->get_Item(_i)", true));
    statement_.EmitInExistingBlock(w);
    w.CloseBrace();
    w.CloseBrace();
  }
}

class BreakValue_3 : GValue_3 {
  public BreakValue_3() { }

  public static readonly BreakValue_3 ^instance_ = new BreakValue_3();

  public override GType_3 Type()  { Debug.Assert(false); return null; }
}

abstract class BreakOrContinue_3 : Scoped_3 {
  protected void Link(Context_3 ctx, Scoped_3 target, Joiner_3 joiner) {
    // When traversed in the control graph, we destroy all variables in the scopes we are exiting,
    // excluding variables defined in the containing Escapable_3 or Loop_3.
    start_ = target.GetTop();
    SetTopVar(ctx);

    prev_ = ctx.Prev();
    if (prev_ != unreachable_)
      joiner.Join(this);

    ctx.SetPrev(unreachable_);
  }
}

class Break_3 : BreakOrContinue_3 {
  public override bool Check(Context_3 ctx) {
    Escapable_3 e = ctx.escape_;
    if (e == null) {
      Error("break statement must appear inside a while, do, for, foreach or switch statement");
      return false;
    }
    Link(ctx, e, e.exit_);
    return true;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    return new BreakValue_3();
  }

  public override void Emit(SourceWriter_3 w) {
    w.WriteLine("break;");
  }
}

class ContinueValue_3 : GValue_3 {
  public ContinueValue_3() { }

  public static readonly ContinueValue_3 ^instance_ = new ContinueValue_3();

  public override GType_3 Type()  { Debug.Assert(false); return null; }
}

class Continue_3 : BreakOrContinue_3 {
  public override bool Check(Context_3 ctx) {
    Loop_3 l = ctx.loop_;
    if (l == null) {
      Error("continue statement must appear inside a while, do, for or foreach statement");
      return false;
    }
    Link(ctx, l, l.loop_);
    return true;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    return new ContinueValue_3();
  }

  public override void Emit(SourceWriter_3 w) {
    w.WriteLine("continue;");
  }
}

class Return_3 : Statement_3 {
  Expression_3 ^exp_;    // null if no return value
  GType_3 exp_type_;
  GType_3 type_;

  public Return_3(Expression_3 ^exp) {
    exp_ = exp;
  }

  public override bool Check(Context_3 ctx) {
    if (exp_ == null) {
      if (ctx.method_.ReturnType() != Void_3.type_) {
        Error("error: returning value from function returning void");
        return false;
      }
    } else {
      type_ = ctx.method_.ReturnType();
      ctx.EnterExpression();
      exp_type_ = exp_.CheckAndHold(ctx);
      if (exp_type_ == null ||
          !exp_type_.CheckConvert(this, type_,
            exp_.IsRefOutParameter() ? ConversionContext_3.AssignVar : ConversionContext_3.Other))
        return false;
      exp_.CheckLoseOwnership(exp_type_, type_);
      ctx.FinishExpression();
      exp_.ReleaseRef(ctx);
    }

    ctx.method_.JoinReturn(ctx);
    ctx.SetPrev(unreachable_);
    return true;
  }

  public override RValue_3 ^Eval(Env_3 env) {
    return exp_ != null ? exp_.Eval(env, type_)
                        : Null_3.Instance.Copy();    // an arbitrary value
  }

  public override void Emit(SourceWriter_3 w) {
    if (exp_ != null && exp_.NeedsRef(exp_type_)) {
      // If_3 exp_ needs a reference count, that reference count needs to survive the destruction
      // of temporaries, so we can't simply emit a temporary reference count wrapper.  For_3 example,
      // when compiling the expression "return (new Foo()).Fun();", if Fun() returns a Foo then we
      // need a wrapper, and we can't generate "return _Ptr<Fun>(Foo().Fun()).Get()" since the _Ptr<Fun>
      // wrapper will be destroyed before the temporary Foo() object is destroyed.  So we need to
      // use an extra variable here.
      w.OpenBrace();
      w.IWriteLine("{0} __ret = {1};", exp_type_.EmitType(), exp_.Emit());
      w.IWriteLine("return __ret.Get();");
      w.CloseBrace();
    } else {
      w.Write("return ");
      if (exp_ != null)
        w.Write(exp_.Emit(exp_type_, type_));
      w.WriteLine(";");
    }
  }
}

class Attribute_3 {
  public const int Abstract = 1,
  Const = 2,
  Extern = 4,
  Override = 8,
  Private = 16,
  Protected = 32,
  Public = 64,
  ReadOnly = 128,
  Ref = 256,
  Static = 512,
  Virtual = 1024,
  Setter = 2048;
}

class AttributeUtil_3 {
  public static bool CheckOnly(int a, int allowed) {
    return (a & ~allowed) == 0;
  }
}

class MethodTraverser_3 : Traverser_3 {
  Method_3 method_;

  public MethodTraverser_3(Method_3 method) { method_ = method; }

  public override int Handle(Control_3 control) {
    if (control == Control_3.unreachable_)
      return Cut;

    Node_3 node = control as Node_3;
    if (node != null) {
      Method_3 c = node.Calls();
      if (c != null)
        method_.calls_.Add(c);
      method_.internal_destroys_.Add(node.NodeDestroys());
    }

    return Continue_3;
  }
}

class Method_3 : Member_3 {
  public readonly ArrayList /* of Parameter_3 */ ^parameters_;

  protected Block_3 ^body_;

  public Joiner_3 ^exit_ = new Joiner_3();

  // all parameters and locals defined in this method
  readonly NonOwningArrayList /* of Local_3 */ ^locals_ = new NonOwningArrayList();

  NonOwningArrayList /* of Method_3 */ ^overrides_;   // list of all overrides (virtual methods only)

  // methods called from this method
  public readonly NonOwningArrayList /* of Method_3 */ ^calls_ = new NonOwningArrayList();

  // Types destroyed inside this method, not including types destroyed through
  // calls to other methods.
  public readonly TypeSet_3 ^internal_destroys_ = new TypeSet_3();

  // Types destroyed inside this method or in any methods called by this method.
  TypeSet_3 ^destroys_;

  TypeSet_3 ^parameter_destroys_;

  // A marker used when performing a depth-first search of the method graph to compute destroys_.
  int method_marker_;

  public Method_3(int attributes, TypeExpr_3 ^return_type_expr,
                string name, ArrayList /* of Parameter_3 */ ^parameters, Block_3 ^body)
    : base(attributes, return_type_expr, name) {
    parameters_ = parameters;
    body_ = body;
  }

  public override int Kind() { return MemberKind_3.Method_3; }

  public GType_3 ReturnType() { return type_; }

  public override ArrayList Parameters() {
    return parameters_;
  }

  public bool IsExtern() { return class_.IsExtern(); }

  public bool IsStatic() {
    return HasAttribute(Attribute_3.Static);
  }

  public override bool Resolve(Program_3 program) {
    if (!base.Resolve(program))
      return false;
    foreach (Parameter_3 p in parameters_)
      if (!p.Resolve(program))
        return false;
    return true;
  }

  public void AddVar(Local_3 v) {
    locals_.Add(v);
  }

  public override bool Sets(Local_3 local) {
    foreach (Parameter_3 p in parameters_)
      if (p == local && p.GetMode() != Mode_3.Out)
        return true;
    return false;
  }

  public void JoinReturn(Context_3 ctx) {
    exit_.Join(ctx.Prev());
  }

  public const int kValidAttributes =
    Attribute_3.Abstract | Attribute_3.Override |
    Attribute_3.Private | Attribute_3.Protected | Attribute_3.Public |
    Attribute_3.Static | Attribute_3.Virtual | Attribute_3.Setter;

  protected override int ValidAttributes() {
    return kValidAttributes;
  }

  // overridden by Constructor_3 subclass
  protected virtual bool CheckEntry(Context_3 ctx) { return true; }

  // overridden by Constructor_3 subclass
  public override bool Check(Context_3 prev_ctx) {
    if (!base.Check(prev_ctx))
      return false;

    bool abstract_or_extern = HasAttribute(Attribute_3.Abstract) || IsExtern();

    if (body_.Absent()) {
      if (!abstract_or_extern) {
        Error("a method without a body must be abstract or extern");
        return false;
      }
      return true;
    } 

    if (abstract_or_extern) {
      Error("an abstract or extern method cannot have a body");
      return false;
    }

    Context_3 ^ctx = new Context_3(prev_ctx, this);

    prev_ = unreachable_;
    ctx.SetPrev(this);    // begin the control graph with this Method_3

    foreach (Parameter_3 p in parameters_)
      if (!p.Check(ctx))
        return false;

    if (!CheckEntry(ctx))
      return false;

    if (!body_.Check(ctx))
      return false;

    if (!(this is Constructor_3) && type_ != Void_3.type_ && ctx.Prev() != unreachable_) {
      Error("method must return a value");
      return false;
    }
    JoinReturn(ctx);

    ctx.ClearPrev();  // control graph is complete

    // Traverse the control graph to build calls_ and internal_destroys_.
    MethodTraverser_3 ^mt = new MethodTraverser_3(this);
    exit_.Traverse(mt, Control_3.GetMarkerValue());

    bool ok = true;
    foreach (Local_3 v in locals_)    // for all locals and parameters
      ok &= v.CheckUsage(this);

    foreach (Parameter_3 p in parameters_)
      p.CheckParameterUsage(this);

    return ok;
  }

  // Determine whether each local variable needs a reference count.
  protected void ComputeRefs() {
    foreach (Local_3 v in locals_)
      v.ComputeRef(this);
  }

  // Return_3 true if this method has a local or parameter with the given name.
  public bool HasLocal(string name) {
    foreach (Local_3 l in locals_)
      if (l.name_ == name)
        return true;
    return false;
  }

  public override TypeSet_3 NodeDestroys() {
    if (parameter_destroys_ == null) {
      parameter_destroys_ = new TypeSet_3();
    foreach (Parameter_3 p in parameters_)
        parameter_destroys_.Add(p.Type().VarDestroys());
    }
    return parameter_destroys_;
  }

  protected override void AddOverride(Member_3 m) {
    if (overrides_ == null)
      overrides_ = new NonOwningArrayList();
    overrides_.Add((Method_3) m);
  }

  bool Visit(int marker, TypeSet_3 set) {
    if (method_marker_ == marker)
      return true;

    method_marker_ = marker;
    set.Add(internal_destroys_);
    if (set.IsObject())
      return false;   // we already have object; no point in traversing further

    foreach (Method_3 m in calls_)
      if (!m.Visit(marker, set))
        return false;

    if (overrides_ != null)
      foreach (Method_3 m in overrides_)
        if (!m.Visit(marker, set))
          return false;

    return true;
  }

  public TypeSet_3 Destroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_3();
      Visit(Control_3.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  // overridden by Constructor_3 subclass
  public virtual RValue_3 ^Eval(Env_3 env) {
    return body_.Eval(env);
  }

  public RValue_3 ^Invoke(GValue_3 obj, ArrayList /* of ValueOrLocation_3 */ values) {
    if (body_.Absent()) { // an external method
      ValueList_3 ^list = new ValueList_3(values);
      if (IsStatic())
        return class_.InvokeStatic(this, list);   // let the class handle it
      return obj.Invoke(this, list);   // let the object handle it
    }

    Env_3 ^env = new Env_3(obj);
    Debug.Assert(values.Count == parameters_.Count);
    for (int i = 0 ; i < values.Count ; ++i)
      env.Add((Parameter_3) parameters_[i], (ValueOrLocation_3) values.Take(i));

    return Eval(env);
  }

  protected void EmitParameterNames(SourceWriter_3 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      w.Write(Param(i).EmitDeclarationName());
    }
    w.Write(")");
  }

  protected void EmitParameters(SourceWriter_3 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      Param(i).EmitDeclaration(w);
    }
    w.Write(") ");
  }

  void EmitAttributes(SourceWriter_3 w, bool declaration) {
    w.Indent();
    if (!IsStatic() && !IsVirtual())
      return;

    if (!declaration)
      w.Write("/* ");
    if (IsStatic())
      w.Write("static ");
    if (IsVirtual())
      w.Write("virtual ");
    if (!declaration)
      w.Write("*/ ");
  }

  void EmitSignature(SourceWriter_3 w, bool declaration) {
    EmitAttributes(w, declaration);
    w.Write("{0} ", type_.EmitReturnType());
    if (!declaration)
      w.Write("{0}::", class_.name_);
    if (HasAttribute(Attribute_3.Setter))
      w.Write("_");
    w.Write(name_);
    EmitParameters(w);
  }

  public virtual void EmitDeclaration(SourceWriter_3 w) {
    ComputeRefs();
    EmitSignature(w, true);
    if (body_.Absent())
      w.Write("= 0");
    w.WriteLine(";");

    if (HasAttribute(Attribute_3.Setter)) {
      w.WriteLine("");
      EmitAttributes(w, true);
      w.Write("{0} ", Param(parameters_.Count - 1).Type().EmitType());
      w.Write(name_);
      EmitParameters(w);
      w.OpenBrace();
      w.IWrite("_{0}", name_);
      EmitParameterNames(w);
      w.WriteLine(";");
      w.IWriteLine("return value;");
      w.CloseBrace();
    }
  }

  protected void EmitExtraDeclarations(SourceWriter_3 w) {
    foreach (Parameter_3 p in parameters_)
      p.EmitExtraDeclaration(w);
  }

  public virtual void Emit(SourceWriter_3 w) {
    if (!body_.Absent()) {
      EmitSignature(w, false);
      w.OpenBrace();
      EmitExtraDeclarations(w);
      body_.list_.Emit(w);
      w.CloseBrace();
      w.WriteLine("");
    }
    if (Gel_3.print_type_sets_)
      Console.WriteLine("{0}.{1}: {2}", class_.name_, name_, Destroys());
  }
}

class Constructor_3 : Method_3 {
  bool call_base_;
  ArrayList /* of Argument_3 */ ^initializer_params_;

  Constructor_3 initializer_;

  bool invoked_;  // true if another constructor invokes this one using : base() or : this()

  public Constructor_3(int attributes, string name, ArrayList ^parameters,
                     bool call_base, ArrayList ^initializer_params, Block_3 ^body)
    : base(attributes, null, name, parameters, body) {
    call_base_ = call_base;
    initializer_params_ = initializer_params;
  }

  public Constructor_3(int attributes, string name, ArrayList ^parameters, Block_3 ^body)
    : this(attributes, name, parameters, true, new ArrayList(), body) { }

  public override int Kind() { return MemberKind_3.Constructor_3; }

  protected override int ValidAttributes() {
    return Attribute_3.Private | Attribute_3.Protected | Attribute_3.Public;
  }

  public override bool Check(Context_3 ctx) {
    if (name_ != class_.name_) {
      Error("constructor name must match class name");
      return false;
    }
    return base.Check(ctx);
  }

  protected override bool CheckEntry(Context_3 ctx) {
    Class_3 c = call_base_ ? class_.Parent() : class_;
    if (c != null || initializer_params_.Count > 0) {
      initializer_ = (Constructor_3) Invocation_3.CheckInvoke(this, ctx, call_base_, c,
                                      c.name_, initializer_params_, MemberKind_3.Constructor_3);
      if (initializer_ == null)
        return false;
      if (initializer_ == this) {
        Error("constructor initializer invokes itself");
        return false;
      }
      initializer_.invoked_ = true;
    }
    return true;
  }

  // A Constructor_3 node in the control graph represents the call to the base constructor;
  // this node gets added when we call Invocation_3.CheckInvoke() above.
  public override Method_3 Calls() { return initializer_; }

  public override RValue_3 ^Eval(Env_3 env) {
    if (initializer_ == null || initializer_.class_ != class_) {
      // run instance variable initializers
      foreach (Field_3 f in class_.fields_)
        if (!f.IsConstOrStatic() && f.Initializer() != null)
          ((GObject_3) env.this_).Set(f, f.Initializer().Eval(Env_3.static_, f.Type()));
    }
    if (initializer_ != null)
      Invocation_3.CallMethod(env, env.this_, initializer_, initializer_params_, false);
    return body_.Eval(env);
  }

  void EmitInitializerArgs(SourceWriter_3 w) {
    w.WriteLine("({0});", Invocation_3.EmitArguments(initializer_, initializer_params_));
  }

  void EmitConstructorBody(SourceWriter_3 w) {
    w.OpenBrace();
    EmitExtraDeclarations(w);
    if (call_base_) {
      if (class_.constructors_.Count > 1)
        w.IWriteLine("_Init();");
      else class_.EmitInitializers(w);

      Class_3 parent = class_.Parent();
      if (parent != GObject_3.type_) {
        w.IWrite("{0}::_Construct", parent.name_);
        EmitInitializerArgs(w);
      }
    } else {
      w.IWrite("_Construct");
      EmitInitializerArgs(w);
    }

    body_.list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitDeclaration(SourceWriter_3 w) {
    ComputeRefs();

    // If_3 we're invoked by some other constructor then we need to declare a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void _Construct");
      EmitParameters(w);
      w.WriteLine(";");
    }

    // Now declare the actual C++ constructor.
    w.IWrite(name_);
    EmitParameters(w);
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_3 w) {
    // If_3 we're invoked by some other constructor then we need to emit a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void {0}::_Construct", name_);
      EmitParameters(w);
      EmitConstructorBody(w);
      w.WriteLine("");
    }

    // Now emit the actual C++ constructor.
    w.IWrite("{0}::{1}", name_, name_);
    EmitParameters(w);
    Class_3 parent = class_.Parent();
    if (parent != GObject_3.type_)
      w.Write(": {0}((Dummy *) 0) ", parent.name_);

    if (invoked_) {   // call the _Construct method we just generated
      w.Write("{ _Construct");
      EmitParameterNames(w);
      w.WriteLine("; }");
    } else EmitConstructorBody(w);
    w.WriteLine("");
  }
}

abstract class PropertyOrIndexer_3 : LMember_3 {
  // If_3 a get accessor is not declared at all, then get_block_ will be null; if it is
  // declared, but has an empty body ("get;") then get_block_ will be a Block_3 whose list_ is
  // null.  We need to distinguish these cases since for abstract or extern properties the
  // presence of a get accessor with an empty body indicates that a property is readable.
  // (set_block_ works similarly.)
  Block_3 ^get_block_, set_block_;

  protected Method_3 getter_, setter_;

  protected PropertyOrIndexer_3(int attributes, TypeExpr_3 ^type_expr, string name,
                              string id1, Block_3 ^block1, string id2, Block_3 ^block2)
    : base(attributes, type_expr, name) {
    StoreAccessor(id1, block1);
    if (id2 != null)
      StoreAccessor(id2, block2);
    if (id1 == id2)
      Error("can't have two {0} accessors", id1);
  }

  void StoreAccessor(string id, Block_3 ^block) {
    // Note that we don't have scanner tokens GET and SET since these are not keywords in GEL2.
    switch (id) {
      case "get": get_block_ = block; return;
      case "set": set_block_ = block; return;
    }
    Error("expected get or set");
  }

  public Method_3 Getter() { return getter_; }
  public Method_3 Setter() { return setter_; }

  protected abstract string BaseName();

  ArrayList ^CopyParameters() {
    ArrayList ^a = new ArrayList();
    foreach (Parameter_3 p in Parameters())
      a.Add(p.Copy());
    return a;
  }

  public override bool Check(Context_3 ctx) {
    if (!base.Check(ctx))
      return false;

    if (get_block_ != null) {
      Method_3 ^m = new Method_3(attributes_, new TypeLiteral_3(type_), "get_" + BaseName(), CopyParameters(), take get_block_);
      getter_ = m;
      class_.Add(m);
      if (!getter_.Resolve(ctx.program_) || !getter_.Check(ctx))
        return false;
    }

    if (set_block_ != null) {
      ArrayList ^set_params = CopyParameters();
      set_params.Add(new Parameter_3(new TypeLiteral_3(type_), "value"));
      Method_3 ^m = new Method_3(attributes_ | Attribute_3.Setter,
                           new TypeLiteral_3(Void_3.type_), "set_" + BaseName(), set_params, take set_block_);
      setter_ = m;
      class_.Add(m);
      if (!setter_.Resolve(ctx.program_) || !setter_.Check(ctx))
        return false;
    }

    return true;
  }

  public override bool CheckAssigning(Syntax_3 caller, Context_3 ctx, bool assigning) {
    if (assigning && set_block_ == null && setter_ == null) {
      caller.Error("can't assign to read-only {0}", KindString());
      return false;
    }
    if (!assigning && get_block_ == null && getter_ == null) {
      caller.Error("can't read from write-only {0}", KindString());
      return false;
    }
    return true;
  }

  public override Location_3 GetLocation(GObject_3 obj) { Debug.Assert(false); return null; }
}

class Property_3 : PropertyOrIndexer_3 {
  public Property_3(int attributes, TypeExpr_3 ^type_expr, string name,
                  string id1, Block_3 ^block1, string id2, Block_3 ^block2)
    : base(attributes, type_expr, name, id1, block1, id2, block2) { }

  public override int Kind() { return MemberKind_3.Property_3; }

  protected override int ValidAttributes() {
    return Method_3.kValidAttributes;
  }

  protected override string BaseName() { return name_; }

  public override RValue_3 ^Get(GValue_3 obj) {
    return Invocation_3.InvokeMethod(obj, getter_, new ArrayList(), true);
  }

  public override void Set(GObject_3 obj, RValue_3 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(val);
    Invocation_3.InvokeMethod(obj, setter_, a, true);
  }

  public override string Emit() {
    return String.Format("get_{0}()", name_);
  }

  public override string EmitSet(string val) {
    return String.Format("set_{0}({1})", name_, val);
  }
}

class Indexer_3 : PropertyOrIndexer_3 {
  public readonly Parameter_3 parameter_;

  ArrayList /* of Parameter_3 */ ^parameters_;

  public Indexer_3(int attributes, TypeExpr_3 ^type_expr, Parameter_3 ^parameter,
                 string id1, Block_3 ^block1, string id2, Block_3 ^block2)
    : base(attributes, type_expr, null, id1, block1, id2, block2) {
    parameter_ = parameter;

    parameters_ = new ArrayList();
    parameters_.Add(parameter);
  }

  public override int Kind() { return MemberKind_3.Indexer_3; }

  public override bool Resolve(Program_3 program) {
    return base.Resolve(program) && parameter_.Resolve(program);
  }

  protected override int ValidAttributes() {
    return Attribute_3.Abstract | Attribute_3.Override |
    Attribute_3.Private | Attribute_3.Protected | Attribute_3.Public | Attribute_3.Virtual;
  }

  protected override string BaseName() { return "Item"; }

  public override bool Check(Context_3 ctx) {
    if (parameter_ is RefOutParameter_3) {
      Error("indexer parameter may not be ref or out");
      return false;
    }

    return base.Check(ctx);
  }

  public override ArrayList /* of Parameter_3 */ Parameters() {
    return parameters_; 
  }

  public RValue_3 ^Get(GValue_3 obj, RValue_3 ^index) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    return Invocation_3.InvokeMethod(obj, getter_, a, true);
  }

  public void Set(GObject_3 obj, RValue_3 ^index, RValue_3 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    a.Add(val);
    Invocation_3.InvokeMethod(obj, setter_, a, true);
  }
}

class Class_3 : Ownable_3 {
  Syntax_3 ^syntax_ = new Syntax_3();
  Program_3 program_;   // containing program
  int attributes_;
  public readonly string name_;
  string parent_name_;    // or null if not specified

  Class_3 parent_;

  public readonly NonOwningArrayList /* of Field_3 */ ^fields_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Method_3 */ ^methods_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Property_3 */ ^properties_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Indexer_3 */ ^indexers_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Constructor_3 */ ^constructors_ = new NonOwningArrayList();

  public readonly ArrayList /* of Member_3 */ ^members_ = new ArrayList();

  public readonly ArrayList /* of Temporaries_3 */ ^temporaries_ = new ArrayList();

  public readonly NonOwningArrayList /* of Class_3 */ ^subclasses_ = new NonOwningArrayList();
  bool emitted_;

  // If_3 virtual_ is true, then this class needs a vtable; we set this for a class C
  // in any of the following cases:
  // - the program converts some type T to C ^ (for then a C ^ may hold a T, and when
  // the owning pointer is destroyed we need to know which destructor to call)
  // - the program explicitly converts from C to some other type (so we need RTTI for C)
  bool virtual_;
  
  // If_3 object_inherit_ is true, then this class must derive from Object in generated C++
  // code; we set this for a class C in any of the following cases:
  // - a member lookup in C yields a member in Object
  // - the program converts from C to Object or from Object to C
  // - the class is used in a generic context, i.e. in the type C [] or C ^ [].  All such types
  //   use the generic compiled classes Array<Object> / Array<_Own<Object>>, and so in this case we need
  //   to be able to cast between C and Object.
  //
  // If_3 object_inherit_ is true then this class and all its superclasses will have vtables since
  // the C++ Object class has a vtable.
  bool object_inherit_;

  bool need_destroy_;  // true if we need to emit _Destroy methods for this class

  // The set of types which may be destroyed when an instance of this class is destroyed.
  TypeSet_3 ^destroys_;

  // A marker used in performing a depth-first search to construct the destroys_ type set.
  int marker_;

  protected Class_3(string name) { name_ = name; }

  public static Class_3 New_3(int attributes, string name, string parent_name) {
    Class_3 c = Internal_3.Find(name);
    if (c == null) {
      Class_3 ^c1 = new Class_3(name);
      c = c1;
      Gel_3.program_.AddOwn(c1);
    }

    c.attributes_ = attributes;
    c.parent_name_ = parent_name;

    return c;
  }

  public override bool IsOwned() { return true; }

  public Program_3 GetProgram() { return program_; }
  public void SetProgram(Program_3 p) { program_ = p; }

  public bool IsExtern() { return HasAttribute(Attribute_3.Extern); }

  public override Class_3 Parent() { return parent_; }

  public override string ToString() { return name_; }

  public override ArrayList Members() { return members_; }

  public override SimpleValue_3 DefaultValue_3() { return Null_3.Instance; }

  public override void SetVirtual() { virtual_ = true; }
  public override void SetObjectInherit() { object_inherit_ = true;  }
  public void NeedDestroy() { need_destroy_ = true; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public virtual GValue_3 ^New_3() { return new GObject_3(this); }
  public virtual RValue_3 ^InvokeStatic(Method_3 m, ValueList_3 args) { Debug.Assert(false); return null; }

  public void Add(Field_3 ^f) { f.SetClass(this); fields_.Add(f); members_.Add(f);  }

  public virtual void Add(Method_3 ^m) { m.SetClass(this); methods_.Add(m); members_.Add(m);  }

  public void Add(Property_3 ^p) { p.SetClass(this); properties_.Add(p); members_.Add(p);  }

  public void Add(Indexer_3 ^i) { i.SetClass(this); indexers_.Add(i); members_.Add(i); }

  public void AddConstructor(Constructor_3 ^c) { c.SetClass(this); constructors_.Add(c); members_.Add(c);  }

  public NonOwningArrayList /* of Member_3 */ ^FindAbstractMembers() {
    NonOwningArrayList /* of Member_3 */ ^a;
    if (parent_ != null)  {
      a = parent_.FindAbstractMembers();

      // remove members overridden in this class
      int i = 0;
      while (i < a.Count) {
        Member_3 m = (Member_3) a[i];
        Member_3 n = GetMatchingMember(m);
        if (n != null) {
          Debug.Assert(n.HasAttribute(Attribute_3.Abstract | Attribute_3.Override));
          a.RemoveAt(i);
        } else ++i;
      }
    } else a = new NonOwningArrayList();

    // add abstract members from this class
    foreach (Member_3 m in members_) {
      if (m.HasAttribute(Attribute_3.Abstract))
        a.Add(m);
    }

    return a;
  }

  public bool ResolveAll(Program_3 program) {
    if (parent_name_ != null) {
      parent_ = program.FindClass(parent_name_);
      if (parent_ == null) {
        syntax_.Error("can't find parent class {0}", parent_name_);
        return false;
      }
    } else if (this == GObject_3.type_)
      parent_ = null;
    else parent_ = GObject_3.type_;
    if (parent_ != null)
      parent_.subclasses_.Add(this);

    foreach (Member_3 m in members_)
      if (!m.Resolve(program))
        return false;

    if (!IsExtern() && constructors_.Count == 0)
      // add a default constructor
      AddConstructor(new Constructor_3(Attribute_3.Public, name_, new ArrayList(), Block_3.EmptyBlock()));

    return true;
  }

  // In our first checking pass we check all constant fields since we may need to evaluate them
  // in the course of checking other code.
  public bool Check1(Context_3 prev_ctx) {
    if (!AttributeUtil_3.CheckOnly(attributes_,
         Attribute_3.Abstract | Attribute_3.Extern | Attribute_3.Public)) {
      syntax_.Error("illegal class attribute");
      return false;
    }

    if (prev_ctx.program_.FindClass(name_) != this) {
      syntax_.Error("can't have two classes named {0}", name_);
      return false;
    }

    Context_3 ^ctx = new Context_3(prev_ctx, this);
    bool ok = true;
    foreach (Field_3 f in fields_) {
      ConstField_3 cf = f as ConstField_3;
      if (cf != null)
        ok &= cf.Check(ctx);
    }
    return ok;
  }

  public bool Check(Context_3 prev_ctx) {
    Context_3 ^ctx = new Context_3(prev_ctx, this);

    bool ok = true;

    foreach (Member_3 m in members_)
      if (m is Field_3 && !(m is ConstField_3) || m is Method_3)
        ok &= m.Check(ctx);

    // We need to check properties and indexers separately since they add methods to the members_
    // array as they are checked.
    foreach (Property_3 p in properties_)
      ok &= p.Check(ctx);
    foreach (Indexer_3 i in indexers_)
      ok &= i.Check(ctx);

    if (!HasAttribute(Attribute_3.Abstract)) {
      NonOwningArrayList ^a = FindAbstractMembers();
      if (a.Count > 0) {
        foreach (Member_3 m in a)
          syntax_.Error("class does not define inherited abstract {0} {1}", m.KindString(), m.name_);
        ok = false;
      }
    }

    return ok;
  }

  public void GetMainMethod(NonOwningArrayList /* of Method_3 */ result) {
    foreach (Method_3 m in methods_)
      if (m.name_ == "Main" && m.IsPublic() && m.IsStatic() && m.ReturnType() == Void_3.type_) {
        int c = m.parameters_.Count;
        if (c > 1)
          continue;
        if (c == 1) {
          Parameter_3 p = m.Param(0);
          if (p.GetMode() != 0 || !p.Type().Equals(new ArrayType_3(GString_3.type_)) )
            continue;
        }
        result.Add(m);
      }
  }

  public override void FindTypeDestroys(int marker, TypeSet_3 set) {
    if (marker_ == marker)
      return;
    marker_ = marker;
    set.Add(this);
    for (Class_3 c = this; c != null; c = c.parent_) {
      if (c != this && c.marker_ == marker)
        break;
      foreach (Field_3 f in c.fields_)
        if (!f.IsConstOrStatic())
          f.Type().FindVarDestroys(marker, set);
    }
    foreach (Class_3 c in subclasses_)
      c.FindTypeDestroys(marker, set);
  }

  public override TypeSet_3 TypeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_3();
      FindTypeDestroys(Control_3.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  public Temporaries_3 NewTemporaries() {
    Temporaries_3 ^t = new Temporaries_3();
    Temporaries_3 ret = t;
    temporaries_.Add(t);
    return ret;
  }

  public void StaticInit() {
    foreach (Field_3 f in fields_) {
      StaticField_3 sf = f as StaticField_3;
      if (sf != null)
        sf.Init();
    }
  }

  public override string EmitTypeName() { return name_; }

  int EmitAccess(SourceWriter_3 w, int old_access, int new_access) {
    new_access = (new_access & Attribute_3.Public) != 0 ? Attribute_3.Public : Attribute_3.Protected;

    if (new_access != old_access) {
      switch (new_access) {
        case Attribute_3.Protected:
          w.Indent(-1);
          w.WriteLine("protected:");
          break;
        case Attribute_3.Public:
          w.Indent(-1);
          w.WriteLine("public:");
          break;
        default:
          Debug.Assert(false);
          break;
      }
    }

    return new_access;
  }

  public void EmitInitializers(SourceWriter_3 w) {
    foreach (Field_3 f in fields_)
      if (!f.IsConstOrStatic())
        f.EmitInitializer(w);
  }

  // Return_3 true if this top-level class must inherit from Object.
  bool ObjectInherit() {
    if (object_inherit_)
      return true;
    foreach (Class_3 c in subclasses_)
      if (c.ObjectInherit())
        return true;
    return false;
  }

  public void EmitDeclaration(SourceWriter_3 w) {
    if (emitted_ || IsExtern())
      return;

    // C++ requires a parent class to appear before its subclasses in a source file.
    parent_.EmitDeclaration(w);

    emitted_ = true;

    w.Write("class {0} ", name_);
    if (parent_ != null)
      w.Write(": public {0} ",
              parent_ == GObject_3.type_ && !ObjectInherit() ? "_Object" : parent_.name_);
    w.OpenBrace();

    int access = 0;

    if (fields_.Count > 0) {
      foreach (Field_3 f in fields_) {
        access = EmitAccess(w, access, f.attributes_);
        f.EmitDeclaration(w);
      }
      w.WriteLine("");
    }

    if (subclasses_.Count > 0) {
      access = EmitAccess(w, access, Attribute_3.Protected);
      w.IWrite("{0}(Dummy *dummy) ", name_);
      if (parent_ != GObject_3.type_)
        w.Write(": {0}(dummy) ", parent_.name_);
      w.WriteLine("{ }");
      w.WriteLine("");
    }

    // If_3 we have more than one constructor, emit an _Init() method which constructors can
    // call to initialize instance variables.
    if (constructors_.Count > 1) {
      access = EmitAccess(w, access, Attribute_3.Protected);
      w.IWriteLine("void _Init();");
      w.WriteLine("");
    }

    foreach (Constructor_3 c in constructors_) {
      access = EmitAccess(w, access, c.attributes_);
      c.EmitDeclaration(w);
    }

    if (virtual_) {
      access = EmitAccess(w, access, Attribute_3.Public);
      w.IWrite("virtual ~{0}()", name_);
      w.WriteLine(" { }");
      w.WriteLine("");
    }

    if (need_destroy_) {
      access = EmitAccess(w, access, Attribute_3.Public);
      w.IWriteLine("GEL_OBJECT({0})", name_);
      w.WriteLine("");
    }

    foreach (Method_3 m in methods_) {
      access = EmitAccess(w, access, m.attributes_);
      m.EmitDeclaration(w);
    }

    w.SubIndent();
    w.WriteLine("};");
    w.WriteLine("");
  }

  public void Emit(SourceWriter_3 w) {
    if (IsExtern())
      return;

    if (fields_.Count > 0) {
      foreach (Field_3 f in fields_)
        f.Emit(w);
      w.WriteLine("");
    }

    if (constructors_.Count > 1) {
      w.IWrite("void {0}::_Init() ", name_);
      w.OpenBrace();
      EmitInitializers(w);
      w.CloseBrace();
      w.WriteLine("");
    }

    foreach (Constructor_3 c in constructors_)
      c.Emit(w);

    foreach (Method_3 m in methods_)
      m.Emit(w);

    if (Gel_3.print_type_sets_)
      Console.WriteLine("~{0}: {1}", name_, TypeDestroys());
  }
}

class ClassPtr_3 {
  public readonly Class_3 class_;

  public ClassPtr_3(Class_3 c) { class_ = c; }
}

class ValueList_3 {
  public ArrayList list_;
  public ValueList_3(ArrayList list) { list_ = list; }

  public GValue_3 Object(int i) { return ((RValue_3) list_[i]).Get(); }
  public bool Bool(int i) { return ((GBool_3) list_[i]).b_; }
  public int Int(int i) { return ((GInt_3) list_[i]).i_; }
  public char Char(int i) { return ((GChar_3) list_[i]).c_; }
  public string GetString(int i) { return ((GString_3) list_[i]).s_; }
}

class Internal_3 : Class_3 {
  static NonOwningArrayList /* of Internal_3 */ ^all_ = new NonOwningArrayList();

  protected Internal_3(string name) : base(name) { }

  public static Internal_3 Find(string name) {
    foreach (Internal_3 p in all_)
      if (p.name_ == name)
        return p;
    return null;
  }

  static void Add(Internal_3 p) { all_.Add(p); }

  public static void Init() {
    Add(GObject_3.type_);
    Add(GArray_3.array_class_);
    Add(GBool_3.type_);
    Add(GChar_3.type_);
    Add(GDouble_3.type_);
    Add(GFloat_3.type_);
    Add(GInt_3.type_);
    Add(GString_3.type_);
    Add(GStringBuilder_3.type_);
    Add(PoolClass_3.instance_);
    Add(DebugClass_3.instance_);
    Add(EnvironmentClass_3.instance_);

    Add(ConsoleClass_3.instance_);
    Add(FileClass_3.instance_);
    Add(PathClass_3.instance_);
    Add(GStreamReader_3.type_);
  }
}

class ObjectClass_3 : Internal_3 {
  public Method_3 equals_;
  public Method_3 get_hash_code_;
  public Method_3 to_string_;

  public ObjectClass_3() : base("Object") { }

  public override void Add(Method_3 ^m) {
    switch (m.name_) {
      case "Equals": equals_ = m; break;
      case "GetHashCode": get_hash_code_ = m; break;
      case "ToString": to_string_ = m; break;
    }
    base.Add(m);
  }
}

class ArrayClass_3 : Internal_3 {
  public ArrayClass_3() : base("Array") { }
}

abstract class SimpleType_3 : Internal_3 {
  protected SimpleType_3(string name) : base(name) { }

  public override bool IsOwned() { return false; }
  public override bool IsReference() { return false; }
  public override bool IsValue() { return true; }

  public override string EmitExprType() { return EmitType(); }
  public override string EmitType() { Debug.Assert(false); return null; }
}

abstract class IntegralType_3 : SimpleType_3 {
  protected IntegralType_3(string name) : base(name) { }
}

class BoolClass_3 : IntegralType_3 {
  public BoolClass_3() : base("Bool") { }

  static GBool_3 ^default_ = new GBool_3(false);
  public override SimpleValue_3 DefaultValue_3() { return default_; }

  public override string ToString() { return "bool"; }

  public override string EmitType() { return "bool"; }
}

class CharClass_3 : IntegralType_3 {
  public CharClass_3() : base("Char") { }

  static GChar_3 ^default_ = new GChar_3('\0');

  public override SimpleValue_3 DefaultValue_3() { return default_; }

  public override bool CanConvert1(GType_3 t) { return t == GInt_3.type_; }

  public override string ToString() { return "char"; }

  public override RValue_3 ^InvokeStatic(Method_3 m, ValueList_3 args) {
    switch (m.name_) {
      case "IsDigit": return new GBool_3(Char.IsDigit(args.Char(0)));
      case "IsLetter": return new GBool_3(Char.IsLetter(args.Char(0)));
      case "IsWhiteSpace": return new GBool_3(Char.IsWhiteSpace(args.Char(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "wchar_t"; }
}

class IntClass_3 : IntegralType_3 {
  public IntClass_3() : base("Int") { }

  static GInt_3 ^default_ = new GInt_3(0);

  public override SimpleValue_3 DefaultValue_3() { return default_; }

  public override bool CanConvert1(GType_3 t) {
    return t == GFloat_3.type_ || t == GDouble_3.type_;
  }

  protected override bool CanConvertExplicit1(GType_3 t) {
    return t == GChar_3.type_;
  }

  public override string ToString() { return "int"; }

  public override RValue_3 ^InvokeStatic(Method_3 m, ValueList_3 args) {
    switch (m.name_) {
      case "Parse": return new GInt_3(int.Parse(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "int"; }
}

class FloatClass_3 : SimpleType_3 {
  public FloatClass_3() : base("Single") { }

  static GFloat_3 ^default_ = new GFloat_3(0.0f);

  public override SimpleValue_3 DefaultValue_3() { return default_; }

  public override bool CanConvert1(GType_3 t) {
    return t == GDouble_3.type_;
  }

  protected override bool CanConvertExplicit1(GType_3 t) {
    return t == GInt_3.type_;
  }

  public override string ToString() { return "float"; }

  public override string EmitType() { return "float"; }
}

class DoubleClass_3 : SimpleType_3 {
  public DoubleClass_3() : base("Double") { }

  static GDouble_3 ^default_ = new GDouble_3(0.0d);

  public override SimpleValue_3 DefaultValue_3() { return default_; }

  protected override bool CanConvertExplicit1(GType_3 t) {
    return t == GInt_3.type_ || t == GFloat_3.type_;
  }

  public override string ToString() { return "double"; }

  public override string EmitType() { return "double"; }
}

class StringClass_3 : Internal_3 {
  public StringClass_3() : base("String") { }

  public override bool IsOwned() { return false; }
  public override bool IsValue() { return true; }

  public override string ToString() { return "string"; }

  public override string EmitType() {
    return "_Ref<String>";
  }

  public override string EmitReturnType() {
    return EmitType();
  }

  public override string EmitGenericType() {
    return EmitType();
  }

  public override RValue_3 ^InvokeStatic(Method_3 m, ValueList_3 args) {
    switch (m.name_) {
      case "Format": return new GString_3(String.Format(args.GetString(0), args.Object(1)));
      default: Debug.Assert(false); return null;
    }
  }
}

class StringBuilderClass_3 : Internal_3 {
  public StringBuilderClass_3() : base("StringBuilder") { }
  public override GValue_3 ^New_3() { return new GStringBuilder_3(); }
}

class GStringBuilder_3 : GValue_3 {
  readonly StringBuilder ^b_ = new StringBuilder();

  public static readonly StringBuilderClass_3 ^type_ = new StringBuilderClass_3();

  public override GType_3 Type() { return type_; }

  public override RValue_3 ^Invoke(Method_3 m, ValueList_3 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "Append": b_.Append(args.Char(0)); return null;
      case "ToString": return new GString_3(b_.ToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class PoolClass_3 : Internal_3 {
  public PoolClass_3() : base("Pool") { }

  public static PoolClass_3 ^instance_ = new PoolClass_3();
}

class DebugClass_3 : Internal_3 {
  public DebugClass_3() : base("Debug") { }
  public static readonly DebugClass_3 ^instance_ = new DebugClass_3();
  
  public override RValue_3 ^InvokeStatic(Method_3 m, ValueList_3 args) {
    switch (m.name_) {
      case "Assert": Debug.Assert(args.Bool(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

class EnvironmentClass_3 : Internal_3 {
  public EnvironmentClass_3() : base("Environment") { }
  public static readonly EnvironmentClass_3 ^instance_ = new EnvironmentClass_3();

  public override RValue_3 ^InvokeStatic(Method_3 m, ValueList_3 args) {
    switch (m.name_) {
      case "Exit": Environment.Exit(args.Int(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

// built-in I/O classes

class ConsoleClass_3 : Internal_3 {
  public ConsoleClass_3() : base("Console") { }

  public override RValue_3 ^InvokeStatic(Method_3 m, ValueList_3 args) {
    switch (m.name_) {
      case "Write":
        switch (m.parameters_.Count) {
          case 1: Console.Write(args.Object(0)); return null;
          case 2: Console.Write(args.GetString(0), args.Object(1)); return null;
          case 3: Console.Write(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      case "WriteLine":
        switch (m.parameters_.Count) {
          case 1: Console.WriteLine(args.Object(0)); return null;
          case 2: Console.WriteLine(args.GetString(0), args.Object(1)); return null;
          case 3: Console.WriteLine(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly ConsoleClass_3 ^instance_ = new ConsoleClass_3();
}

class FileClass_3 : Internal_3 {
  public FileClass_3() : base("File") { }

  public override RValue_3 ^InvokeStatic(Method_3 m, ValueList_3 args) {
    switch (m.name_) {
      case "Delete": File.Delete(args.GetString(0)); return null;
      case "Exists": return new GBool_3(File.Exists(args.ToString()));
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly FileClass_3 ^instance_ = new FileClass_3();
}

class PathClass_3 : Internal_3 {
  public PathClass_3() : base("Path") { }

  public override RValue_3 ^InvokeStatic(Method_3 m, ValueList_3 args) {
    switch (m.name_) {
      case "GetTempFileName": return new GString_3(Path.GetTempFileName());
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly PathClass_3 ^instance_ = new PathClass_3();
}

class StreamReaderClass_3 : Internal_3 {
  public StreamReaderClass_3() : base("StreamReader") { }
  public override GValue_3 ^New_3() { return new GStreamReader_3(); }
}

class GStreamReader_3 : GValue_3 {
  StreamReader ^reader_;

  public static readonly StreamReaderClass_3 ^type_ = new StreamReaderClass_3();

  public override GType_3 Type() { return type_; }

  public override RValue_3 ^Invoke(Method_3 m, ValueList_3 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StreamReader": reader_ = new StreamReader(args.GetString(0)); return null;
      case "Read": return new GInt_3(reader_.Read());
      case "Peek": return new GInt_3(reader_.Peek());
      default: Debug.Assert(false); return null;
    }
  }
}

class Program_3 {
  ArrayList /* of string */ ^gel_import_ = new ArrayList();
  ArrayList /* of string */ ^cpp_import_ = new ArrayList();

  static Scanner_3 ^scanner_;

  NonOwningArrayList ^classes_ = new NonOwningArrayList();
  ArrayList ^own_classes_ = new ArrayList();

  public bool crt_alloc_;
  public bool debug_;
  public bool safe_ = true;

  public Control_3 prev_;   // previous node in control flow graph, used during graph construction

  public void Import(string s) {
    ArrayList a = null;
    string extension = Path.GetExtension(s);
    switch (extension) {
      case ".gel": a = gel_import_; break;
      case ".cpp": a = cpp_import_; break;
      default:
        new Syntax_3().Error("can't import file with extension {0}", extension);
        Environment.Exit(0);
        break;
    }
    foreach (string i in a)
      if (i == s)
        return;   // already imported
    a.Add(s);
  }

  public void FindAndImport(string s) {
    // First look relative to the importing file.
    string dir = Path.GetDirectoryName(Gel_3.CurrentFile());
    string s1 = Path.Combine(dir, s);
    if (!File.Exists(s1)) {
      // Now look relative to the GEL2 directory.
      s1 = Path.Combine(Gel_3.gel_directory_, s);
      if (!File.Exists(s1)) {
        new Syntax_3().Error("import not found: ", s);
        Environment.Exit(0);
      }
    }
    Import(s1);
  }
  
  public void Add(Class_3 c) {
    c.SetProgram(this);
    classes_.Add(c);
  }

  public void AddOwn(Class_3 ^c) {
    own_classes_.Add(c);
  }

  public Class_3 FindClass(string name) {
    foreach (Class_3 c in classes_)
      if (c.name_ == name)
        return c;
    return null;
  }

  public string CurrentFile() {
    return scanner_.filename_;
  }

  public int Line() {
    return scanner_.Line();
  }

  string Builtin(string module) {
    string file = String.Format("{0}.gel", module);
    return Path.Combine(Gel_3.gel_directory_, file);
  }

  public bool Parse() {
    Parser ^parser = new Parser();
    for (int i = 0; i < gel_import_.Count; ++i) {
      string file = (string) gel_import_[i];
      scanner_ = new Scanner_3(file);
      parser.yyParse(scanner_);
      if (i == 0) {
        Import(Builtin("internal"));
        Import(Builtin("library"));
      }
    }
    return true;
  }

  public bool Resolve() {
    foreach (Class_3 c in classes_)
      if (!c.ResolveAll(this))
        return false;

    return true;
  }

  public bool Check() {
    Context_3 ^ctx = new Context_3(this);
    bool ok = true;

    // Make a first checking pass where we check only constant fields.
    foreach (Class_3 c in classes_)
      ok &= c.Check1(ctx);

    foreach (Class_3 c in classes_)
      ok &= c.Check(ctx);

    return ok;
  }

  Method_3 FindMain() {
    NonOwningArrayList ^methods = new NonOwningArrayList();
    foreach (Class_3 c in classes_) {
      c.GetMainMethod(methods);
    }
    if (methods.Count == 0) {
      Console.WriteLine("no Main() method found");
      return null;
    }
    if (methods.Count > 1) {
      Console.WriteLine("error: found more than one Main() method");
      return null;
    }
    return (Method_3) methods[0];
  }

  public void Eval(ArrayList /* of string */ args) {
    Method_3 m = FindMain();
    if (m == null)
      return;
    ArrayList ^a = new ArrayList();
    if (m.parameters_.Count > 0) {   // Main() takes a string[] argument
      GArray_3 ^arr = new GArray_3(new ArrayType_3(GString_3.type_), args.Count);
      for (int i = 0 ; i < args.Count ; ++i)
        arr.Set(i, new GString_3((string) args[i]));
      a.Add(arr);
    }
    foreach (Class_3 c in classes_)
      c.StaticInit();
    m.Invoke(null, a);
  }

  void EmitMain(SourceWriter_3 w, Method_3 main) {
    bool args = main.parameters_.Count > 0;
    w.Write("int main({0}) ", args ? "int argc, char *argv[]" : "");
    w.OpenBrace();
    w.IWriteLine("return gel_runmain({0}::Main{1});", main.GetClass().name_, args ? ", argc, argv" : "");
    w.CloseBrace();
  }

  public bool Emit(SourceWriter_3 w) {
    Method_3 main = FindMain();
    if (main == null)
      return false;

    w.WriteLine("#define MEMORY_OWN 1");
    if (safe_)
      w.WriteLine("#define MEMORY_SAFE 1");
    if (crt_alloc_)
      w.WriteLine("#define MEMORY_CRT 1");

    foreach (string f in cpp_import_)
      w.WriteLine("#include {0}", GString_3.EmitString(f));

    // We undefine NULL since Gel_3 code may legitimately define fields or variables with that name.
    // Generated code uses 0, not NULL, to indicate the null pointer.
    w.WriteLine("#undef NULL");

    w.WriteLine("");

    // Forward-declare all classes since C++ requires a class to be declared before its name can
    // be used as a type.
    foreach (Class_3 c in classes_)
      if (!(c.HasAttribute(Attribute_3.Extern)))
        w.WriteLine("class {0};", c.name_);
    w.WriteLine("");

    foreach (Class_3 c in classes_)
      c.EmitDeclaration(w);

    foreach (Class_3 c in classes_)
      c.Emit(w);

    EmitMain(w, main);
    return true;
  }

  // Emit C++ code.
  public bool Generate(string basename) {
    string cpp_file = basename + ".cpp";
    StreamWriter ^w = new StreamWriter(cpp_file);
    bool ok = Emit(new SourceWriter_3(w));
    w.Close();
    return ok;
  }

  static string[] ^vsdirs = { "Microsoft Visual Studio 8",
                            "Microsoft Visual Studio .NET 2003",
                            "Microsoft Visual Studio .NET 2002" };

  string VsVars(int i) {
    return String.Format("C:\\Program_3 Files\\{0}\\Common7\\Tools\\vsvars32.bat", vsdirs[i]);
  }

  string FindVsVars() {
    for (int i = 0; i < vsdirs.Length; ++i) {
      string f = VsVars(i);
      if (File.Exists(f))
        return f;
    }

    Console.WriteLine("Error: unable to find vsvars32.bat at any of the following locations:");
    Console.WriteLine("");
    for (int i = 0; i < vsdirs.Length; ++i)
      Console.WriteLine(VsVars(i));
    Console.WriteLine("");
    Console.WriteLine("Your Visual Studio installation may be invalid.  Aborting compilation.");
    return null;
  }

  // Report compilation error. Print error message from a file
  void ReportCompilationError(string error_msg_file) {
      Console.WriteLine(
        "Error: unable to compile generated C++ code.  You may have found a bug in the GEL2 compiler.");
      Console.WriteLine("C++ compiler output follows:");
      Console.WriteLine("");
      Console.WriteLine((new StreamReader(error_msg_file)).ReadToEnd());
  }

  void UnixCppCompile(string basename) {
    string command_out = Path.GetTempFileName();
    string dbg_options = debug_ ? "-g -DDEBUG" : "-O2 -DNDEBUG";
    StringBuilder ^sb = new StringBuilder();
    // -o basename, use basename as the executable name
    // -Werror, make all warnings into hard errors
    sb.AppendFormat("/usr/bin/g++ -o {0} -Werror {1} {2}.cpp",
                    basename, dbg_options, basename);

    // Append redirection of output
    sb.AppendFormat(" > {0} 2>&1", command_out);
 
    string sh_cmd = sb.ToString();

    if (Gel_3.verbose_) 
      Console.WriteLine(sh_cmd);
  
    if (Process.System(sh_cmd) !=0) {
      ReportCompilationError(command_out);
    }
    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".o");
  }

  // Run vsvars32.bat and the run the given command, redirecting output to a file.
  // We must always redirect output since vsvars32 prints a message "Setting environment..."
  // which we don't want users to see.
  int VsRun(string vsvars, string command, string output) {
    command = String.Format("(\"{0}\" & {1}) > \"{2}\"", 
                            vsvars, command, output);
    return Process.System(command);
  }

  void VsCppCompile(string basename) {
    string vsvars = FindVsVars();
    if (vsvars == null)
      return;
    string command_out = Path.GetTempFileName();

    string options = debug_ ?
      //  /MDd - runtime library: multithreaded debug DLL
      //  /Od - optimization: disabled
      //  /ZI - debug information format: Program_3 Database for Edit & Continue_3
      "/MDd /Od /ZI /D \"_DEBUG\"" :

      //  /MD - runtime library: multithreaded DLL
      //  /O2 - optimization: Maximize Speed
      //  /GL - optimization: Whole Program_3 Optimization
      "/MD /O2 /GL /D \"NDEBUG\"";

    StringBuilder ^sb = new StringBuilder();
    //  /WX - treat warnings as errors
    sb.AppendFormat("cl /nologo /WX {0} {1}.cpp", options, basename);
    string mode = debug_ ? "debug" : "release";
    if (!crt_alloc_)
      sb.AppendFormat(" {0}\\{1}\\dlmalloc.obj", Gel_3.gel_directory_, mode);
    sb.Append(" user32.lib shell32.lib shlwapi.lib");
    string command = sb.ToString();
    if (Gel_3.verbose_)
      Console.WriteLine(command);

    if (VsRun(vsvars, command, command_out) != 0) {
      ReportCompilationError(command_out);
    } else {
      // Run the manifest tool to embed the linker-generated manifest into the executable file;
      // this allows the executable to find the C runtime DLL even when the manifest file is absent.
      string mt_command = String.Format("mt -nologo -manifest {0}.exe.manifest -outputresource:\"{0}.exe;#1\"",
                              basename);
      if (Gel_3.verbose_)
        Console.WriteLine(mt_command);
      if (VsRun(vsvars, mt_command, command_out) != 0)
        Console.WriteLine("warning: could not run manifest tool");
    }

    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".obj");
    File.Delete(basename + ".exe.manifest");
  }

  // Invoke the C++ compiler to generate a native executable.
  void CppCompile(string basename) {
    if (Environment.OSVersion.Platform == PlatformID.Win32NT) 
      VsCppCompile(basename);
    else
      UnixCppCompile(basename);
  }

  public void Compile(string output, bool cpp_only) {
    if (output == null)
      output = Path.GetFileNameWithoutExtension((string) gel_import_[0]);
    if (Generate(output) && !cpp_only)
      CppCompile(output);
  }
}

class Scanner_3 : yyInput {
  public readonly string filename_;

  int line_;
  public int Line() { return line_; }

  StreamReader ^sr_;
  int token_;
  object ^ value_;

  int next_token_ = -1;
  object ^ next_value_;

  public Scanner_3 (string filename) {
    filename_ = filename;
    sr_ = new StreamReader(filename);
    line_ = 1;
  }

  public override int GetToken () {
    return token_;
  }

  public override object ^ GetValue () {
    return take value_;
  }

  int Read() {
    int i = sr_.Read();
    if (i == '\n')
      ++line_;
    return i;
  }

  bool Read(out char c) {
    int i = Read();
    c = (char) i;
    return i != -1;
  }

  char Peek() {
    return (char) sr_.Peek();
  }

  string ReadWord(char first) {
    StringBuilder ^sb = new StringBuilder();
    if (first != '\0')
      sb.Append(first);
    while (true) {
      char c = Peek();
      if (!Char.IsLetter(c) && !Char.IsDigit(c) && c != '_')
        break;
      sb.Append(c);
      Read();
    }
    return sb.ToString();
  }

  // Read to the end of the current line.
  string ReadLine() {
    StringBuilder ^sb = new StringBuilder();
    char c;
    while (Read(out c)) {
      if (c == '\n')
        break;
      sb.Append(c);
    }
    return sb.ToString();
  }

  // Read a comment delimited by /* ... */, assuming we've already read the opening /*.
  // Returns true on success, or false on EOF.
  bool ReadDelimitedComment() {
    char prev = (char) 0;
    while (true) {
      char c;
      if (!Read(out c)) {
        Console.WriteLine("warning: unterminated comment at end of file");
        return false;
      }
      if (c == '/' && prev == '*')
        return true;
      prev = c;
    }
  }

  // Preprocess input, handling whitespace, comments and directives; return the first
  // character not eaten by preprocessing, or -1 on EOF.
  int GetChar() {
    while (true) {
      int i = Read();
      if (i == -1)
        return -1;   // end of input
      if (i == 0)
        continue;   // end of this file; move on
      char c = (char) i;

      if (c == '\n' && Peek() == '#') {
        Read();
        string directive = ReadWord('\0');
        if (directive == "line") {
          ReadLine();
          continue;
        }
        Console.WriteLine("error: unknown preprocessing directive {0}", directive);
        Environment.Exit(0);
      }

      if (Char.IsWhiteSpace(c))
        continue;

      if (c == '/') {
        switch (Peek()) {
          case '/':  // single-line comment
            Read();
            int line = line_;
            string s = ReadLine();
            if (Gel_3.error_test_ && s.StartsWith(" error"))
              Gel_3.expected_error_lines_.Add(line);
            continue;

          case '*':  // comment delimited by /* ... */
            Read();   // move past opening '*'
            if (!ReadDelimitedComment())
              return (char) 0;
            continue;
        }
      }

      return c;
    }
  }

  bool IsDigit(char c, bool hex) {
    if (Char.IsDigit(c))
      return true;
    if (!hex)
      return false;
    return (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');
  }

  // Read a number, possibly including a decimal point and/or exponent.
  string ReadNumber(char first, bool hex, out bool real) {
    bool dot = false, exp = false;
    StringBuilder ^sb = new StringBuilder();
    sb.Append(first);
    if (first == '.')
      dot = true;

    while (true) {
      bool need_digit = false;
      char c = Peek();
      if (c == '.' && !hex && !dot && !exp) {
        sb.Append(c);
        Read();
        dot = true;
        c = Peek();
        need_digit = true;
      }
      else if ((c == 'e' || c == 'E') && !hex && !exp) {
        sb.Append(c);
        Read();
        exp = true;
        c = Peek();
        if (c == '+' || c == '-') {
          sb.Append(c);
          Read();
          c = Peek();
        }
        need_digit = true;
      }
      if (!IsDigit(c, hex)) {
        if (!need_digit)
          break;
        real = false;
        return null;
      }
      sb.Append(c);
      Read();
    }

    real = dot || exp;
    return sb.ToString();
  }

  int ParseNumber(char first, out object ^val) {
    bool hex = false;
    if (first == '0') {
      char p = Peek();
      if (p == 'x' || p == 'X') {
        Read();
        hex = true;
      }
    }
    bool real;
    string s = ReadNumber(first, hex, out real);
    if (s == null) {
      val = null;
      return Parser.SCAN_ERROR;
    }
    if (!hex) {
      switch (Peek()) {
        case 'F':
        case 'f':
          Read();
          val = Single.Parse(s);
          return Parser.FLOAT_LITERAL;
        case 'D':
        case 'd':
          Read();
          real = true;
        break;
    }
    }
    if (real) {
      val = Double.Parse(s);
      return Parser.DOUBLE_LITERAL;
    }
    val = int.Parse(s, hex ? NumberStyles.HexNumber : NumberStyles.Integer);
    return Parser.INT_LITERAL;
  }

  int ParseWord(char first, out object ^val) {
    string s = ReadWord(first);

    val = null;
    switch (s) {
      case "abstract": return Parser.ABSTRACT;
      case "as": return Parser.AS;
      case "base": return Parser.BASE;
      case "bool": return Parser.BOOL;
      case "break": return Parser.BREAK;
      case "case": return Parser.CASE;
      case "char": return Parser.CHAR;
      case "class": return Parser.CLASS;
      case "const": return Parser.CONST_TOKEN;
      case "continue": return Parser.CONTINUE;
      case "default": return Parser.DEFAULT;
      case "do": return Parser.DO;
      case "double": return Parser.DOUBLE;
      case "else": return Parser.ELSE;
      case "extern": return Parser.EXTERN;
      case "false": return Parser.FALSE_TOKEN;
      case "float": return Parser.FLOAT;
      case "for": return Parser.FOR;
      case "foreach": return Parser.FOREACH;
      case "if": return Parser.IF;
      case "import": return Parser.IMPORT;
      case "in": return Parser.IN_TOKEN;
      case "int": return Parser.INT;
      case "is": return Parser.IS;
      case "new": return Parser.NEW;
      case "null": return Parser.NULL;
      case "object": return Parser.OBJECT;
      case "out": return Parser.OUT_TOKEN;
      case "override": return Parser.OVERRIDE;
      case "pool": return Parser.POOL;
      case "private": return Parser.PRIVATE;
      case "protected": return Parser.PROTECTED;
      case "public": return Parser.PUBLIC;
      case "readonly": return Parser.READONLY;
      case "ref": return Parser.REF;
      case "return": return Parser.RETURN;
      case "short": return Parser.SHORT;
      case "static": return Parser.STATIC;
      case "string": return Parser.STRING;
      case "switch": return Parser.SWITCH;
      case "take": return Parser.TAKE;
      case "this": return Parser.THIS_TOKEN;
      case "true": return Parser.TRUE_TOKEN;
      case "virtual": return Parser.VIRTUAL;
      case "void": return Parser.VOID_TOKEN;
      case "while": return Parser.WHILE;
      default:
        val = s;
        return Parser.ID;
    }
  }

  bool ParseEscape(ref char c) {
    if (!Read(out c))
      return false;
    switch (c) {
      case '\'':
      case '\"':
      case '\\':
        break;
      case '0': c = '\0'; break;
      case 'n': c = '\n'; break;
      case 'r': c = '\r'; break;
      case 't': c = '\t'; break;
      default: return false;
    }
    return true;
  }

  int ParseChar(out object ^val) {
    val = null;
    char c;
    if (!Read(out c))
      return Parser.SCAN_ERROR;
    if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
    char d;
    if (!Read(out d) || d != '\'')
      return Parser.SCAN_ERROR;
    val = c;
    return Parser.CHAR_LITERAL;
  }

  int ParseString(out object ^val) {
    val = null;
    StringBuilder ^sb = new StringBuilder();
    while (true) {
      char c;
      if (!Read(out c))
        return Parser.SCAN_ERROR;
      if (c == '"')
        break;
      if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
      sb.Append(c);
    }
    val = sb.ToString();
    return Parser.STRING_LITERAL;
  }

  int ReadToken(out object ^val) {
    val = null;

    int i = GetChar();
    if (i == -1)
      return -1;
    char c = (char) i;

    if (Char.IsDigit(c) || c == '.' && Char.IsDigit(Peek()))
      return ParseNumber(c, out val);

    if (Char.IsLetter(c) || c == '_')
      return ParseWord(c, out val);

    if (c == '\'')
      return ParseChar(out val);

    if (c == '"')
      return ParseString(out val);

    char peek = Peek();
    int token = 0;
    switch (c.ToString() + peek.ToString()) {
      case "++": token = Parser.PLUS_PLUS; break;
      case "--": token = Parser.MINUS_MINUS; break;
      case "&&": token = Parser.OP_AND; break;
      case "||": token = Parser.OP_OR; break;
      case "==": token = Parser.OP_EQUAL; break;
      case "!=": token = Parser.OP_NE; break;
      case "<=": token = Parser.OP_LE; break;
      case "<<": token = Parser.OP_LEFT_SHIFT; break;
      case ">=": token = Parser.OP_GE; break;
      case ">>": token = Parser.OP_RIGHT_SHIFT; break;
      case "*=": token = Parser.STAR_EQUAL; break;
      case "/=": token = Parser.SLASH_EQUAL; break;
      case "%=": token = Parser.PERCENT_EQUAL; break;
      case "+=": token = Parser.PLUS_EQUAL; break;
      case "-=": token = Parser.MINUS_EQUAL; break;
      case "&=": token = Parser.AND_EQUAL; break;
      case "|=": token = Parser.OR_EQUAL; break;

      // Return_3 [] as a single token; this lets the parser distinguish the cases
      // "foo[] a;" and "foo[x] = 4" as soon as it reads the first token after the identifier "foo".
      case "[]": token = Parser.ARRAY_TYPE; break;
    }
    if (token != 0) {
      Read();
    } else token = c;

    val = token;
    return token;
  }

  public override bool Advance () {
    if (next_token_ != -1) {
      token_ = next_token_;
      value_ = take next_value_;
      next_token_ = -1;
    } else {
      token_ = ReadToken(out value_);
      if (token_ == -1) return false;
    }

    if (token_ == ')') {
      // We need to read one token ahead to determine whether this close parenthesis
      // ends a type cast.  See e.g. the discussion in the Cast_3 Expressions section
      // of the C# specification.
      next_token_ = ReadToken(out next_value_);
      switch (next_token_) {
        case -1:  // end of file
          break;
        case '!':
        case '(':
        case Parser.ID:
        case Parser.INT_LITERAL:
        case Parser.CHAR_LITERAL:
        case Parser.STRING_LITERAL:
          token_ = Parser.CAST_CLOSE_PAREN;
          break;
        default:
          if (next_token_ >= Parser.FIRST_KEYWORD && next_token_ <= Parser.LAST_KEYWORD &&
              next_token_ != Parser.AS && next_token_ != Parser.IS)
            token_ = Parser.CAST_CLOSE_PAREN;
          break;
      }
    }
    return true;
  }

  public override void Fatal() {
    new Syntax_3().Error("irrecoverable syntax error");
    Environment.Exit(1);
  }

}

class Gel_3 {
  public static bool verbose_;

  public static bool error_test_;
  public static bool print_type_sets_;

  public static readonly ArrayList /* of int */ ^expected_error_lines_ = new ArrayList();
  public static readonly ArrayList /* of int */ ^error_lines_ = new ArrayList();

  public static Program_3 ^program_;

  public static readonly string gel_directory_ = GetLibraryPath();

  static string GetLibraryPath() {
    return Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName); 
  }

  public static string CurrentFile() {
    return program_ == null ? "" : program_.CurrentFile();
  }

  public static int Line() {
    return program_ == null ? 0 : program_.Line();
  }

  public static void Exit() { Environment.Exit(0); }

  // Given two sorted ArrayLists a, b of ints, return an ArrayList containing all ints which appear
  // in [a] but not in [b].
  ArrayList ^Diff(ArrayList a, ArrayList b) {
    ArrayList ^ret = new ArrayList();
    int bi = 0;
    foreach (int i in a) {
      while (bi < b.Count && (int) b[bi] < i)
        ++bi;
      if (bi >= b.Count || (int) b[bi] > i)
        ret.Add(i);
    }
    return ret;
  }

  void WriteLineNumbers(ArrayList a) {
    for (int i = 0; i < a.Count; ++i) {
      if (i > 0)
        Console.Write(", ");
      Console.Write(a[i]);
    }
    Console.WriteLine("");
  }

  void ErrorTestReport() {
    Console.WriteLine("");
    ArrayList ^e = Diff(error_lines_, expected_error_lines_);
    if (e.Count > 0) {
      Console.Write("unexpected error at line ");
      WriteLineNumbers(e);
    }
    ArrayList ^e2 = Diff(expected_error_lines_, error_lines_);
    if (e2.Count > 0) {
      Console.Write("expected error at line ");
      WriteLineNumbers(e2);
    }
    if (e.Count == 0 && e2.Count == 0)
      Console.WriteLine("all errors expected");
  }

  void Usage_3() {
    Console.WriteLine("usage: gel <source-file> ... [args]");
    Console.WriteLine("       gel -c [-d] [-o <name>] [-u] [-v] [-cpp] <source-file> ...");
    Console.WriteLine("");
    Console.WriteLine("   -c: compile to native executable");
    Console.WriteLine("   -d: debug mode: disable optimizations, link with debug build of C runtime");
    Console.WriteLine("   -o: specify output filename");
    Console.WriteLine("   -u: unsafe: skip reference count checks");
    Console.WriteLine("   -v: verbose: display command used to invoke C++ compiler");
    Console.WriteLine(" -cpp: compile to C++ only");
  }

  public void Run(string[] args) {
    if (args.Length < 1) {
      Usage_3();
      return;
    }

    Internal_3.Init();

    program_ = new Program_3();
    bool compile = false;
    bool cpp_only = false;
    string output = null;
    int i;
    for (i = 0; i < args.Length && args[i].StartsWith("-"); ++i)
      switch (args[i]) {
        case "-c": compile = true; break;
        case "-d": program_.debug_ = true; break;
        case "-e": error_test_ = true; break;
        case "-o":
          if (++i >= args.Length) {
            Usage_3();
            return;
          }
          output = Path.GetFileNameWithoutExtension(args[i]);
          break;
        case "-u": program_.safe_ = false; break;
        case "-v": verbose_ = true; break;
        case "-cpp": cpp_only = true; break;
        case "-crt": program_.crt_alloc_ = true; break;
        case "-typeset": print_type_sets_ = true; break;
        default:
          Console.WriteLine("unrecognized option: {0}", args[i]);
          return;
      }

    for (; i < args.Length ; ++i)
      if (args[i].EndsWith(".gel"))
        program_.Import(args[i]);
      else {
        if (args[i] == "-")   // marker indicating end of source files
          ++i;
        break;
      }

    ArrayList ^program_args = new ArrayList();
    if (compile) {
      if (i < args.Length) {
        Console.WriteLine("file to compile has unrecognized extension: {0}", args[i]);
        return;
      }
    } else {
      for (; i < args.Length; ++i)
        program_args.Add(args[i]);
    }

    if (!program_.Parse())
      return;

    bool ok = program_.Resolve() && program_.Check();
    if (error_test_)
      ErrorTestReport();
    if (!ok)
      return;

    if (compile)
      program_.Compile(output, cpp_only);
    else program_.Eval(program_args);
  }

  public static void Main_3(string[] args) {
    new Gel_3().Run(args);
  }
}
/*
Copyright (c) 2006 Google Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

class Syntax_4 {
  public readonly string file_;
  public readonly int line_;

  public Syntax_4() { file_ = Gel_4.CurrentFile(); line_ = Gel_4.Line(); }

  static void Report(string file, int line, string type) {
    Console.Write("{0}({1}): ", file, line);
    Console.Write("{0}: ", type);
    if (Gel_4.error_test_)
      Gel_4.error_lines_.Add(line);
  }

  public void Error(string message) {
    Report(file_, line_, "error");
    Console.WriteLine(message);
  }

  public void Error(string format, object arg) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg);
  }

  public void Error(string format, object arg1, object arg2) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2);
  }

  public void Error(string format, object arg1, object arg2, object arg3) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2, arg3);
  }

  public void Warning(string message) {
    Report(file_, line_, "warning");
    Console.WriteLine(message);
  }
}

abstract class TypeExpr_4 : Syntax_4 {
  public abstract GType_4 Resolve(Program_4 program);
  public abstract TypeExpr_4 ^Copy();
}

class ConversionContext_4 {
  public const int Other = 0,
                   AssignVar = 1,
                   MethodArg = 2;
}

// GEL2 includes the following kinds of types:
// - simple types (int, bool, char, float, double): SimpleType_4
// - owned types (including array types): ArrayType_4 or Class_4 with Owned() => true
// - owning types: Owning_4
// - string: GString_4
// - null type: NullType_4
// - void: VoidType_4

abstract class GType_4 {
  public virtual bool IsOwned() { return false; }

  // A reference type is an owned, owning, string or null type.
  public virtual bool IsReference() { return true; }

  // A value type is a simple or string type.
  public virtual bool IsValue() { return false; }

  public virtual Class_4 Parent() { return GObject_4.type_; }
  
  // If_4 this is an owning type T ^ then return T; otherwise return this.
  public virtual GType_4 BaseType() { return this; }

  // Return_4 the set of types which may be destroyed when a variable of this type
  // is destroyed.
  public virtual TypeSet_4 VarDestroys() { return TypeSet_4.empty_; }

  // Return_4 the set of types which may be destroyed when a value of this concrete type
  // is destroyed.
  public virtual TypeSet_4 TypeDestroys() { return TypeSet_4.empty_; }

  public virtual void FindVarDestroys(int marker, TypeSet_4 set) { }

  public virtual void FindTypeDestroys(int marker, TypeSet_4 set) { }

  public virtual bool IsSubtype(GType_4 type) {
    for (GType_4 t = this; t != null ; t = t.Parent())
      if (type.Equals(t))
        return true;
    return false;
  }

  public virtual Owning_4 OwningType() { Debug.Assert(false); return null; }

  protected virtual bool CanConvertOwnership(GType_4 t, int context) {
    bool from_owning = this is Owning_4;
    bool to_owning = t is Owning_4;
    if (IsValue() && t.BaseType() == GObject_4.type_) {
      Debug.Assert(!from_owning);
      // boxing conversion yields an owning pointer; string->object conversion may
      // yield an owning or non-owning pointer
      return to_owning || context == ConversionContext_4.MethodArg || this == GString_4.type_;
    }
    if (BaseType() == GObject_4.type_ && t.IsValue()) {
      Debug.Assert(!to_owning);
      return true;  // an unboxing or object->string conversion, OK in any context
    }
    return from_owning == to_owning ||
           from_owning && !to_owning &&
             (context == ConversionContext_4.AssignVar || context == ConversionContext_4.MethodArg);
  }

  // Ensure that this class will inherit from Object in generated C++ code.
  public virtual void SetObjectInherit() { }

  // Return_4 true if there is a non-subtyping implicit conversion from this to t.
  public virtual bool CanConvert1(GType_4 t) { return false; }

  // Return_4 true if there is a non-subtyping explicit conversion from this to t.
  protected virtual bool CanConvertExplicit1(GType_4 t) { return false; }

  // Return_4 true if this type can be converted to type [to].
  public bool CanConvert(GType_4 to, int context, bool is_explicit, bool subtype_only) {
    if (!CanConvertOwnership(to, context))
      return false;

    GType_4 from_base = BaseType();
    GType_4 to_base = to.BaseType();
    if (from_base.Equals(to_base))
      return true;   // identity conversion

    // If_4 we ever perform a conversion to C ^, then C must have a vtable so that we can call
    // a virtual destructor when an owning pointer is destroyed.
    if (to is Owning_4 && this != Null_4.type_)
      to_base.SetVirtual();

    // If_4 we ever perform an explicit conversion from a class, that class must
    // have a vtable so that every instance of the class will have run-time type information.
    if (is_explicit)
      from_base.SetVirtual();

    // If_4 we ever convert between C and Object, then C must derive from Object in generated code.
    if (from_base == GObject_4.type_)
      to_base.SetObjectInherit();
    else if (to_base == GObject_4.type_)
      from_base.SetObjectInherit();

    return from_base.IsSubtype(to_base) ||
           !subtype_only && from_base.CanConvert1(to_base) ||
           is_explicit && (to_base.IsSubtype(from_base) ||
                           !subtype_only && from_base.CanConvertExplicit1(to_base));
  }

  public bool CanConvert(GType_4 t, int context) { return CanConvert(t, context, false, false); }
  public bool CanConvert(GType_4 t) { return CanConvert(t, ConversionContext_4.Other); }

  public bool CanConvertExplicit(GType_4 t, bool subtype_only) {
    return CanConvert(t, ConversionContext_4.Other, true, subtype_only);
  }

  public bool CheckConvert(Syntax_4 caller, GType_4 t, int context) {
    if (!CanConvert(t, context)) {
      caller.Error("can't convert {0} to {1}", this, t);
      return false;
    }
    return true;
  }

  public bool CheckConvert(Syntax_4 caller, GType_4 t) {
    return CheckConvert(caller, t, ConversionContext_4.Other);
  }

  // Return_4 a type to which the types [this] and t can both be implicitly converted.
  public GType_4 CommonType(Syntax_4 caller, GType_4 t) {
    if (CanConvert(t))
      return t;
    if (t.CanConvert(this))
      return this;
    caller.Error("incompatible types: {0} and {1}", this, t);
    return null;
  }

  public abstract SimpleValue_4 DefaultValue_4();

  static ArrayList ^empty_array_ = new ArrayList();
  public virtual ArrayList /* of Member_4 */ Members() { return empty_array_; }

  public Member_4 GetMatchingMember(Member_4 m1) {
    foreach (Member_4 m in Members())
      if (m.MatchSignature(m1))
        return m;
    return null;
  }

  // Find a match for m in this type or its ancestors, ignoring private members and
  // optionally ignoring overrides.
  public Member_4 FindMatchingMember(Member_4 m, bool override_ok) {
    for (GType_4 t = this ; t != null ; t = t.Parent()) {
      Member_4 m1 = t.GetMatchingMember(m);
      if (m1 != null && !m1.IsPrivate() && (override_ok || !m1.IsOverride()))
        return m1;
    }
    return null;
  }

  int Score(bool accessible, int mismatches) {
    return (accessible ? 0 : 100) + mismatches;
  }

  public Member_4 Lookup(Syntax_4 caller, Class_4 from_class, bool through_base,
                       int kind, string name, ArrayList /* of Argument_4 */ arguments, bool report_error) {
    Member_4 m1 = null;   // the best match we've found so far
    bool found_any = false;
    bool accessible = false;
    int score = -1;

    GType_4 this_type = BaseType();
    GType_4 t;
    for (t = this_type; t != null; t = (kind == MemberKind_4.Constructor_4 ? null : t.Parent())) {
      foreach (Member_4 m in t.Members())
        if (Member_4.MatchKind(m.Kind(), kind) && m.name_ == name && !m.IsOverride()) {
          found_any = true;
          int mismatches = 0;
          if (arguments != null && !m.IsApplicable(arguments, out mismatches))
            continue; // wrong argument count
          bool new_accessible = m.IsAccessible(from_class, this_type, through_base);
          int new_score = Score(new_accessible, mismatches);
          if (new_score == 0 && score == 0) {
            if (report_error)
              caller.Error("{0}: ambiguous {1} call", name, Member_4.ToString(kind));
            return null;
          }
          if (score == -1 || new_score < score) {
            m1 = m;
            score = new_score;
            accessible = new_accessible;
          }
        }
      if (score == 0)
        break;
    }

    if (score != 0) {
      if (report_error) {
        string k = Member_4.ToString(kind);
        if (!found_any)
          caller.Error("{0}: {1} not found", name, k);
        else if (score == -1) {
          string a = String.Format("{0} argument{1}", arguments.Count, arguments.Count == 1 ? "" : "s");
          caller.Error("{0}: no {1} overload takes {2}", name, k, a);
        } else if (!accessible)
          caller.Error("{0}: can't access {1} {2}",
                       name, m1.IsProtected() ? "protected" : "private", k);
        else {
          caller.Error("{0}: the best overloaded {1} match has some invalid arguments", name, k);
          m1.ReportMismatches(caller, arguments);
        }
      }
      return null;
    }

    // If_4 we've found a member of the Object class, then we're using this class as an object,
    // so in generated code it must ultimately inherit from Object, not _Object.
    if (t == GObject_4.type_)
      this_type.SetObjectInherit();

    if (through_base) {
      // As_4 a special case, whenever we're accessing through base we find the member which will
      // actually be invoked; this is not necessarily the same as the member we've just found
      // if the member is virtual.
      m1 = FindMatchingMember(m1, true);
      Debug.Assert(m1 != null);
    }

    return m1;
  }

  public virtual void SetVirtual() { }

  // Emit the name of the C++ class we use to hold instances of this type.
  public virtual string EmitTypeName() { Debug.Assert(false); return null; }

  // Return_4 a C++ type of the form "T<U>".  If_4 U ends with a '>', we emit an
  // extra space to avoid emitting the token >>, which will cause GCC to complain.
  public static string ConstructType(string generic, string type) {
    return String.Format("{0}<{1}{2}>", generic, type,
                         type.EndsWith(">") ? " " : "");
  }

  string EmitNonOwningPointer(string name) {
    if (Gel_4.program_.safe_)
      return ConstructType(this == GObject_4.type_ ? "_PtrRef" : "_Ptr", name);
    return String.Format("{0} *", name);
  }

  // Emit a C++ type used for variables holding instances of this type.
  public virtual string EmitType() {
    return EmitNonOwningPointer(EmitTypeName());
  }

  // Emit a C++ type used for expressions holding instances of this type.
  public virtual string EmitExprType() {
    return EmitTypeName() + " *";
  }

  public virtual string EmitReturnType() {
    return EmitExprType();
  }

  public virtual string EmitGenericType() {
    return IsReference() ? EmitNonOwningPointer("Object") : EmitType();
  }
}

class TypeSet_4 {
  NonOwningArrayList /* of GType_4 */ ^types_ = new NonOwningArrayList();

  public static readonly TypeSet_4 ^empty_ = new TypeSet_4();

  public void Add(GType_4 type) {
    for (int i = 0; i < types_.Count; ++i) {
      GType_4 t = (GType_4) types_[i];
      if (type.IsSubtype(t))
        return;
      if (t.IsSubtype(type)) {
        types_[i++] = type;
        while (i < types_.Count) {
          t = (GType_4) types_[i];
          if (t.IsSubtype(type))
            types_.RemoveAt(i);
          else ++i;
        }
        return;
      }
    }
    types_.Add(type);
  }

  public void Add(TypeSet_4 set) {
    foreach (GType_4 t in set.types_)
      Add(t);
  }

  public bool Contains(GType_4 type) {
    foreach (GType_4 t in types_)
      if (type.IsSubtype(t))
        return true;
    return false;
  }

  public bool IsObject() {
    return types_.Count > 0 && types_[0] == GObject_4.type_;
  }

  public override string ToString() {
    StringBuilder ^sb = new StringBuilder();
    sb.Append("{");
    foreach (GType_4 t in types_)
      sb.AppendFormat(" {0}", t.ToString());
    sb.Append(" }");
    return sb.ToString();
  }
}

class VoidType_4 : GType_4 {
  public override bool IsReference() { Debug.Assert(false); return false; }

  public override SimpleValue_4 DefaultValue_4() { Debug.Assert(false); return null; }

  public override string ToString() { return "void"; }

  public override string EmitExprType() { return "void"; }
  public override string EmitType() { return "void"; }
}

class Void_4 {
  public static readonly GType_4 ^type_ = new VoidType_4();
}

// an RValue_4, a Location_4 containing an RValue_4, or a LocationRef_4 pointing to a Location_4 containing an RValue_4
abstract class ValueOrLocation_4 {
  public abstract GValue_4 Get();
}

// a GValue_4 or a reference to a GValue_4
abstract class RValue_4 : ValueOrLocation_4 {
  public abstract RValue_4 ^CopyRef();
}

abstract class GValue_4 : RValue_4 {
  public override GValue_4 Get() { return this; }

  public abstract GType_4 Type();

  public override RValue_4 ^CopyRef() { return new Reference_4(this); }

  public virtual RValue_4 ^Get(Field_4 field) { Debug.Assert(false); return null; }
  public virtual RValue_4 ^Take_4(Field_4 field) { Debug.Assert(false); return null; }

  public virtual RValue_4 ^ConvertExplicit(ref RValue_4 ^this_own, GType_4 t) {
    // try implicit conversion
    RValue_4 ^v = Convert(ref this_own, t);
    if (v != this || Type().IsSubtype(t) )
      return v;

    Console.WriteLine("type cast failed: object of type {0} is not a {1}", Type(), t);
    Gel_4.Exit();
    return null;
  }

  // Implicitly convert this value to type t.
  public virtual RValue_4 ^Convert(ref RValue_4 ^this_own, GType_4 t) {
    return take this_own;
  }

  public virtual bool DefaultEquals(object o) { return Equals(o); }
  public virtual int DefaultHashCode() { return GetHashCode(); }
  public virtual string DefaultToString() { return ToString(); }

  public virtual RValue_4 ^Invoke(Method_4 m, ValueList_4 args) {
    switch (m.name_) {
      case "Equals": return new GBool_4(DefaultEquals(args.Object(0)));
      case "GetHashCode": return new GInt_4(DefaultHashCode());
      case "ToString": return new GString_4(DefaultToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class Reference_4 : RValue_4 {
  public readonly GValue_4 value_;    // a reference value, never a SimpleValue_4

  public Reference_4(GValue_4 v) { value_ = v; }

  public override GValue_4 Get() { return value_; }

  public override RValue_4 ^CopyRef() { return new Reference_4(value_); }
}

abstract class SimpleValue_4 : GValue_4 {
  public abstract SimpleValue_4 ^Copy();
  public override RValue_4 ^CopyRef() { return Copy(); }
  public abstract string Emit();
}

class GBool_4 : SimpleValue_4 {
  public readonly bool b_;

  public GBool_4(bool b) { b_ = b; }

  public override bool Equals(object o) {
    GBool_4 b = o as GBool_4;
    return b != null && b.b_ == b_;
  }

  public override int GetHashCode() { return b_.GetHashCode(); }

  public override SimpleValue_4 ^Copy() { return new GBool_4(b_); }

  public static readonly BoolClass_4 ^type_ = new BoolClass_4();

  public override GType_4 Type() { return type_; }

  public override string ToString() { return b_.ToString(); }

  public override string Emit() { return b_ ? "true" : "false"; }
}

class GInt_4 : SimpleValue_4 {
  public readonly int i_;

  public GInt_4(int i) { i_ = i; }

  public static readonly IntClass_4 ^type_ = new IntClass_4();

  public override GType_4 Type() { return type_; }

  public override bool Equals(object o) {
    GInt_4 i = o as GInt_4;
    return i != null && i.i_ == i_;
  }

  public override int GetHashCode() { return i_.GetHashCode(); }

  public override SimpleValue_4 ^Copy() { return new GInt_4(i_); }

  public override RValue_4 ^Convert(ref RValue_4 ^this_own, GType_4 t) {
    if (t == GFloat_4.type_)
      return new GFloat_4(i_);
    if (t == GDouble_4.type_)
      return new GDouble_4(i_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_4 ^ConvertExplicit(ref RValue_4 ^this_own, GType_4 t) {
    return t == GChar_4.type_ ? new GChar_4((char) i_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return i_.ToString(); }

  public override string Emit() { return i_.ToString(); }
}

class GFloat_4 : SimpleValue_4 {
  public readonly float f_;

  public GFloat_4(float f) { f_ = f; }

  public static readonly FloatClass_4 ^type_ = new FloatClass_4();

  public override GType_4 Type() { return type_; }

  public override bool Equals(object o) {
    GFloat_4 f = o as GFloat_4;
    return f != null && f.f_ == f_;
  }

  public override int GetHashCode() { return f_.GetHashCode(); }

  public override SimpleValue_4 ^Copy() { return new GFloat_4(f_); }

  public override RValue_4 ^Convert(ref RValue_4 ^this_own, GType_4 t) {
    if (t == GDouble_4.type_)
      return new GDouble_4(f_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_4 ^ConvertExplicit(ref RValue_4 ^this_own, GType_4 t) {
    return t == GInt_4.type_ ? new GInt_4((int) f_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return f_.ToString(); }

  public override string Emit() {
    string s = f_.ToString();
    return s + (s.IndexOf('.') == -1 ? ".0f" : "f");
  }
}

class GDouble_4 : SimpleValue_4 {
  public readonly double d_;

  public GDouble_4(double d) { d_ = d; }

  public static readonly DoubleClass_4 ^type_ = new DoubleClass_4();

  public override GType_4 Type() { return type_; }

  public override bool Equals(object o) {
    GDouble_4 d = o as GDouble_4;
    return d != null && d.d_ == d_;
  }

  public override int GetHashCode() { return d_.GetHashCode(); }

  public override SimpleValue_4 ^Copy() { return new GDouble_4(d_); }

  public override RValue_4 ^ConvertExplicit(ref RValue_4 ^this_own, GType_4 t) {
    if (t == GInt_4.type_)
      return new GInt_4((int) d_);
    if (t == GFloat_4.type_)
      return new GFloat_4((float) d_);
    return base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return d_.ToString(); }

  public override string Emit() {
    string s = d_.ToString();
    if (s.IndexOf('.') == -1)
      s = s + ".0";
    return s;
  }
}

class GChar_4 : SimpleValue_4 {
  public readonly char c_;

  public GChar_4(char c) { c_ = c; }

  public static readonly CharClass_4 ^type_ = new CharClass_4();

  public override GType_4 Type() { return type_; }

  public override bool Equals(object o) {
    GChar_4 c = o as GChar_4;
    return c != null && c.c_ == c_;
  }

  public override int GetHashCode() { return c_.GetHashCode(); }

  public override SimpleValue_4 ^Copy() { return new GChar_4(c_); }

  public override RValue_4 ^Convert(ref RValue_4 ^this_own, GType_4 t) {
    return t == GInt_4.type_ ? new GInt_4(c_) : base.Convert(ref this_own, t);
  }

  public override string ToString() { return c_.ToString(); }

  public static string Emit(char c) {
    switch (c) {
      case '\0': return "\\0";
      case '\n': return "\\n";
      case '\r': return "\\r";
      case '\t': return "\\t";
      case '\'': return "\\'";
      case '\"': return "\\\"";
      case '\\': return "\\\\";
    }
    if (c < 32) {
      Debug.Assert(false); return null;
    }
    return c.ToString();
  }

  public override string Emit() {
    return String.Format("'{0}'", Emit(c_));
  }
}

abstract class LocationOrRef_4 : ValueOrLocation_4 {
  public abstract Location_4 GetLoc();
}

class Location_4 : LocationOrRef_4 {
  public RValue_4 ^value_;

  public Location_4(RValue_4 ^val) { value_ = val; }

  public override GValue_4 Get() { return value_.Get(); }

  public override Location_4 GetLoc() { return this; }
}

// We allocate a LocationRef_4 when we need an owning reference to a Location_4 which we don't own.
class LocationRef_4 : LocationOrRef_4 {
  public readonly Location_4 location_;

  public LocationRef_4(Location_4 loc) { location_ = loc; }

  public override GValue_4 Get() { return location_.Get(); }

  public override Location_4 GetLoc() { return location_; }
}

class MapNode_4 {
  public readonly MapNode_4 ^next_;
  public readonly object key_;
  public ValueOrLocation_4 ^value_;   // (must appear after next_ so it will be destroyed first)

  public MapNode_4(object key, ValueOrLocation_4 ^value, MapNode_4 ^next) {
    key_ = key; value_ = value; next_ = next;
  }
}

class Map_4 {
  MapNode_4 ^nodes_;

  protected MapNode_4 Find1(object key) {
    for (MapNode_4 n = nodes_; n != null; n = n.next_)
      if (n.key_ == key)
        return n;
    return null;
  }

  protected virtual MapNode_4 Find(object key) {
    MapNode_4 n = Find1(key);
    Debug.Assert(n != null);
    return n;
  }

  public RValue_4 ^Get(object key) {
    return Find(key).value_.Get().CopyRef();
  }

  public RValue_4 ^Take_4(object key) {
    MapNode_4 n = Find(key);
    LocationOrRef_4 l = n.value_ as LocationOrRef_4;
    if (l != null)
      return take l.GetLoc().value_;
    return (RValue_4) take n.value_;
  }

  public void Set(object key, RValue_4 ^val) {
    MapNode_4 n = Find(key);
    LocationOrRef_4 l = n.value_ as LocationOrRef_4;
    if (l != null)
      l.GetLoc().value_ = val;
    else n.value_ = val;
  }

  public void Add(object key, ValueOrLocation_4 ^val) {
    nodes_ = new MapNode_4(key, val, take nodes_);
  }

  public Location_4 GetLocation(object key) {
    MapNode_4 n = Find(key);
    LocationOrRef_4 l = n.value_ as LocationOrRef_4;
    if (l != null)
      return l.GetLoc();
    Location_4 ^loc1 = new Location_4((RValue_4) take n.value_);
    Location_4 loc = loc1;
    n.value_ = loc1;
    return loc;
  }
}

class GObject_4 : GValue_4 {
  public readonly Class_4 class_;   // the class of this object

  Map_4 ^map_ = new Map_4();

  public GObject_4(Class_4 cl) {
    class_ = cl;
    while (cl != null) {
      foreach (Field_4 f in cl.fields_)
        map_.Add(f, f.Type().DefaultValue_4().Copy() );
      cl = cl.Parent();
    }
  }

  // the type of this object
  public override GType_4 Type() { return class_; }

  public override RValue_4 ^Get(Field_4 field) { return map_.Get(field); }
  public override RValue_4 ^Take_4(Field_4 field) { return map_.Take_4(field); }
  public void Set(Field_4 field, RValue_4 ^val) { map_.Set(field, val); }
  public Location_4 GetLocation(Field_4 field) { return map_.GetLocation(field); }

  public override int DefaultHashCode() { return base.GetHashCode(); }
  public override int GetHashCode() {
    GInt_4 ^i = (GInt_4) Invocation_4.InvokeMethod(this, GObject_4.type_.get_hash_code_, new ArrayList(), true);
    return i.i_;
  }

  public override bool DefaultEquals(object o) { return base.Equals(o); }
  public override bool Equals(object o) {
    GValue_4 v = o as GValue_4;
    if (v == null)
      return false;

    ArrayList ^args = new ArrayList();
    args.Add(v.CopyRef());
    GBool_4 ^b = (GBool_4) Invocation_4.InvokeMethod(this, GObject_4.type_.equals_, args, true);
    return b.b_;
  }

  public override string DefaultToString() { return String.Format("<object {0}>", class_.name_); }
  public override string ToString() {
    GString_4 ^s = (GString_4) Invocation_4.InvokeMethod(this, GObject_4.type_.to_string_, new ArrayList(), true);
    return s.s_;
  }

  // the Object class
  public static readonly ObjectClass_4 ^type_ = new ObjectClass_4();
}

class NullType_4 : GType_4 {
  public override string ToString() { return "null_type"; }

  public override SimpleValue_4 DefaultValue_4() { Debug.Assert(false); return null; }

  public override bool IsSubtype(GType_4 t1) {
    return t1.IsReference();
  }

  protected override bool CanConvertOwnership(GType_4 t, int context) {
    return true;    // conversion from null type to owning type is okay
  }

  public override string EmitType() { Debug.Assert(false); return null; }
}

class Null_4 : SimpleValue_4 {
  public Null_4() { }

  public static readonly NullType_4 ^type_ = new NullType_4();

  public override GType_4 Type() { return type_; }

  public override bool Equals(object o) {
    return o is Null_4;
  }

  public override SimpleValue_4 ^Copy() { return new Null_4(); }

  public override int GetHashCode() { return 0; }

  public static readonly Null_4 ^Instance = new Null_4();

  public override string ToString() { return ""; }

  public override string Emit() { return "0"; }
}

class Owning_4 : GType_4 {
  GType_4 base_type_;

  public Owning_4(GType_4 type) {
    base_type_ = type;
  }

  public override Class_4 Parent() { Debug.Assert(false); return null; }

  public override SimpleValue_4 DefaultValue_4() { return Null_4.Instance; }

  public override GType_4 BaseType() { return base_type_; }

  public override TypeSet_4 VarDestroys() { return base_type_.TypeDestroys(); }

  public override void FindVarDestroys(int marker, TypeSet_4 set) {
    base_type_.FindTypeDestroys(marker, set);
  }

  public override bool Equals(object o) {
    Owning_4 t = o as Owning_4;
    return t != null && t.base_type_.Equals(base_type_);
  }

  public override int GetHashCode() { return base_type_.GetHashCode() * 87; }

  public override string ToString() { return base_type_.ToString() + " ^"; }

  public override string EmitTypeName() {
    return base_type_.EmitTypeName();
  }

  string EmitType(string name) {
    return ConstructType(base_type_ == GObject_4.type_ ? "_OwnRef" : "_Own", name);
  }

  public override string EmitType() {
    // We represent an object ^ using a _OwnRef<Object>.
    // We represent a Foo ^ using an _Own<Foo>.
    return EmitType(EmitTypeName());
  }

  public override string EmitGenericType() {
    // We represent an object ^ [] using an _Array<_OwnRef<Object>>.
    // We represent a Foo ^ [] using an _Array<_Own<Object>>.
    return EmitType("Object");
  }
}

class OwningExpr_4 : TypeExpr_4 {
  readonly TypeExpr_4 ^expr_;

  public OwningExpr_4(TypeExpr_4 ^expr) { expr_ = expr; }

  public override TypeExpr_4 ^Copy() { return new OwningExpr_4(expr_.Copy()); }

  public override GType_4 Resolve(Program_4 program) {
    GType_4 t = expr_.Resolve(program);
    if (t == null)
        return null;
    if (t.IsValue()) {
      Error("^ cannot be applied to primitive types or strings");
      return null;
    }
    return t.OwningType();
  }
}

class GString_4 : SimpleValue_4 {
  public readonly string s_;

  public GString_4(string s) { s_ = s; }

  public static readonly StringClass_4 ^type_ = new StringClass_4();

  public override GType_4 Type() { return type_; }

  public override bool Equals(object o) {
    GString_4 s = o as GString_4;
    return s != null && s.s_ == s_;
  }

  public override SimpleValue_4 ^Copy() { return new GString_4(s_); }

  public override int GetHashCode() { return s_.GetHashCode(); }

  public override string ToString() { return s_; }

  public override RValue_4 ^Invoke(Method_4 m, ValueList_4 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StartsWith": return new GBool_4(s_.StartsWith(args.GetString(0)));
      case "EndsWith": return new GBool_4(s_.EndsWith(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public static string EmitStringConst(string s) {
    return String.Format("L{0}", EmitString(s));
  }

  public static string EmitString(string s) {
    StringBuilder ^sb = new StringBuilder();
    sb.Append('"');
    for (int i = 0; i < s.Length; ++i)
      sb.Append(GChar_4.Emit(s[i]));
    sb.Append('"');
    return sb.ToString();
  }

  public override string Emit() {
    string s = String.Format("new String({0})", EmitStringConst(s_));
    s = String.Format("_Ref<String>({0}).Get()", s);
    return s;
  }
}

abstract class Ownable_4 : GType_4 {
  Owning_4 ^owning_type_;

  public override Owning_4 OwningType() {
    if (owning_type_ == null)
      owning_type_ = new Owning_4(this);
    return owning_type_;
  }
}

class ArrayType_4 : Ownable_4 {
  GType_4 element_type_;

  public ArrayType_4(GType_4 type) {
    element_type_ = type;

    // Any type used generically must inherit from Object in C++ code.
    type.BaseType().SetObjectInherit();
  }

  public override bool IsOwned() { return true; }

  public override Class_4 Parent() { return GArray_4.array_class_; }

  public override SimpleValue_4 DefaultValue_4() { return Null_4.Instance; }

  public GType_4 ElementType() { return element_type_; }

  public override bool Equals(object o) {
    ArrayType_4 t = o as ArrayType_4;
    return (t != null && t.element_type_.Equals(element_type_));
  }

  public override TypeSet_4 TypeDestroys() { return element_type_.VarDestroys(); }

  public override void FindTypeDestroys(int marker, TypeSet_4 set) {
    element_type_.FindVarDestroys(marker, set);
  }

  public override int GetHashCode() { return element_type_.GetHashCode() * 77; }

  public override string EmitTypeName() {
    return ConstructType("_Array", element_type_.EmitGenericType());  
  }

  public override string ToString() {
    return element_type_.ToString() + "[]";
  }
}

class ArrayTypeExpr_4 : TypeExpr_4 {
  readonly TypeExpr_4 ^expr_;
  GType_4 ^type_;

  public ArrayTypeExpr_4(TypeExpr_4 ^expr) { expr_ = expr; }

  public override TypeExpr_4 ^Copy() { return new ArrayTypeExpr_4(expr_.Copy()); }

  public override GType_4 Resolve(Program_4 program) {
    GType_4 t = expr_.Resolve(program);
    return t == null ? null : (type_ = new ArrayType_4(t));
  }
}

class GArray_4 : GValue_4 {
  ArrayType_4 type_;

  ValueOrLocation_4^[] ^elements_;   // each element is a GValue_4 or a Location_4

  public override GType_4 Type() { return type_; }

  public GArray_4(ArrayType_4 type, int count) {
    type_ = type;
    elements_ = new ValueOrLocation_4^[count];
    for (int i = 0 ; i < count ; ++i)
      elements_[i] = type_.ElementType().DefaultValue_4().Copy();
  }

  void CheckIndex(int index) {
    if (index < 0 || index >= elements_.Length) {
      Console.WriteLine("error: array access out of bounds");
      Gel_4.Exit();
    }
  }

  public RValue_4 ^Get(int index) {
    CheckIndex(index);
    return elements_[index].Get().CopyRef();
  }

  public RValue_4 ^Take_4(int index) {
    CheckIndex(index);
    Location_4 loc = elements_[index] as Location_4;
    if (loc != null)
      return take loc.value_;
    return (RValue_4) (take elements_[index]);
  }

  public void Set(int index, RValue_4 ^val) {
    CheckIndex(index);
    Location_4 loc = elements_[index] as Location_4;
    if (loc != null)
      loc.value_ = val;
    else elements_[index] = val;
  }

  public Location_4 GetLocation(int index) {
    CheckIndex(index);
    Location_4 loc = elements_[index] as Location_4;
    if (loc != null)
      return loc;
    Location_4 ^loc1 = new Location_4((RValue_4) take elements_[index]);
    loc = loc1;
    elements_[index] = loc1;
    return loc;
  }

  public static readonly ArrayClass_4 ^array_class_ = new ArrayClass_4();

  public override RValue_4 ^Invoke(Method_4 m, ValueList_4 args) {
    if (m.GetClass() != array_class_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "CopyTo":
        GArray_4 a = (GArray_4) args.Object(0);
        if (!type_.Equals(a.type_)) {
          Console.WriteLine("error: can't copy between arrays of different types");
          Gel_4.Exit();
        }
        if (a.type_.ElementType() is Owning_4) {
          Console.WriteLine("error: can't copy to owning array");
          Gel_4.Exit();
        }
        // should check for index out of bounds here!
        int dest = args.Int(1);
        for (int i = 0 ; i < elements_.Length ; ++i)
          a.Set(dest + i, Get(i));
        return null;
      case "get_Length":
        return new GInt_4(elements_.Length);
      default:
        Debug.Assert(false); return null;
    }
  }
}

// A control graph object representing temporary variables destroyed when a top-level
// expression completes evaluation. 
class Temporaries_4 : Node_4 {
  NonOwningArrayList /* of GType_4 */ ^types_ = new NonOwningArrayList();
  TypeSet_4 ^destroys_;

  public void Add(GType_4 t) {
    Debug.Assert(t is Owning_4);
    types_.Add(t.BaseType());
  }

  public override TypeSet_4 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_4();
    foreach (GType_4 t in types_)
        destroys_.Add(t.TypeDestroys());
    }
    return destroys_;
  }
}

class Context_4 {
  public readonly Program_4 program_;   // containing program
  public readonly Class_4 class_;       // containing class
  public readonly Method_4 method_;     // containing method
  public readonly Escapable_4 escape_;  // containing switch, while, do, for, or foreach
  public readonly Loop_4 loop_;         // containing while, do, for, or foreach
  public Local_4 var_;    // chain of local variable declarations

  // subexpressions of the current top-level expression possibly yielding temporary objects
  NonOwningArrayList /* of Expression_4 */ ^temporaries_ = new NonOwningArrayList();

  public Context_4(Program_4 program) { program_ = program; }

  public Context_4(Class_4 cl) { program_ = cl.GetProgram(); class_ = cl; }

  // Copy a context; new variable declarations in either copy will not be visible in the other.
  public Context_4(Context_4 cx) {
    program_ = cx.program_;
    class_ = cx.class_;
    method_ = cx.method_;
    escape_ = cx.escape_;
    loop_ = cx.loop_;
    var_ = cx.var_;
  }

  public Context_4(Context_4 cx, Class_4 c) : this(cx) { class_ = c; }

  public Context_4(Context_4 cx, Method_4 m) : this(cx) { method_ = m; }

  public Context_4(Context_4 cx, Loop_4 l) : this(cx) {
    escape_ = l;
    loop_ = l;
  }

  public Context_4(Context_4 cx, Switch_4 s) : this(cx) { escape_ = s; }

  public bool IsStatic() { return method_ == null || method_.IsStatic(); }

  public void SetVar(Local_4 var) {
    var_ = var;
  }

  public Local_4 FindVar(string name) {
    for (Local_4 v = var_; v != null; v = v.next_)
      if (v.name_ == name)
        return v;
    return null;
  }

  public Control_4 Prev() { return program_.prev_; }

  public void SetPrev(Control_4 c) {
    Debug.Assert(c != null);
    program_.prev_ = c;
  }

  public void ClearPrev() { program_.prev_ = null; }

  // Called when we begin type-checking a top-level expression.
  public void EnterExpression() {
    Debug.Assert(temporaries_.Count == 0);
  }

  public void AddTemporary(Expression_4 e) {
    temporaries_.Add(e);
  }

  // Called when we've finished type-checking a top-level expression.
  public void FinishExpression() {
    Temporaries_4 t = null;
    foreach (Expression_4 e in temporaries_)
      if (!e.LosesOwnership()) {
        if (t == null)
          t = class_.NewTemporaries();
        t.Add(e.TemporaryType());
      }
    if (t != null)
      t.AddControl(this);
    temporaries_.Clear();
  }
}

class Env_4 : Map_4 {
  public readonly GValue_4 this_;
  readonly Env_4 next_;

  public Env_4(GValue_4 _this) { this_ = _this; next_ = null; }
  public Env_4(Env_4 next) { this_ = next.this_; next_ = next; }

  protected override MapNode_4 Find(object key) {
    for (Env_4 e = this; e != null; e = e.next_) {
      MapNode_4 n = e.Find1(key);
      if (n != null)
        return n;
    }
    Debug.Assert(false);
    return null;
  }

  public static readonly Env_4 ^static_ = new Env_4((GValue_4) null);
}

class TypeLiteral_4 : TypeExpr_4 {
  public readonly GType_4 type_;

  public TypeLiteral_4(GType_4 type) { type_ = type; }

  public override GType_4 Resolve(Program_4 program) {
    return type_;
  }

  public override TypeExpr_4 ^Copy() { return new TypeLiteral_4(type_); }
}

class TypeName_4 : TypeExpr_4 {
  string name_;

  public TypeName_4(string name) { name_ = name; }

  public override GType_4 Resolve(Program_4 program) {
    GType_4 type = program.FindClass(name_);
    if (type == null)
      Error("unknown type: {0}", name_);
    return type;
  }

  public override TypeExpr_4 ^Copy() { return new TypeName_4(name_); }
}

abstract class Traverser_4 {
  // Handle a graph item found in a depth first search; returns one of the exit codes below.
  public abstract int Handle(Control_4 control);

  public const int Continue_4 = 0,  // continue searching, including children of this node
                   Cut = 1,       // continue searching, excluding children of this node
                   Abort = 2;     // abort the search

}

// an item in the control graph: either a Node_4 or Joiner_4
abstract class Control_4 : Syntax_4 {
  public int marker_ = 0;    // marker for depth first search of control flow graph

  static int marker_value_ = 0;
  public static int GetMarkerValue() { return ++marker_value_; }

  // A node representing unreachability.  We could represent this using null, but it's
  // clearer to have this be explicit. 
  public static readonly Node_4 ^unreachable_ = new Node_4();

  // A helper function for Traverse.  If_4 we return true then we should cut the
  // traversal at this point.
  protected bool Visit(Traverser_4 traverser, int marker, out bool ok) {
    ok = true;
    if (marker_ == marker)
      return true;  // we've already seen this node
    marker_ = marker;
    int code = traverser.Handle(this);
    if (code == Traverser_4.Abort)
      ok = false;
    return (code != Traverser_4.Continue_4);
  }

  // Perform a depth-first search of the graph starting with this item, calling the
  // given Traverser_4 for each Node_4 found.  Returns false if the search was aborted.
  public abstract bool Traverse(Traverser_4 traverser, int marker);
}

// A node in the control graph.
class Node_4 : Control_4 {
  public Control_4 prev_;   // previous item in graph

  // add this node to the control graph
  public bool AddControl(Context_4 ctx) {
    Control_4 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      prev_ = prev;
      ctx.SetPrev(this);
      return true;
    }
    else return false;
  }

  // If_4 this node calls a method or constructor then return it; otherwise return null.
  // implementers: LValue_4, Invocation_4, New_4, Assign_4, Constructor_4
  public virtual Method_4 Calls() { return null; }

  // Return_4 the set of types which this node may destroy.
  // implementers: Assign_4, RefOutArgument_4, Scoped_4, Temporaries_4
  public virtual TypeSet_4 NodeDestroys() { return TypeSet_4.empty_; }

  // Return_4 true if this node assigns a value to the given Local_4.
  // implementers: Assign_4, RefOutArgument_4, VariableDeclaration_4, Method_4, ForEach_4
  public virtual bool Sets(Local_4 local) { return false; }

  // Return_4 true if this node takes ownership from the given local.
  // implementers: Name_4
  public virtual bool Takes(Local_4 local) { return false; }

  public bool CanDestroy(GType_4 type) {
    Method_4 m = Calls();
    if (m != null && m.Destroys().Contains(type))
      return true;
    return NodeDestroys().Contains(type);
  }

  public override bool Traverse(Traverser_4 traverser, int marker) {
    Node_4 n = this;
    Control_4 prev = null;

    // Traverse nodes iteratively until we come to a Join; this efficiently avoids
    // making a recursive call on each successive node.
    while (n != null) {
      bool ok;
      if (n.Visit(traverser, marker, out ok))
        return ok;
      prev = n.prev_;
      n = prev as Node_4;
    }
    Debug.Assert(prev != null);  // a Traverser_4 must end traversal before we run off the end
    return prev.Traverse(traverser, marker);
  }
}

class Joiner_4 : Control_4 {
  NonOwningArrayList /* of Control_4 */ ^prev_ = new NonOwningArrayList();

  public void Join(Control_4 c) {
    Debug.Assert(c != null);
    if (c == unreachable_)
      return;
    if (prev_.Count == 0 || c != prev_[0])
      prev_.Add(c);
  }

  // add this joiner to the control graph
  public void AddControl(Context_4 ctx) {
    Control_4 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      Join(prev);
      ctx.SetPrev(this);
    }
  }

  // Once we've finished merging paths into a Joiner_4, if the Joiner_4 points to only a single path
  // then as an optimization we can discard the Joiner_4 and just use that path instead.
  public Control_4 Combine() {
    switch (prev_.Count) {
      case 0:
        prev_ = null;
        return unreachable_;
      case 1:
        Control_4 c = (Control_4) prev_[0];
        prev_ = null;
        return c;
      default: return this;
    }
  }

  public override bool Traverse(Traverser_4 traverser, int marker) {
    bool ok;
    if (Visit(traverser, marker, out ok))
      return ok;

    foreach (Control_4 p in prev_)
      if (!p.Traverse(traverser, marker))
        return false;  // aborted
    return true;
  }
}

class ExprKind_4 {
  public const int Value = 0,

  // either a local variable, or an expression whose value is derived from local variables
                   Local_4 = 1,

                   Field_4 = 2,
                   Property_4 = 3,
                   Indexer_4 = 4,
                   Type = 5;
}

class SourceWriter_4 {
  public readonly StreamWriter writer_;
  int indent_ = 0;

  public SourceWriter_4(StreamWriter writer) { writer_ = writer; }

  public void AddIndent() { ++indent_; }
  public void SubIndent() { --indent_; }

  public void Indent(int adjust) {
    for (int i = 0; i < 2 * indent_ + adjust; ++i)
      writer_.Write(' ');
  }

  public void Indent() { Indent(0); }

  public void Write(string s) { writer_.Write(s); }
  public void Write(string s, object arg) { writer_.Write(s, arg); }
  public void Write(string s, object arg1, object arg2) { writer_.Write(s, arg1, arg2); }
  public void Write(string s, object arg1, object arg2, object arg3) { writer_.Write(s, arg1, arg2, arg3); }

  public void IWrite(string s) { Indent(); Write(s); }
  public void IWrite(string s, object arg) { Indent(); Write(s, arg); }
  public void IWrite(string s, object arg1, object arg2) { Indent(); Write(s, arg1, arg2); }
  public void IWrite(string s, object arg1, object arg2, object arg3) { Indent(); Write(s, arg1, arg2, arg3); }

  public void WriteLine(string s) { writer_.WriteLine(s); }
  public void WriteLine(string s, object arg) { writer_.WriteLine(s, arg); }
  public void WriteLine(string s, object arg1, object arg2) { writer_.WriteLine(s, arg1, arg2); }
  public void WriteLine(string s, object arg1, object arg2, object arg3) { writer_.WriteLine(s, arg1, arg2, arg3); }

  public void IWriteLine(string s) { Indent(); WriteLine(s); }
  public void IWriteLine(string s, object arg) { Indent(); WriteLine(s, arg); }
  public void IWriteLine(string s, object arg1, object arg2) { Indent(); WriteLine(s, arg1, arg2); }
  public void IWriteLine(string s, object arg1, object arg2, object arg3) { Indent(); WriteLine(s, arg1, arg2, arg3); }

  public void OpenBrace() { WriteLine("{"); AddIndent(); }
  public void CloseBrace() { SubIndent(); IWriteLine("}"); }
}

class Usage_4 {
  public const int Used = 0, LosesOwnership = 1, Unused = 2;
}

abstract class Expression_4 : Node_4 {
  protected int usage_ = Usage_4.Used;

  // start_ and end_ mark the points in the control graph where this expression is evaluated and used,
  // respectively.  If_4 this expression's type is owned, we use this information to determine whether
  // we need to emit a reference count for this expression.
  Control_4 start_;
  Control_4 end_;

  public abstract GType_4 Check(Context_4 ctx);

  public GType_4 CheckTop(Context_4 ctx) {
    ctx.EnterExpression();
    GType_4 t = Check(ctx);
    ctx.FinishExpression();
    return t;
  }

  public GType_4 CheckAndHold(Context_4 ctx) {
    GType_4 t = Check(ctx);
    if (t != null)
      HoldRef(ctx);
    return t;
  }

  // A fancier checking protocol implemented by lvalues and used by certain callers.
  public virtual GType_4 Check(Context_4 ctx, bool read, bool write, bool type_ok) {
    return Check(ctx);
  }

  public virtual int Kind() { return ExprKind_4.Value; }
  public virtual bool IsRefOutParameter() { return false; }

  public virtual bool IsTrueLiteral() { return false; }
  public virtual bool IsFalseLiteral() { return false; }

  // If_4 this expression is a local variable (possibly cast to a different type),
  // then return that local; otherwise return null.
  public virtual Local_4 GetLocal() { return null; }

  // Return_4 the type of an expression yielding a temporary object.
  // (It might be convenient to generalize this to be able to return any expression's type.)
  public virtual GType_4 TemporaryType() { Debug.Assert(false); return null; }

  public void HoldRef(Context_4 ctx) {
    start_ = ctx.Prev();
    Debug.Assert(start_ != null);
  }

  public void ReleaseRef(Context_4 ctx) {
    end_ = ctx.Prev();
    Debug.Assert(end_ != null);
  }

  public abstract RValue_4 ^Eval(Env_4 env);

  public bool Check(Context_4 ctx, GType_4 t2) {
    GType_4 t = Check(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public bool CheckTop(Context_4 ctx, GType_4 t2) {
    GType_4 t = CheckTop(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public RValue_4 ^Eval(Env_4 env, GType_4 t) {
    RValue_4 ^r = Eval(env);
    GValue_4 v = r.Get();
    return v.Convert(ref r, t);
  }

  public bool EvalBool(Env_4 env) { return ((GBool_4) Eval(env)).b_; }

  public int EvalInt(Env_4 env) {
    RValue_4 ^r = Eval(env, GInt_4.type_);
    GInt_4 i = (GInt_4) r;
    return i.i_;
  }

  public double EvalDouble(Env_4 env) { return ((GDouble_4) Eval(env, GDouble_4.type_)).d_; }
  public float EvalFloat(Env_4 env) { return ((GFloat_4) Eval(env, GFloat_4.type_)).f_; }
  public string EvalString(Env_4 env) { return ((GString_4) Eval(env)).s_; }

  public virtual bool IsConstant() {
    return false;
  }

  public bool CheckConstant() {
    if (IsConstant())
      return true;
    Error("expression must be a constant");
    return false;
  }

  public bool LosesOwnership() { return usage_ == Usage_4.LosesOwnership; }

  public virtual void LoseOwnership() {
    usage_ = Usage_4.LosesOwnership;
  }

  public void SetUnused() {
    Debug.Assert(usage_ == Usage_4.Used);
    usage_ = Usage_4.Unused;
  }

  protected static string EmitAllocate(string type, string args, bool lose_ownership) {
    // If_4 an allocated object never loses ownership then it can be stack allocated.  We
    // can't emit "&Foo(...)" since standard C++ doesn't allow us to take the address
    // of a temporary (both GCC and Visual C++ will allow this, but will emit a warning).
    // So instead we call a function _Addr() to get the address.
    return String.Format(
      !lose_ownership ? "{0}({1})._Addr<{0} *>()" : "new {0}({1})",
      type, args);
  }

  public void CheckLoseOwnership(GType_4 from, GType_4 to) {
    if (to is Owning_4)
      LoseOwnership();
  }

  public abstract string Emit();    // return a C++ expression representing this GEL2 expression

  public bool NeedsRef(GType_4 type) {
    return Gel_4.program_.safe_ && type.IsOwned() && ExpressionTraverser_4.NeedRef(start_, end_, this, type);
  }

  // Emit this expression, adding a reference-counting _Ptr wrapper if needed.
  public string EmitRef(GType_4 type) {
    string s = Emit();
    if (NeedsRef(type))
      s = String.Format("{0}({1}).Get()", type.EmitType(), s);
    return s;
  }

  // Emit an implicit conversion from type [source] to type [dest].
  public static string EmitImplicit(GType_4 source, GType_4 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (!source.IsReference() && dest == GObject_4.type_) {   // a boxing conversion
      Class_4 c = (Class_4) source;
      return EmitAllocate(c.name_, val, loses_ownership);
    }

    if (source == GInt_4.type_ && dest == GFloat_4.type_)
      // an implicit conversion in GEL2, but C++ compilers may warn if we don't use a cast
      return String.Format("static_cast<float>({0})", val);
    
    return val;
  }

  // Emit this expression, converting implicitly from type [source] to type [dest].
  public string Emit(GType_4 source, GType_4 dest) {
    return EmitImplicit(source, dest, Emit(), LosesOwnership());
  }

  public string EmitRef(GType_4 source, GType_4 dest) {
    return EmitImplicit(source, dest, EmitRef(source), LosesOwnership());
  }

  public static string EmitExplicit(GType_4 source, GType_4 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (source.CanConvert(dest)) {
      string v = EmitImplicit(source, dest, val, loses_ownership);
      if (v != val)
        return v;

      // There's nothing to do, but we emit a static_cast anyway since a GEL2 programmer
      // may use a type cast for method call disambiguation; we want to pass such casts onward.
      return String.Format("static_cast<{0} >({1})", dest.EmitExprType(), val);
    }

    if (source.IsReference() && dest.IsReference()) {
      string s = String.Format("_Cast<{0} *>({1})", dest.EmitTypeName(), val);
      ArrayType_4 at = dest as ArrayType_4;
      if (at != null) {
        GType_4 element_type = at.ElementType();
        if (element_type.IsReference())
          s = String.Format("({0})->CheckType(&typeid({1}))", s, element_type.EmitType());
      }
      return s;
    }

    if (source == GObject_4.type_ && !dest.IsReference())  // unboxing conversion
      return String.Format("_Unbox<{0} *>({1})->Value()", ((Class_4) dest).name_, val);

    if (!source.IsReference() && !dest.IsReference())
      return String.Format("static_cast<{0}>({1})", dest.EmitType(), val);

    Debug.Assert(false);
    return null;
  }

  public string EmitExplicit(GType_4 source, GType_4 dest) {
    return EmitExplicit(source, dest, Emit(), LosesOwnership());
  }

  public virtual string EmitArrow(GType_4 t, Member_4 m) {
    return String.Format("({0})->", EmitRef(t));
  }

  // Emit this expression as a local or field initializer, implicitly casting to [type].
  public void EmitAsInitializer(SourceWriter_4 w, GType_4 initializer_type, GType_4 type) {
    // For_4 owning variables, we must emit an initializer of the form "Foo var(val)" since
    // _Own has no copy constructor and hence GCC won't allow "Foo var = val".  For_4 other
    // variables either form is valid, but we emit the second form since it looks clearer.
    w.Write(type is Owning_4 ? "({0})" : " = {0}", Emit(initializer_type, type));
  }

  // Given a value retrieved from a variable, emit an accessor call if needed.
  protected string OwnSuffix(GType_4 t) {
    if (t is Owning_4)
      return LosesOwnership() ? ".Take_4()" : ".Get()";
    if (t == GString_4.type_ || Gel_4.program_.safe_ && t.IsReference() )
      return ".Get()";
    return "";
  }

  // Given a value returned from a function call, emit a wrapper and/or accessor call if needed.
  protected string Hold(GType_4 t, string s) {
    if (t == GString_4.type_)
      return s + ".Get()";
    if (t is Owning_4)
      switch (usage_) {
        case Usage_4.Used:  // does not lose ownership; we need a freeing wrapper
          return String.Format("{0}({1}).Get()", t.EmitType(), s);
        case Usage_4.LosesOwnership:
          return s;
        case Usage_4.Unused:  // a top-level owning expression
          return "delete " + s;
        default: Debug.Assert(false); break;
      }
    return s;
  }
}

class Literal_4 : Expression_4 {
  public readonly SimpleValue_4 ^value_;

  public Literal_4(SimpleValue_4 ^v) { value_ = v; }

  public override bool IsTrueLiteral() {
    GBool_4 b = value_ as GBool_4;
    return b != null && b.b_;
  }

  public override bool IsFalseLiteral() {
    GBool_4 b = value_ as GBool_4;
    return b != null && !b.b_;
  }

  public override GType_4 Check(Context_4 ctx) { return value_.Type(); }

  public override RValue_4 ^Eval(Env_4 env) { return value_.Copy(); }

  public override bool IsConstant() { return true; }

  public override string Emit() { return value_.Emit(); }
}

// An LValue_4 is an expression which can be assigned to: a Name_4, Dot_4, or Sub_4.
//
// In the control graph, an LValue_4 represents a read; if an LValue_4 is written then
// some other node (e.g. an Assign_4) will appear representing the write.
abstract class LValue_4 : Expression_4 {
  public override GType_4 Check(Context_4 ctx) {
    return Check(ctx, true, false, false);
  }

  public abstract override GType_4 Check(Context_4 ctx, bool read, bool write, bool type_ok);

  public abstract GType_4 StorageType();

  public virtual bool IsLocal() { return false; }
  public virtual bool IsLocal(Local_4 l) { return false; }

  public abstract PropertyOrIndexer_4 GetPropertyOrIndexer();

  public override Method_4 Calls() {
    PropertyOrIndexer_4 pi = GetPropertyOrIndexer();
    return pi == null ? null : pi.Getter();
  }

  public virtual void ReleaseAll(Context_4 ctx) { }

  // For_4 LValues, evaluation proceeds in two stages: the caller first calls Eval1(), then
  // passes the resulting values to EvalGet(), EvalSet() and/or EvalLocation().  This_4 lets
  // us evaluate the left side of an assignment expression before evaluating the right side,
  // and also lets us get and then set an indexer without evaluating its expression twice.

  public abstract void Eval1(Env_4 env, out RValue_4 ^v1, out RValue_4 ^v2);
  public abstract RValue_4 ^EvalGet(Env_4 env, RValue_4 ^v1, RValue_4 ^v2);
  public abstract void EvalSet(Env_4 env, RValue_4 ^v1, RValue_4 ^v2, RValue_4 ^val);
  public abstract Location_4 EvalLocation(Env_4 env, RValue_4 ^v1, RValue_4 ^v2);

  public override RValue_4 ^Eval(Env_4 env) {
    RValue_4 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalGet(env, val1, val2);
  }

  public void EvalSet(Env_4 env, RValue_4 ^v) {
    RValue_4 ^val1, val2;
    Eval1(env, out val1, out val2);
    EvalSet(env, val1, val2, v);
  }

  public Location_4 EvalLocation(Env_4 env) {
    RValue_4 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalLocation(env, val1, val2);
  }

  public abstract string EmitSet(string val);

  public abstract string EmitLocation();
}

class Name_4 : LValue_4 {
  public readonly string name_;

  protected Local_4 local_;
  protected LMember_4 field_;  // a field or property

  public Name_4(string n) { name_ = n; }

  public override bool IsLocal() { return local_ != null; }
  public override bool IsLocal(Local_4 l) { return local_ == l; }
  public override bool IsRefOutParameter() { return local_ is RefOutParameter_4; }

  public override bool IsConstant() {
    Debug.Assert(local_ != null || field_ != null);   // make sure we were already type checked
    return field_ is ConstField_4;
  }

  public override GType_4 Check(Context_4 ctx, bool read, bool write, bool type_ok) {
    local_ = ctx.FindVar(name_);
    if (local_ != null) {
      // For_4 reads, we add this Name_4 node to the flow graph; for writes,
      // the caller must add a node which defines this Name_4.
      if (read)
        if (AddControl(ctx))
          local_.AddUse(this);
      if (write)
        local_.SetMutable();
      return local_.ReadType();
    }

    GType_4 cl = type_ok ? ctx.program_.FindClass(name_) : null;
    field_ = (LMember_4) ctx.class_.Lookup(this, ctx.class_, false, MemberKind_4.Field_4, name_, null, cl == null);
    if (field_ != null) {
      if (!field_.CheckAccess(this, ctx, write, true, !ctx.IsStatic()))
        return null;
      if (read) {
        // Only property reads have side effects we need to register in the control graph.
        if (field_ is Property_4)
          AddControl(ctx);
      }
      return field_.Type().BaseType();
    }

    return cl;
  }

  public override int Kind() {
    if (local_ != null)
      return ExprKind_4.Local_4;
    if (field_ is Field_4)
      return ExprKind_4.Field_4;
    if (field_ is Property_4)
      return ExprKind_4.Property_4;
    Debug.Assert(field_ == null);
    return ExprKind_4.Type;
  }

  public override Local_4 GetLocal() { return local_; }

  public override GType_4 StorageType() { return local_ != null ? local_.Type() : field_.Type(); }

  public override bool Takes(Local_4 local) {
    return local_ == local && LosesOwnership() && local.Type() is Owning_4;
  }

  public override PropertyOrIndexer_4 GetPropertyOrIndexer() { return field_ as Property_4; }

  public override void Eval1(Env_4 env, out RValue_4 ^v1, out RValue_4 ^v2) { v1 = v2 = null; }

  public override RValue_4 ^EvalGet(Env_4 env, RValue_4 ^v1, RValue_4 ^v2) {
    if (LosesOwnership() && StorageType() is Owning_4)
      return local_ != null ? env.Take_4(local_) : field_.Take_4(env.this_);
    else return local_ != null ? env.Get(local_) : field_.Get(env.this_);
  }

  public override void EvalSet(Env_4 env, RValue_4 ^v1, RValue_4 ^v2, RValue_4 ^val) {
    if (local_ != null)
      env.Set(local_, val);
    else field_.Set((GObject_4) env.this_, val);
  }

  public override Location_4 EvalLocation(Env_4 env, RValue_4 ^v1, RValue_4 ^v2) {
    return local_ != null ? env.GetLocation(local_) : field_.GetLocation((GObject_4) env.this_);
  }

  public override string Emit() {
    if (local_ != null) {
      string s = local_.Emit();
      return local_.IsWrapper() ? s + OwnSuffix(local_.Type()) : s;
    }
    if (field_ != null)
      return field_.Emit() + OwnSuffix(field_.Type());
    return name_;
  }

  public override string EmitSet(string val) {
    if (local_ != null)
      return String.Format("{0} = {1}", local_.Emit(), val);
    Debug.Assert(field_ != null);
    return field_.EmitSet(val);
  }

  public override string EmitLocation() {
    if (local_ != null)
      return "&" + local_.Emit();
    if (field_ != null)
      return "&" + field_.Emit();
    return "&" + name_;
  }
}

class Parenthesized_4 : Expression_4 {
  Expression_4 ^expr_;

  public Parenthesized_4(Expression_4 ^e) { expr_ = e; }

  public override GType_4 Check(Context_4 ctx) { return expr_.Check(ctx); }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_4 ^Eval(Env_4 env) { return expr_.Eval(env); }

  public override string Emit() { return String.Format("({0})", expr_.Emit()); }
}

class PredefinedType_4 : Expression_4 {
  Class_4 type_;

  public PredefinedType_4(Class_4 type) { type_ = type; }

  public override GType_4 Check(Context_4 ctx) { Debug.Assert(false); return null; }

  public override GType_4 Check(Context_4 ctx, bool read, bool write, bool type_ok) {
    Debug.Assert(type_ok);
    return type_;
  }

  public override int Kind() {
    return ExprKind_4.Type;
  }

  public override RValue_4 ^Eval(Env_4 env) { Debug.Assert(false); return null; }

  public override string Emit() { return type_.name_; }
}

class Dot_4 : LValue_4 {
  Expression_4 ^expr_;  // set to null for a static invocation
  GType_4 expr_type_;
  string name_;

  LMember_4 field_;

  public Dot_4(Expression_4 ^expr, string name) { expr_ = expr; name_ = name; }

  public override bool IsConstant() {
    Debug.Assert(field_ != null);   // make sure we were already type checked
    return field_ is ConstField_4;
  }

  public override GType_4 Check(Context_4 ctx, bool read, bool write, bool type_ok) {
    expr_type_ = expr_.Check(ctx, true, false, true);
    if (expr_type_ == null)
      return null;
    bool is_static = (expr_.Kind() == ExprKind_4.Type);
    if (is_static)
      expr_ = null;
    else expr_.HoldRef(ctx);

    field_ = (LMember_4) expr_type_.Lookup(this, ctx.class_, expr_ is Base_4,
                                         MemberKind_4.Field_4, name_, null, true);
    if (field_ == null)
      return null;

    if (!field_.CheckAccess(this, ctx, write, is_static, !is_static))
      return null;

    if (read) {
      // Only property reads have side effects we need to register in the control graph.
      // (For_4 writes the caller, such as Assign_4, will add its own node.)
      if (field_ is Property_4)
        AddControl(ctx);
      if (expr_ != null)
        expr_.ReleaseRef(ctx);
    }

    return field_.Type().BaseType();
  }

  public override void ReleaseAll(Context_4 ctx) {
    if (expr_ != null)
      expr_.ReleaseRef(ctx);
  }

  public override int Kind() {
    if (field_ is Field_4)
      return ExprKind_4.Field_4;
    if (field_ is Property_4)
      return ExprKind_4.Property_4;
    Debug.Assert(false);
    return 0;
  }

  public override GType_4 StorageType() { return field_.Type(); }

  public override PropertyOrIndexer_4 GetPropertyOrIndexer() { return field_ as Property_4; }

  public override void Eval1(Env_4 env, out RValue_4 ^v1, out RValue_4 ^v2) {
    v1 = v2 = null;
    if (expr_ != null) {  // instance field
      v1 = expr_.Eval(env);
      if (v1 is Null_4) {
        Error("attempted to access field of null object");
        Gel_4.Exit();
      }
    }
  }

  public override RValue_4 ^EvalGet(Env_4 env, RValue_4 ^v1, RValue_4 ^v2) {
    GValue_4 obj = v1 == null ? null : v1.Get();
    return LosesOwnership() && field_.Type() is Owning_4 ? field_.Take_4(obj) : field_.Get(obj);
  }

  public override void EvalSet(Env_4 env, RValue_4 ^v1, RValue_4 ^v2, RValue_4 ^val) {
    GObject_4 obj = v1 == null ? null : (GObject_4) v1.Get();
    field_.Set(obj, val);
  }

  public override Location_4 EvalLocation(Env_4 env, RValue_4 ^v1, RValue_4 ^v2) {
    return field_.GetLocation((GObject_4) v1);
  }

  string EmitPrefix() {
    return expr_ != null ?
      expr_.EmitArrow(expr_type_, field_) :  // instance access
      field_.GetClass().name_ + "::";   // static access
  }

  public override string Emit() {
    string s = EmitPrefix() + field_.Emit();
    GType_4 t = field_.Type();
    return field_ is Property_4 ? Hold(t, s) : s + OwnSuffix(t);
  }

  public override string EmitSet(string val) {
    return EmitPrefix() + field_.EmitSet(val);
  }

  public override string EmitLocation() {
    return "&" + EmitPrefix() + field_.Emit();
  }
}

class Mode_4 {
  public const int In = 0,
                   Ref = 1,
                   Out = 2;

  public static string ToString(int mode) {
    switch (mode) {
      case In: return "";
      case Ref: return "ref ";
      case Out: return "out ";
      default: Debug.Assert(false); return null;
    }
  }
}

abstract class Argument_4 : Node_4 {
  protected GType_4 type_;

  public GType_4 Type() { return type_; }

  public abstract int GetMode();
  public string TypeString() { return Mode_4.ToString(GetMode()) + type_.ToString(); }

  public abstract bool Check(Context_4 ctx);
  public abstract void FinishCall(Context_4 ctx);

  public abstract void AddEval(ArrayList a, Env_4 env, GType_4 t);

  public abstract string Emit(GType_4 t);
}

class InArgument_4 : Argument_4 {
  public readonly Expression_4 ^expr_;

  public InArgument_4(Expression_4 ^expr) { expr_ = expr; }
  public InArgument_4(GType_4 type) { type_ = type; }

  public override int GetMode() { return 0; }

  public override bool Check(Context_4 ctx) {
    if (type_ == null)
      type_ = expr_.CheckAndHold(ctx);
    return type_ != null;
  }

  public override void FinishCall(Context_4 ctx) {
    expr_.ReleaseRef(ctx);
  }

  public override void AddEval(ArrayList a, Env_4 env, GType_4 t) {
    a.Add(expr_.Eval(env, t));
  }

  public override string Emit(GType_4 t) {
    return expr_.EmitRef(type_, t);
  }
}

class RefOutArgument_4 : Argument_4 {
  public readonly int mode_;
  public readonly LValue_4 ^lvalue_;

  public RefOutArgument_4(int mode, LValue_4 ^lvalue) { mode_ = mode; lvalue_ = lvalue; }

  public override int GetMode() { return mode_; }

  public override bool Check(Context_4 ctx) {
    type_ = lvalue_.Check(ctx, mode_ == Mode_4.Ref, true, false);
    if (type_ == null)
      return false;
    if (lvalue_.Kind() == ExprKind_4.Indexer_4) {
      Error("can't pass indexer as ref or out argument");
      return false;
    }
    return true;
  }

  public override void FinishCall(Context_4 ctx) {
    AddControl(ctx);
  }

  public override bool Sets(Local_4 local) { return lvalue_.IsLocal(local); }

  public override TypeSet_4 NodeDestroys() { return lvalue_.StorageType().VarDestroys(); }

  public GType_4 StorageType() { return lvalue_.StorageType(); }

  public override void AddEval(ArrayList a, Env_4 env, GType_4 t) {
    a.Add(new LocationRef_4(lvalue_.EvalLocation(env)));
  }

  public override string Emit(GType_4 t) { return lvalue_.EmitLocation(); }
}

class Invocation_4 : Expression_4 {
  Expression_4 ^obj_;    // may be null
  GType_4 obj_type_;
  string name_;
  ArrayList /* of Argument_4 */ ^arguments_;

  Method_4 method_;

  public Invocation_4(Expression_4 ^obj, string name, ArrayList ^arguments) {
    obj_ = obj; name_ = name; arguments_ = arguments;
  }

  public static Method_4 CheckInvoke(Node_4 caller, Context_4 ctx, bool through_base, GType_4 type,
                                   string name, ArrayList /* of Argument_4 */ arguments,
                                   int kind) {
    foreach (Argument_4 arg in arguments)
      if (!arg.Check(ctx))
        return null;

    // Add the caller to the graph; this node represents the invocation itself.
    caller.AddControl(ctx);

    // Now we can release temporary expressions and add control graph nodes representing
    // assignments to ref and out parameters.
    foreach (Argument_4 arg in arguments)
      arg.FinishCall(ctx);

    Method_4 m = (Method_4) type.Lookup(caller, ctx.class_, through_base, kind, name, arguments, true);
    if (m != null)
      for (int i = 0; i < m.parameters_.Count; ++i) {
        Parameter_4 p = m.Param(i);
        if (p.GetMode() == Mode_4.In) {
          InArgument_4 a = (InArgument_4) arguments[i];
          a.expr_.CheckLoseOwnership(a.Type(), p.Type());
        }
      }
    return m;
  }

  public override GType_4 Check(Context_4 ctx) {
    GType_4 t;
    bool is_class = false;  // true when calling a static method using a class name

    if (obj_ == null)
      t = ctx.class_;
    else {
      t = obj_type_ = obj_.Check(ctx, true, false, true);
      if (t == null)
        return null;
      if (obj_.Kind() == ExprKind_4.Type)
        is_class = true;
      else obj_.HoldRef(ctx);
    }

    method_ = CheckInvoke(this, ctx, obj_ is Base_4, t, name_, arguments_, MemberKind_4.Method_4);
    if (method_ == null)
      return null;

    if (method_ is Constructor_4) {
      Error("can't call constructor directly");
      return null;
    }

    if (obj_ == null) {
      if (!method_.IsStatic() && ctx.IsStatic()) {
        Error("can't call instance method in static context");
        return null;
      }
    } else {
      obj_.ReleaseRef(ctx);
      if (is_class) {
        if (!method_.IsStatic()) {
          Error("can't invoke non-static method through class name");
          return null;
        }
      } else {
        if (method_.IsStatic()) {
          Error("can't invoke static method through object");
          return null;
        }
      }
    }

    GType_4 ret = method_.ReturnType();
    if (ret is Owning_4)
      ctx.AddTemporary(this);
    return ret;
  }

  public override GType_4 TemporaryType() { return method_.ReturnType(); }

  public override Method_4 Calls() { return method_; }

  public static RValue_4 ^InvokeMethod(GValue_4 obj, Method_4 m, ArrayList /* of RValue_4 */ values,
                                    bool virtual_ok) {
    if (m.IsVirtual() && virtual_ok) {
      GType_4 t = obj.Type();
      m = (Method_4) t.FindMatchingMember(m, true);
      Debug.Assert(m != null);
    }
    return m.Invoke(obj, values);
  }

  public static RValue_4 ^CallMethod(Env_4 env, GValue_4 obj,
                                  Method_4 m, ArrayList /* of Argument_4 */ args,
                                  bool virtual_ok) {
    ArrayList /* of ValueOrLocation_4 */ ^values = new ArrayList();
    int i;
    for (i = 0 ; i < args.Count ; ++i) {
      Argument_4 a = (Argument_4) args[i];
      a.AddEval(values, env, m.Param(i).Type());
    }
    return InvokeMethod(obj, m, values, virtual_ok);
  }

  public RValue_4 ^Eval(Env_4 env, Expression_4 obj, Method_4 m, ArrayList /* of Argument_4 */ args) {
    RValue_4 ^r;
    GValue_4 v;
    if (m.IsStatic())
      v = null;
    else {
      if (obj == null)
        v = env.this_;
      else {
        r = obj.Eval(env);
        v = r.Get();
        if (v is Null_4) {
          Error("attempted to call method on null object");
          Gel_4.Exit();
        }
      }
    }

    return CallMethod(env, v, m, args, !(obj is Base_4));
  }

  public override RValue_4 ^Eval(Env_4 env) {
    return Eval(env, obj_, method_, arguments_);
  }

  public static string EmitArguments(Method_4 m, ArrayList /* of Argument_4 */ arguments) {
    StringBuilder ^sb = new StringBuilder();
    Debug.Assert(m.parameters_.Count == arguments.Count);
    for (int i = 0; i < arguments.Count; ++i) {
      if (i > 0)
        sb.Append(", ");
      Argument_4 a = (Argument_4)arguments[i];
      sb.Append(a.Emit(m.Param(i).Type()));
    }
    return sb.ToString();
  }

  public override string Emit() {
    StringBuilder ^sb = new StringBuilder();
    if (obj_ != null) {
      if (method_.IsStatic())
        sb.AppendFormat("{0}::", obj_.Emit());
      else if (obj_type_.IsReference())
        sb.Append(obj_.EmitArrow(obj_type_, method_));
      else sb.AppendFormat("({0})->", obj_.Emit(obj_type_, GObject_4.type_));   // box values
    }
    sb.AppendFormat("{0} ({1})", method_.name_, EmitArguments(method_, arguments_));
    return Hold(method_.ReturnType(), sb.ToString());
  }
}

// an expression of the form a[b]
class Sub_4 : LValue_4 {
  readonly Expression_4 ^base_;
  GType_4 base_type_;
  readonly Expression_4 ^index_;
  GType_4 index_type_;

  GType_4 element_type_;    // for array accesses; null for indexers
  Indexer_4 indexer_;

  public Sub_4(Expression_4 ^base_exp, Expression_4 ^index) { base_ = base_exp; index_ = index; }

  public override GType_4 Check(Context_4 ctx, bool read, bool write, bool type_ok) {
    base_type_ = base_.CheckAndHold(ctx);
    if (base_type_ == null)
      return null;

    index_type_ = index_.CheckAndHold(ctx);
    if (index_type_ == null)
      return null;

    if (read)
      ReleaseAll(ctx);

    ArrayType_4 at = base_type_.BaseType() as ArrayType_4;
    if (at != null) {
      if (!index_type_.CheckConvert(this, GInt_4.type_))
        return null;
      element_type_ = at.ElementType();
      return element_type_.BaseType();
    }

    ArrayList ^arguments = new ArrayList();
    arguments.Add(new InArgument_4(index_type_));

    indexer_ = (Indexer_4) base_type_.Lookup(this, ctx.class_, base_ is Base_4,
                                           MemberKind_4.Indexer_4, null, arguments, true);
    if (indexer_ == null)
      return null;

    if (read && !indexer_.CheckAssigning(this, ctx, false) ||
        write && !indexer_.CheckAssigning(this, ctx, true))
      return null;

    if (read)
      AddControl(ctx);

    return indexer_.Type();
  }

  public override void ReleaseAll(Context_4 ctx) {
    base_.ReleaseRef(ctx);
    index_.ReleaseRef(ctx);
  }

  public override int Kind() {
    return element_type_ != null ? ExprKind_4.Field_4 : ExprKind_4.Indexer_4;
  }

  public override GType_4 StorageType() {
    return element_type_ != null ? element_type_ : indexer_.Type();
  }

  public override PropertyOrIndexer_4 GetPropertyOrIndexer() { return indexer_; }

  public override void Eval1(Env_4 env, out RValue_4 ^v1, out RValue_4 ^v2) {
    v1 = base_.Eval(env);
    if (v1 is Null_4) {
      Error("attempted array or indexer access through null");
      Gel_4.Exit();
    }
    v2 = index_.Eval(env);
  }

  int Index(RValue_4 ^v) {
    // ++ We get an ownership error if we combine the following two lines into one; why?
    v = v.Get().Convert(ref v, GInt_4.type_);
    return ((GInt_4) v).i_;
  }

  public override RValue_4 ^EvalGet(Env_4 env, RValue_4 ^v1, RValue_4 ^v2) {
    if (indexer_ == null) {
      GArray_4 arr = (GArray_4) v1.Get();
      int i = Index(v2);
      return LosesOwnership() && element_type_ is Owning_4 ? arr.Take_4(i) : arr.Get(i);
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    return Invocation_4.InvokeMethod(v1.Get(), indexer_.Getter(), args, true);
  }

  public override void EvalSet(Env_4 env, RValue_4 ^v1, RValue_4 ^v2, RValue_4 ^val) {
    if (indexer_ == null) {
      ((GArray_4) v1.Get()).Set(Index(v2), val);
      return;
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    args.Add(val);
    Invocation_4.InvokeMethod(v1.Get(), indexer_.Setter(), args, true);
  }

  public override Location_4 EvalLocation(Env_4 env, RValue_4 ^v1, RValue_4 ^v2) {
    int i = ((GInt_4) v2).i_;
    return ((GArray_4) v1).GetLocation(i);
  }

  string EmitBase() {
    return base_.EmitArrow(base_type_, indexer_);
  }

  string EmitIndex() {
    return index_.Emit(index_type_, indexer_ != null ? indexer_.parameter_.Type() : GInt_4.type_);
  }

  public override string Emit() {
    string get = String.Format("{0}get_Item({1})", EmitBase(), EmitIndex());
    if (element_type_ != null) {
      get = get + OwnSuffix(element_type_);
      if (!element_type_.IsValue())
        get = String.Format("static_cast<{0} >({1})", element_type_.EmitExprType(), get);
      return get;
    } else return Hold(indexer_.Type(), get);
  }

  public override string EmitSet(string val) {
    return String.Format(element_type_ != null ? "{0}get_Item({1}) = {2}" : "{0}set_Item({1}, {2})",
       EmitBase(), EmitIndex(), val);
  }

  public override string EmitLocation() {
    return String.Format("{0}get_location({1})", EmitBase(), EmitIndex());
  }
}

class This_4 : Expression_4 {
  public override GType_4 Check(Context_4 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access this in a static context");
      return null;
    }
    return ctx.class_;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    return new Reference_4(env.this_);
  }

  public override string Emit() { return "this"; }
}

class Base_4 : Expression_4 {
  Class_4 parent_;

  public override GType_4 Check(Context_4 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access base in a static context");
      return null;
    }
    parent_ = ctx.class_.Parent();
    if (parent_ == null) {
      Error("can't access base: class has no parent");
      return null;
    }
    return parent_;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    return new Reference_4(env.this_);
  }

  public override string Emit() { return "this"; }

  public override string EmitArrow(GType_4 t, Member_4 m) {
    return m.GetClass().name_ + "::"; 
  }
}

class New_4 : Expression_4 {
  Expression_4 ^creator_;    // either a pool or null
  TypeExpr_4 ^type_expr_;
  ArrayList /* of Expression_4 */ ^arguments_;

  Class_4 class_;
  Constructor_4 constructor_;

  public New_4(Expression_4 ^creator, TypeExpr_4 ^expr, ArrayList ^arguments) {
    creator_ = creator;
    type_expr_ = expr;
    arguments_ = arguments;
  }

  GType_4 Type() {
    return creator_ == null ? (GType_4) class_.OwningType() : class_;
  }

  public override GType_4 TemporaryType() { return Type(); }    

  public override GType_4 Check(Context_4 ctx) {
    if (creator_ != null) {
      GType_4 c = creator_.Check(ctx);
      if (c == null)
        return null;
      if (!c.BaseType().IsSubtype(PoolClass_4.instance_)) {
        Error("object creator must be a pool");
        return null;
      }
    }
    GType_4 t = type_expr_.Resolve(ctx.program_);
    if (t == null)
      return null;
    class_ = (Class_4) t;
    if (class_.HasAttribute(Attribute_4.Abstract)) {
      Error("can't instantiate abstract class");
      return null;
    }
    if (creator_ != null) {
      class_.NeedDestroy(); // every pool-allocated class needs the _Destroy1 and _Destroy2 methods
      class_.SetVirtual();  // every pool-allocated class must be virtual
    }

    constructor_ = (Constructor_4) Invocation_4.CheckInvoke(this, ctx, false, class_,
                                      class_.name_, arguments_, MemberKind_4.Constructor_4);
    if (constructor_ == null)
      return null;

    GType_4 type = Type();
    if (type is Owning_4)
      ctx.AddTemporary(this);
    return type;
  }

  public override Method_4 Calls() { return constructor_; }

  public override RValue_4 ^Eval(Env_4 env) {
    GValue_4 ^obj = class_.New_4();
    Invocation_4.CallMethod(env, obj, constructor_, arguments_, false);
    return obj;
  }

  public override string Emit() {
    string args = Invocation_4.EmitArguments(constructor_, arguments_);

    return creator_ == null ?
      EmitAllocate(class_.name_, args, LosesOwnership()) :
      String.Format("new ({0}->Alloc(sizeof({1}))) {1}({2})", creator_.Emit(), class_.name_, args);
  }
}

class ArrayInitializer_4 : Expression_4 {
  public readonly ArrayList /* of Expression_4 */ ^initializers_;

  public ArrayInitializer_4(ArrayList ^initializers) { initializers_ = initializers; }

  public override GType_4 Check(Context_4 ctx) {
    Error("only static fields may have array initializers");
    return null;
  }

  public bool CheckElements(Context_4 ctx, GType_4 element_type) {
    foreach (Expression_4 e in initializers_)
      if (!e.CheckConstant() || !e.Check(ctx, element_type))
        return false;
    return true;
  }

  public override RValue_4 ^Eval(Env_4 env) { Debug.Assert(false); return null; }

  public GArray_4 ^Eval(ArrayType_4 type) {
    GArray_4 ^a = new GArray_4(type, initializers_.Count);
    for (int i = 0; i < initializers_.Count; ++i) {
      Expression_4 e = (Expression_4) initializers_[i];
      a.Set(i, e.Eval(Env_4.static_, type.ElementType()));
    }
    return a;
  }

  public override string Emit() { Debug.Assert(false); return null; }

  public void Emit(SourceWriter_4 w) {
    int count = initializers_.Count;
    int per_row = 12;

    w.Write("{ ");
    if (count > per_row) {    // format onto multiple rows
      w.WriteLine("");
      w.AddIndent();
      w.Indent();
    }
    for (int i = 0; i < count; ++i) {
      if (i > 0) {
        w.Write(", ");
        if (i % per_row == 0) {
          w.WriteLine("");
          w.Indent();
        }
      }
      Expression_4 e = (Expression_4) initializers_[i];
      SimpleValue_4 ^v = (SimpleValue_4) e.Eval(Env_4.static_);
      w.Write(v.Emit());
    }
    if (count > per_row) {
      w.SubIndent();
      w.WriteLine("");
    }
    w.Write(" }");
  }
}

class NewArray_4 : Expression_4 {
  TypeExpr_4 ^element_type_expr_;
  int dimensions_;
  ArrayType_4 ^array_type_;

  Expression_4 ^count_;

  public NewArray_4(TypeExpr_4 ^element_type_expr, int dimensions, Expression_4 ^count) {
    element_type_expr_ = element_type_expr;
    dimensions_ = dimensions;
    count_ = count;
  }

  GType_4 Type() {
    return (GType_4) array_type_.OwningType();
  }

  public override GType_4 TemporaryType() { return Type(); }

  public override GType_4 Check(Context_4 ctx) {
    if (element_type_expr_ is ArrayTypeExpr_4) {
      Error("syntax error in new expression");
      return null;
    }
    for (int i = 0; i < dimensions_; ++i)
      element_type_expr_ = new ArrayTypeExpr_4(take element_type_expr_);
    GType_4 element_type = element_type_expr_.Resolve(ctx.program_);
    if (element_type == null)
      return null;
    array_type_ = new ArrayType_4(element_type);

    if (!count_.Check(ctx, GInt_4.type_))
      return null;

    GType_4 t = Type();
    if (t is Owning_4)
      ctx.AddTemporary(this);
    return t;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    return new GArray_4(array_type_, count_.EvalInt(env));
  }

  public override string Emit() {
    GType_4 t = array_type_.ElementType();
    string array_type = GType_4.ConstructType(
      t is Owning_4 ? "_Array" : "_CopyableArray",
      t.EmitGenericType());
    string args = String.Format("&typeid({0}), {1}", t.EmitType(), count_.Emit());
    return EmitAllocate(array_type, args, LosesOwnership());
  }
}

abstract class Unary_4 : Expression_4 {
  protected Expression_4 ^exp_;

  protected Unary_4(Expression_4 ^e) { exp_ = e; }

  public override bool IsConstant() { return exp_.IsConstant(); }
}

// unary minus operator
class Minus_4 : Unary_4 {
  GType_4 type_;

  public Minus_4(Expression_4 ^e) : base(e) { }

  public override GType_4 Check(Context_4 ctx) {
    type_ = exp_.Check(ctx);
    if (type_ != GInt_4.type_ && type_ != GFloat_4.type_ && type_ != GDouble_4.type_) {
      Error("- operator cannot be applied to value of type {0}", type_);
      return null;
    }
    return type_;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    if (type_ == GInt_4.type_) {
    int i = exp_.EvalInt(env);
    return new GInt_4(-i);
  }
    if (type_ == GFloat_4.type_) {
      float f = exp_.EvalFloat(env);
      return new GFloat_4(-f);
    }
    if (type_ == GDouble_4.type_) {
      double d = exp_.EvalDouble(env);
      return new GDouble_4(-d);
    }
    Debug.Assert(false);
    return null;
  }

  public override string Emit() { return "-" + exp_.Emit(); }
}

class Not_4 : Unary_4 {
  public Not_4(Expression_4 ^e) : base(e) { }

  public override GType_4 Check(Context_4 ctx) {
    return exp_.Check(ctx, GBool_4.type_) ? GBool_4.type_ : null;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    bool b = exp_.EvalBool(env);
    return new GBool_4(!b);
  }

  public override string Emit() { return "!" + exp_.Emit(); }
}

// the bitwise complement (~) operator
class Complement_4 : Unary_4 {
  public Complement_4(Expression_4 ^e) : base(e) { }

  public override GType_4 Check(Context_4 ctx) {
    return exp_.Check(ctx, GInt_4.type_) ? GInt_4.type_ : null;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    int i = exp_.EvalInt(env);
    return new GInt_4(~i);
  }

  public override string Emit() { return "~" + exp_.Emit(); }
}

class IncDec_4 : Expression_4 {
  bool pre_;    // true for pre-increment/decrement; false for post-increment/decrement
  bool inc_;
  LValue_4 ^lvalue_;

  public IncDec_4(bool pre, bool inc, LValue_4 ^lvalue) { pre_ = pre; inc_ = inc; lvalue_ = lvalue; }

  public override GType_4 Check(Context_4 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    GType_4 t = lvalue_.Check(ctx, true, true, false);
    if (t == null)
      return null;
    if (lvalue_.Kind() == ExprKind_4.Indexer_4) {
      Error("++ and -- can't yet operate on indexers");
      return null;
    }
    if (t != GInt_4.type_) {
      Error("++ and -- can operate only on integers");
      return null;
    }
    return GInt_4.type_;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    Location_4 loc = lvalue_.EvalLocation(env);
    GInt_4 ^i = (GInt_4) take loc.value_;
    loc.value_ = new GInt_4(inc_ ? i.i_ + 1 : i.i_ - 1);
    return pre_ ? ((GInt_4) loc.value_).Copy() : i;
  }

  string EmitOp() { return inc_ ? "++" : "--"; }

  public override string Emit() {
    return pre_ ? EmitOp() + lvalue_.Emit() : lvalue_.Emit() + EmitOp();
  }
}

abstract class Conversion_4 : Expression_4 {
  protected Expression_4 ^expr_;
  protected TypeExpr_4 ^type_expr_;

  protected GType_4 from_base_;
  protected GType_4 to_type_, to_base_;

  protected Conversion_4(Expression_4 ^expr, TypeExpr_4 ^type_expr) {
    expr_ = expr; type_expr_ = type_expr;
  }

  protected bool CheckConversion(Context_4 ctx, bool subtype_only) {
    GType_4 from = expr_.Check(ctx);
    if (from == null)
      return false;
    from_base_ = from.BaseType();

    to_base_ = type_expr_.Resolve(ctx.program_);
    if (to_base_ == null)
      return false;
    if (!to_base_.IsValue() &&
       (from is Owning_4 || from_base_.IsValue()))
      to_type_ = to_base_.OwningType();
    else to_type_ = to_base_;

    if (!from.CanConvertExplicit(to_type_, subtype_only)) {
      Error("can't convert from {0} to {1}", from_base_, to_base_);
      return false;
    }
    return true;
  }
}

class Cast_4 : Conversion_4 {
  public Cast_4(Expression_4 ^expr, TypeExpr_4 ^type_expr) : base(expr, type_expr) { }

  public override Local_4 GetLocal() { return expr_.GetLocal(); }
  
  public override GType_4 Check(Context_4 ctx) {
    return CheckConversion(ctx, false) ? to_type_ : null;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_4.Local_4 ? ExprKind_4.Local_4 : ExprKind_4.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_4 ^Eval(Env_4 env) {
    RValue_4 ^r = expr_.Eval(env);
    return r.Get().ConvertExplicit(ref r, to_base_);
  }

  public override string Emit() {
    return expr_.EmitExplicit(from_base_, to_type_);
  }
}

class Binary_4 : Expression_4 {
  int op_;
  Expression_4 ^left_, right_;
  GType_4 left_type_, right_type_;
  GType_4 type_;

  const int CONCATENATE = 0;

  public Binary_4(Expression_4 ^left, int op, Expression_4 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public static GType_4 Promote(Syntax_4 caller, GType_4 left, int op, GType_4 right) {
    if (left.CanConvert(GInt_4.type_) && right.CanConvert(GInt_4.type_))
      return GInt_4.type_;
    if (left.CanConvert(GFloat_4.type_) && right.CanConvert(GFloat_4.type_))
      return GFloat_4.type_;
    if (left.CanConvert(GDouble_4.type_) && right.CanConvert(GDouble_4.type_))
      return GDouble_4.type_;
    caller.Error("can't apply operator {0} to operands of type {1} and {2}", OpName(op), left, right);
    return null;
  }

  bool CheckIntArgs() {
    if (left_type_.CheckConvert(this, GInt_4.type_) && right_type_.CheckConvert(this, GInt_4.type_)) {
      type_ = GInt_4.type_;
      return true;
    }
    return false;
  }

  public override GType_4 Check(Context_4 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);

    if (op_ == '+' && (left_type_ == GString_4.type_ || right_type_ == GString_4.type_)) {
      op_ = CONCATENATE;

      // If_4 we'll be calling ToString() on a class, ensure that it will inherit from
      // Object in generated code.
      if (left_type_ != GString_4.type_)
        left_type_.CanConvert(GObject_4.type_);
      if (right_type_ != GString_4.type_)
        right_type_.CanConvert(GObject_4.type_);

      return GString_4.type_;
    }

    switch (op_) {
      case '*':
      case '/':
      case '+':
      case '-':
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_;

      case '%':
      case Parser.OP_LEFT_SHIFT:
      case Parser.OP_RIGHT_SHIFT:
        return CheckIntArgs() ? GInt_4.type_ : null;

      case '&':
      case '|':
        if (left_type_ == GBool_4.type_ && right_type_ == GBool_4.type_)
          type_ = GBool_4.type_;
        else {
          if (!CheckIntArgs())
            return null;
          type_ = GInt_4.type_;
        }
        return type_;

      case '<':
      case Parser.OP_LE:
      case '>':
      case Parser.OP_GE:
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_ == null ? null : GBool_4.type_;

      default:
        Debug.Assert(false);
        return null;
    }
  }

  public static GBool_4 ^BoolOp(bool x, int op, bool y) {
    switch (op) {
      case '&': return new GBool_4(x & y);
      case '|': return new GBool_4(x | y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_4 ^IntOp(int x, int op, int y) {
    switch (op) {
      case '*': return new GInt_4(x * y);
      case '/': return new GInt_4(x / y);
      case '%': return new GInt_4(x % y);
      case '+': return new GInt_4(x + y);
      case '-': return new GInt_4(x - y);
      case Parser.OP_LEFT_SHIFT: return new GInt_4(x << y);
      case Parser.OP_RIGHT_SHIFT: return new GInt_4(x >> y);
      case '&': return new GInt_4(x & y);
      case '|': return new GInt_4(x | y);
      case '<': return new GBool_4(x < y);
      case Parser.OP_LE: return new GBool_4(x <= y);
      case '>': return new GBool_4(x > y);
      case Parser.OP_GE: return new GBool_4(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_4 ^FloatOp(float x, int op, float y) {
    switch (op) {
      case '*': return new GFloat_4(x * y);
      case '/': return new GFloat_4(x / y);
      case '+': return new GFloat_4(x + y);
      case '-': return new GFloat_4(x - y);
      case '<': return new GBool_4(x < y);
      case Parser.OP_LE: return new GBool_4(x <= y);
      case '>': return new GBool_4(x > y);
      case Parser.OP_GE: return new GBool_4(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_4 ^DoubleOp(double x, int op, double y) {
    switch (op) {
      case '*': return new GDouble_4(x * y);
      case '/': return new GDouble_4(x / y);
      case '+': return new GDouble_4(x + y);
      case '-': return new GDouble_4(x - y);
      case '<': return new GBool_4(x < y);
      case Parser.OP_LE: return new GBool_4(x <= y);
      case '>': return new GBool_4(x > y);
      case Parser.OP_GE: return new GBool_4(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public override RValue_4 ^Eval(Env_4 env) {
    if (op_ == CONCATENATE)
      return new GString_4(left_.Eval(env).ToString() + right_.Eval(env).ToString());

    if (type_ == GBool_4.type_)
      return BoolOp(left_.EvalBool(env), op_, right_.EvalBool(env));
    if (type_ == GInt_4.type_)
      return IntOp(left_.EvalInt(env), op_, right_.EvalInt(env));
    if (type_ == GFloat_4.type_)
      return FloatOp(left_.EvalFloat(env), op_, right_.EvalFloat(env));
    if (type_ == GDouble_4.type_)
      return DoubleOp(left_.EvalDouble(env), op_, right_.EvalDouble(env));

    Debug.Assert(false);
    return null;
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  static string OpName(int op) {
    switch (op) {
      case Parser.OP_LEFT_SHIFT: return "<<";
      case Parser.OP_RIGHT_SHIFT: return ">>";
      case Parser.OP_LE: return "<=";
      case Parser.OP_GE: return ">=";
      default: return ((char) op).ToString();
    }
  }

  public override string Emit() {
    if (op_ == CONCATENATE)
      return Hold(GString_4.type_,
        String.Format("String::_Concat({0}, {1})",
          left_.EmitRef(left_type_, GObject_4.type_), right_.Emit(right_type_, GObject_4.type_)));

    return String.Format("{0} {1} {2}",
      left_.EmitRef(left_type_), OpName(op_), right_.Emit() );
  }
}

class Equality_4 : Expression_4 {
  bool equal_;    // true for ==, false for !=
  Expression_4 ^left_, right_;
  GType_4 left_type_, right_type_, type_;

  public Equality_4(Expression_4 ^left, int op, Expression_4 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_EQUAL: equal_ = true; break;
      case Parser.OP_NE: equal_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_4 Check(Context_4 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);
    if (left_type_.IsReference() != right_type_.IsReference()) {
      Error("can't compare types {0} and {1}", left_type_, right_type_);
      return null;
    }
    type_ = left_type_.BaseType().CommonType(this, right_type_.BaseType());
    return type_ == null ? null : GBool_4.type_;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    RValue_4 ^left = left_.Eval(env, type_);
    RValue_4 ^right = right_.Eval(env, type_);
    bool eq = left.Get().DefaultEquals(right.Get());
    return new GBool_4(equal_ ? eq : !eq);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    string emit_left = left_.EmitRef(left_type_);
    string emit_right = right_.Emit();
    if (type_ == GString_4.type_)
      return String.Format("{0}String::_Equals({1}, {2})",
                           equal_ ? "" : "!", emit_left, emit_right);
    return String.Format("{0} {1} {2}", emit_left, equal_ ? "==" : "!=", emit_right);
  }
}

class Is_4 : Conversion_4 {
  public Is_4(Expression_4 ^expr, TypeExpr_4 ^type_expr) : base(expr, type_expr) { }

  public override GType_4 Check(Context_4 ctx) {
    return CheckConversion(ctx, true) ? GBool_4.type_ : null;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    RValue_4 ^r = expr_.Eval(env);
    GValue_4 v = r.Get();
    return new GBool_4(!(v is Null_4) && v.Type().IsSubtype(to_base_));
  }

  public override string Emit() {
    if (from_base_.IsReference()) {
      Class_4 c = (Class_4) to_base_;
      return String.Format("dynamic_cast<{0} *>({1}) != 0", c.name_, expr_.Emit());
    }
    return to_base_ == from_base_ || to_base_ == GObject_4.type_ ? "true" : "false";
  }
}

class As_4 : Conversion_4 {
  public As_4(Expression_4 ^expr, TypeExpr_4 ^type_expr) : base(expr, type_expr) { }

  public override Local_4 GetLocal() { return expr_.GetLocal(); }

  public override GType_4 Check(Context_4 ctx) {
    if (!CheckConversion(ctx, true))
      return null;
    if (!to_base_.IsReference()) {
      Error("as operator must convert to reference type");
      return null;
    }
    return to_type_;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_4.Local_4 ? ExprKind_4.Local_4 : ExprKind_4.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_4 ^Eval(Env_4 env) {
    RValue_4 ^r = expr_.Eval(env);
    return r.Get().Type().IsSubtype(to_base_) ? r : Null_4.Instance.Copy();
  }

  public override string Emit() {
    if (from_base_.CanConvert(to_base_))
      return expr_.Emit(from_base_, to_base_);
    Class_4 c = (Class_4) to_base_;
    return String.Format("dynamic_cast<{0} *>({1})", c.name_, expr_.Emit());
  }
}

// a && or || operator
class LogicalOp_4 : Expression_4 {
  bool and_;  // true => &&, false => ||
  Expression_4 ^left_, right_;
  Joiner_4 ^join_ = new Joiner_4();

  public LogicalOp_4(Expression_4 ^left, int op, Expression_4 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_AND: and_ = true; break;
      case Parser.OP_OR: and_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_4 Check(Context_4 ctx) {
    if (!left_.Check(ctx, GBool_4.type_))
      return null;

    join_.Join(ctx.Prev());
    if (!right_.Check(ctx, GBool_4.type_))
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    return GBool_4.type_;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    bool left = left_.EvalBool(env);
    bool b = and_ ? left && right_.EvalBool(env) : left || right_.EvalBool(env);
    return new GBool_4(b);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    return String.Format("{0} {1} {2}", left_.Emit(), and_ ? "&&" : "||", right_.Emit());
  }

}

// the ?: operator
class Conditional_4 : Expression_4 {
  Expression_4 ^condition_;
  Expression_4 ^if_true_, if_false_;

  GType_4 true_type_, false_type_;
  GType_4 type_;
  Joiner_4 ^join_ = new Joiner_4();

  public Conditional_4(Expression_4 ^condition, Expression_4 ^if_true, Expression_4 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override GType_4 Check(Context_4 ctx) {
    if (!condition_.Check(ctx, GBool_4.type_))
      return null;

    Control_4 c = ctx.Prev();

    true_type_ = if_true_.Check(ctx);
    if (true_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    false_type_ = if_false_.Check(ctx);
    if (false_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    type_ = true_type_.CommonType(this, false_type_);
    return type_;
  }

  public override int Kind() {
    return if_true_.Kind() == ExprKind_4.Local_4 && if_false_.Kind() == ExprKind_4.Local_4 ? ExprKind_4.Local_4 : ExprKind_4.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    if_true_.LoseOwnership();
    if_false_.LoseOwnership();
  }

  public override RValue_4 ^Eval(Env_4 env) {
    return condition_.EvalBool(env) ? if_true_.Eval(env, type_) : if_false_.Eval(env, type_);
  }

  public override string Emit() {
    return String.Format("{0} ? {1} : {2}", condition_.Emit(),
                         if_true_.Emit(true_type_, type_), if_false_.Emit(false_type_, type_));
  }
}

class Assign_4 : Expression_4 {
  LValue_4 ^left_;
  Expression_4 ^right_;

  GType_4 left_type_, right_type_;

  public Assign_4(LValue_4 ^left, Expression_4 ^right) {
    left_ = left; right_ = right;
  }

  public static bool CheckAssign(Syntax_4 caller, GType_4 left_type, Expression_4 right, GType_4 right_type) {
    if (!right_type.CheckConvert(caller, left_type,
      right.Kind() == ExprKind_4.Local_4 ? ConversionContext_4.AssignVar : ConversionContext_4.Other))
      return false;
    right.CheckLoseOwnership(right_type, left_type);
    return true;
  }

  public override GType_4 Check(Context_4 ctx) {
    left_type_ = left_.Check(ctx, false, true, false);
    if (left_type_ == null)
      return null;

    right_type_ = right_.Check(ctx, true, false, false);
    if (right_type_ == null || !CheckAssign(this, left_.StorageType(), right_, right_type_))
      return null;
    right_.HoldRef(ctx);

    AddControl(ctx);
    left_.ReleaseAll(ctx);
    right_.ReleaseRef(ctx);
    return left_type_;
  }

  public override Method_4 Calls() {
    PropertyOrIndexer_4 pi = left_.GetPropertyOrIndexer();
    return pi == null ? null : pi.Setter();
  }

  public override bool Sets(Local_4 local) { return left_.IsLocal(local); }

  public override TypeSet_4 NodeDestroys() {
    return left_.GetPropertyOrIndexer() != null ? TypeSet_4.empty_ : left_.StorageType().VarDestroys();
  }

  public override RValue_4 ^Eval(Env_4 env) {
    RValue_4 ^v1, v2;
    left_.Eval1(env, out v1, out v2);
    RValue_4 ^val = right_.Eval(env, left_type_);
    RValue_4 ^ret = val.CopyRef();
    left_.EvalSet(env, v1, v2, val);
    return ret;
  }

  public override string Emit() {
    return left_.EmitSet(right_.EmitRef(right_type_, left_type_));
  }
}

// a compound assignment operator such as += or -=
class CompoundAssign_4 : Expression_4 {
  LValue_4 ^left_;
  int op_;
  Expression_4 ^right_;

  GType_4 type_;

  public CompoundAssign_4(LValue_4 ^left, int op, Expression_4 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public override GType_4 Check(Context_4 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    type_ = left_.Check(ctx, true, true, false);
    if (type_ == null)
      return null;
    if (left_.Kind() == ExprKind_4.Indexer_4) {
      Error("compound assignments don't yet work on indexers");
      return null;
    }
    if (type_ == GBool_4.type_ && (op_ == '&' || op_ == '|')) {
      if (!right_.Check(ctx, GBool_4.type_))
        return null;
      return type_;
    }
    if (type_ != GInt_4.type_ && type_ != GFloat_4.type_ && type_ != GDouble_4.type_) {
      Error("compound assignment operator {0}= can't operate on object of type {1}", (char) op_, type_);
      return null;
    }
    if (!right_.Check(ctx, type_))
      return null;
    return type_;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    Location_4 loc = left_.EvalLocation(env);
    if (type_ == GBool_4.type_) {
      bool x = ((GBool_4) loc.value_).b_;
      bool y = right_.EvalBool(env);
      loc.value_ = Binary_4.BoolOp(x, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GInt_4.type_) {
      GInt_4 x = (GInt_4) loc.value_;
      int y = right_.EvalInt(env);
      loc.value_ = Binary_4.IntOp(x.i_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GFloat_4.type_) {
      GFloat_4 x = (GFloat_4) loc.value_;
      float y = right_.EvalFloat(env);
      loc.value_ = Binary_4.FloatOp(x.f_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GDouble_4.type_) {
      GDouble_4 x = (GDouble_4) loc.value_;
      double y = right_.EvalDouble(env);
      loc.value_ = Binary_4.DoubleOp(x.d_, op_, y);
      return loc.value_.CopyRef();
    } else {
      Debug.Assert(false);
      return null;
    }
  }

  public override string Emit() {
    return String.Format("{0} {1}= {2}", left_.Emit(), (char) op_, right_.Emit());
  }
}

class Take_4 : Expression_4 {
  LValue_4 ^exp_;
  Owning_4 type_;

  public Take_4(LValue_4 ^exp) { exp_ = exp; }

  public override GType_4 Check(Context_4 ctx) {
    GType_4 t = exp_.Check(ctx);
    if (t == null)
      return null;
    type_ = exp_.StorageType() as Owning_4;
    if (type_ == null) {
      Error("take must be applied to owning pointer");
      return null;
    }
    exp_.LoseOwnership();
    ctx.AddTemporary(this);
    return type_;
  }

  public override GType_4 TemporaryType() { return type_; }

  public override RValue_4 ^Eval(Env_4 env) {
    RValue_4 ^v = exp_.Eval(env);
    exp_.EvalSet(env, Null_4.Instance.Copy());
    return v;
  }

  public override string Emit() {
    return Hold(exp_.StorageType(), exp_.Emit());
  }
}

abstract class Statement_4 : Node_4 {
  public abstract bool Check(Context_4 ctx);
  public abstract RValue_4 ^Eval(Env_4 env);

  public abstract void Emit(SourceWriter_4 w);

  public virtual void EmitEmbedded(SourceWriter_4 w) {
    w.WriteLine("");
    w.AddIndent();
    w.Indent();
    Emit(w);
    w.SubIndent();
  }

  public virtual void EmitInExistingBlock(SourceWriter_4 w) {
    w.Indent();
    Emit(w);
  }
}

class StatementList_4 {
  public readonly ArrayList /* of Statement_4 */ ^statements_ = new ArrayList();

  public void Add(Statement_4 ^s) { statements_.Add(s); }

  public bool Check(Context_4 ctx) {
    bool ok = true;
    foreach (Statement_4 s in statements_)
      ok &= s.Check(ctx);
    return ok;
  }

  public RValue_4 ^Eval(Env_4 env) {
    foreach (Statement_4 s in statements_) {
      RValue_4 ^v = s.Eval(env);
      if (v != null)
        return v;
    }
    return null;
  }

  public void Emit(SourceWriter_4 w) {
    foreach (Statement_4 s in statements_) {
      w.Indent();
      s.Emit(w);
    }
  }
}

class EmptyStatement_4 : InlineStatement_4 {
  public EmptyStatement_4() { }

  public override bool Check(Context_4 ctx) { return true; }
  public override RValue_4 ^Eval(Env_4 env) { return null; }
  public override void EmitInline(SourceWriter_4 w) { }

  public static readonly EmptyStatement_4 ^instance_ = new EmptyStatement_4();
}

// A Scoped_4 is a statement defining one or more local variables.  If_4 a Scoped_4 appears in the
// control graph, then it destroys those variables when traversed.
abstract class Scoped_4 : Statement_4 {
  protected Local_4 start_;   // the first local outside this statement
  protected Local_4 top_;     // the top local defined inside this statement

  TypeSet_4 ^destroys_;

  protected void SetStartVar(Context_4 ctx) { start_ = top_ = ctx.var_; }
  protected void SetTopVar(Context_4 ctx) { top_ = ctx.var_; }

  public Local_4 GetStart() { return start_; }
  public Local_4 GetTop() { return top_; }

  public override TypeSet_4 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_4();
    for (Local_4 l = top_; l != start_; l = l.next_)
        destroys_.Add(l.Type().VarDestroys());
    }
    return destroys_;
  }
}

class Block_4 : Scoped_4 {
  public readonly StatementList_4 ^list_;

  public Block_4(StatementList_4 ^list) { list_ = list; }

  public bool Absent() { return list_ == null; }

  public override bool Check(Context_4 ctx) {
    Context_4 ^ctx1 = new Context_4(ctx);   // don't pass declarations outside block
    SetStartVar(ctx1);

    if (!list_.Check(ctx1))
      return false;

    SetTopVar(ctx1);

    // Add this Block_4 to the control graph; this represents the destruction of variables
    // within the block at block exit.
    AddControl(ctx1);

    return true;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    return list_.Eval(new Env_4(env));
  }

  public static Block_4 ^EmptyBlock() { return new Block_4(new StatementList_4()); }

  public override void Emit(SourceWriter_4 w) {
    w.OpenBrace();
    list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitEmbedded(SourceWriter_4 w) {
    w.Write(" ");
    Emit(w);
  }

  public override void EmitInExistingBlock(SourceWriter_4 w) {
    list_.Emit(w);
  }
}

class MemberKind_4 {
  public const int
    Field_4 = 0,
    Method_4 = 1,
    Property_4 = 2,
    Indexer_4 = 3,
    Constructor_4 = 4;
}

class Named_4 : Node_4 {
  public readonly TypeExpr_4 ^type_expr_;   // may be null for certain objects such as constructors
  protected GType_4 type_;

  public readonly string name_;

  public Named_4(TypeExpr_4 ^type_expr, string name) {
    type_expr_ = type_expr;
    name_ = name;
  }

  public GType_4 Type() { return type_; }

  public virtual bool Resolve(Program_4 program) {
    if (type_expr_ == null || type_ != null)
      return true;
    type_ = type_expr_.Resolve(program);
    return type_ != null;
  }
}

abstract class Member_4 : Named_4 {
  protected Class_4 class_;    // containing class

  public readonly int attributes_;

  protected Member_4(int attributes, TypeExpr_4 ^type_expr, string name) : base(type_expr, name) {
    attributes_ = attributes;
  }

  public abstract int Kind();

  public static string ToString(int kind) {
    switch (kind) {
      case MemberKind_4.Field_4: return "field";
      case MemberKind_4.Method_4: return "method";
      case MemberKind_4.Property_4: return "property";
      case MemberKind_4.Indexer_4: return "indexer";
      case MemberKind_4.Constructor_4: return "constructor";
      default: Debug.Assert(false); return null;
    }
  }

  public string KindString() { return ToString(Kind()); }

  protected abstract int ValidAttributes();

  public Class_4 GetClass() { return class_; }
  public void SetClass(Class_4 cl) { class_ = cl; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public bool IsOverride() { return HasAttribute(Attribute_4.Override); }

  public bool IsProtected() { return HasAttribute(Attribute_4.Protected); }

  public bool IsPublic() { return HasAttribute(Attribute_4.Public); }

  public bool IsPrivate() { return !HasAttribute(Attribute_4.Public | Attribute_4.Protected); }

  public bool IsVirtual() {
    return HasAttribute(Attribute_4.Virtual | Attribute_4.Abstract | Attribute_4.Override);
  }

  static ArrayList ^empty_ = new ArrayList();

  public virtual ArrayList /* of Parameter_4 */ Parameters() { return empty_; }

  public Parameter_4 Param(int i) {
    return (Parameter_4) Parameters()[i];
  }

  public bool IsAccessible(Class_4 from_class, GType_4 through_type, bool through_base) {
    if (IsPublic())
      return true;

    // In GEL2 (as in C# and C++), a class [from_class] can access a protected member of
    // a class C only if [from_class] is a subtype of C and the access is
    // through a subtype of [from_class].  See e.g. C# 3.5.3 "Protected Access for Instance Members".
    if (IsProtected())
      return through_base || from_class.IsSubtype(class_) && through_type.IsSubtype(from_class);

    // default private access
    return from_class == class_;
  }

  public static bool MatchKind(int kind1, int kind2) {
    return kind1 == kind2 ||
           kind1 == MemberKind_4.Field_4 && kind2 == MemberKind_4.Property_4 ||
           kind1 == MemberKind_4.Property_4 && kind2 == MemberKind_4.Field_4;
  }

  public bool MatchSignature(Member_4 m) {
    if (!MatchKind(Kind(), m.Kind()))
      return false;

    if (name_ != m.name_ || Parameters().Count != m.Parameters().Count)
      return false;

    int i = 0;
    foreach (Parameter_4 p in m.Parameters()) {
      Parameter_4 q = Param(i);
      if (!p.Match(q))
        return false;
      ++i;
    }
    return true;
  }

  public bool IsApplicable(ArrayList arguments, out int mismatches) {
    mismatches = 0;
    if (Parameters().Count != arguments.Count)
      return false;
    int i = 0;
    foreach (Argument_4 a in arguments) {
      if (!Param(i).CanReceive(a))
        ++mismatches;
      ++i;
    }
    return true;
  }

  public void ReportMismatches(Syntax_4 caller, ArrayList arguments) {
    Debug.Assert(Parameters().Count == arguments.Count);
    int i = 0;
    foreach (Argument_4 a in arguments) {
      Parameter_4 p = Param(i);
      if (!p.CanReceive(a))
        caller.Error("argument {0}: can't convert from {1} to {2}", i + 1, a.TypeString(), p.TypeString());
      ++i;
    }
  }

  protected virtual void AddOverride(Member_4 m) { }

  bool CheckOverride(Context_4 ctx) {
    Class_4 parent = ctx.class_.Parent();
    Member_4 m = parent != null ? parent.FindMatchingMember(this, false) : null;
    if (m != null) {
      if (this is Field_4) {
        Error("can't define field with same name as field/property in superclass");
        return false;
      }
      if (m is Field_4) {
        Error("can't define property with same name as field in superclass");
        return false;
      }
      if (!HasAttribute(Attribute_4.Override)) {
        Error("must use override keyword to override superclass {0}", KindString());
        return false;
      }
      if (HasAttribute(Attribute_4.Virtual)) {
        Error("{0} with override or abstract keyword cannot be marked virtual", KindString());
        return false;
      }
      if (!m.IsVirtual()) {
        Error("attempting to override non-virtual {0}", KindString());
        return false;
      }
      if (!m.Type().Equals(Type())) {
        Error("can't override {0} with different return type", KindString());
        return false;
      }
      if (m.IsPublic() != IsPublic()) {
        Error("override {0} must have same accessibility as {0} it overrides", KindString());
        return false;
      }
      m.AddOverride(this);
    } else if (HasAttribute(Attribute_4.Override)) {
      Error("can't find {0} to override", KindString());
      return false;
    }
    return true;
  }

  bool CheckAccessibility() {
    int n = 0;
    if ((attributes_ & Attribute_4.Private) != 0)
      ++n;
    if ((attributes_ & Attribute_4.Protected) != 0)
      ++n;
    if ((attributes_ & Attribute_4.Public) != 0)
      ++n;
    if (n > 1) {
      Error("only one access level (private, protected, public) may be specified");
      return false;
    }

    if (IsVirtual() && IsPrivate()) {
      Error("a virtual or abstract {0} may not be private", KindString());
      return false;
    }

    return true;
  }

  public virtual bool Check(Context_4 ctx) {
    if (!AttributeUtil_4.CheckOnly(attributes_, ValidAttributes())) {
      Error("illegal {0} attribute", KindString());
      return false;
    }

    if (HasAttribute(Attribute_4.Abstract) && !ctx.class_.HasAttribute(Attribute_4.Abstract)) {
      Error("an abstract {0} can be defined only in an abstract class", KindString());
      return false;
    }

    if (name_ == class_.name_ && !(this is Constructor_4)) {
      Error("{0} cannot have same name as enclosing class", KindString());
      return false;
    }

    if (class_.GetMatchingMember(this) != this) {
      Error("{0} {1} appears twice in same class", KindString(), name_ != null ? name_ : "");
      return false;
    }

    return CheckOverride(ctx) && CheckAccessibility();
  }
}

// a member which represents a storage location: a field, property, or indexer
abstract class LMember_4 : Member_4 {
  protected LMember_4(int attributes, TypeExpr_4 ^type_expr, string name)
    : base(attributes, type_expr, name) { }

  public bool IsConstOrStatic() {
    return HasAttribute(Attribute_4.Const | Attribute_4.Static);
  }

  protected bool CheckStatic(Syntax_4 caller, bool static_ok, bool instance_ok) {
    if (!static_ok && IsConstOrStatic()) {
      caller.Error("{0} {1} is static", KindString(), name_);
      return false;
    }
    if (!instance_ok && !IsConstOrStatic()) {
      caller.Error("{0} {1} is not static", KindString(), name_);
      return false;
    }
    return true;
  }

  public abstract bool CheckAssigning(Syntax_4 caller, Context_4 ctx, bool assigning);

  public bool CheckAccess(Syntax_4 caller, Context_4 ctx, bool assigning, bool static_ok, bool instance_ok) {
    return CheckStatic(caller, static_ok, instance_ok) && CheckAssigning(caller, ctx, assigning);
  }

  public abstract Location_4 GetLocation(GObject_4 obj);

  // These methods are for fields and properties; indexers have their own versions which take
  // an extra index argument.
  public virtual RValue_4 ^Get(GValue_4 obj) { Debug.Assert(false); return null; }
  public virtual RValue_4 ^Take_4(GValue_4 obj) { Debug.Assert(false); return null; }
  public virtual void Set(GObject_4 obj, RValue_4 ^val)  { Debug.Assert(false); }

  public virtual string Emit()  { Debug.Assert(false); return null; }
  public virtual string EmitSet(string val)  { Debug.Assert(false); return null; }
}

class Field_4 : LMember_4 {
  protected Expression_4 ^initializer_;    // or null if none
  protected GType_4 initializer_type_;

  public Field_4(int attributes, TypeExpr_4 ^type_expr, string name, Expression_4 ^initializer)
  : base(attributes, type_expr, name) {
    initializer_ = initializer;
  }

  // Create a field for an internal class.  Such fields will never be type checked.
  public Field_4(GType_4 type, string name) : this(Attribute_4.Public | Attribute_4.ReadOnly, null, name, null) {
    type_ = type;
  }

  public static Field_4 ^New_4(int attributes, TypeExpr_4 ^type_expr, string name, Expression_4 ^initializer) {
    if ((attributes & Attribute_4.Static) != 0)
      return new StaticField_4(attributes, type_expr, name, initializer);
    if ((attributes & Attribute_4.Const) != 0)
      return new ConstField_4(attributes, type_expr, name, initializer);
    return new Field_4(attributes, type_expr, name, initializer);
  }

  public override int Kind() { return MemberKind_4.Field_4; }

  public Expression_4 Initializer() { return initializer_; }

  protected virtual bool CheckInitializer(Context_4 ctx) {
    if (initializer_ == null)
      return true;

    ctx.EnterExpression();
    initializer_type_ = initializer_.Check(ctx);
    bool b = initializer_type_ != null &&
             Assign_4.CheckAssign(this, type_, initializer_, initializer_type_);
    ctx.FinishExpression();
    return b;
  }

  protected override int ValidAttributes() {
    return Attribute_4.Const | Attribute_4.Private | Attribute_4.Protected | Attribute_4.Public |
           Attribute_4.ReadOnly | Attribute_4.Static;
  }

  public override bool Check(Context_4 ctx) {
    if (!base.Check(ctx))
      return false;

    // We build up a small control graph even when checking field initializers; we do this
    // since expression-checking code uses the graph to determine when temporary
    // ref counts are needed.
    prev_ = unreachable_;
    ctx.SetPrev(this);

    bool b = CheckInitializer(ctx);

    ctx.ClearPrev();
    return b;
  }

  public override bool CheckAssigning(Syntax_4 caller, Context_4 ctx, bool assigning) {
    if (assigning) {
      if (HasAttribute(Attribute_4.Const)) {
        caller.Error("can't assign to const field");
        return false;
      }
      if (HasAttribute(Attribute_4.ReadOnly) &&
          (ctx.class_ != class_ || !(ctx.method_ is Constructor_4)) ) {
        caller.Error("readonly field {0} can only be assigned in constructor", name_);
        return false;
      }
    }
    return true;
  }

  public override RValue_4 ^Get(GValue_4 obj) { return obj.Get(this); }
  public override RValue_4 ^Take_4(GValue_4 obj) { return obj.Take_4(this); }
  public override void Set(GObject_4 obj, RValue_4 ^val) { obj.Set(this, val); }
  public override Location_4 GetLocation(GObject_4 obj) { return obj.GetLocation(this); }

  protected void WriteField(SourceWriter_4 w, bool declaration) {
    w.Indent();
    if (declaration && IsConstOrStatic())
      w.Write("static ");
    w.Write("{0} ", type_.EmitType());
    if (this is ConstField_4)
      w.Write("const ");
    if (!declaration)
      w.Write("{0}::", class_.name_);
    w.Write(name_);
  }

  protected void WriteDeclaration(SourceWriter_4 w) { WriteField(w, true); }
  protected void WriteDefinition(SourceWriter_4 w) { WriteField(w, false); }

  public virtual void EmitDeclaration(SourceWriter_4 w) {
    WriteDeclaration(w);
    w.WriteLine(";");
  }

  public void EmitInitializer(SourceWriter_4 w) {
    w.IWrite("{0} = ", name_);
    if (initializer_ != null)
      w.Write(initializer_.Emit(initializer_type_, type_));
    else w.Write(type_.DefaultValue_4().Emit());
    w.WriteLine(";");
  }

  public virtual void Emit(SourceWriter_4 w) { }

  public override string Emit() { return name_; }

  public override string EmitSet(string val) {
    return String.Format("{0} = {1}", name_, val);
  }
}

class StaticField_4 : Field_4 {
  protected Location_4 ^loc_;

  public StaticField_4(int attributes, TypeExpr_4 ^type_expr, string name, Expression_4 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_4 ctx) {
    if (!base.Check(ctx))
      return false;
    loc_ = new Location_4(Type().DefaultValue_4().Copy());
    return true;
  }

  protected override bool CheckInitializer(Context_4 ctx) {
    ArrayInitializer_4 ai = initializer_ as ArrayInitializer_4;
    if (ai != null) {
      GType_4 type = type_;
      Owning_4 o = type as Owning_4;
      type = (o != null) ? o.BaseType() : null;
      ArrayType_4 at = type as ArrayType_4;
      if (at == null) {
        Error("only owning arrays may have initializers");
        return false;
      }
      return ai.CheckElements(ctx, at.ElementType());
    }

    return base.CheckInitializer(ctx);
  }

  public virtual void Init() {
    ArrayInitializer_4 ai = initializer_ as ArrayInitializer_4;
    if (ai != null)
      loc_.value_ = ai.Eval((ArrayType_4) type_.BaseType());
    else if (initializer_ != null)
      loc_.value_ = initializer_.Eval(Env_4.static_, type_);
  }

  public override RValue_4 ^Get(GValue_4 obj) { return loc_.Get().CopyRef(); }
  public override RValue_4 ^Take_4(GValue_4 obj) { return take loc_.value_; }
  public override void Set(GObject_4 obj, RValue_4 ^val) { loc_.value_ = val; }
  public override Location_4 GetLocation(GObject_4 obj) { return loc_; }

  public override void Emit(SourceWriter_4 w) {
    ArrayInitializer_4 ai = initializer_ as ArrayInitializer_4;
    if (ai != null) {
      GType_4 element_type = ((ArrayType_4) type_.BaseType()).ElementType();
      string varname = String.Format("_{0}_{1}", class_.name_, name_);
      w.Write("{0} {1}[] = ", element_type.EmitGenericType(), varname);
      ai.Emit(w);
      w.WriteLine(";");
      WriteDefinition(w);
      w.Write("(new {0}", GType_4.ConstructType("_StaticArray", element_type.EmitGenericType()));
      w.Write("(&typeid({0}), {1}, {2}))", element_type.EmitType(), ai.initializers_.Count, varname);
    } else {
      WriteDefinition(w);
      if (initializer_ != null)
        initializer_.EmitAsInitializer(w, initializer_type_, type_);
    }
    w.WriteLine(";");
    w.WriteLine("");
  }
}

class ConstField_4 : Field_4 {
  protected SimpleValue_4 ^value_;

  public ConstField_4(int attributes, TypeExpr_4 ^type_expr, string name, Expression_4 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_4 ctx) {
    if (!base.Check(ctx))
      return false;
    return initializer_.CheckConstant();
  }

  SimpleValue_4 ^Get() {
    if (value_ == DefaultValue_4.instance_) {
      Error("circular dependency among constant fields");
      Gel_4.Exit();
    }
    if (value_ == null) {
      value_ = new DefaultValue_4();    // marker used to catch circular const references
      value_ = (SimpleValue_4)initializer_.Eval(Env_4.static_, type_);
    }
    return value_.Copy();
  }

  public override RValue_4 ^Get(GValue_4 obj) {
    return Get();
  }

  public override void Set(GObject_4 obj, RValue_4 ^val) { Debug.Assert(false); }
  public override Location_4 GetLocation(GObject_4 obj) { Debug.Assert(false); return null; }

  public override void EmitDeclaration(SourceWriter_4 w) {
    WriteDeclaration(w);
    if (type_ is IntegralType_4)
      w.Write(" = {0}", Get().Emit());
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_4 w) {
    WriteDefinition(w);
    if (!(type_ is IntegralType_4)) {
      w.WriteLine(" = {0};", Get().Emit());
    }
    w.WriteLine(";");
  }
}

class ExpressionTraverser_4 : Traverser_4 {
  readonly Control_4 start_;
  Local_4 local_;
  GType_4 type_;
  bool assign_;
  bool destroy_;

  public ExpressionTraverser_4(Control_4 start, Local_4 local, GType_4 type) {
    start_ = start; local_ = local; type_ = type;
  }

  public override int Handle(Control_4 control) {
    if (control == start_)
      return Cut;
    Node_4 node = control as Node_4;
    if (node != null) {
      if (!destroy_ && node.CanDestroy(type_))
        destroy_ = true;
      else if (local_ != null && node.Sets(local_))
        assign_ = true;
    }
    return Continue_4;
  }

  // Return_4 true if the given expression needs a reference count while we evaluate
  // the control graph nodes between [start] and [end].
  // A local variable needs a ref count if it is assigned to and the object
  // the variable previously pointed to might possibly be destroyed.
  // Any other expression needs a ref count if the object it evaluates to
  // might possibly be destroyed.
  public static bool NeedRef(Control_4 start, Control_4 end, Expression_4 expr, GType_4 type) {
    Debug.Assert(start != null && end != null);
    if (start == end || !type.IsOwned() || expr is This_4 || expr is Base_4)
      return false;
    Local_4 local = expr.GetLocal();
    ExpressionTraverser_4 ^et = new ExpressionTraverser_4(start, local, type);
    end.Traverse(et, Control_4.GetMarkerValue());
    return et.destroy_ && (local == null || et.assign_);
  }
}

abstract class LocalHandler_4 {
  public abstract bool Handle(Local_4 local, Node_4 node, Name_4 use);
}

class LocalChecker_4 : LocalHandler_4 {
  public override bool Handle(Local_4 local, Node_4 node, Name_4 use) {
    if (node == Control_4.unreachable_) {
      if (use != null)
        use.Error("variable {0} may be used before it is assigned a value", use.name_);
      else
        local.Error("out parameter {0} must be assigned before leaving method", local.name_);
      return false;
    }
    if (node.Takes(local)) {
      Name_4 name = (Name_4) node;
      name.Error("can't transfer ownership from {0}: value may be used again", name.name_);
      return false;
    }
    return true;
  }
}

class LocalRefAnalyzer_4 : LocalHandler_4 {
  public override bool Handle(Local_4 local, Node_4 node, Name_4 use) {
    Debug.Assert(node != Control_4.unreachable_);
    if (node.CanDestroy(local.Type())) {
      local.NeedsRef();
      return false;   // abort search
    }
    return true;
  }
}

class LocalTraverser_4 : Traverser_4 {
  readonly Local_4 local_;
  readonly LocalHandler_4 handler_;
  Name_4 use_;

  public LocalTraverser_4(Local_4 local, LocalHandler_4 handler) {
    local_ = local;
    handler_ = handler;
  }

  public void SetUse(Name_4 use) { use_ = use; }

  public override int Handle(Control_4 control) {
    Node_4 node = control as Node_4;
    if (node == null)
      return Continue_4;

    if (node.Sets(local_))
      return Cut;

    return handler_.Handle(local_, node, use_) ? Continue_4 : Abort;
  }
}

class Local_4 : Named_4 {
  protected Expression_4 ^initializer_;    // or null if none
  protected GType_4 initializer_type_;

  public Local_4 next_;    // next variable upward in scope chain

  NonOwningArrayList /* of Name_4 */ ^uses_ = new NonOwningArrayList();    // all uses of this variable

  protected bool mutable_;   // true if this local may ever change after it's first initialized

  protected bool needs_ref_;    // true if this variable needs a reference count in emitted code

  public Expression_4 Initializer() { return initializer_; }

  public void NeedsRef() { needs_ref_ = true; }

  public virtual string Emit() { return name_; }

  // Return_4 true if we represent this local using a smart pointer wrapper (i.e.
  // _Ptr, _Own, _OwnRef or _Ref).
  public virtual bool IsWrapper() {
    return type_ is Owning_4 || type_ == GString_4.type_ || needs_ref_;
  }

  public Local_4(TypeExpr_4 ^type_expr, string name, Expression_4 ^initializer) : base(type_expr, name) {
    initializer_ = initializer;
    next_ = null;
  }

  public bool Check(Context_4 ctx) {
    Local_4 decl = ctx.FindVar(name_);
    if (decl != null) {
      Error("error: variable already defined");
      return false;
    }

    if (initializer_ != null) {
      ctx.EnterExpression();
      initializer_type_ = initializer_.Check(ctx);
      bool ok = initializer_type_ != null &&
                Assign_4.CheckAssign(this, type_, initializer_, initializer_type_);

      // Add this Local_4 to the control graph.  We need to do this before calling
      // FinishExpression since the Local_4 will be initialized before temporaries 
      // are destroyed.
      AddControl(ctx);

      ctx.FinishExpression();
      if (!ok)
        return false;
    }

    next_ = ctx.var_;
    ctx.SetVar(this);

    ctx.method_.AddVar(this);
    return true;
  }

  public override bool Sets(Local_4 local) {
    return this == local && initializer_ != null;
  }

  public virtual GType_4 ReadType() {
    return type_;
  }

  public void AddUse(Name_4 name) {
    uses_.Add(name);
  }

  public void SetMutable() { mutable_ = true; }

  // Traverse the control graph nodes where this local is live, calling the given
  // LocalHandler_4's Handle method on each node.
  public bool Traverse(Method_4 method, LocalHandler_4 h) {
    LocalTraverser_4 ^t = new LocalTraverser_4(this, h);
    int marker = Control_4.GetMarkerValue();
    foreach (Name_4 name in uses_) {
      t.SetUse(name);
      if (!name.prev_.Traverse(t, marker))
        return false;
    }

    Parameter_4 p = this as Parameter_4;
    if (p != null && p.GetMode() == Mode_4.Out) {
      t.SetUse(null);
      if (!method.exit_.Traverse(t, marker))
        return false;
    }
    return true;
  }

  // check variable usage once control flow graph is complete
  public bool CheckUsage(Method_4 method) {
    return Traverse(method, new LocalChecker_4());
  }

  // Determine whether this Local_4 needs a reference count.  This_4 can happen only after
  // we've built up a control graph for all methods.
  public void ComputeRef(Method_4 method) {
    // For_4 now, a variable of type object always needs a reference count since it may
    // contain a string and we don't yet detect string destruction in the graph traversal.
    if (type_ == GObject_4.type_)
      NeedsRef();
    else if (type_.IsOwned())
      Traverse(method, new LocalRefAnalyzer_4());
  }

  public void EvalInit(Env_4 env) {
    env.Add(this, initializer_ != null ? initializer_.Eval(env, type_) : null);
  }

  protected virtual string EmitDeclarationType() {
    return IsWrapper() ? type_.EmitType() : type_.EmitExprType();
  }

  public virtual string EmitDeclarationName() { return name_; }

  public void EmitDeclaration(SourceWriter_4 w) {
    w.Write("{0} {1}", EmitDeclarationType(), EmitDeclarationName());
  }

  public void EmitInitializer(SourceWriter_4 w) {
    if (initializer_ != null)
      initializer_.EmitAsInitializer(w, initializer_type_, type_);
  }
}

class Parameter_4 : Local_4 {
  public Parameter_4(TypeExpr_4 ^type_expr, string name) : base(type_expr, name, null) { }

  // We represent some parameters using both a C++ parameter and a C++ local, which
  // have different types; we call these dual parameters.  For_4 such parameters
  // param_name_ is the C++ parameter name.
  string param_name_;

  public static Parameter_4 ^New_4(int mode, TypeExpr_4 ^type_expr, string name) {
    return mode == 0 ? new Parameter_4(type_expr, name) :
                               new RefOutParameter_4(mode, type_expr, name);
  }

  public virtual int GetMode() { return 0; }
  public string TypeString() { return Mode_4.ToString(GetMode()) + type_.ToString(); }

  public virtual Parameter_4 ^Copy() {
    return new Parameter_4(new TypeLiteral_4(type_), name_);
  }

  public virtual bool CanReceive(Argument_4 a) {
    return a.GetMode() == 0 && a.Type().CanConvert(type_, ConversionContext_4.MethodArg);
  }

  public bool Match(Parameter_4 p) {
    return GetMode() == p.GetMode() && type_.Equals(p.type_);
  }

  public override bool IsWrapper() {
    return type_ is Owning_4 || type_ == GString_4.type_ || mutable_ && needs_ref_;
  }

  public void CheckParameterUsage(Method_4 method) {
    if (type_ is Owning_4 && !(this is RefOutParameter_4)) {
      // We need both a C++ parameter and a C++ local: the parameter type can't be
      // _Own<>, since _Own has no public copy constructor and GCC doesn't allow passing
      // by value when a class's copy constructor is private.
      string n = name_;
      do {
        n = "_" + n;
      } while (method.HasLocal(n));
      param_name_ = n;
    }
  }

  protected override string EmitDeclarationType() {
    // For_4 owning parameters the declaration type is the expression type since we can't
    // pass _Own<> by value.
    return type_ is Owning_4 ? type_.EmitExprType() : base.EmitDeclarationType();
  }

  public override string EmitDeclarationName() {
    return param_name_ != null ? param_name_ : name_;
  }

  public void EmitExtraDeclaration(SourceWriter_4 w) {
    if (param_name_ != null)
      w.IWriteLine("{0} {1}({2});", type_.EmitType(), name_, param_name_);
  }
}

class RefOutParameter_4 : Parameter_4 {
  public readonly int mode_;
  public override int GetMode() { return mode_; }

  public RefOutParameter_4(int mode, TypeExpr_4 ^type_expr, string name) : base(type_expr, name) {
    mode_ = mode;
    mutable_ = true;
  }

  public override Parameter_4 ^Copy() { Debug.Assert(false); return null; }

  public override bool CanReceive(Argument_4 a) {
    if (mode_ != a.GetMode())
      return false;
    RefOutArgument_4 ra = (RefOutArgument_4) a;
    return type_.Equals(ra.StorageType());
  }

  public override GType_4 ReadType() {
    // If_4 a ref parameter has an owning type, we require the user to use the take operator to take
    // ownership of the value, since taking ownership has the visible side effect of clearing the
    // value the ref parameter points to.
    return mode_ == Mode_4.Ref ? type_.BaseType() : type_;
  }

  public override string Emit() {
    return "(*" + name_ + ")";
  }

  protected override string EmitDeclarationType() {
    return type_.EmitType() + " *";
  }
}

abstract class InlineStatement_4 : Statement_4 {
  public abstract void EmitInline(SourceWriter_4 w);

  public override void Emit(SourceWriter_4 w) {
    EmitInline(w);
    w.WriteLine(";");
  }
}

class VariableDeclaration_4 : InlineStatement_4 {
  ArrayList /* of Local_4 */ ^locals_ = new ArrayList();

  public VariableDeclaration_4(TypeExpr_4 ^type_expr, string name, Expression_4 ^initializer) {
    locals_.Add(new Local_4(type_expr, name, initializer));
  }

  public void Add(string name, Expression_4 ^initializer) {
    TypeExpr_4 ^t = ((Local_4) locals_[0]).type_expr_.Copy();
    locals_.Add(new Local_4(t, name, initializer));
  }

  public override bool Check(Context_4 ctx) {
    // local variables are not resolved during the Resolve phase, so we must resolve them here
    foreach (Local_4 l in locals_)
      if (!l.Resolve(ctx.program_) || !l.Check(ctx))
        return false;

    return true;
  }

  // Return_4 the type of all variables in this VariableDeclaration_4.
  public GType_4 Type() { return ((Local_4) locals_[0]).Type(); }

  public override RValue_4 ^Eval(Env_4 env) {
    foreach (Local_4 l in locals_)
      l.EvalInit(env);
    return null;
  }

  void Emit(SourceWriter_4 w, bool in_line) {
    if (in_line)
      Debug.Assert(locals_.Count == 1);

    foreach (Local_4 l in locals_) {
      l.EmitDeclaration(w);
      l.EmitInitializer(w);
      if (!in_line)
        w.WriteLine(";");
    }
  }

  public override void EmitInline(SourceWriter_4 w) { Emit(w, true); }
  public override void Emit(SourceWriter_4 w) { Emit(w, false); }
}

class ExpressionStatement_4 : InlineStatement_4 {
  Expression_4 ^exp_;

  public ExpressionStatement_4(Expression_4 ^e) {
    exp_ = e;
  }

  public override bool Check(Context_4 ctx) {
    if (exp_.CheckTop(ctx) == null)
      return false;
    exp_.SetUnused();
    return true;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    exp_.Eval(env);   // discard expression value
    return null;
  }

  public override void EmitInline(SourceWriter_4 w) {
    w.Write(exp_.Emit());
  }

}

class If_4 : Statement_4 {
  Expression_4 ^condition_;
  Statement_4 ^if_true_;
  Statement_4 ^if_false_;
  Joiner_4 ^join_ = new Joiner_4();

  public If_4(Expression_4 ^condition, Statement_4 ^if_true, Statement_4 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override bool Check(Context_4 ctx) {
    if (!condition_.Check(ctx, GBool_4.type_))
      return false;

    Control_4 c = ctx.Prev();

    if (!if_true_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    if (if_false_ != null && !if_false_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());
    return true;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    if (condition_.EvalBool(env))
      return if_true_.Eval(env);
    else
      return if_false_ != null ? if_false_.Eval(env) : null;
  }

  public override void Emit(SourceWriter_4 w) {
    w.Write("if ({0})", condition_.Emit());
    if_true_.EmitEmbedded(w);
    if (if_false_ != null) {
      w.IWrite("else");
      if_false_.EmitEmbedded(w);
    }
  }

}

class DefaultValue_4 : SimpleValue_4 {
  public DefaultValue_4() { }
  public static readonly DefaultValue_4 ^instance_ = new DefaultValue_4();

  public override SimpleValue_4 ^Copy() { Debug.Assert(false); return null; }
  public override GType_4 Type()  { Debug.Assert(false); return null; }
  public override string Emit() { Debug.Assert(false); return null; }
}

// A section in a switch statement.
//
// In GEL2, unlike C# and C++, local variables declared in a switch section are visible only
// in that section.  There doesn't seem to be much point in allowing sections to share locals
// since GEL2 (like C#) doesn't allow control to fall through from one section to the next.  This_4 also
// makes compiling to C++ slightly easier since C++ doesn't allow local variables in switch sections
// other than the last to have initializers (see e.g. C++ Primer, 4th ed., 6.6.5 "Variable Definitions
// inside a switch").

class SwitchSection_4 : Node_4 {
  ArrayList /* of Expression_4 */ ^cases_;     // null represents default:
  public readonly Block_4 ^block_;

  ArrayList /* of GValue_4 */ ^values_ = new ArrayList();

  public SwitchSection_4(ArrayList ^cases, StatementList_4 ^statements) {
    cases_ = cases;
    block_ = new Block_4(statements);
  }

  public bool Check(Context_4 ctx, GType_4 switch_type, OwningHashtable all_values, out bool is_default) {
    is_default = false;
    foreach (Expression_4 e in cases_) {
      GValue_4 ^v;
      if (e == null) {
        is_default = true;
        v = new DefaultValue_4();
      } else {
        if (!e.Check(ctx, switch_type) || !e.CheckConstant())
          return false;
        v = (GValue_4) e.Eval(Env_4.static_, switch_type);
      }
      if (all_values.ContainsKey(v)) {
        Error("switch statement cannot contain the same value twice");
        return false;
      }
      all_values.Set(v, null);
      values_.Add(v);
    }
    return block_.Check(ctx);
  }

  public bool Match(GValue_4 v) {
    foreach (GValue_4 val in values_)
      if (val.Equals(v))
        return true;
    return false;
  }

  public void Emit(SourceWriter_4 w) {
    foreach (Expression_4 c in cases_)
      if (c == null)
        w.IWriteLine("default:");
      else w.IWriteLine("case {0}:", c.Emit());
    w.Indent();
    block_.Emit(w);
  }

  public void EmitString(SourceWriter_4 w) {
    w.IWrite("if (");
    for (int i = 0 ; i < values_.Count ; ++i) {
      if (i > 0) {
        w.WriteLine(" ||");
        w.IWrite("    ");
      }
      w.Write("_s->_Equals({0})", 
              GString_4.EmitStringConst(((GString_4) values_[i]).s_));
    }
    w.Write(") ");
    block_.Emit(w);
  }
}

abstract class Escapable_4 : Scoped_4 {
  public readonly Joiner_4 ^exit_ = new Joiner_4();
}

class Switch_4 : Escapable_4 {
  Expression_4 ^expr_;
  GType_4 type_;
  ArrayList /* of SwitchSection_4 */ ^sections_;
  SwitchSection_4 default_;    // or null if no default section

  public Switch_4(Expression_4 ^expr, ArrayList ^sections) { expr_ = expr; sections_ = sections; }

  public override bool Check(Context_4 ctx) {
    SetStartVar(ctx);
    type_ = expr_.CheckTop(ctx);
    if (type_ == null)
      return false;
    if (type_ != GInt_4.type_ && type_ != GChar_4.type_ && type_ != GString_4.type_) {
      Error("switch expression must be of type int, char or string");
      return false;
    }
    Context_4 ^ctx1 = new Context_4(ctx, this);
    OwningHashtable ^values = new OwningHashtable();
    Control_4 c = ctx1.Prev();
    foreach (SwitchSection_4 s in sections_) {
      bool is_default;
      ctx1.SetPrev(c);
      if (!s.Check(ctx1, type_, values, out is_default))
        return false;
      if (is_default)
        default_ = s;
      if (ctx1.Prev() != unreachable_) {
        s.Error("switch case may not fall through to following case");
        return false;
      }
    }
    if (default_ == null)
      exit_.Join(c);
    ctx1.SetPrev(exit_.Combine());
    return true;
  }

  SwitchSection_4 FindSection(GValue_4 v) {
    foreach (SwitchSection_4 s in sections_)
      if (s.Match(v))
        return s;
    return default_;
  }

  RValue_4 ^CatchBreak(RValue_4 ^v) {
    return v is BreakValue_4 ? null : v;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    RValue_4 ^v = expr_.Eval(env);
    if (v == null)
      return null;
    SwitchSection_4 s = FindSection(v.Get());
    if (s == null)
      return null;
    return CatchBreak(s.block_.Eval(env));
  }

  public override void Emit(SourceWriter_4 w) {
    if (type_ == GString_4.type_) {
      // For_4 now, we implement a switch on strings using a sequence of if statements.  We wrap
      // the sequence in a dummy switch statement so that break statements will work properly.
      // If_4 the switch statement has just a default: label then the Microsoft C++ compiler issues
      // a warning, and if it has just a case 0: label then the compiler doesn't realize that the
      // case will always be executed, which may lead to warnings about not all code paths returning
      // a value.  So we use both default: and case 0:, which seems to work fine.
      w.Write("switch (0) ");
      w.OpenBrace();
      w.IWriteLine("case 0:");
      w.IWriteLine("default:");
      w.IWriteLine("StringPtr _s = {0};", expr_.Emit());
      foreach (SwitchSection_4 s in sections_)
        if (s != default_)
          s.EmitString(w);
      if (default_ != null)
        default_.block_.Emit(w);
      w.CloseBrace();
    } else {
      w.Write("switch ({0}) ", expr_.Emit());
      w.OpenBrace();

      foreach (SwitchSection_4 s in sections_)
        s.Emit(w);

      w.CloseBrace();
    }
  }
}

abstract class Loop_4 : Escapable_4 {
  public readonly Joiner_4 ^loop_ = new Joiner_4();
}

abstract class ForOrWhile_4 : Loop_4 {
  protected Expression_4 ^condition_;
  protected Statement_4 ^statement_;

  protected ForOrWhile_4(Expression_4 ^condition, Statement_4 ^statement) {
    condition_ = condition; statement_ = statement;
  }

  protected abstract InlineStatement_4 Initializer();
  protected abstract InlineStatement_4 Iterator();

  public override bool Check(Context_4 prev_ctx) {
    Context_4 ^ctx = new Context_4(prev_ctx, this);   // initializer may declare new local variable
    SetStartVar(ctx);
    if (!Initializer().Check(ctx))
      return false;
    SetTopVar(ctx);

    loop_.AddControl(ctx);

    if (!condition_.CheckTop(ctx, GBool_4.type_))
      return false;

    if (!condition_.IsTrueLiteral())  // we may exit the loop at this point
      exit_.Join(ctx.Prev());  

    if (!statement_.Check(ctx))
      return false;

    if (!Iterator().Check(ctx))
      return false;

    loop_.Join(ctx.Prev());  // loop back to top

    ctx.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy any local defined in an initializer above.
    AddControl(ctx);

    return true;
  }

  public override RValue_4 ^Eval(Env_4 outer_env) {
    Env_4 ^env = new Env_4(outer_env);   // initializer may declare new local
    for (Initializer().Eval(env); condition_.EvalBool(env); Iterator().Eval(env)) {
      RValue_4 ^v = statement_.Eval(env);
      if (v is BreakValue_4)
        break;
      if (v is ContinueValue_4)
        continue;
      if (v != null)
        return v;
    }
    return null;
  }
}

class While_4 : ForOrWhile_4 {
  public While_4(Expression_4 ^condition, Statement_4 ^statement) : base(condition, statement) { }

  protected override InlineStatement_4 Initializer()  { return EmptyStatement_4.instance_; }
  protected override InlineStatement_4 Iterator()  { return EmptyStatement_4.instance_; }

  public override void Emit(SourceWriter_4 w) {
    w.Write("while ({0})", condition_.Emit());
    statement_.EmitEmbedded(w);
  }
}

class For_4 : ForOrWhile_4 {
  InlineStatement_4 ^initializer_;
  InlineStatement_4 ^iterator_;

  public For_4(InlineStatement_4 ^initializer, Expression_4 ^condition, InlineStatement_4 ^iterator,
             Statement_4 ^statement)
    : base(condition != null ? condition : new Literal_4(new GBool_4(true)),
           statement) {
    initializer_ = initializer != null ? initializer : new EmptyStatement_4();
    iterator_ = iterator != null ? iterator : new EmptyStatement_4();
  }

  protected override InlineStatement_4 Initializer()  { return initializer_; }
  protected override InlineStatement_4 Iterator()  { return iterator_; }

  public override void Emit(SourceWriter_4 w) {
    w.Write("for (");
    initializer_.EmitInline(w);
    w.Write("; {0}; ", condition_.Emit());
    iterator_.EmitInline(w);
    w.Write(")");
    statement_.EmitEmbedded(w);
  }
}

class Do_4 : Loop_4 {
  Statement_4 ^statement_;
  Expression_4 ^condition_;

  Joiner_4 ^join_ = new Joiner_4();

  public Do_4(Statement_4 ^statement, Expression_4 ^condition) {
    statement_ = statement;
    condition_ = condition;
  }

  public override bool Check(Context_4 ctx) {
    join_.AddControl(ctx);

    Context_4 ^ctx1 = new Context_4(ctx, this);
    SetStartVar(ctx);

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx.Prev());  // continue statements jump here
    ctx.SetPrev(loop_.Combine());

    if (!condition_.CheckTop(ctx, GBool_4.type_))
      return false;

    if (!condition_.IsFalseLiteral())
      join_.Join(ctx.Prev());   // loop back to top
    if (!condition_.IsTrueLiteral())
      exit_.Join(ctx.Prev());   // fall through to exit
    ctx.SetPrev(exit_.Combine());

    return true;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    do {
      RValue_4 ^v = statement_.Eval(env);
      if (v is BreakValue_4)
        break;
      if (v is ContinueValue_4)
        continue;
      if (v != null)
        return v;
    } while (condition_.EvalBool(env));
    return null;
  }

  public override void Emit(SourceWriter_4 w) {
    w.IWrite("do");
    statement_.EmitEmbedded(w);
    w.IWriteLine("while ({0});", condition_.Emit());
  }
}

// A helper class for ForEach_4: a node defining a single variable in the control graph.
class Definer_4 : Node_4 {
  Local_4 local_;

  public Definer_4(Local_4 local) { local_ = local; }

  public override bool Sets(Local_4 local) {
    return local_ == local;
  }
}

class ForEach_4 : Loop_4 {
  Local_4 ^local_;
  Expression_4 ^expr_;
  GType_4 expr_type_;
  Statement_4 ^statement_;

  Property_4 count_;
  Indexer_4 indexer_;

  Definer_4 ^definer_;

  public ForEach_4(TypeExpr_4 ^type_expr, string name, Expression_4 ^expr, Statement_4 ^statement) {
    local_ = new Local_4(type_expr, name, null);
    expr_ = expr;
    statement_ = statement;
  }

  public override bool Check(Context_4 ctx) {
    if (!local_.Resolve(ctx.program_))
      return false;

    expr_type_ = expr_.CheckTop(ctx);
    if (expr_type_ == null)
      return false;

    count_ = expr_type_.Lookup(this, ctx.class_, false, MemberKind_4.Property_4, "Count", null, false) as Property_4;
    if (count_ == null) {
      Error("object enumerable by foreach must have an accessible property Count");
      return false;
    }
    if (count_.Type() != GInt_4.type_) {
      Error("object enumerable by foreach must have a property Count of type int");
      return false;
    }

    ArrayList ^args = new ArrayList();
    args.Add(new InArgument_4(GInt_4.type_));
    indexer_ = (Indexer_4) expr_type_.Lookup(this, ctx.class_, false, MemberKind_4.Indexer_4, null, args, false);
    if (indexer_ == null) {
      Error("object enumerable by foreach must have an accessible indexer on integers");
      return false;
    }
    if (!indexer_.CheckAssigning(this, ctx, false))
      return false;

    GType_4 indexer_type = indexer_.Type();
    GType_4 iterator_type = local_.Type();
    if (!indexer_type.CanConvertExplicit(iterator_type, false)) {
      Error("enumeration type {0} is not explicitly convertible to iteration variable type {1}",
        indexer_type, iterator_type);
      return false;
    }

    Context_4 ^ctx1 = new Context_4(ctx, this);

    SetStartVar(ctx1);
    if (!local_.Check(ctx1))   // will add local to scope chain
      return false;
    SetTopVar(ctx1);

    // Add a control graph node representing the creation of the local above.
    definer_ = new Definer_4(local_);
    definer_.AddControl(ctx1);

    loop_.AddControl(ctx1);   // continue statements jump here

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx1.Prev());   // loop back to top

    exit_.Join(loop_);  // any loop iteration may exit

    ctx1.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy the local variable created above.
    AddControl(ctx1);

    return true;
  }

  public override RValue_4 ^Eval(Env_4 outer_env) {
    RValue_4 ^r = expr_.Eval(outer_env);
    GValue_4 e = r.Get();
    if (e is Null_4) {
      Error("foreach: can't iterate over null object");
      Gel_4.Exit();
    }

    int count = ((GInt_4) count_.Get(e)).i_;

    Env_4 ^env = new Env_4(outer_env);
    env.Add(local_, null);
    for (int i = 0 ; i < count ; ++i) {
      RValue_4 ^v = indexer_.Get(e, new GInt_4(i));
      env.Set(local_, v.Get().ConvertExplicit(ref v, local_.Type()));
      RValue_4 ^s = statement_.Eval(env);
      if (s is BreakValue_4)
        break;
      if (s is ContinueValue_4)
        continue;
      if (s != null)
        return s;
    }
    return null;
  }

  public override void Emit(SourceWriter_4 w) {
    w.OpenBrace();
    w.IWriteLine("{0} _collection = {1};", expr_type_.BaseType().EmitType(), expr_.Emit());
    w.IWriteLine("int _count = _collection->get_Count();");
    w.IWrite("for (int _i = 0 ; _i < _count ; ++_i) ");
    w.OpenBrace();
    w.Indent();
    local_.EmitDeclaration(w);
    w.WriteLine(" = {0}; ",
      Expression_4.EmitExplicit(indexer_.Type(), local_.Type(), "_collection->get_Item(_i)", true));
    statement_.EmitInExistingBlock(w);
    w.CloseBrace();
    w.CloseBrace();
  }
}

class BreakValue_4 : GValue_4 {
  public BreakValue_4() { }

  public static readonly BreakValue_4 ^instance_ = new BreakValue_4();

  public override GType_4 Type()  { Debug.Assert(false); return null; }
}

abstract class BreakOrContinue_4 : Scoped_4 {
  protected void Link(Context_4 ctx, Scoped_4 target, Joiner_4 joiner) {
    // When traversed in the control graph, we destroy all variables in the scopes we are exiting,
    // excluding variables defined in the containing Escapable_4 or Loop_4.
    start_ = target.GetTop();
    SetTopVar(ctx);

    prev_ = ctx.Prev();
    if (prev_ != unreachable_)
      joiner.Join(this);

    ctx.SetPrev(unreachable_);
  }
}

class Break_4 : BreakOrContinue_4 {
  public override bool Check(Context_4 ctx) {
    Escapable_4 e = ctx.escape_;
    if (e == null) {
      Error("break statement must appear inside a while, do, for, foreach or switch statement");
      return false;
    }
    Link(ctx, e, e.exit_);
    return true;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    return new BreakValue_4();
  }

  public override void Emit(SourceWriter_4 w) {
    w.WriteLine("break;");
  }
}

class ContinueValue_4 : GValue_4 {
  public ContinueValue_4() { }

  public static readonly ContinueValue_4 ^instance_ = new ContinueValue_4();

  public override GType_4 Type()  { Debug.Assert(false); return null; }
}

class Continue_4 : BreakOrContinue_4 {
  public override bool Check(Context_4 ctx) {
    Loop_4 l = ctx.loop_;
    if (l == null) {
      Error("continue statement must appear inside a while, do, for or foreach statement");
      return false;
    }
    Link(ctx, l, l.loop_);
    return true;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    return new ContinueValue_4();
  }

  public override void Emit(SourceWriter_4 w) {
    w.WriteLine("continue;");
  }
}

class Return_4 : Statement_4 {
  Expression_4 ^exp_;    // null if no return value
  GType_4 exp_type_;
  GType_4 type_;

  public Return_4(Expression_4 ^exp) {
    exp_ = exp;
  }

  public override bool Check(Context_4 ctx) {
    if (exp_ == null) {
      if (ctx.method_.ReturnType() != Void_4.type_) {
        Error("error: returning value from function returning void");
        return false;
      }
    } else {
      type_ = ctx.method_.ReturnType();
      ctx.EnterExpression();
      exp_type_ = exp_.CheckAndHold(ctx);
      if (exp_type_ == null ||
          !exp_type_.CheckConvert(this, type_,
            exp_.IsRefOutParameter() ? ConversionContext_4.AssignVar : ConversionContext_4.Other))
        return false;
      exp_.CheckLoseOwnership(exp_type_, type_);
      ctx.FinishExpression();
      exp_.ReleaseRef(ctx);
    }

    ctx.method_.JoinReturn(ctx);
    ctx.SetPrev(unreachable_);
    return true;
  }

  public override RValue_4 ^Eval(Env_4 env) {
    return exp_ != null ? exp_.Eval(env, type_)
                        : Null_4.Instance.Copy();    // an arbitrary value
  }

  public override void Emit(SourceWriter_4 w) {
    if (exp_ != null && exp_.NeedsRef(exp_type_)) {
      // If_4 exp_ needs a reference count, that reference count needs to survive the destruction
      // of temporaries, so we can't simply emit a temporary reference count wrapper.  For_4 example,
      // when compiling the expression "return (new Foo()).Fun();", if Fun() returns a Foo then we
      // need a wrapper, and we can't generate "return _Ptr<Fun>(Foo().Fun()).Get()" since the _Ptr<Fun>
      // wrapper will be destroyed before the temporary Foo() object is destroyed.  So we need to
      // use an extra variable here.
      w.OpenBrace();
      w.IWriteLine("{0} __ret = {1};", exp_type_.EmitType(), exp_.Emit());
      w.IWriteLine("return __ret.Get();");
      w.CloseBrace();
    } else {
      w.Write("return ");
      if (exp_ != null)
        w.Write(exp_.Emit(exp_type_, type_));
      w.WriteLine(";");
    }
  }
}

class Attribute_4 {
  public const int Abstract = 1,
  Const = 2,
  Extern = 4,
  Override = 8,
  Private = 16,
  Protected = 32,
  Public = 64,
  ReadOnly = 128,
  Ref = 256,
  Static = 512,
  Virtual = 1024,
  Setter = 2048;
}

class AttributeUtil_4 {
  public static bool CheckOnly(int a, int allowed) {
    return (a & ~allowed) == 0;
  }
}

class MethodTraverser_4 : Traverser_4 {
  Method_4 method_;

  public MethodTraverser_4(Method_4 method) { method_ = method; }

  public override int Handle(Control_4 control) {
    if (control == Control_4.unreachable_)
      return Cut;

    Node_4 node = control as Node_4;
    if (node != null) {
      Method_4 c = node.Calls();
      if (c != null)
        method_.calls_.Add(c);
      method_.internal_destroys_.Add(node.NodeDestroys());
    }

    return Continue_4;
  }
}

class Method_4 : Member_4 {
  public readonly ArrayList /* of Parameter_4 */ ^parameters_;

  protected Block_4 ^body_;

  public Joiner_4 ^exit_ = new Joiner_4();

  // all parameters and locals defined in this method
  readonly NonOwningArrayList /* of Local_4 */ ^locals_ = new NonOwningArrayList();

  NonOwningArrayList /* of Method_4 */ ^overrides_;   // list of all overrides (virtual methods only)

  // methods called from this method
  public readonly NonOwningArrayList /* of Method_4 */ ^calls_ = new NonOwningArrayList();

  // Types destroyed inside this method, not including types destroyed through
  // calls to other methods.
  public readonly TypeSet_4 ^internal_destroys_ = new TypeSet_4();

  // Types destroyed inside this method or in any methods called by this method.
  TypeSet_4 ^destroys_;

  TypeSet_4 ^parameter_destroys_;

  // A marker used when performing a depth-first search of the method graph to compute destroys_.
  int method_marker_;

  public Method_4(int attributes, TypeExpr_4 ^return_type_expr,
                string name, ArrayList /* of Parameter_4 */ ^parameters, Block_4 ^body)
    : base(attributes, return_type_expr, name) {
    parameters_ = parameters;
    body_ = body;
  }

  public override int Kind() { return MemberKind_4.Method_4; }

  public GType_4 ReturnType() { return type_; }

  public override ArrayList Parameters() {
    return parameters_;
  }

  public bool IsExtern() { return class_.IsExtern(); }

  public bool IsStatic() {
    return HasAttribute(Attribute_4.Static);
  }

  public override bool Resolve(Program_4 program) {
    if (!base.Resolve(program))
      return false;
    foreach (Parameter_4 p in parameters_)
      if (!p.Resolve(program))
        return false;
    return true;
  }

  public void AddVar(Local_4 v) {
    locals_.Add(v);
  }

  public override bool Sets(Local_4 local) {
    foreach (Parameter_4 p in parameters_)
      if (p == local && p.GetMode() != Mode_4.Out)
        return true;
    return false;
  }

  public void JoinReturn(Context_4 ctx) {
    exit_.Join(ctx.Prev());
  }

  public const int kValidAttributes =
    Attribute_4.Abstract | Attribute_4.Override |
    Attribute_4.Private | Attribute_4.Protected | Attribute_4.Public |
    Attribute_4.Static | Attribute_4.Virtual | Attribute_4.Setter;

  protected override int ValidAttributes() {
    return kValidAttributes;
  }

  // overridden by Constructor_4 subclass
  protected virtual bool CheckEntry(Context_4 ctx) { return true; }

  // overridden by Constructor_4 subclass
  public override bool Check(Context_4 prev_ctx) {
    if (!base.Check(prev_ctx))
      return false;

    bool abstract_or_extern = HasAttribute(Attribute_4.Abstract) || IsExtern();

    if (body_.Absent()) {
      if (!abstract_or_extern) {
        Error("a method without a body must be abstract or extern");
        return false;
      }
      return true;
    } 

    if (abstract_or_extern) {
      Error("an abstract or extern method cannot have a body");
      return false;
    }

    Context_4 ^ctx = new Context_4(prev_ctx, this);

    prev_ = unreachable_;
    ctx.SetPrev(this);    // begin the control graph with this Method_4

    foreach (Parameter_4 p in parameters_)
      if (!p.Check(ctx))
        return false;

    if (!CheckEntry(ctx))
      return false;

    if (!body_.Check(ctx))
      return false;

    if (!(this is Constructor_4) && type_ != Void_4.type_ && ctx.Prev() != unreachable_) {
      Error("method must return a value");
      return false;
    }
    JoinReturn(ctx);

    ctx.ClearPrev();  // control graph is complete

    // Traverse the control graph to build calls_ and internal_destroys_.
    MethodTraverser_4 ^mt = new MethodTraverser_4(this);
    exit_.Traverse(mt, Control_4.GetMarkerValue());

    bool ok = true;
    foreach (Local_4 v in locals_)    // for all locals and parameters
      ok &= v.CheckUsage(this);

    foreach (Parameter_4 p in parameters_)
      p.CheckParameterUsage(this);

    return ok;
  }

  // Determine whether each local variable needs a reference count.
  protected void ComputeRefs() {
    foreach (Local_4 v in locals_)
      v.ComputeRef(this);
  }

  // Return_4 true if this method has a local or parameter with the given name.
  public bool HasLocal(string name) {
    foreach (Local_4 l in locals_)
      if (l.name_ == name)
        return true;
    return false;
  }

  public override TypeSet_4 NodeDestroys() {
    if (parameter_destroys_ == null) {
      parameter_destroys_ = new TypeSet_4();
    foreach (Parameter_4 p in parameters_)
        parameter_destroys_.Add(p.Type().VarDestroys());
    }
    return parameter_destroys_;
  }

  protected override void AddOverride(Member_4 m) {
    if (overrides_ == null)
      overrides_ = new NonOwningArrayList();
    overrides_.Add((Method_4) m);
  }

  bool Visit(int marker, TypeSet_4 set) {
    if (method_marker_ == marker)
      return true;

    method_marker_ = marker;
    set.Add(internal_destroys_);
    if (set.IsObject())
      return false;   // we already have object; no point in traversing further

    foreach (Method_4 m in calls_)
      if (!m.Visit(marker, set))
        return false;

    if (overrides_ != null)
      foreach (Method_4 m in overrides_)
        if (!m.Visit(marker, set))
          return false;

    return true;
  }

  public TypeSet_4 Destroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_4();
      Visit(Control_4.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  // overridden by Constructor_4 subclass
  public virtual RValue_4 ^Eval(Env_4 env) {
    return body_.Eval(env);
  }

  public RValue_4 ^Invoke(GValue_4 obj, ArrayList /* of ValueOrLocation_4 */ values) {
    if (body_.Absent()) { // an external method
      ValueList_4 ^list = new ValueList_4(values);
      if (IsStatic())
        return class_.InvokeStatic(this, list);   // let the class handle it
      return obj.Invoke(this, list);   // let the object handle it
    }

    Env_4 ^env = new Env_4(obj);
    Debug.Assert(values.Count == parameters_.Count);
    for (int i = 0 ; i < values.Count ; ++i)
      env.Add((Parameter_4) parameters_[i], (ValueOrLocation_4) values.Take(i));

    return Eval(env);
  }

  protected void EmitParameterNames(SourceWriter_4 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      w.Write(Param(i).EmitDeclarationName());
    }
    w.Write(")");
  }

  protected void EmitParameters(SourceWriter_4 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      Param(i).EmitDeclaration(w);
    }
    w.Write(") ");
  }

  void EmitAttributes(SourceWriter_4 w, bool declaration) {
    w.Indent();
    if (!IsStatic() && !IsVirtual())
      return;

    if (!declaration)
      w.Write("/* ");
    if (IsStatic())
      w.Write("static ");
    if (IsVirtual())
      w.Write("virtual ");
    if (!declaration)
      w.Write("*/ ");
  }

  void EmitSignature(SourceWriter_4 w, bool declaration) {
    EmitAttributes(w, declaration);
    w.Write("{0} ", type_.EmitReturnType());
    if (!declaration)
      w.Write("{0}::", class_.name_);
    if (HasAttribute(Attribute_4.Setter))
      w.Write("_");
    w.Write(name_);
    EmitParameters(w);
  }

  public virtual void EmitDeclaration(SourceWriter_4 w) {
    ComputeRefs();
    EmitSignature(w, true);
    if (body_.Absent())
      w.Write("= 0");
    w.WriteLine(";");

    if (HasAttribute(Attribute_4.Setter)) {
      w.WriteLine("");
      EmitAttributes(w, true);
      w.Write("{0} ", Param(parameters_.Count - 1).Type().EmitType());
      w.Write(name_);
      EmitParameters(w);
      w.OpenBrace();
      w.IWrite("_{0}", name_);
      EmitParameterNames(w);
      w.WriteLine(";");
      w.IWriteLine("return value;");
      w.CloseBrace();
    }
  }

  protected void EmitExtraDeclarations(SourceWriter_4 w) {
    foreach (Parameter_4 p in parameters_)
      p.EmitExtraDeclaration(w);
  }

  public virtual void Emit(SourceWriter_4 w) {
    if (!body_.Absent()) {
      EmitSignature(w, false);
      w.OpenBrace();
      EmitExtraDeclarations(w);
      body_.list_.Emit(w);
      w.CloseBrace();
      w.WriteLine("");
    }
    if (Gel_4.print_type_sets_)
      Console.WriteLine("{0}.{1}: {2}", class_.name_, name_, Destroys());
  }
}

class Constructor_4 : Method_4 {
  bool call_base_;
  ArrayList /* of Argument_4 */ ^initializer_params_;

  Constructor_4 initializer_;

  bool invoked_;  // true if another constructor invokes this one using : base() or : this()

  public Constructor_4(int attributes, string name, ArrayList ^parameters,
                     bool call_base, ArrayList ^initializer_params, Block_4 ^body)
    : base(attributes, null, name, parameters, body) {
    call_base_ = call_base;
    initializer_params_ = initializer_params;
  }

  public Constructor_4(int attributes, string name, ArrayList ^parameters, Block_4 ^body)
    : this(attributes, name, parameters, true, new ArrayList(), body) { }

  public override int Kind() { return MemberKind_4.Constructor_4; }

  protected override int ValidAttributes() {
    return Attribute_4.Private | Attribute_4.Protected | Attribute_4.Public;
  }

  public override bool Check(Context_4 ctx) {
    if (name_ != class_.name_) {
      Error("constructor name must match class name");
      return false;
    }
    return base.Check(ctx);
  }

  protected override bool CheckEntry(Context_4 ctx) {
    Class_4 c = call_base_ ? class_.Parent() : class_;
    if (c != null || initializer_params_.Count > 0) {
      initializer_ = (Constructor_4) Invocation_4.CheckInvoke(this, ctx, call_base_, c,
                                      c.name_, initializer_params_, MemberKind_4.Constructor_4);
      if (initializer_ == null)
        return false;
      if (initializer_ == this) {
        Error("constructor initializer invokes itself");
        return false;
      }
      initializer_.invoked_ = true;
    }
    return true;
  }

  // A Constructor_4 node in the control graph represents the call to the base constructor;
  // this node gets added when we call Invocation_4.CheckInvoke() above.
  public override Method_4 Calls() { return initializer_; }

  public override RValue_4 ^Eval(Env_4 env) {
    if (initializer_ == null || initializer_.class_ != class_) {
      // run instance variable initializers
      foreach (Field_4 f in class_.fields_)
        if (!f.IsConstOrStatic() && f.Initializer() != null)
          ((GObject_4) env.this_).Set(f, f.Initializer().Eval(Env_4.static_, f.Type()));
    }
    if (initializer_ != null)
      Invocation_4.CallMethod(env, env.this_, initializer_, initializer_params_, false);
    return body_.Eval(env);
  }

  void EmitInitializerArgs(SourceWriter_4 w) {
    w.WriteLine("({0});", Invocation_4.EmitArguments(initializer_, initializer_params_));
  }

  void EmitConstructorBody(SourceWriter_4 w) {
    w.OpenBrace();
    EmitExtraDeclarations(w);
    if (call_base_) {
      if (class_.constructors_.Count > 1)
        w.IWriteLine("_Init();");
      else class_.EmitInitializers(w);

      Class_4 parent = class_.Parent();
      if (parent != GObject_4.type_) {
        w.IWrite("{0}::_Construct", parent.name_);
        EmitInitializerArgs(w);
      }
    } else {
      w.IWrite("_Construct");
      EmitInitializerArgs(w);
    }

    body_.list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitDeclaration(SourceWriter_4 w) {
    ComputeRefs();

    // If_4 we're invoked by some other constructor then we need to declare a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void _Construct");
      EmitParameters(w);
      w.WriteLine(";");
    }

    // Now declare the actual C++ constructor.
    w.IWrite(name_);
    EmitParameters(w);
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_4 w) {
    // If_4 we're invoked by some other constructor then we need to emit a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void {0}::_Construct", name_);
      EmitParameters(w);
      EmitConstructorBody(w);
      w.WriteLine("");
    }

    // Now emit the actual C++ constructor.
    w.IWrite("{0}::{1}", name_, name_);
    EmitParameters(w);
    Class_4 parent = class_.Parent();
    if (parent != GObject_4.type_)
      w.Write(": {0}((Dummy *) 0) ", parent.name_);

    if (invoked_) {   // call the _Construct method we just generated
      w.Write("{ _Construct");
      EmitParameterNames(w);
      w.WriteLine("; }");
    } else EmitConstructorBody(w);
    w.WriteLine("");
  }
}

abstract class PropertyOrIndexer_4 : LMember_4 {
  // If_4 a get accessor is not declared at all, then get_block_ will be null; if it is
  // declared, but has an empty body ("get;") then get_block_ will be a Block_4 whose list_ is
  // null.  We need to distinguish these cases since for abstract or extern properties the
  // presence of a get accessor with an empty body indicates that a property is readable.
  // (set_block_ works similarly.)
  Block_4 ^get_block_, set_block_;

  protected Method_4 getter_, setter_;

  protected PropertyOrIndexer_4(int attributes, TypeExpr_4 ^type_expr, string name,
                              string id1, Block_4 ^block1, string id2, Block_4 ^block2)
    : base(attributes, type_expr, name) {
    StoreAccessor(id1, block1);
    if (id2 != null)
      StoreAccessor(id2, block2);
    if (id1 == id2)
      Error("can't have two {0} accessors", id1);
  }

  void StoreAccessor(string id, Block_4 ^block) {
    // Note that we don't have scanner tokens GET and SET since these are not keywords in GEL2.
    switch (id) {
      case "get": get_block_ = block; return;
      case "set": set_block_ = block; return;
    }
    Error("expected get or set");
  }

  public Method_4 Getter() { return getter_; }
  public Method_4 Setter() { return setter_; }

  protected abstract string BaseName();

  ArrayList ^CopyParameters() {
    ArrayList ^a = new ArrayList();
    foreach (Parameter_4 p in Parameters())
      a.Add(p.Copy());
    return a;
  }

  public override bool Check(Context_4 ctx) {
    if (!base.Check(ctx))
      return false;

    if (get_block_ != null) {
      Method_4 ^m = new Method_4(attributes_, new TypeLiteral_4(type_), "get_" + BaseName(), CopyParameters(), take get_block_);
      getter_ = m;
      class_.Add(m);
      if (!getter_.Resolve(ctx.program_) || !getter_.Check(ctx))
        return false;
    }

    if (set_block_ != null) {
      ArrayList ^set_params = CopyParameters();
      set_params.Add(new Parameter_4(new TypeLiteral_4(type_), "value"));
      Method_4 ^m = new Method_4(attributes_ | Attribute_4.Setter,
                           new TypeLiteral_4(Void_4.type_), "set_" + BaseName(), set_params, take set_block_);
      setter_ = m;
      class_.Add(m);
      if (!setter_.Resolve(ctx.program_) || !setter_.Check(ctx))
        return false;
    }

    return true;
  }

  public override bool CheckAssigning(Syntax_4 caller, Context_4 ctx, bool assigning) {
    if (assigning && set_block_ == null && setter_ == null) {
      caller.Error("can't assign to read-only {0}", KindString());
      return false;
    }
    if (!assigning && get_block_ == null && getter_ == null) {
      caller.Error("can't read from write-only {0}", KindString());
      return false;
    }
    return true;
  }

  public override Location_4 GetLocation(GObject_4 obj) { Debug.Assert(false); return null; }
}

class Property_4 : PropertyOrIndexer_4 {
  public Property_4(int attributes, TypeExpr_4 ^type_expr, string name,
                  string id1, Block_4 ^block1, string id2, Block_4 ^block2)
    : base(attributes, type_expr, name, id1, block1, id2, block2) { }

  public override int Kind() { return MemberKind_4.Property_4; }

  protected override int ValidAttributes() {
    return Method_4.kValidAttributes;
  }

  protected override string BaseName() { return name_; }

  public override RValue_4 ^Get(GValue_4 obj) {
    return Invocation_4.InvokeMethod(obj, getter_, new ArrayList(), true);
  }

  public override void Set(GObject_4 obj, RValue_4 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(val);
    Invocation_4.InvokeMethod(obj, setter_, a, true);
  }

  public override string Emit() {
    return String.Format("get_{0}()", name_);
  }

  public override string EmitSet(string val) {
    return String.Format("set_{0}({1})", name_, val);
  }
}

class Indexer_4 : PropertyOrIndexer_4 {
  public readonly Parameter_4 parameter_;

  ArrayList /* of Parameter_4 */ ^parameters_;

  public Indexer_4(int attributes, TypeExpr_4 ^type_expr, Parameter_4 ^parameter,
                 string id1, Block_4 ^block1, string id2, Block_4 ^block2)
    : base(attributes, type_expr, null, id1, block1, id2, block2) {
    parameter_ = parameter;

    parameters_ = new ArrayList();
    parameters_.Add(parameter);
  }

  public override int Kind() { return MemberKind_4.Indexer_4; }

  public override bool Resolve(Program_4 program) {
    return base.Resolve(program) && parameter_.Resolve(program);
  }

  protected override int ValidAttributes() {
    return Attribute_4.Abstract | Attribute_4.Override |
    Attribute_4.Private | Attribute_4.Protected | Attribute_4.Public | Attribute_4.Virtual;
  }

  protected override string BaseName() { return "Item"; }

  public override bool Check(Context_4 ctx) {
    if (parameter_ is RefOutParameter_4) {
      Error("indexer parameter may not be ref or out");
      return false;
    }

    return base.Check(ctx);
  }

  public override ArrayList /* of Parameter_4 */ Parameters() {
    return parameters_; 
  }

  public RValue_4 ^Get(GValue_4 obj, RValue_4 ^index) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    return Invocation_4.InvokeMethod(obj, getter_, a, true);
  }

  public void Set(GObject_4 obj, RValue_4 ^index, RValue_4 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    a.Add(val);
    Invocation_4.InvokeMethod(obj, setter_, a, true);
  }
}

class Class_4 : Ownable_4 {
  Syntax_4 ^syntax_ = new Syntax_4();
  Program_4 program_;   // containing program
  int attributes_;
  public readonly string name_;
  string parent_name_;    // or null if not specified

  Class_4 parent_;

  public readonly NonOwningArrayList /* of Field_4 */ ^fields_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Method_4 */ ^methods_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Property_4 */ ^properties_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Indexer_4 */ ^indexers_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Constructor_4 */ ^constructors_ = new NonOwningArrayList();

  public readonly ArrayList /* of Member_4 */ ^members_ = new ArrayList();

  public readonly ArrayList /* of Temporaries_4 */ ^temporaries_ = new ArrayList();

  public readonly NonOwningArrayList /* of Class_4 */ ^subclasses_ = new NonOwningArrayList();
  bool emitted_;

  // If_4 virtual_ is true, then this class needs a vtable; we set this for a class C
  // in any of the following cases:
  // - the program converts some type T to C ^ (for then a C ^ may hold a T, and when
  // the owning pointer is destroyed we need to know which destructor to call)
  // - the program explicitly converts from C to some other type (so we need RTTI for C)
  bool virtual_;
  
  // If_4 object_inherit_ is true, then this class must derive from Object in generated C++
  // code; we set this for a class C in any of the following cases:
  // - a member lookup in C yields a member in Object
  // - the program converts from C to Object or from Object to C
  // - the class is used in a generic context, i.e. in the type C [] or C ^ [].  All such types
  //   use the generic compiled classes Array<Object> / Array<_Own<Object>>, and so in this case we need
  //   to be able to cast between C and Object.
  //
  // If_4 object_inherit_ is true then this class and all its superclasses will have vtables since
  // the C++ Object class has a vtable.
  bool object_inherit_;

  bool need_destroy_;  // true if we need to emit _Destroy methods for this class

  // The set of types which may be destroyed when an instance of this class is destroyed.
  TypeSet_4 ^destroys_;

  // A marker used in performing a depth-first search to construct the destroys_ type set.
  int marker_;

  protected Class_4(string name) { name_ = name; }

  public static Class_4 New_4(int attributes, string name, string parent_name) {
    Class_4 c = Internal_4.Find(name);
    if (c == null) {
      Class_4 ^c1 = new Class_4(name);
      c = c1;
      Gel_4.program_.AddOwn(c1);
    }

    c.attributes_ = attributes;
    c.parent_name_ = parent_name;

    return c;
  }

  public override bool IsOwned() { return true; }

  public Program_4 GetProgram() { return program_; }
  public void SetProgram(Program_4 p) { program_ = p; }

  public bool IsExtern() { return HasAttribute(Attribute_4.Extern); }

  public override Class_4 Parent() { return parent_; }

  public override string ToString() { return name_; }

  public override ArrayList Members() { return members_; }

  public override SimpleValue_4 DefaultValue_4() { return Null_4.Instance; }

  public override void SetVirtual() { virtual_ = true; }
  public override void SetObjectInherit() { object_inherit_ = true;  }
  public void NeedDestroy() { need_destroy_ = true; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public virtual GValue_4 ^New_4() { return new GObject_4(this); }
  public virtual RValue_4 ^InvokeStatic(Method_4 m, ValueList_4 args) { Debug.Assert(false); return null; }

  public void Add(Field_4 ^f) { f.SetClass(this); fields_.Add(f); members_.Add(f);  }

  public virtual void Add(Method_4 ^m) { m.SetClass(this); methods_.Add(m); members_.Add(m);  }

  public void Add(Property_4 ^p) { p.SetClass(this); properties_.Add(p); members_.Add(p);  }

  public void Add(Indexer_4 ^i) { i.SetClass(this); indexers_.Add(i); members_.Add(i); }

  public void AddConstructor(Constructor_4 ^c) { c.SetClass(this); constructors_.Add(c); members_.Add(c);  }

  public NonOwningArrayList /* of Member_4 */ ^FindAbstractMembers() {
    NonOwningArrayList /* of Member_4 */ ^a;
    if (parent_ != null)  {
      a = parent_.FindAbstractMembers();

      // remove members overridden in this class
      int i = 0;
      while (i < a.Count) {
        Member_4 m = (Member_4) a[i];
        Member_4 n = GetMatchingMember(m);
        if (n != null) {
          Debug.Assert(n.HasAttribute(Attribute_4.Abstract | Attribute_4.Override));
          a.RemoveAt(i);
        } else ++i;
      }
    } else a = new NonOwningArrayList();

    // add abstract members from this class
    foreach (Member_4 m in members_) {
      if (m.HasAttribute(Attribute_4.Abstract))
        a.Add(m);
    }

    return a;
  }

  public bool ResolveAll(Program_4 program) {
    if (parent_name_ != null) {
      parent_ = program.FindClass(parent_name_);
      if (parent_ == null) {
        syntax_.Error("can't find parent class {0}", parent_name_);
        return false;
      }
    } else if (this == GObject_4.type_)
      parent_ = null;
    else parent_ = GObject_4.type_;
    if (parent_ != null)
      parent_.subclasses_.Add(this);

    foreach (Member_4 m in members_)
      if (!m.Resolve(program))
        return false;

    if (!IsExtern() && constructors_.Count == 0)
      // add a default constructor
      AddConstructor(new Constructor_4(Attribute_4.Public, name_, new ArrayList(), Block_4.EmptyBlock()));

    return true;
  }

  // In our first checking pass we check all constant fields since we may need to evaluate them
  // in the course of checking other code.
  public bool Check1(Context_4 prev_ctx) {
    if (!AttributeUtil_4.CheckOnly(attributes_,
         Attribute_4.Abstract | Attribute_4.Extern | Attribute_4.Public)) {
      syntax_.Error("illegal class attribute");
      return false;
    }

    if (prev_ctx.program_.FindClass(name_) != this) {
      syntax_.Error("can't have two classes named {0}", name_);
      return false;
    }

    Context_4 ^ctx = new Context_4(prev_ctx, this);
    bool ok = true;
    foreach (Field_4 f in fields_) {
      ConstField_4 cf = f as ConstField_4;
      if (cf != null)
        ok &= cf.Check(ctx);
    }
    return ok;
  }

  public bool Check(Context_4 prev_ctx) {
    Context_4 ^ctx = new Context_4(prev_ctx, this);

    bool ok = true;

    foreach (Member_4 m in members_)
      if (m is Field_4 && !(m is ConstField_4) || m is Method_4)
        ok &= m.Check(ctx);

    // We need to check properties and indexers separately since they add methods to the members_
    // array as they are checked.
    foreach (Property_4 p in properties_)
      ok &= p.Check(ctx);
    foreach (Indexer_4 i in indexers_)
      ok &= i.Check(ctx);

    if (!HasAttribute(Attribute_4.Abstract)) {
      NonOwningArrayList ^a = FindAbstractMembers();
      if (a.Count > 0) {
        foreach (Member_4 m in a)
          syntax_.Error("class does not define inherited abstract {0} {1}", m.KindString(), m.name_);
        ok = false;
      }
    }

    return ok;
  }

  public void GetMainMethod(NonOwningArrayList /* of Method_4 */ result) {
    foreach (Method_4 m in methods_)
      if (m.name_ == "Main" && m.IsPublic() && m.IsStatic() && m.ReturnType() == Void_4.type_) {
        int c = m.parameters_.Count;
        if (c > 1)
          continue;
        if (c == 1) {
          Parameter_4 p = m.Param(0);
          if (p.GetMode() != 0 || !p.Type().Equals(new ArrayType_4(GString_4.type_)) )
            continue;
        }
        result.Add(m);
      }
  }

  public override void FindTypeDestroys(int marker, TypeSet_4 set) {
    if (marker_ == marker)
      return;
    marker_ = marker;
    set.Add(this);
    for (Class_4 c = this; c != null; c = c.parent_) {
      if (c != this && c.marker_ == marker)
        break;
      foreach (Field_4 f in c.fields_)
        if (!f.IsConstOrStatic())
          f.Type().FindVarDestroys(marker, set);
    }
    foreach (Class_4 c in subclasses_)
      c.FindTypeDestroys(marker, set);
  }

  public override TypeSet_4 TypeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_4();
      FindTypeDestroys(Control_4.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  public Temporaries_4 NewTemporaries() {
    Temporaries_4 ^t = new Temporaries_4();
    Temporaries_4 ret = t;
    temporaries_.Add(t);
    return ret;
  }

  public void StaticInit() {
    foreach (Field_4 f in fields_) {
      StaticField_4 sf = f as StaticField_4;
      if (sf != null)
        sf.Init();
    }
  }

  public override string EmitTypeName() { return name_; }

  int EmitAccess(SourceWriter_4 w, int old_access, int new_access) {
    new_access = (new_access & Attribute_4.Public) != 0 ? Attribute_4.Public : Attribute_4.Protected;

    if (new_access != old_access) {
      switch (new_access) {
        case Attribute_4.Protected:
          w.Indent(-1);
          w.WriteLine("protected:");
          break;
        case Attribute_4.Public:
          w.Indent(-1);
          w.WriteLine("public:");
          break;
        default:
          Debug.Assert(false);
          break;
      }
    }

    return new_access;
  }

  public void EmitInitializers(SourceWriter_4 w) {
    foreach (Field_4 f in fields_)
      if (!f.IsConstOrStatic())
        f.EmitInitializer(w);
  }

  // Return_4 true if this top-level class must inherit from Object.
  bool ObjectInherit() {
    if (object_inherit_)
      return true;
    foreach (Class_4 c in subclasses_)
      if (c.ObjectInherit())
        return true;
    return false;
  }

  public void EmitDeclaration(SourceWriter_4 w) {
    if (emitted_ || IsExtern())
      return;

    // C++ requires a parent class to appear before its subclasses in a source file.
    parent_.EmitDeclaration(w);

    emitted_ = true;

    w.Write("class {0} ", name_);
    if (parent_ != null)
      w.Write(": public {0} ",
              parent_ == GObject_4.type_ && !ObjectInherit() ? "_Object" : parent_.name_);
    w.OpenBrace();

    int access = 0;

    if (fields_.Count > 0) {
      foreach (Field_4 f in fields_) {
        access = EmitAccess(w, access, f.attributes_);
        f.EmitDeclaration(w);
      }
      w.WriteLine("");
    }

    if (subclasses_.Count > 0) {
      access = EmitAccess(w, access, Attribute_4.Protected);
      w.IWrite("{0}(Dummy *dummy) ", name_);
      if (parent_ != GObject_4.type_)
        w.Write(": {0}(dummy) ", parent_.name_);
      w.WriteLine("{ }");
      w.WriteLine("");
    }

    // If_4 we have more than one constructor, emit an _Init() method which constructors can
    // call to initialize instance variables.
    if (constructors_.Count > 1) {
      access = EmitAccess(w, access, Attribute_4.Protected);
      w.IWriteLine("void _Init();");
      w.WriteLine("");
    }

    foreach (Constructor_4 c in constructors_) {
      access = EmitAccess(w, access, c.attributes_);
      c.EmitDeclaration(w);
    }

    if (virtual_) {
      access = EmitAccess(w, access, Attribute_4.Public);
      w.IWrite("virtual ~{0}()", name_);
      w.WriteLine(" { }");
      w.WriteLine("");
    }

    if (need_destroy_) {
      access = EmitAccess(w, access, Attribute_4.Public);
      w.IWriteLine("GEL_OBJECT({0})", name_);
      w.WriteLine("");
    }

    foreach (Method_4 m in methods_) {
      access = EmitAccess(w, access, m.attributes_);
      m.EmitDeclaration(w);
    }

    w.SubIndent();
    w.WriteLine("};");
    w.WriteLine("");
  }

  public void Emit(SourceWriter_4 w) {
    if (IsExtern())
      return;

    if (fields_.Count > 0) {
      foreach (Field_4 f in fields_)
        f.Emit(w);
      w.WriteLine("");
    }

    if (constructors_.Count > 1) {
      w.IWrite("void {0}::_Init() ", name_);
      w.OpenBrace();
      EmitInitializers(w);
      w.CloseBrace();
      w.WriteLine("");
    }

    foreach (Constructor_4 c in constructors_)
      c.Emit(w);

    foreach (Method_4 m in methods_)
      m.Emit(w);

    if (Gel_4.print_type_sets_)
      Console.WriteLine("~{0}: {1}", name_, TypeDestroys());
  }
}

class ClassPtr_4 {
  public readonly Class_4 class_;

  public ClassPtr_4(Class_4 c) { class_ = c; }
}

class ValueList_4 {
  public ArrayList list_;
  public ValueList_4(ArrayList list) { list_ = list; }

  public GValue_4 Object(int i) { return ((RValue_4) list_[i]).Get(); }
  public bool Bool(int i) { return ((GBool_4) list_[i]).b_; }
  public int Int(int i) { return ((GInt_4) list_[i]).i_; }
  public char Char(int i) { return ((GChar_4) list_[i]).c_; }
  public string GetString(int i) { return ((GString_4) list_[i]).s_; }
}

class Internal_4 : Class_4 {
  static NonOwningArrayList /* of Internal_4 */ ^all_ = new NonOwningArrayList();

  protected Internal_4(string name) : base(name) { }

  public static Internal_4 Find(string name) {
    foreach (Internal_4 p in all_)
      if (p.name_ == name)
        return p;
    return null;
  }

  static void Add(Internal_4 p) { all_.Add(p); }

  public static void Init() {
    Add(GObject_4.type_);
    Add(GArray_4.array_class_);
    Add(GBool_4.type_);
    Add(GChar_4.type_);
    Add(GDouble_4.type_);
    Add(GFloat_4.type_);
    Add(GInt_4.type_);
    Add(GString_4.type_);
    Add(GStringBuilder_4.type_);
    Add(PoolClass_4.instance_);
    Add(DebugClass_4.instance_);
    Add(EnvironmentClass_4.instance_);

    Add(ConsoleClass_4.instance_);
    Add(FileClass_4.instance_);
    Add(PathClass_4.instance_);
    Add(GStreamReader_4.type_);
  }
}

class ObjectClass_4 : Internal_4 {
  public Method_4 equals_;
  public Method_4 get_hash_code_;
  public Method_4 to_string_;

  public ObjectClass_4() : base("Object") { }

  public override void Add(Method_4 ^m) {
    switch (m.name_) {
      case "Equals": equals_ = m; break;
      case "GetHashCode": get_hash_code_ = m; break;
      case "ToString": to_string_ = m; break;
    }
    base.Add(m);
  }
}

class ArrayClass_4 : Internal_4 {
  public ArrayClass_4() : base("Array") { }
}

abstract class SimpleType_4 : Internal_4 {
  protected SimpleType_4(string name) : base(name) { }

  public override bool IsOwned() { return false; }
  public override bool IsReference() { return false; }
  public override bool IsValue() { return true; }

  public override string EmitExprType() { return EmitType(); }
  public override string EmitType() { Debug.Assert(false); return null; }
}

abstract class IntegralType_4 : SimpleType_4 {
  protected IntegralType_4(string name) : base(name) { }
}

class BoolClass_4 : IntegralType_4 {
  public BoolClass_4() : base("Bool") { }

  static GBool_4 ^default_ = new GBool_4(false);
  public override SimpleValue_4 DefaultValue_4() { return default_; }

  public override string ToString() { return "bool"; }

  public override string EmitType() { return "bool"; }
}

class CharClass_4 : IntegralType_4 {
  public CharClass_4() : base("Char") { }

  static GChar_4 ^default_ = new GChar_4('\0');

  public override SimpleValue_4 DefaultValue_4() { return default_; }

  public override bool CanConvert1(GType_4 t) { return t == GInt_4.type_; }

  public override string ToString() { return "char"; }

  public override RValue_4 ^InvokeStatic(Method_4 m, ValueList_4 args) {
    switch (m.name_) {
      case "IsDigit": return new GBool_4(Char.IsDigit(args.Char(0)));
      case "IsLetter": return new GBool_4(Char.IsLetter(args.Char(0)));
      case "IsWhiteSpace": return new GBool_4(Char.IsWhiteSpace(args.Char(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "wchar_t"; }
}

class IntClass_4 : IntegralType_4 {
  public IntClass_4() : base("Int") { }

  static GInt_4 ^default_ = new GInt_4(0);

  public override SimpleValue_4 DefaultValue_4() { return default_; }

  public override bool CanConvert1(GType_4 t) {
    return t == GFloat_4.type_ || t == GDouble_4.type_;
  }

  protected override bool CanConvertExplicit1(GType_4 t) {
    return t == GChar_4.type_;
  }

  public override string ToString() { return "int"; }

  public override RValue_4 ^InvokeStatic(Method_4 m, ValueList_4 args) {
    switch (m.name_) {
      case "Parse": return new GInt_4(int.Parse(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "int"; }
}

class FloatClass_4 : SimpleType_4 {
  public FloatClass_4() : base("Single") { }

  static GFloat_4 ^default_ = new GFloat_4(0.0f);

  public override SimpleValue_4 DefaultValue_4() { return default_; }

  public override bool CanConvert1(GType_4 t) {
    return t == GDouble_4.type_;
  }

  protected override bool CanConvertExplicit1(GType_4 t) {
    return t == GInt_4.type_;
  }

  public override string ToString() { return "float"; }

  public override string EmitType() { return "float"; }
}

class DoubleClass_4 : SimpleType_4 {
  public DoubleClass_4() : base("Double") { }

  static GDouble_4 ^default_ = new GDouble_4(0.0d);

  public override SimpleValue_4 DefaultValue_4() { return default_; }

  protected override bool CanConvertExplicit1(GType_4 t) {
    return t == GInt_4.type_ || t == GFloat_4.type_;
  }

  public override string ToString() { return "double"; }

  public override string EmitType() { return "double"; }
}

class StringClass_4 : Internal_4 {
  public StringClass_4() : base("String") { }

  public override bool IsOwned() { return false; }
  public override bool IsValue() { return true; }

  public override string ToString() { return "string"; }

  public override string EmitType() {
    return "_Ref<String>";
  }

  public override string EmitReturnType() {
    return EmitType();
  }

  public override string EmitGenericType() {
    return EmitType();
  }

  public override RValue_4 ^InvokeStatic(Method_4 m, ValueList_4 args) {
    switch (m.name_) {
      case "Format": return new GString_4(String.Format(args.GetString(0), args.Object(1)));
      default: Debug.Assert(false); return null;
    }
  }
}

class StringBuilderClass_4 : Internal_4 {
  public StringBuilderClass_4() : base("StringBuilder") { }
  public override GValue_4 ^New_4() { return new GStringBuilder_4(); }
}

class GStringBuilder_4 : GValue_4 {
  readonly StringBuilder ^b_ = new StringBuilder();

  public static readonly StringBuilderClass_4 ^type_ = new StringBuilderClass_4();

  public override GType_4 Type() { return type_; }

  public override RValue_4 ^Invoke(Method_4 m, ValueList_4 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "Append": b_.Append(args.Char(0)); return null;
      case "ToString": return new GString_4(b_.ToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class PoolClass_4 : Internal_4 {
  public PoolClass_4() : base("Pool") { }

  public static PoolClass_4 ^instance_ = new PoolClass_4();
}

class DebugClass_4 : Internal_4 {
  public DebugClass_4() : base("Debug") { }
  public static readonly DebugClass_4 ^instance_ = new DebugClass_4();
  
  public override RValue_4 ^InvokeStatic(Method_4 m, ValueList_4 args) {
    switch (m.name_) {
      case "Assert": Debug.Assert(args.Bool(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

class EnvironmentClass_4 : Internal_4 {
  public EnvironmentClass_4() : base("Environment") { }
  public static readonly EnvironmentClass_4 ^instance_ = new EnvironmentClass_4();

  public override RValue_4 ^InvokeStatic(Method_4 m, ValueList_4 args) {
    switch (m.name_) {
      case "Exit": Environment.Exit(args.Int(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

// built-in I/O classes

class ConsoleClass_4 : Internal_4 {
  public ConsoleClass_4() : base("Console") { }

  public override RValue_4 ^InvokeStatic(Method_4 m, ValueList_4 args) {
    switch (m.name_) {
      case "Write":
        switch (m.parameters_.Count) {
          case 1: Console.Write(args.Object(0)); return null;
          case 2: Console.Write(args.GetString(0), args.Object(1)); return null;
          case 3: Console.Write(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      case "WriteLine":
        switch (m.parameters_.Count) {
          case 1: Console.WriteLine(args.Object(0)); return null;
          case 2: Console.WriteLine(args.GetString(0), args.Object(1)); return null;
          case 3: Console.WriteLine(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly ConsoleClass_4 ^instance_ = new ConsoleClass_4();
}

class FileClass_4 : Internal_4 {
  public FileClass_4() : base("File") { }

  public override RValue_4 ^InvokeStatic(Method_4 m, ValueList_4 args) {
    switch (m.name_) {
      case "Delete": File.Delete(args.GetString(0)); return null;
      case "Exists": return new GBool_4(File.Exists(args.ToString()));
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly FileClass_4 ^instance_ = new FileClass_4();
}

class PathClass_4 : Internal_4 {
  public PathClass_4() : base("Path") { }

  public override RValue_4 ^InvokeStatic(Method_4 m, ValueList_4 args) {
    switch (m.name_) {
      case "GetTempFileName": return new GString_4(Path.GetTempFileName());
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly PathClass_4 ^instance_ = new PathClass_4();
}

class StreamReaderClass_4 : Internal_4 {
  public StreamReaderClass_4() : base("StreamReader") { }
  public override GValue_4 ^New_4() { return new GStreamReader_4(); }
}

class GStreamReader_4 : GValue_4 {
  StreamReader ^reader_;

  public static readonly StreamReaderClass_4 ^type_ = new StreamReaderClass_4();

  public override GType_4 Type() { return type_; }

  public override RValue_4 ^Invoke(Method_4 m, ValueList_4 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StreamReader": reader_ = new StreamReader(args.GetString(0)); return null;
      case "Read": return new GInt_4(reader_.Read());
      case "Peek": return new GInt_4(reader_.Peek());
      default: Debug.Assert(false); return null;
    }
  }
}

class Program_4 {
  ArrayList /* of string */ ^gel_import_ = new ArrayList();
  ArrayList /* of string */ ^cpp_import_ = new ArrayList();

  static Scanner_4 ^scanner_;

  NonOwningArrayList ^classes_ = new NonOwningArrayList();
  ArrayList ^own_classes_ = new ArrayList();

  public bool crt_alloc_;
  public bool debug_;
  public bool safe_ = true;

  public Control_4 prev_;   // previous node in control flow graph, used during graph construction

  public void Import(string s) {
    ArrayList a = null;
    string extension = Path.GetExtension(s);
    switch (extension) {
      case ".gel": a = gel_import_; break;
      case ".cpp": a = cpp_import_; break;
      default:
        new Syntax_4().Error("can't import file with extension {0}", extension);
        Environment.Exit(0);
        break;
    }
    foreach (string i in a)
      if (i == s)
        return;   // already imported
    a.Add(s);
  }

  public void FindAndImport(string s) {
    // First look relative to the importing file.
    string dir = Path.GetDirectoryName(Gel_4.CurrentFile());
    string s1 = Path.Combine(dir, s);
    if (!File.Exists(s1)) {
      // Now look relative to the GEL2 directory.
      s1 = Path.Combine(Gel_4.gel_directory_, s);
      if (!File.Exists(s1)) {
        new Syntax_4().Error("import not found: ", s);
        Environment.Exit(0);
      }
    }
    Import(s1);
  }
  
  public void Add(Class_4 c) {
    c.SetProgram(this);
    classes_.Add(c);
  }

  public void AddOwn(Class_4 ^c) {
    own_classes_.Add(c);
  }

  public Class_4 FindClass(string name) {
    foreach (Class_4 c in classes_)
      if (c.name_ == name)
        return c;
    return null;
  }

  public string CurrentFile() {
    return scanner_.filename_;
  }

  public int Line() {
    return scanner_.Line();
  }

  string Builtin(string module) {
    string file = String.Format("{0}.gel", module);
    return Path.Combine(Gel_4.gel_directory_, file);
  }

  public bool Parse() {
    Parser ^parser = new Parser();
    for (int i = 0; i < gel_import_.Count; ++i) {
      string file = (string) gel_import_[i];
      scanner_ = new Scanner_4(file);
      parser.yyParse(scanner_);
      if (i == 0) {
        Import(Builtin("internal"));
        Import(Builtin("library"));
      }
    }
    return true;
  }

  public bool Resolve() {
    foreach (Class_4 c in classes_)
      if (!c.ResolveAll(this))
        return false;

    return true;
  }

  public bool Check() {
    Context_4 ^ctx = new Context_4(this);
    bool ok = true;

    // Make a first checking pass where we check only constant fields.
    foreach (Class_4 c in classes_)
      ok &= c.Check1(ctx);

    foreach (Class_4 c in classes_)
      ok &= c.Check(ctx);

    return ok;
  }

  Method_4 FindMain() {
    NonOwningArrayList ^methods = new NonOwningArrayList();
    foreach (Class_4 c in classes_) {
      c.GetMainMethod(methods);
    }
    if (methods.Count == 0) {
      Console.WriteLine("no Main() method found");
      return null;
    }
    if (methods.Count > 1) {
      Console.WriteLine("error: found more than one Main() method");
      return null;
    }
    return (Method_4) methods[0];
  }

  public void Eval(ArrayList /* of string */ args) {
    Method_4 m = FindMain();
    if (m == null)
      return;
    ArrayList ^a = new ArrayList();
    if (m.parameters_.Count > 0) {   // Main() takes a string[] argument
      GArray_4 ^arr = new GArray_4(new ArrayType_4(GString_4.type_), args.Count);
      for (int i = 0 ; i < args.Count ; ++i)
        arr.Set(i, new GString_4((string) args[i]));
      a.Add(arr);
    }
    foreach (Class_4 c in classes_)
      c.StaticInit();
    m.Invoke(null, a);
  }

  void EmitMain(SourceWriter_4 w, Method_4 main) {
    bool args = main.parameters_.Count > 0;
    w.Write("int main({0}) ", args ? "int argc, char *argv[]" : "");
    w.OpenBrace();
    w.IWriteLine("return gel_runmain({0}::Main{1});", main.GetClass().name_, args ? ", argc, argv" : "");
    w.CloseBrace();
  }

  public bool Emit(SourceWriter_4 w) {
    Method_4 main = FindMain();
    if (main == null)
      return false;

    w.WriteLine("#define MEMORY_OWN 1");
    if (safe_)
      w.WriteLine("#define MEMORY_SAFE 1");
    if (crt_alloc_)
      w.WriteLine("#define MEMORY_CRT 1");

    foreach (string f in cpp_import_)
      w.WriteLine("#include {0}", GString_4.EmitString(f));

    // We undefine NULL since Gel_4 code may legitimately define fields or variables with that name.
    // Generated code uses 0, not NULL, to indicate the null pointer.
    w.WriteLine("#undef NULL");

    w.WriteLine("");

    // Forward-declare all classes since C++ requires a class to be declared before its name can
    // be used as a type.
    foreach (Class_4 c in classes_)
      if (!(c.HasAttribute(Attribute_4.Extern)))
        w.WriteLine("class {0};", c.name_);
    w.WriteLine("");

    foreach (Class_4 c in classes_)
      c.EmitDeclaration(w);

    foreach (Class_4 c in classes_)
      c.Emit(w);

    EmitMain(w, main);
    return true;
  }

  // Emit C++ code.
  public bool Generate(string basename) {
    string cpp_file = basename + ".cpp";
    StreamWriter ^w = new StreamWriter(cpp_file);
    bool ok = Emit(new SourceWriter_4(w));
    w.Close();
    return ok;
  }

  static string[] ^vsdirs = { "Microsoft Visual Studio 8",
                            "Microsoft Visual Studio .NET 2003",
                            "Microsoft Visual Studio .NET 2002" };

  string VsVars(int i) {
    return String.Format("C:\\Program_4 Files\\{0}\\Common7\\Tools\\vsvars32.bat", vsdirs[i]);
  }

  string FindVsVars() {
    for (int i = 0; i < vsdirs.Length; ++i) {
      string f = VsVars(i);
      if (File.Exists(f))
        return f;
    }

    Console.WriteLine("Error: unable to find vsvars32.bat at any of the following locations:");
    Console.WriteLine("");
    for (int i = 0; i < vsdirs.Length; ++i)
      Console.WriteLine(VsVars(i));
    Console.WriteLine("");
    Console.WriteLine("Your Visual Studio installation may be invalid.  Aborting compilation.");
    return null;
  }

  // Report compilation error. Print error message from a file
  void ReportCompilationError(string error_msg_file) {
      Console.WriteLine(
        "Error: unable to compile generated C++ code.  You may have found a bug in the GEL2 compiler.");
      Console.WriteLine("C++ compiler output follows:");
      Console.WriteLine("");
      Console.WriteLine((new StreamReader(error_msg_file)).ReadToEnd());
  }

  void UnixCppCompile(string basename) {
    string command_out = Path.GetTempFileName();
    string dbg_options = debug_ ? "-g -DDEBUG" : "-O2 -DNDEBUG";
    StringBuilder ^sb = new StringBuilder();
    // -o basename, use basename as the executable name
    // -Werror, make all warnings into hard errors
    sb.AppendFormat("/usr/bin/g++ -o {0} -Werror {1} {2}.cpp",
                    basename, dbg_options, basename);

    // Append redirection of output
    sb.AppendFormat(" > {0} 2>&1", command_out);
 
    string sh_cmd = sb.ToString();

    if (Gel_4.verbose_) 
      Console.WriteLine(sh_cmd);
  
    if (Process.System(sh_cmd) !=0) {
      ReportCompilationError(command_out);
    }
    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".o");
  }

  // Run vsvars32.bat and the run the given command, redirecting output to a file.
  // We must always redirect output since vsvars32 prints a message "Setting environment..."
  // which we don't want users to see.
  int VsRun(string vsvars, string command, string output) {
    command = String.Format("(\"{0}\" & {1}) > \"{2}\"", 
                            vsvars, command, output);
    return Process.System(command);
  }

  void VsCppCompile(string basename) {
    string vsvars = FindVsVars();
    if (vsvars == null)
      return;
    string command_out = Path.GetTempFileName();

    string options = debug_ ?
      //  /MDd - runtime library: multithreaded debug DLL
      //  /Od - optimization: disabled
      //  /ZI - debug information format: Program_4 Database for Edit & Continue_4
      "/MDd /Od /ZI /D \"_DEBUG\"" :

      //  /MD - runtime library: multithreaded DLL
      //  /O2 - optimization: Maximize Speed
      //  /GL - optimization: Whole Program_4 Optimization
      "/MD /O2 /GL /D \"NDEBUG\"";

    StringBuilder ^sb = new StringBuilder();
    //  /WX - treat warnings as errors
    sb.AppendFormat("cl /nologo /WX {0} {1}.cpp", options, basename);
    string mode = debug_ ? "debug" : "release";
    if (!crt_alloc_)
      sb.AppendFormat(" {0}\\{1}\\dlmalloc.obj", Gel_4.gel_directory_, mode);
    sb.Append(" user32.lib shell32.lib shlwapi.lib");
    string command = sb.ToString();
    if (Gel_4.verbose_)
      Console.WriteLine(command);

    if (VsRun(vsvars, command, command_out) != 0) {
      ReportCompilationError(command_out);
    } else {
      // Run the manifest tool to embed the linker-generated manifest into the executable file;
      // this allows the executable to find the C runtime DLL even when the manifest file is absent.
      string mt_command = String.Format("mt -nologo -manifest {0}.exe.manifest -outputresource:\"{0}.exe;#1\"",
                              basename);
      if (Gel_4.verbose_)
        Console.WriteLine(mt_command);
      if (VsRun(vsvars, mt_command, command_out) != 0)
        Console.WriteLine("warning: could not run manifest tool");
    }

    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".obj");
    File.Delete(basename + ".exe.manifest");
  }

  // Invoke the C++ compiler to generate a native executable.
  void CppCompile(string basename) {
    if (Environment.OSVersion.Platform == PlatformID.Win32NT) 
      VsCppCompile(basename);
    else
      UnixCppCompile(basename);
  }

  public void Compile(string output, bool cpp_only) {
    if (output == null)
      output = Path.GetFileNameWithoutExtension((string) gel_import_[0]);
    if (Generate(output) && !cpp_only)
      CppCompile(output);
  }
}

class Scanner_4 : yyInput {
  public readonly string filename_;

  int line_;
  public int Line() { return line_; }

  StreamReader ^sr_;
  int token_;
  object ^ value_;

  int next_token_ = -1;
  object ^ next_value_;

  public Scanner_4 (string filename) {
    filename_ = filename;
    sr_ = new StreamReader(filename);
    line_ = 1;
  }

  public override int GetToken () {
    return token_;
  }

  public override object ^ GetValue () {
    return take value_;
  }

  int Read() {
    int i = sr_.Read();
    if (i == '\n')
      ++line_;
    return i;
  }

  bool Read(out char c) {
    int i = Read();
    c = (char) i;
    return i != -1;
  }

  char Peek() {
    return (char) sr_.Peek();
  }

  string ReadWord(char first) {
    StringBuilder ^sb = new StringBuilder();
    if (first != '\0')
      sb.Append(first);
    while (true) {
      char c = Peek();
      if (!Char.IsLetter(c) && !Char.IsDigit(c) && c != '_')
        break;
      sb.Append(c);
      Read();
    }
    return sb.ToString();
  }

  // Read to the end of the current line.
  string ReadLine() {
    StringBuilder ^sb = new StringBuilder();
    char c;
    while (Read(out c)) {
      if (c == '\n')
        break;
      sb.Append(c);
    }
    return sb.ToString();
  }

  // Read a comment delimited by /* ... */, assuming we've already read the opening /*.
  // Returns true on success, or false on EOF.
  bool ReadDelimitedComment() {
    char prev = (char) 0;
    while (true) {
      char c;
      if (!Read(out c)) {
        Console.WriteLine("warning: unterminated comment at end of file");
        return false;
      }
      if (c == '/' && prev == '*')
        return true;
      prev = c;
    }
  }

  // Preprocess input, handling whitespace, comments and directives; return the first
  // character not eaten by preprocessing, or -1 on EOF.
  int GetChar() {
    while (true) {
      int i = Read();
      if (i == -1)
        return -1;   // end of input
      if (i == 0)
        continue;   // end of this file; move on
      char c = (char) i;

      if (c == '\n' && Peek() == '#') {
        Read();
        string directive = ReadWord('\0');
        if (directive == "line") {
          ReadLine();
          continue;
        }
        Console.WriteLine("error: unknown preprocessing directive {0}", directive);
        Environment.Exit(0);
      }

      if (Char.IsWhiteSpace(c))
        continue;

      if (c == '/') {
        switch (Peek()) {
          case '/':  // single-line comment
            Read();
            int line = line_;
            string s = ReadLine();
            if (Gel_4.error_test_ && s.StartsWith(" error"))
              Gel_4.expected_error_lines_.Add(line);
            continue;

          case '*':  // comment delimited by /* ... */
            Read();   // move past opening '*'
            if (!ReadDelimitedComment())
              return (char) 0;
            continue;
        }
      }

      return c;
    }
  }

  bool IsDigit(char c, bool hex) {
    if (Char.IsDigit(c))
      return true;
    if (!hex)
      return false;
    return (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');
  }

  // Read a number, possibly including a decimal point and/or exponent.
  string ReadNumber(char first, bool hex, out bool real) {
    bool dot = false, exp = false;
    StringBuilder ^sb = new StringBuilder();
    sb.Append(first);
    if (first == '.')
      dot = true;

    while (true) {
      bool need_digit = false;
      char c = Peek();
      if (c == '.' && !hex && !dot && !exp) {
        sb.Append(c);
        Read();
        dot = true;
        c = Peek();
        need_digit = true;
      }
      else if ((c == 'e' || c == 'E') && !hex && !exp) {
        sb.Append(c);
        Read();
        exp = true;
        c = Peek();
        if (c == '+' || c == '-') {
          sb.Append(c);
          Read();
          c = Peek();
        }
        need_digit = true;
      }
      if (!IsDigit(c, hex)) {
        if (!need_digit)
          break;
        real = false;
        return null;
      }
      sb.Append(c);
      Read();
    }

    real = dot || exp;
    return sb.ToString();
  }

  int ParseNumber(char first, out object ^val) {
    bool hex = false;
    if (first == '0') {
      char p = Peek();
      if (p == 'x' || p == 'X') {
        Read();
        hex = true;
      }
    }
    bool real;
    string s = ReadNumber(first, hex, out real);
    if (s == null) {
      val = null;
      return Parser.SCAN_ERROR;
    }
    if (!hex) {
      switch (Peek()) {
        case 'F':
        case 'f':
          Read();
          val = Single.Parse(s);
          return Parser.FLOAT_LITERAL;
        case 'D':
        case 'd':
          Read();
          real = true;
        break;
    }
    }
    if (real) {
      val = Double.Parse(s);
      return Parser.DOUBLE_LITERAL;
    }
    val = int.Parse(s, hex ? NumberStyles.HexNumber : NumberStyles.Integer);
    return Parser.INT_LITERAL;
  }

  int ParseWord(char first, out object ^val) {
    string s = ReadWord(first);

    val = null;
    switch (s) {
      case "abstract": return Parser.ABSTRACT;
      case "as": return Parser.AS;
      case "base": return Parser.BASE;
      case "bool": return Parser.BOOL;
      case "break": return Parser.BREAK;
      case "case": return Parser.CASE;
      case "char": return Parser.CHAR;
      case "class": return Parser.CLASS;
      case "const": return Parser.CONST_TOKEN;
      case "continue": return Parser.CONTINUE;
      case "default": return Parser.DEFAULT;
      case "do": return Parser.DO;
      case "double": return Parser.DOUBLE;
      case "else": return Parser.ELSE;
      case "extern": return Parser.EXTERN;
      case "false": return Parser.FALSE_TOKEN;
      case "float": return Parser.FLOAT;
      case "for": return Parser.FOR;
      case "foreach": return Parser.FOREACH;
      case "if": return Parser.IF;
      case "import": return Parser.IMPORT;
      case "in": return Parser.IN_TOKEN;
      case "int": return Parser.INT;
      case "is": return Parser.IS;
      case "new": return Parser.NEW;
      case "null": return Parser.NULL;
      case "object": return Parser.OBJECT;
      case "out": return Parser.OUT_TOKEN;
      case "override": return Parser.OVERRIDE;
      case "pool": return Parser.POOL;
      case "private": return Parser.PRIVATE;
      case "protected": return Parser.PROTECTED;
      case "public": return Parser.PUBLIC;
      case "readonly": return Parser.READONLY;
      case "ref": return Parser.REF;
      case "return": return Parser.RETURN;
      case "short": return Parser.SHORT;
      case "static": return Parser.STATIC;
      case "string": return Parser.STRING;
      case "switch": return Parser.SWITCH;
      case "take": return Parser.TAKE;
      case "this": return Parser.THIS_TOKEN;
      case "true": return Parser.TRUE_TOKEN;
      case "virtual": return Parser.VIRTUAL;
      case "void": return Parser.VOID_TOKEN;
      case "while": return Parser.WHILE;
      default:
        val = s;
        return Parser.ID;
    }
  }

  bool ParseEscape(ref char c) {
    if (!Read(out c))
      return false;
    switch (c) {
      case '\'':
      case '\"':
      case '\\':
        break;
      case '0': c = '\0'; break;
      case 'n': c = '\n'; break;
      case 'r': c = '\r'; break;
      case 't': c = '\t'; break;
      default: return false;
    }
    return true;
  }

  int ParseChar(out object ^val) {
    val = null;
    char c;
    if (!Read(out c))
      return Parser.SCAN_ERROR;
    if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
    char d;
    if (!Read(out d) || d != '\'')
      return Parser.SCAN_ERROR;
    val = c;
    return Parser.CHAR_LITERAL;
  }

  int ParseString(out object ^val) {
    val = null;
    StringBuilder ^sb = new StringBuilder();
    while (true) {
      char c;
      if (!Read(out c))
        return Parser.SCAN_ERROR;
      if (c == '"')
        break;
      if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
      sb.Append(c);
    }
    val = sb.ToString();
    return Parser.STRING_LITERAL;
  }

  int ReadToken(out object ^val) {
    val = null;

    int i = GetChar();
    if (i == -1)
      return -1;
    char c = (char) i;

    if (Char.IsDigit(c) || c == '.' && Char.IsDigit(Peek()))
      return ParseNumber(c, out val);

    if (Char.IsLetter(c) || c == '_')
      return ParseWord(c, out val);

    if (c == '\'')
      return ParseChar(out val);

    if (c == '"')
      return ParseString(out val);

    char peek = Peek();
    int token = 0;
    switch (c.ToString() + peek.ToString()) {
      case "++": token = Parser.PLUS_PLUS; break;
      case "--": token = Parser.MINUS_MINUS; break;
      case "&&": token = Parser.OP_AND; break;
      case "||": token = Parser.OP_OR; break;
      case "==": token = Parser.OP_EQUAL; break;
      case "!=": token = Parser.OP_NE; break;
      case "<=": token = Parser.OP_LE; break;
      case "<<": token = Parser.OP_LEFT_SHIFT; break;
      case ">=": token = Parser.OP_GE; break;
      case ">>": token = Parser.OP_RIGHT_SHIFT; break;
      case "*=": token = Parser.STAR_EQUAL; break;
      case "/=": token = Parser.SLASH_EQUAL; break;
      case "%=": token = Parser.PERCENT_EQUAL; break;
      case "+=": token = Parser.PLUS_EQUAL; break;
      case "-=": token = Parser.MINUS_EQUAL; break;
      case "&=": token = Parser.AND_EQUAL; break;
      case "|=": token = Parser.OR_EQUAL; break;

      // Return_4 [] as a single token; this lets the parser distinguish the cases
      // "foo[] a;" and "foo[x] = 4" as soon as it reads the first token after the identifier "foo".
      case "[]": token = Parser.ARRAY_TYPE; break;
    }
    if (token != 0) {
      Read();
    } else token = c;

    val = token;
    return token;
  }

  public override bool Advance () {
    if (next_token_ != -1) {
      token_ = next_token_;
      value_ = take next_value_;
      next_token_ = -1;
    } else {
      token_ = ReadToken(out value_);
      if (token_ == -1) return false;
    }

    if (token_ == ')') {
      // We need to read one token ahead to determine whether this close parenthesis
      // ends a type cast.  See e.g. the discussion in the Cast_4 Expressions section
      // of the C# specification.
      next_token_ = ReadToken(out next_value_);
      switch (next_token_) {
        case -1:  // end of file
          break;
        case '!':
        case '(':
        case Parser.ID:
        case Parser.INT_LITERAL:
        case Parser.CHAR_LITERAL:
        case Parser.STRING_LITERAL:
          token_ = Parser.CAST_CLOSE_PAREN;
          break;
        default:
          if (next_token_ >= Parser.FIRST_KEYWORD && next_token_ <= Parser.LAST_KEYWORD &&
              next_token_ != Parser.AS && next_token_ != Parser.IS)
            token_ = Parser.CAST_CLOSE_PAREN;
          break;
      }
    }
    return true;
  }

  public override void Fatal() {
    new Syntax_4().Error("irrecoverable syntax error");
    Environment.Exit(1);
  }

}

class Gel_4 {
  public static bool verbose_;

  public static bool error_test_;
  public static bool print_type_sets_;

  public static readonly ArrayList /* of int */ ^expected_error_lines_ = new ArrayList();
  public static readonly ArrayList /* of int */ ^error_lines_ = new ArrayList();

  public static Program_4 ^program_;

  public static readonly string gel_directory_ = GetLibraryPath();

  static string GetLibraryPath() {
    return Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName); 
  }

  public static string CurrentFile() {
    return program_ == null ? "" : program_.CurrentFile();
  }

  public static int Line() {
    return program_ == null ? 0 : program_.Line();
  }

  public static void Exit() { Environment.Exit(0); }

  // Given two sorted ArrayLists a, b of ints, return an ArrayList containing all ints which appear
  // in [a] but not in [b].
  ArrayList ^Diff(ArrayList a, ArrayList b) {
    ArrayList ^ret = new ArrayList();
    int bi = 0;
    foreach (int i in a) {
      while (bi < b.Count && (int) b[bi] < i)
        ++bi;
      if (bi >= b.Count || (int) b[bi] > i)
        ret.Add(i);
    }
    return ret;
  }

  void WriteLineNumbers(ArrayList a) {
    for (int i = 0; i < a.Count; ++i) {
      if (i > 0)
        Console.Write(", ");
      Console.Write(a[i]);
    }
    Console.WriteLine("");
  }

  void ErrorTestReport() {
    Console.WriteLine("");
    ArrayList ^e = Diff(error_lines_, expected_error_lines_);
    if (e.Count > 0) {
      Console.Write("unexpected error at line ");
      WriteLineNumbers(e);
    }
    ArrayList ^e2 = Diff(expected_error_lines_, error_lines_);
    if (e2.Count > 0) {
      Console.Write("expected error at line ");
      WriteLineNumbers(e2);
    }
    if (e.Count == 0 && e2.Count == 0)
      Console.WriteLine("all errors expected");
  }

  void Usage_4() {
    Console.WriteLine("usage: gel <source-file> ... [args]");
    Console.WriteLine("       gel -c [-d] [-o <name>] [-u] [-v] [-cpp] <source-file> ...");
    Console.WriteLine("");
    Console.WriteLine("   -c: compile to native executable");
    Console.WriteLine("   -d: debug mode: disable optimizations, link with debug build of C runtime");
    Console.WriteLine("   -o: specify output filename");
    Console.WriteLine("   -u: unsafe: skip reference count checks");
    Console.WriteLine("   -v: verbose: display command used to invoke C++ compiler");
    Console.WriteLine(" -cpp: compile to C++ only");
  }

  public void Run(string[] args) {
    if (args.Length < 1) {
      Usage_4();
      return;
    }

    Internal_4.Init();

    program_ = new Program_4();
    bool compile = false;
    bool cpp_only = false;
    string output = null;
    int i;
    for (i = 0; i < args.Length && args[i].StartsWith("-"); ++i)
      switch (args[i]) {
        case "-c": compile = true; break;
        case "-d": program_.debug_ = true; break;
        case "-e": error_test_ = true; break;
        case "-o":
          if (++i >= args.Length) {
            Usage_4();
            return;
          }
          output = Path.GetFileNameWithoutExtension(args[i]);
          break;
        case "-u": program_.safe_ = false; break;
        case "-v": verbose_ = true; break;
        case "-cpp": cpp_only = true; break;
        case "-crt": program_.crt_alloc_ = true; break;
        case "-typeset": print_type_sets_ = true; break;
        default:
          Console.WriteLine("unrecognized option: {0}", args[i]);
          return;
      }

    for (; i < args.Length ; ++i)
      if (args[i].EndsWith(".gel"))
        program_.Import(args[i]);
      else {
        if (args[i] == "-")   // marker indicating end of source files
          ++i;
        break;
      }

    ArrayList ^program_args = new ArrayList();
    if (compile) {
      if (i < args.Length) {
        Console.WriteLine("file to compile has unrecognized extension: {0}", args[i]);
        return;
      }
    } else {
      for (; i < args.Length; ++i)
        program_args.Add(args[i]);
    }

    if (!program_.Parse())
      return;

    bool ok = program_.Resolve() && program_.Check();
    if (error_test_)
      ErrorTestReport();
    if (!ok)
      return;

    if (compile)
      program_.Compile(output, cpp_only);
    else program_.Eval(program_args);
  }

  public static void Main_4(string[] args) {
    new Gel_4().Run(args);
  }
}
/*
Copyright (c) 2006 Google Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

class Syntax_5 {
  public readonly string file_;
  public readonly int line_;

  public Syntax_5() { file_ = Gel_5.CurrentFile(); line_ = Gel_5.Line(); }

  static void Report(string file, int line, string type) {
    Console.Write("{0}({1}): ", file, line);
    Console.Write("{0}: ", type);
    if (Gel_5.error_test_)
      Gel_5.error_lines_.Add(line);
  }

  public void Error(string message) {
    Report(file_, line_, "error");
    Console.WriteLine(message);
  }

  public void Error(string format, object arg) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg);
  }

  public void Error(string format, object arg1, object arg2) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2);
  }

  public void Error(string format, object arg1, object arg2, object arg3) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2, arg3);
  }

  public void Warning(string message) {
    Report(file_, line_, "warning");
    Console.WriteLine(message);
  }
}

abstract class TypeExpr_5 : Syntax_5 {
  public abstract GType_5 Resolve(Program_5 program);
  public abstract TypeExpr_5 ^Copy();
}

class ConversionContext_5 {
  public const int Other = 0,
                   AssignVar = 1,
                   MethodArg = 2;
}

// GEL2 includes the following kinds of types:
// - simple types (int, bool, char, float, double): SimpleType_5
// - owned types (including array types): ArrayType_5 or Class_5 with Owned() => true
// - owning types: Owning_5
// - string: GString_5
// - null type: NullType_5
// - void: VoidType_5

abstract class GType_5 {
  public virtual bool IsOwned() { return false; }

  // A reference type is an owned, owning, string or null type.
  public virtual bool IsReference() { return true; }

  // A value type is a simple or string type.
  public virtual bool IsValue() { return false; }

  public virtual Class_5 Parent() { return GObject_5.type_; }
  
  // If_5 this is an owning type T ^ then return T; otherwise return this.
  public virtual GType_5 BaseType() { return this; }

  // Return_5 the set of types which may be destroyed when a variable of this type
  // is destroyed.
  public virtual TypeSet_5 VarDestroys() { return TypeSet_5.empty_; }

  // Return_5 the set of types which may be destroyed when a value of this concrete type
  // is destroyed.
  public virtual TypeSet_5 TypeDestroys() { return TypeSet_5.empty_; }

  public virtual void FindVarDestroys(int marker, TypeSet_5 set) { }

  public virtual void FindTypeDestroys(int marker, TypeSet_5 set) { }

  public virtual bool IsSubtype(GType_5 type) {
    for (GType_5 t = this; t != null ; t = t.Parent())
      if (type.Equals(t))
        return true;
    return false;
  }

  public virtual Owning_5 OwningType() { Debug.Assert(false); return null; }

  protected virtual bool CanConvertOwnership(GType_5 t, int context) {
    bool from_owning = this is Owning_5;
    bool to_owning = t is Owning_5;
    if (IsValue() && t.BaseType() == GObject_5.type_) {
      Debug.Assert(!from_owning);
      // boxing conversion yields an owning pointer; string->object conversion may
      // yield an owning or non-owning pointer
      return to_owning || context == ConversionContext_5.MethodArg || this == GString_5.type_;
    }
    if (BaseType() == GObject_5.type_ && t.IsValue()) {
      Debug.Assert(!to_owning);
      return true;  // an unboxing or object->string conversion, OK in any context
    }
    return from_owning == to_owning ||
           from_owning && !to_owning &&
             (context == ConversionContext_5.AssignVar || context == ConversionContext_5.MethodArg);
  }

  // Ensure that this class will inherit from Object in generated C++ code.
  public virtual void SetObjectInherit() { }

  // Return_5 true if there is a non-subtyping implicit conversion from this to t.
  public virtual bool CanConvert1(GType_5 t) { return false; }

  // Return_5 true if there is a non-subtyping explicit conversion from this to t.
  protected virtual bool CanConvertExplicit1(GType_5 t) { return false; }

  // Return_5 true if this type can be converted to type [to].
  public bool CanConvert(GType_5 to, int context, bool is_explicit, bool subtype_only) {
    if (!CanConvertOwnership(to, context))
      return false;

    GType_5 from_base = BaseType();
    GType_5 to_base = to.BaseType();
    if (from_base.Equals(to_base))
      return true;   // identity conversion

    // If_5 we ever perform a conversion to C ^, then C must have a vtable so that we can call
    // a virtual destructor when an owning pointer is destroyed.
    if (to is Owning_5 && this != Null_5.type_)
      to_base.SetVirtual();

    // If_5 we ever perform an explicit conversion from a class, that class must
    // have a vtable so that every instance of the class will have run-time type information.
    if (is_explicit)
      from_base.SetVirtual();

    // If_5 we ever convert between C and Object, then C must derive from Object in generated code.
    if (from_base == GObject_5.type_)
      to_base.SetObjectInherit();
    else if (to_base == GObject_5.type_)
      from_base.SetObjectInherit();

    return from_base.IsSubtype(to_base) ||
           !subtype_only && from_base.CanConvert1(to_base) ||
           is_explicit && (to_base.IsSubtype(from_base) ||
                           !subtype_only && from_base.CanConvertExplicit1(to_base));
  }

  public bool CanConvert(GType_5 t, int context) { return CanConvert(t, context, false, false); }
  public bool CanConvert(GType_5 t) { return CanConvert(t, ConversionContext_5.Other); }

  public bool CanConvertExplicit(GType_5 t, bool subtype_only) {
    return CanConvert(t, ConversionContext_5.Other, true, subtype_only);
  }

  public bool CheckConvert(Syntax_5 caller, GType_5 t, int context) {
    if (!CanConvert(t, context)) {
      caller.Error("can't convert {0} to {1}", this, t);
      return false;
    }
    return true;
  }

  public bool CheckConvert(Syntax_5 caller, GType_5 t) {
    return CheckConvert(caller, t, ConversionContext_5.Other);
  }

  // Return_5 a type to which the types [this] and t can both be implicitly converted.
  public GType_5 CommonType(Syntax_5 caller, GType_5 t) {
    if (CanConvert(t))
      return t;
    if (t.CanConvert(this))
      return this;
    caller.Error("incompatible types: {0} and {1}", this, t);
    return null;
  }

  public abstract SimpleValue_5 DefaultValue_5();

  static ArrayList ^empty_array_ = new ArrayList();
  public virtual ArrayList /* of Member_5 */ Members() { return empty_array_; }

  public Member_5 GetMatchingMember(Member_5 m1) {
    foreach (Member_5 m in Members())
      if (m.MatchSignature(m1))
        return m;
    return null;
  }

  // Find a match for m in this type or its ancestors, ignoring private members and
  // optionally ignoring overrides.
  public Member_5 FindMatchingMember(Member_5 m, bool override_ok) {
    for (GType_5 t = this ; t != null ; t = t.Parent()) {
      Member_5 m1 = t.GetMatchingMember(m);
      if (m1 != null && !m1.IsPrivate() && (override_ok || !m1.IsOverride()))
        return m1;
    }
    return null;
  }

  int Score(bool accessible, int mismatches) {
    return (accessible ? 0 : 100) + mismatches;
  }

  public Member_5 Lookup(Syntax_5 caller, Class_5 from_class, bool through_base,
                       int kind, string name, ArrayList /* of Argument_5 */ arguments, bool report_error) {
    Member_5 m1 = null;   // the best match we've found so far
    bool found_any = false;
    bool accessible = false;
    int score = -1;

    GType_5 this_type = BaseType();
    GType_5 t;
    for (t = this_type; t != null; t = (kind == MemberKind_5.Constructor_5 ? null : t.Parent())) {
      foreach (Member_5 m in t.Members())
        if (Member_5.MatchKind(m.Kind(), kind) && m.name_ == name && !m.IsOverride()) {
          found_any = true;
          int mismatches = 0;
          if (arguments != null && !m.IsApplicable(arguments, out mismatches))
            continue; // wrong argument count
          bool new_accessible = m.IsAccessible(from_class, this_type, through_base);
          int new_score = Score(new_accessible, mismatches);
          if (new_score == 0 && score == 0) {
            if (report_error)
              caller.Error("{0}: ambiguous {1} call", name, Member_5.ToString(kind));
            return null;
          }
          if (score == -1 || new_score < score) {
            m1 = m;
            score = new_score;
            accessible = new_accessible;
          }
        }
      if (score == 0)
        break;
    }

    if (score != 0) {
      if (report_error) {
        string k = Member_5.ToString(kind);
        if (!found_any)
          caller.Error("{0}: {1} not found", name, k);
        else if (score == -1) {
          string a = String.Format("{0} argument{1}", arguments.Count, arguments.Count == 1 ? "" : "s");
          caller.Error("{0}: no {1} overload takes {2}", name, k, a);
        } else if (!accessible)
          caller.Error("{0}: can't access {1} {2}",
                       name, m1.IsProtected() ? "protected" : "private", k);
        else {
          caller.Error("{0}: the best overloaded {1} match has some invalid arguments", name, k);
          m1.ReportMismatches(caller, arguments);
        }
      }
      return null;
    }

    // If_5 we've found a member of the Object class, then we're using this class as an object,
    // so in generated code it must ultimately inherit from Object, not _Object.
    if (t == GObject_5.type_)
      this_type.SetObjectInherit();

    if (through_base) {
      // As_5 a special case, whenever we're accessing through base we find the member which will
      // actually be invoked; this is not necessarily the same as the member we've just found
      // if the member is virtual.
      m1 = FindMatchingMember(m1, true);
      Debug.Assert(m1 != null);
    }

    return m1;
  }

  public virtual void SetVirtual() { }

  // Emit the name of the C++ class we use to hold instances of this type.
  public virtual string EmitTypeName() { Debug.Assert(false); return null; }

  // Return_5 a C++ type of the form "T<U>".  If_5 U ends with a '>', we emit an
  // extra space to avoid emitting the token >>, which will cause GCC to complain.
  public static string ConstructType(string generic, string type) {
    return String.Format("{0}<{1}{2}>", generic, type,
                         type.EndsWith(">") ? " " : "");
  }

  string EmitNonOwningPointer(string name) {
    if (Gel_5.program_.safe_)
      return ConstructType(this == GObject_5.type_ ? "_PtrRef" : "_Ptr", name);
    return String.Format("{0} *", name);
  }

  // Emit a C++ type used for variables holding instances of this type.
  public virtual string EmitType() {
    return EmitNonOwningPointer(EmitTypeName());
  }

  // Emit a C++ type used for expressions holding instances of this type.
  public virtual string EmitExprType() {
    return EmitTypeName() + " *";
  }

  public virtual string EmitReturnType() {
    return EmitExprType();
  }

  public virtual string EmitGenericType() {
    return IsReference() ? EmitNonOwningPointer("Object") : EmitType();
  }
}

class TypeSet_5 {
  NonOwningArrayList /* of GType_5 */ ^types_ = new NonOwningArrayList();

  public static readonly TypeSet_5 ^empty_ = new TypeSet_5();

  public void Add(GType_5 type) {
    for (int i = 0; i < types_.Count; ++i) {
      GType_5 t = (GType_5) types_[i];
      if (type.IsSubtype(t))
        return;
      if (t.IsSubtype(type)) {
        types_[i++] = type;
        while (i < types_.Count) {
          t = (GType_5) types_[i];
          if (t.IsSubtype(type))
            types_.RemoveAt(i);
          else ++i;
        }
        return;
      }
    }
    types_.Add(type);
  }

  public void Add(TypeSet_5 set) {
    foreach (GType_5 t in set.types_)
      Add(t);
  }

  public bool Contains(GType_5 type) {
    foreach (GType_5 t in types_)
      if (type.IsSubtype(t))
        return true;
    return false;
  }

  public bool IsObject() {
    return types_.Count > 0 && types_[0] == GObject_5.type_;
  }

  public override string ToString() {
    StringBuilder ^sb = new StringBuilder();
    sb.Append("{");
    foreach (GType_5 t in types_)
      sb.AppendFormat(" {0}", t.ToString());
    sb.Append(" }");
    return sb.ToString();
  }
}

class VoidType_5 : GType_5 {
  public override bool IsReference() { Debug.Assert(false); return false; }

  public override SimpleValue_5 DefaultValue_5() { Debug.Assert(false); return null; }

  public override string ToString() { return "void"; }

  public override string EmitExprType() { return "void"; }
  public override string EmitType() { return "void"; }
}

class Void_5 {
  public static readonly GType_5 ^type_ = new VoidType_5();
}

// an RValue_5, a Location_5 containing an RValue_5, or a LocationRef_5 pointing to a Location_5 containing an RValue_5
abstract class ValueOrLocation_5 {
  public abstract GValue_5 Get();
}

// a GValue_5 or a reference to a GValue_5
abstract class RValue_5 : ValueOrLocation_5 {
  public abstract RValue_5 ^CopyRef();
}

abstract class GValue_5 : RValue_5 {
  public override GValue_5 Get() { return this; }

  public abstract GType_5 Type();

  public override RValue_5 ^CopyRef() { return new Reference_5(this); }

  public virtual RValue_5 ^Get(Field_5 field) { Debug.Assert(false); return null; }
  public virtual RValue_5 ^Take_5(Field_5 field) { Debug.Assert(false); return null; }

  public virtual RValue_5 ^ConvertExplicit(ref RValue_5 ^this_own, GType_5 t) {
    // try implicit conversion
    RValue_5 ^v = Convert(ref this_own, t);
    if (v != this || Type().IsSubtype(t) )
      return v;

    Console.WriteLine("type cast failed: object of type {0} is not a {1}", Type(), t);
    Gel_5.Exit();
    return null;
  }

  // Implicitly convert this value to type t.
  public virtual RValue_5 ^Convert(ref RValue_5 ^this_own, GType_5 t) {
    return take this_own;
  }

  public virtual bool DefaultEquals(object o) { return Equals(o); }
  public virtual int DefaultHashCode() { return GetHashCode(); }
  public virtual string DefaultToString() { return ToString(); }

  public virtual RValue_5 ^Invoke(Method_5 m, ValueList_5 args) {
    switch (m.name_) {
      case "Equals": return new GBool_5(DefaultEquals(args.Object(0)));
      case "GetHashCode": return new GInt_5(DefaultHashCode());
      case "ToString": return new GString_5(DefaultToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class Reference_5 : RValue_5 {
  public readonly GValue_5 value_;    // a reference value, never a SimpleValue_5

  public Reference_5(GValue_5 v) { value_ = v; }

  public override GValue_5 Get() { return value_; }

  public override RValue_5 ^CopyRef() { return new Reference_5(value_); }
}

abstract class SimpleValue_5 : GValue_5 {
  public abstract SimpleValue_5 ^Copy();
  public override RValue_5 ^CopyRef() { return Copy(); }
  public abstract string Emit();
}

class GBool_5 : SimpleValue_5 {
  public readonly bool b_;

  public GBool_5(bool b) { b_ = b; }

  public override bool Equals(object o) {
    GBool_5 b = o as GBool_5;
    return b != null && b.b_ == b_;
  }

  public override int GetHashCode() { return b_.GetHashCode(); }

  public override SimpleValue_5 ^Copy() { return new GBool_5(b_); }

  public static readonly BoolClass_5 ^type_ = new BoolClass_5();

  public override GType_5 Type() { return type_; }

  public override string ToString() { return b_.ToString(); }

  public override string Emit() { return b_ ? "true" : "false"; }
}

class GInt_5 : SimpleValue_5 {
  public readonly int i_;

  public GInt_5(int i) { i_ = i; }

  public static readonly IntClass_5 ^type_ = new IntClass_5();

  public override GType_5 Type() { return type_; }

  public override bool Equals(object o) {
    GInt_5 i = o as GInt_5;
    return i != null && i.i_ == i_;
  }

  public override int GetHashCode() { return i_.GetHashCode(); }

  public override SimpleValue_5 ^Copy() { return new GInt_5(i_); }

  public override RValue_5 ^Convert(ref RValue_5 ^this_own, GType_5 t) {
    if (t == GFloat_5.type_)
      return new GFloat_5(i_);
    if (t == GDouble_5.type_)
      return new GDouble_5(i_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_5 ^ConvertExplicit(ref RValue_5 ^this_own, GType_5 t) {
    return t == GChar_5.type_ ? new GChar_5((char) i_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return i_.ToString(); }

  public override string Emit() { return i_.ToString(); }
}

class GFloat_5 : SimpleValue_5 {
  public readonly float f_;

  public GFloat_5(float f) { f_ = f; }

  public static readonly FloatClass_5 ^type_ = new FloatClass_5();

  public override GType_5 Type() { return type_; }

  public override bool Equals(object o) {
    GFloat_5 f = o as GFloat_5;
    return f != null && f.f_ == f_;
  }

  public override int GetHashCode() { return f_.GetHashCode(); }

  public override SimpleValue_5 ^Copy() { return new GFloat_5(f_); }

  public override RValue_5 ^Convert(ref RValue_5 ^this_own, GType_5 t) {
    if (t == GDouble_5.type_)
      return new GDouble_5(f_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_5 ^ConvertExplicit(ref RValue_5 ^this_own, GType_5 t) {
    return t == GInt_5.type_ ? new GInt_5((int) f_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return f_.ToString(); }

  public override string Emit() {
    string s = f_.ToString();
    return s + (s.IndexOf('.') == -1 ? ".0f" : "f");
  }
}

class GDouble_5 : SimpleValue_5 {
  public readonly double d_;

  public GDouble_5(double d) { d_ = d; }

  public static readonly DoubleClass_5 ^type_ = new DoubleClass_5();

  public override GType_5 Type() { return type_; }

  public override bool Equals(object o) {
    GDouble_5 d = o as GDouble_5;
    return d != null && d.d_ == d_;
  }

  public override int GetHashCode() { return d_.GetHashCode(); }

  public override SimpleValue_5 ^Copy() { return new GDouble_5(d_); }

  public override RValue_5 ^ConvertExplicit(ref RValue_5 ^this_own, GType_5 t) {
    if (t == GInt_5.type_)
      return new GInt_5((int) d_);
    if (t == GFloat_5.type_)
      return new GFloat_5((float) d_);
    return base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return d_.ToString(); }

  public override string Emit() {
    string s = d_.ToString();
    if (s.IndexOf('.') == -1)
      s = s + ".0";
    return s;
  }
}

class GChar_5 : SimpleValue_5 {
  public readonly char c_;

  public GChar_5(char c) { c_ = c; }

  public static readonly CharClass_5 ^type_ = new CharClass_5();

  public override GType_5 Type() { return type_; }

  public override bool Equals(object o) {
    GChar_5 c = o as GChar_5;
    return c != null && c.c_ == c_;
  }

  public override int GetHashCode() { return c_.GetHashCode(); }

  public override SimpleValue_5 ^Copy() { return new GChar_5(c_); }

  public override RValue_5 ^Convert(ref RValue_5 ^this_own, GType_5 t) {
    return t == GInt_5.type_ ? new GInt_5(c_) : base.Convert(ref this_own, t);
  }

  public override string ToString() { return c_.ToString(); }

  public static string Emit(char c) {
    switch (c) {
      case '\0': return "\\0";
      case '\n': return "\\n";
      case '\r': return "\\r";
      case '\t': return "\\t";
      case '\'': return "\\'";
      case '\"': return "\\\"";
      case '\\': return "\\\\";
    }
    if (c < 32) {
      Debug.Assert(false); return null;
    }
    return c.ToString();
  }

  public override string Emit() {
    return String.Format("'{0}'", Emit(c_));
  }
}

abstract class LocationOrRef_5 : ValueOrLocation_5 {
  public abstract Location_5 GetLoc();
}

class Location_5 : LocationOrRef_5 {
  public RValue_5 ^value_;

  public Location_5(RValue_5 ^val) { value_ = val; }

  public override GValue_5 Get() { return value_.Get(); }

  public override Location_5 GetLoc() { return this; }
}

// We allocate a LocationRef_5 when we need an owning reference to a Location_5 which we don't own.
class LocationRef_5 : LocationOrRef_5 {
  public readonly Location_5 location_;

  public LocationRef_5(Location_5 loc) { location_ = loc; }

  public override GValue_5 Get() { return location_.Get(); }

  public override Location_5 GetLoc() { return location_; }
}

class MapNode_5 {
  public readonly MapNode_5 ^next_;
  public readonly object key_;
  public ValueOrLocation_5 ^value_;   // (must appear after next_ so it will be destroyed first)

  public MapNode_5(object key, ValueOrLocation_5 ^value, MapNode_5 ^next) {
    key_ = key; value_ = value; next_ = next;
  }
}

class Map_5 {
  MapNode_5 ^nodes_;

  protected MapNode_5 Find1(object key) {
    for (MapNode_5 n = nodes_; n != null; n = n.next_)
      if (n.key_ == key)
        return n;
    return null;
  }

  protected virtual MapNode_5 Find(object key) {
    MapNode_5 n = Find1(key);
    Debug.Assert(n != null);
    return n;
  }

  public RValue_5 ^Get(object key) {
    return Find(key).value_.Get().CopyRef();
  }

  public RValue_5 ^Take_5(object key) {
    MapNode_5 n = Find(key);
    LocationOrRef_5 l = n.value_ as LocationOrRef_5;
    if (l != null)
      return take l.GetLoc().value_;
    return (RValue_5) take n.value_;
  }

  public void Set(object key, RValue_5 ^val) {
    MapNode_5 n = Find(key);
    LocationOrRef_5 l = n.value_ as LocationOrRef_5;
    if (l != null)
      l.GetLoc().value_ = val;
    else n.value_ = val;
  }

  public void Add(object key, ValueOrLocation_5 ^val) {
    nodes_ = new MapNode_5(key, val, take nodes_);
  }

  public Location_5 GetLocation(object key) {
    MapNode_5 n = Find(key);
    LocationOrRef_5 l = n.value_ as LocationOrRef_5;
    if (l != null)
      return l.GetLoc();
    Location_5 ^loc1 = new Location_5((RValue_5) take n.value_);
    Location_5 loc = loc1;
    n.value_ = loc1;
    return loc;
  }
}

class GObject_5 : GValue_5 {
  public readonly Class_5 class_;   // the class of this object

  Map_5 ^map_ = new Map_5();

  public GObject_5(Class_5 cl) {
    class_ = cl;
    while (cl != null) {
      foreach (Field_5 f in cl.fields_)
        map_.Add(f, f.Type().DefaultValue_5().Copy() );
      cl = cl.Parent();
    }
  }

  // the type of this object
  public override GType_5 Type() { return class_; }

  public override RValue_5 ^Get(Field_5 field) { return map_.Get(field); }
  public override RValue_5 ^Take_5(Field_5 field) { return map_.Take_5(field); }
  public void Set(Field_5 field, RValue_5 ^val) { map_.Set(field, val); }
  public Location_5 GetLocation(Field_5 field) { return map_.GetLocation(field); }

  public override int DefaultHashCode() { return base.GetHashCode(); }
  public override int GetHashCode() {
    GInt_5 ^i = (GInt_5) Invocation_5.InvokeMethod(this, GObject_5.type_.get_hash_code_, new ArrayList(), true);
    return i.i_;
  }

  public override bool DefaultEquals(object o) { return base.Equals(o); }
  public override bool Equals(object o) {
    GValue_5 v = o as GValue_5;
    if (v == null)
      return false;

    ArrayList ^args = new ArrayList();
    args.Add(v.CopyRef());
    GBool_5 ^b = (GBool_5) Invocation_5.InvokeMethod(this, GObject_5.type_.equals_, args, true);
    return b.b_;
  }

  public override string DefaultToString() { return String.Format("<object {0}>", class_.name_); }
  public override string ToString() {
    GString_5 ^s = (GString_5) Invocation_5.InvokeMethod(this, GObject_5.type_.to_string_, new ArrayList(), true);
    return s.s_;
  }

  // the Object class
  public static readonly ObjectClass_5 ^type_ = new ObjectClass_5();
}

class NullType_5 : GType_5 {
  public override string ToString() { return "null_type"; }

  public override SimpleValue_5 DefaultValue_5() { Debug.Assert(false); return null; }

  public override bool IsSubtype(GType_5 t1) {
    return t1.IsReference();
  }

  protected override bool CanConvertOwnership(GType_5 t, int context) {
    return true;    // conversion from null type to owning type is okay
  }

  public override string EmitType() { Debug.Assert(false); return null; }
}

class Null_5 : SimpleValue_5 {
  public Null_5() { }

  public static readonly NullType_5 ^type_ = new NullType_5();

  public override GType_5 Type() { return type_; }

  public override bool Equals(object o) {
    return o is Null_5;
  }

  public override SimpleValue_5 ^Copy() { return new Null_5(); }

  public override int GetHashCode() { return 0; }

  public static readonly Null_5 ^Instance = new Null_5();

  public override string ToString() { return ""; }

  public override string Emit() { return "0"; }
}

class Owning_5 : GType_5 {
  GType_5 base_type_;

  public Owning_5(GType_5 type) {
    base_type_ = type;
  }

  public override Class_5 Parent() { Debug.Assert(false); return null; }

  public override SimpleValue_5 DefaultValue_5() { return Null_5.Instance; }

  public override GType_5 BaseType() { return base_type_; }

  public override TypeSet_5 VarDestroys() { return base_type_.TypeDestroys(); }

  public override void FindVarDestroys(int marker, TypeSet_5 set) {
    base_type_.FindTypeDestroys(marker, set);
  }

  public override bool Equals(object o) {
    Owning_5 t = o as Owning_5;
    return t != null && t.base_type_.Equals(base_type_);
  }

  public override int GetHashCode() { return base_type_.GetHashCode() * 87; }

  public override string ToString() { return base_type_.ToString() + " ^"; }

  public override string EmitTypeName() {
    return base_type_.EmitTypeName();
  }

  string EmitType(string name) {
    return ConstructType(base_type_ == GObject_5.type_ ? "_OwnRef" : "_Own", name);
  }

  public override string EmitType() {
    // We represent an object ^ using a _OwnRef<Object>.
    // We represent a Foo ^ using an _Own<Foo>.
    return EmitType(EmitTypeName());
  }

  public override string EmitGenericType() {
    // We represent an object ^ [] using an _Array<_OwnRef<Object>>.
    // We represent a Foo ^ [] using an _Array<_Own<Object>>.
    return EmitType("Object");
  }
}

class OwningExpr_5 : TypeExpr_5 {
  readonly TypeExpr_5 ^expr_;

  public OwningExpr_5(TypeExpr_5 ^expr) { expr_ = expr; }

  public override TypeExpr_5 ^Copy() { return new OwningExpr_5(expr_.Copy()); }

  public override GType_5 Resolve(Program_5 program) {
    GType_5 t = expr_.Resolve(program);
    if (t == null)
        return null;
    if (t.IsValue()) {
      Error("^ cannot be applied to primitive types or strings");
      return null;
    }
    return t.OwningType();
  }
}

class GString_5 : SimpleValue_5 {
  public readonly string s_;

  public GString_5(string s) { s_ = s; }

  public static readonly StringClass_5 ^type_ = new StringClass_5();

  public override GType_5 Type() { return type_; }

  public override bool Equals(object o) {
    GString_5 s = o as GString_5;
    return s != null && s.s_ == s_;
  }

  public override SimpleValue_5 ^Copy() { return new GString_5(s_); }

  public override int GetHashCode() { return s_.GetHashCode(); }

  public override string ToString() { return s_; }

  public override RValue_5 ^Invoke(Method_5 m, ValueList_5 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StartsWith": return new GBool_5(s_.StartsWith(args.GetString(0)));
      case "EndsWith": return new GBool_5(s_.EndsWith(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public static string EmitStringConst(string s) {
    return String.Format("L{0}", EmitString(s));
  }

  public static string EmitString(string s) {
    StringBuilder ^sb = new StringBuilder();
    sb.Append('"');
    for (int i = 0; i < s.Length; ++i)
      sb.Append(GChar_5.Emit(s[i]));
    sb.Append('"');
    return sb.ToString();
  }

  public override string Emit() {
    string s = String.Format("new String({0})", EmitStringConst(s_));
    s = String.Format("_Ref<String>({0}).Get()", s);
    return s;
  }
}

abstract class Ownable_5 : GType_5 {
  Owning_5 ^owning_type_;

  public override Owning_5 OwningType() {
    if (owning_type_ == null)
      owning_type_ = new Owning_5(this);
    return owning_type_;
  }
}

class ArrayType_5 : Ownable_5 {
  GType_5 element_type_;

  public ArrayType_5(GType_5 type) {
    element_type_ = type;

    // Any type used generically must inherit from Object in C++ code.
    type.BaseType().SetObjectInherit();
  }

  public override bool IsOwned() { return true; }

  public override Class_5 Parent() { return GArray_5.array_class_; }

  public override SimpleValue_5 DefaultValue_5() { return Null_5.Instance; }

  public GType_5 ElementType() { return element_type_; }

  public override bool Equals(object o) {
    ArrayType_5 t = o as ArrayType_5;
    return (t != null && t.element_type_.Equals(element_type_));
  }

  public override TypeSet_5 TypeDestroys() { return element_type_.VarDestroys(); }

  public override void FindTypeDestroys(int marker, TypeSet_5 set) {
    element_type_.FindVarDestroys(marker, set);
  }

  public override int GetHashCode() { return element_type_.GetHashCode() * 77; }

  public override string EmitTypeName() {
    return ConstructType("_Array", element_type_.EmitGenericType());  
  }

  public override string ToString() {
    return element_type_.ToString() + "[]";
  }
}

class ArrayTypeExpr_5 : TypeExpr_5 {
  readonly TypeExpr_5 ^expr_;
  GType_5 ^type_;

  public ArrayTypeExpr_5(TypeExpr_5 ^expr) { expr_ = expr; }

  public override TypeExpr_5 ^Copy() { return new ArrayTypeExpr_5(expr_.Copy()); }

  public override GType_5 Resolve(Program_5 program) {
    GType_5 t = expr_.Resolve(program);
    return t == null ? null : (type_ = new ArrayType_5(t));
  }
}

class GArray_5 : GValue_5 {
  ArrayType_5 type_;

  ValueOrLocation_5^[] ^elements_;   // each element is a GValue_5 or a Location_5

  public override GType_5 Type() { return type_; }

  public GArray_5(ArrayType_5 type, int count) {
    type_ = type;
    elements_ = new ValueOrLocation_5^[count];
    for (int i = 0 ; i < count ; ++i)
      elements_[i] = type_.ElementType().DefaultValue_5().Copy();
  }

  void CheckIndex(int index) {
    if (index < 0 || index >= elements_.Length) {
      Console.WriteLine("error: array access out of bounds");
      Gel_5.Exit();
    }
  }

  public RValue_5 ^Get(int index) {
    CheckIndex(index);
    return elements_[index].Get().CopyRef();
  }

  public RValue_5 ^Take_5(int index) {
    CheckIndex(index);
    Location_5 loc = elements_[index] as Location_5;
    if (loc != null)
      return take loc.value_;
    return (RValue_5) (take elements_[index]);
  }

  public void Set(int index, RValue_5 ^val) {
    CheckIndex(index);
    Location_5 loc = elements_[index] as Location_5;
    if (loc != null)
      loc.value_ = val;
    else elements_[index] = val;
  }

  public Location_5 GetLocation(int index) {
    CheckIndex(index);
    Location_5 loc = elements_[index] as Location_5;
    if (loc != null)
      return loc;
    Location_5 ^loc1 = new Location_5((RValue_5) take elements_[index]);
    loc = loc1;
    elements_[index] = loc1;
    return loc;
  }

  public static readonly ArrayClass_5 ^array_class_ = new ArrayClass_5();

  public override RValue_5 ^Invoke(Method_5 m, ValueList_5 args) {
    if (m.GetClass() != array_class_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "CopyTo":
        GArray_5 a = (GArray_5) args.Object(0);
        if (!type_.Equals(a.type_)) {
          Console.WriteLine("error: can't copy between arrays of different types");
          Gel_5.Exit();
        }
        if (a.type_.ElementType() is Owning_5) {
          Console.WriteLine("error: can't copy to owning array");
          Gel_5.Exit();
        }
        // should check for index out of bounds here!
        int dest = args.Int(1);
        for (int i = 0 ; i < elements_.Length ; ++i)
          a.Set(dest + i, Get(i));
        return null;
      case "get_Length":
        return new GInt_5(elements_.Length);
      default:
        Debug.Assert(false); return null;
    }
  }
}

// A control graph object representing temporary variables destroyed when a top-level
// expression completes evaluation. 
class Temporaries_5 : Node_5 {
  NonOwningArrayList /* of GType_5 */ ^types_ = new NonOwningArrayList();
  TypeSet_5 ^destroys_;

  public void Add(GType_5 t) {
    Debug.Assert(t is Owning_5);
    types_.Add(t.BaseType());
  }

  public override TypeSet_5 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_5();
    foreach (GType_5 t in types_)
        destroys_.Add(t.TypeDestroys());
    }
    return destroys_;
  }
}

class Context_5 {
  public readonly Program_5 program_;   // containing program
  public readonly Class_5 class_;       // containing class
  public readonly Method_5 method_;     // containing method
  public readonly Escapable_5 escape_;  // containing switch, while, do, for, or foreach
  public readonly Loop_5 loop_;         // containing while, do, for, or foreach
  public Local_5 var_;    // chain of local variable declarations

  // subexpressions of the current top-level expression possibly yielding temporary objects
  NonOwningArrayList /* of Expression_5 */ ^temporaries_ = new NonOwningArrayList();

  public Context_5(Program_5 program) { program_ = program; }

  public Context_5(Class_5 cl) { program_ = cl.GetProgram(); class_ = cl; }

  // Copy a context; new variable declarations in either copy will not be visible in the other.
  public Context_5(Context_5 cx) {
    program_ = cx.program_;
    class_ = cx.class_;
    method_ = cx.method_;
    escape_ = cx.escape_;
    loop_ = cx.loop_;
    var_ = cx.var_;
  }

  public Context_5(Context_5 cx, Class_5 c) : this(cx) { class_ = c; }

  public Context_5(Context_5 cx, Method_5 m) : this(cx) { method_ = m; }

  public Context_5(Context_5 cx, Loop_5 l) : this(cx) {
    escape_ = l;
    loop_ = l;
  }

  public Context_5(Context_5 cx, Switch_5 s) : this(cx) { escape_ = s; }

  public bool IsStatic() { return method_ == null || method_.IsStatic(); }

  public void SetVar(Local_5 var) {
    var_ = var;
  }

  public Local_5 FindVar(string name) {
    for (Local_5 v = var_; v != null; v = v.next_)
      if (v.name_ == name)
        return v;
    return null;
  }

  public Control_5 Prev() { return program_.prev_; }

  public void SetPrev(Control_5 c) {
    Debug.Assert(c != null);
    program_.prev_ = c;
  }

  public void ClearPrev() { program_.prev_ = null; }

  // Called when we begin type-checking a top-level expression.
  public void EnterExpression() {
    Debug.Assert(temporaries_.Count == 0);
  }

  public void AddTemporary(Expression_5 e) {
    temporaries_.Add(e);
  }

  // Called when we've finished type-checking a top-level expression.
  public void FinishExpression() {
    Temporaries_5 t = null;
    foreach (Expression_5 e in temporaries_)
      if (!e.LosesOwnership()) {
        if (t == null)
          t = class_.NewTemporaries();
        t.Add(e.TemporaryType());
      }
    if (t != null)
      t.AddControl(this);
    temporaries_.Clear();
  }
}

class Env_5 : Map_5 {
  public readonly GValue_5 this_;
  readonly Env_5 next_;

  public Env_5(GValue_5 _this) { this_ = _this; next_ = null; }
  public Env_5(Env_5 next) { this_ = next.this_; next_ = next; }

  protected override MapNode_5 Find(object key) {
    for (Env_5 e = this; e != null; e = e.next_) {
      MapNode_5 n = e.Find1(key);
      if (n != null)
        return n;
    }
    Debug.Assert(false);
    return null;
  }

  public static readonly Env_5 ^static_ = new Env_5((GValue_5) null);
}

class TypeLiteral_5 : TypeExpr_5 {
  public readonly GType_5 type_;

  public TypeLiteral_5(GType_5 type) { type_ = type; }

  public override GType_5 Resolve(Program_5 program) {
    return type_;
  }

  public override TypeExpr_5 ^Copy() { return new TypeLiteral_5(type_); }
}

class TypeName_5 : TypeExpr_5 {
  string name_;

  public TypeName_5(string name) { name_ = name; }

  public override GType_5 Resolve(Program_5 program) {
    GType_5 type = program.FindClass(name_);
    if (type == null)
      Error("unknown type: {0}", name_);
    return type;
  }

  public override TypeExpr_5 ^Copy() { return new TypeName_5(name_); }
}

abstract class Traverser_5 {
  // Handle a graph item found in a depth first search; returns one of the exit codes below.
  public abstract int Handle(Control_5 control);

  public const int Continue_5 = 0,  // continue searching, including children of this node
                   Cut = 1,       // continue searching, excluding children of this node
                   Abort = 2;     // abort the search

}

// an item in the control graph: either a Node_5 or Joiner_5
abstract class Control_5 : Syntax_5 {
  public int marker_ = 0;    // marker for depth first search of control flow graph

  static int marker_value_ = 0;
  public static int GetMarkerValue() { return ++marker_value_; }

  // A node representing unreachability.  We could represent this using null, but it's
  // clearer to have this be explicit. 
  public static readonly Node_5 ^unreachable_ = new Node_5();

  // A helper function for Traverse.  If_5 we return true then we should cut the
  // traversal at this point.
  protected bool Visit(Traverser_5 traverser, int marker, out bool ok) {
    ok = true;
    if (marker_ == marker)
      return true;  // we've already seen this node
    marker_ = marker;
    int code = traverser.Handle(this);
    if (code == Traverser_5.Abort)
      ok = false;
    return (code != Traverser_5.Continue_5);
  }

  // Perform a depth-first search of the graph starting with this item, calling the
  // given Traverser_5 for each Node_5 found.  Returns false if the search was aborted.
  public abstract bool Traverse(Traverser_5 traverser, int marker);
}

// A node in the control graph.
class Node_5 : Control_5 {
  public Control_5 prev_;   // previous item in graph

  // add this node to the control graph
  public bool AddControl(Context_5 ctx) {
    Control_5 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      prev_ = prev;
      ctx.SetPrev(this);
      return true;
    }
    else return false;
  }

  // If_5 this node calls a method or constructor then return it; otherwise return null.
  // implementers: LValue_5, Invocation_5, New_5, Assign_5, Constructor_5
  public virtual Method_5 Calls() { return null; }

  // Return_5 the set of types which this node may destroy.
  // implementers: Assign_5, RefOutArgument_5, Scoped_5, Temporaries_5
  public virtual TypeSet_5 NodeDestroys() { return TypeSet_5.empty_; }

  // Return_5 true if this node assigns a value to the given Local_5.
  // implementers: Assign_5, RefOutArgument_5, VariableDeclaration_5, Method_5, ForEach_5
  public virtual bool Sets(Local_5 local) { return false; }

  // Return_5 true if this node takes ownership from the given local.
  // implementers: Name_5
  public virtual bool Takes(Local_5 local) { return false; }

  public bool CanDestroy(GType_5 type) {
    Method_5 m = Calls();
    if (m != null && m.Destroys().Contains(type))
      return true;
    return NodeDestroys().Contains(type);
  }

  public override bool Traverse(Traverser_5 traverser, int marker) {
    Node_5 n = this;
    Control_5 prev = null;

    // Traverse nodes iteratively until we come to a Join; this efficiently avoids
    // making a recursive call on each successive node.
    while (n != null) {
      bool ok;
      if (n.Visit(traverser, marker, out ok))
        return ok;
      prev = n.prev_;
      n = prev as Node_5;
    }
    Debug.Assert(prev != null);  // a Traverser_5 must end traversal before we run off the end
    return prev.Traverse(traverser, marker);
  }
}

class Joiner_5 : Control_5 {
  NonOwningArrayList /* of Control_5 */ ^prev_ = new NonOwningArrayList();

  public void Join(Control_5 c) {
    Debug.Assert(c != null);
    if (c == unreachable_)
      return;
    if (prev_.Count == 0 || c != prev_[0])
      prev_.Add(c);
  }

  // add this joiner to the control graph
  public void AddControl(Context_5 ctx) {
    Control_5 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      Join(prev);
      ctx.SetPrev(this);
    }
  }

  // Once we've finished merging paths into a Joiner_5, if the Joiner_5 points to only a single path
  // then as an optimization we can discard the Joiner_5 and just use that path instead.
  public Control_5 Combine() {
    switch (prev_.Count) {
      case 0:
        prev_ = null;
        return unreachable_;
      case 1:
        Control_5 c = (Control_5) prev_[0];
        prev_ = null;
        return c;
      default: return this;
    }
  }

  public override bool Traverse(Traverser_5 traverser, int marker) {
    bool ok;
    if (Visit(traverser, marker, out ok))
      return ok;

    foreach (Control_5 p in prev_)
      if (!p.Traverse(traverser, marker))
        return false;  // aborted
    return true;
  }
}

class ExprKind_5 {
  public const int Value = 0,

  // either a local variable, or an expression whose value is derived from local variables
                   Local_5 = 1,

                   Field_5 = 2,
                   Property_5 = 3,
                   Indexer_5 = 4,
                   Type = 5;
}

class SourceWriter_5 {
  public readonly StreamWriter writer_;
  int indent_ = 0;

  public SourceWriter_5(StreamWriter writer) { writer_ = writer; }

  public void AddIndent() { ++indent_; }
  public void SubIndent() { --indent_; }

  public void Indent(int adjust) {
    for (int i = 0; i < 2 * indent_ + adjust; ++i)
      writer_.Write(' ');
  }

  public void Indent() { Indent(0); }

  public void Write(string s) { writer_.Write(s); }
  public void Write(string s, object arg) { writer_.Write(s, arg); }
  public void Write(string s, object arg1, object arg2) { writer_.Write(s, arg1, arg2); }
  public void Write(string s, object arg1, object arg2, object arg3) { writer_.Write(s, arg1, arg2, arg3); }

  public void IWrite(string s) { Indent(); Write(s); }
  public void IWrite(string s, object arg) { Indent(); Write(s, arg); }
  public void IWrite(string s, object arg1, object arg2) { Indent(); Write(s, arg1, arg2); }
  public void IWrite(string s, object arg1, object arg2, object arg3) { Indent(); Write(s, arg1, arg2, arg3); }

  public void WriteLine(string s) { writer_.WriteLine(s); }
  public void WriteLine(string s, object arg) { writer_.WriteLine(s, arg); }
  public void WriteLine(string s, object arg1, object arg2) { writer_.WriteLine(s, arg1, arg2); }
  public void WriteLine(string s, object arg1, object arg2, object arg3) { writer_.WriteLine(s, arg1, arg2, arg3); }

  public void IWriteLine(string s) { Indent(); WriteLine(s); }
  public void IWriteLine(string s, object arg) { Indent(); WriteLine(s, arg); }
  public void IWriteLine(string s, object arg1, object arg2) { Indent(); WriteLine(s, arg1, arg2); }
  public void IWriteLine(string s, object arg1, object arg2, object arg3) { Indent(); WriteLine(s, arg1, arg2, arg3); }

  public void OpenBrace() { WriteLine("{"); AddIndent(); }
  public void CloseBrace() { SubIndent(); IWriteLine("}"); }
}

class Usage_5 {
  public const int Used = 0, LosesOwnership = 1, Unused = 2;
}

abstract class Expression_5 : Node_5 {
  protected int usage_ = Usage_5.Used;

  // start_ and end_ mark the points in the control graph where this expression is evaluated and used,
  // respectively.  If_5 this expression's type is owned, we use this information to determine whether
  // we need to emit a reference count for this expression.
  Control_5 start_;
  Control_5 end_;

  public abstract GType_5 Check(Context_5 ctx);

  public GType_5 CheckTop(Context_5 ctx) {
    ctx.EnterExpression();
    GType_5 t = Check(ctx);
    ctx.FinishExpression();
    return t;
  }

  public GType_5 CheckAndHold(Context_5 ctx) {
    GType_5 t = Check(ctx);
    if (t != null)
      HoldRef(ctx);
    return t;
  }

  // A fancier checking protocol implemented by lvalues and used by certain callers.
  public virtual GType_5 Check(Context_5 ctx, bool read, bool write, bool type_ok) {
    return Check(ctx);
  }

  public virtual int Kind() { return ExprKind_5.Value; }
  public virtual bool IsRefOutParameter() { return false; }

  public virtual bool IsTrueLiteral() { return false; }
  public virtual bool IsFalseLiteral() { return false; }

  // If_5 this expression is a local variable (possibly cast to a different type),
  // then return that local; otherwise return null.
  public virtual Local_5 GetLocal() { return null; }

  // Return_5 the type of an expression yielding a temporary object.
  // (It might be convenient to generalize this to be able to return any expression's type.)
  public virtual GType_5 TemporaryType() { Debug.Assert(false); return null; }

  public void HoldRef(Context_5 ctx) {
    start_ = ctx.Prev();
    Debug.Assert(start_ != null);
  }

  public void ReleaseRef(Context_5 ctx) {
    end_ = ctx.Prev();
    Debug.Assert(end_ != null);
  }

  public abstract RValue_5 ^Eval(Env_5 env);

  public bool Check(Context_5 ctx, GType_5 t2) {
    GType_5 t = Check(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public bool CheckTop(Context_5 ctx, GType_5 t2) {
    GType_5 t = CheckTop(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public RValue_5 ^Eval(Env_5 env, GType_5 t) {
    RValue_5 ^r = Eval(env);
    GValue_5 v = r.Get();
    return v.Convert(ref r, t);
  }

  public bool EvalBool(Env_5 env) { return ((GBool_5) Eval(env)).b_; }

  public int EvalInt(Env_5 env) {
    RValue_5 ^r = Eval(env, GInt_5.type_);
    GInt_5 i = (GInt_5) r;
    return i.i_;
  }

  public double EvalDouble(Env_5 env) { return ((GDouble_5) Eval(env, GDouble_5.type_)).d_; }
  public float EvalFloat(Env_5 env) { return ((GFloat_5) Eval(env, GFloat_5.type_)).f_; }
  public string EvalString(Env_5 env) { return ((GString_5) Eval(env)).s_; }

  public virtual bool IsConstant() {
    return false;
  }

  public bool CheckConstant() {
    if (IsConstant())
      return true;
    Error("expression must be a constant");
    return false;
  }

  public bool LosesOwnership() { return usage_ == Usage_5.LosesOwnership; }

  public virtual void LoseOwnership() {
    usage_ = Usage_5.LosesOwnership;
  }

  public void SetUnused() {
    Debug.Assert(usage_ == Usage_5.Used);
    usage_ = Usage_5.Unused;
  }

  protected static string EmitAllocate(string type, string args, bool lose_ownership) {
    // If_5 an allocated object never loses ownership then it can be stack allocated.  We
    // can't emit "&Foo(...)" since standard C++ doesn't allow us to take the address
    // of a temporary (both GCC and Visual C++ will allow this, but will emit a warning).
    // So instead we call a function _Addr() to get the address.
    return String.Format(
      !lose_ownership ? "{0}({1})._Addr<{0} *>()" : "new {0}({1})",
      type, args);
  }

  public void CheckLoseOwnership(GType_5 from, GType_5 to) {
    if (to is Owning_5)
      LoseOwnership();
  }

  public abstract string Emit();    // return a C++ expression representing this GEL2 expression

  public bool NeedsRef(GType_5 type) {
    return Gel_5.program_.safe_ && type.IsOwned() && ExpressionTraverser_5.NeedRef(start_, end_, this, type);
  }

  // Emit this expression, adding a reference-counting _Ptr wrapper if needed.
  public string EmitRef(GType_5 type) {
    string s = Emit();
    if (NeedsRef(type))
      s = String.Format("{0}({1}).Get()", type.EmitType(), s);
    return s;
  }

  // Emit an implicit conversion from type [source] to type [dest].
  public static string EmitImplicit(GType_5 source, GType_5 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (!source.IsReference() && dest == GObject_5.type_) {   // a boxing conversion
      Class_5 c = (Class_5) source;
      return EmitAllocate(c.name_, val, loses_ownership);
    }

    if (source == GInt_5.type_ && dest == GFloat_5.type_)
      // an implicit conversion in GEL2, but C++ compilers may warn if we don't use a cast
      return String.Format("static_cast<float>({0})", val);
    
    return val;
  }

  // Emit this expression, converting implicitly from type [source] to type [dest].
  public string Emit(GType_5 source, GType_5 dest) {
    return EmitImplicit(source, dest, Emit(), LosesOwnership());
  }

  public string EmitRef(GType_5 source, GType_5 dest) {
    return EmitImplicit(source, dest, EmitRef(source), LosesOwnership());
  }

  public static string EmitExplicit(GType_5 source, GType_5 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (source.CanConvert(dest)) {
      string v = EmitImplicit(source, dest, val, loses_ownership);
      if (v != val)
        return v;

      // There's nothing to do, but we emit a static_cast anyway since a GEL2 programmer
      // may use a type cast for method call disambiguation; we want to pass such casts onward.
      return String.Format("static_cast<{0} >({1})", dest.EmitExprType(), val);
    }

    if (source.IsReference() && dest.IsReference()) {
      string s = String.Format("_Cast<{0} *>({1})", dest.EmitTypeName(), val);
      ArrayType_5 at = dest as ArrayType_5;
      if (at != null) {
        GType_5 element_type = at.ElementType();
        if (element_type.IsReference())
          s = String.Format("({0})->CheckType(&typeid({1}))", s, element_type.EmitType());
      }
      return s;
    }

    if (source == GObject_5.type_ && !dest.IsReference())  // unboxing conversion
      return String.Format("_Unbox<{0} *>({1})->Value()", ((Class_5) dest).name_, val);

    if (!source.IsReference() && !dest.IsReference())
      return String.Format("static_cast<{0}>({1})", dest.EmitType(), val);

    Debug.Assert(false);
    return null;
  }

  public string EmitExplicit(GType_5 source, GType_5 dest) {
    return EmitExplicit(source, dest, Emit(), LosesOwnership());
  }

  public virtual string EmitArrow(GType_5 t, Member_5 m) {
    return String.Format("({0})->", EmitRef(t));
  }

  // Emit this expression as a local or field initializer, implicitly casting to [type].
  public void EmitAsInitializer(SourceWriter_5 w, GType_5 initializer_type, GType_5 type) {
    // For_5 owning variables, we must emit an initializer of the form "Foo var(val)" since
    // _Own has no copy constructor and hence GCC won't allow "Foo var = val".  For_5 other
    // variables either form is valid, but we emit the second form since it looks clearer.
    w.Write(type is Owning_5 ? "({0})" : " = {0}", Emit(initializer_type, type));
  }

  // Given a value retrieved from a variable, emit an accessor call if needed.
  protected string OwnSuffix(GType_5 t) {
    if (t is Owning_5)
      return LosesOwnership() ? ".Take_5()" : ".Get()";
    if (t == GString_5.type_ || Gel_5.program_.safe_ && t.IsReference() )
      return ".Get()";
    return "";
  }

  // Given a value returned from a function call, emit a wrapper and/or accessor call if needed.
  protected string Hold(GType_5 t, string s) {
    if (t == GString_5.type_)
      return s + ".Get()";
    if (t is Owning_5)
      switch (usage_) {
        case Usage_5.Used:  // does not lose ownership; we need a freeing wrapper
          return String.Format("{0}({1}).Get()", t.EmitType(), s);
        case Usage_5.LosesOwnership:
          return s;
        case Usage_5.Unused:  // a top-level owning expression
          return "delete " + s;
        default: Debug.Assert(false); break;
      }
    return s;
  }
}

class Literal_5 : Expression_5 {
  public readonly SimpleValue_5 ^value_;

  public Literal_5(SimpleValue_5 ^v) { value_ = v; }

  public override bool IsTrueLiteral() {
    GBool_5 b = value_ as GBool_5;
    return b != null && b.b_;
  }

  public override bool IsFalseLiteral() {
    GBool_5 b = value_ as GBool_5;
    return b != null && !b.b_;
  }

  public override GType_5 Check(Context_5 ctx) { return value_.Type(); }

  public override RValue_5 ^Eval(Env_5 env) { return value_.Copy(); }

  public override bool IsConstant() { return true; }

  public override string Emit() { return value_.Emit(); }
}

// An LValue_5 is an expression which can be assigned to: a Name_5, Dot_5, or Sub_5.
//
// In the control graph, an LValue_5 represents a read; if an LValue_5 is written then
// some other node (e.g. an Assign_5) will appear representing the write.
abstract class LValue_5 : Expression_5 {
  public override GType_5 Check(Context_5 ctx) {
    return Check(ctx, true, false, false);
  }

  public abstract override GType_5 Check(Context_5 ctx, bool read, bool write, bool type_ok);

  public abstract GType_5 StorageType();

  public virtual bool IsLocal() { return false; }
  public virtual bool IsLocal(Local_5 l) { return false; }

  public abstract PropertyOrIndexer_5 GetPropertyOrIndexer();

  public override Method_5 Calls() {
    PropertyOrIndexer_5 pi = GetPropertyOrIndexer();
    return pi == null ? null : pi.Getter();
  }

  public virtual void ReleaseAll(Context_5 ctx) { }

  // For_5 LValues, evaluation proceeds in two stages: the caller first calls Eval1(), then
  // passes the resulting values to EvalGet(), EvalSet() and/or EvalLocation().  This_5 lets
  // us evaluate the left side of an assignment expression before evaluating the right side,
  // and also lets us get and then set an indexer without evaluating its expression twice.

  public abstract void Eval1(Env_5 env, out RValue_5 ^v1, out RValue_5 ^v2);
  public abstract RValue_5 ^EvalGet(Env_5 env, RValue_5 ^v1, RValue_5 ^v2);
  public abstract void EvalSet(Env_5 env, RValue_5 ^v1, RValue_5 ^v2, RValue_5 ^val);
  public abstract Location_5 EvalLocation(Env_5 env, RValue_5 ^v1, RValue_5 ^v2);

  public override RValue_5 ^Eval(Env_5 env) {
    RValue_5 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalGet(env, val1, val2);
  }

  public void EvalSet(Env_5 env, RValue_5 ^v) {
    RValue_5 ^val1, val2;
    Eval1(env, out val1, out val2);
    EvalSet(env, val1, val2, v);
  }

  public Location_5 EvalLocation(Env_5 env) {
    RValue_5 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalLocation(env, val1, val2);
  }

  public abstract string EmitSet(string val);

  public abstract string EmitLocation();
}

class Name_5 : LValue_5 {
  public readonly string name_;

  protected Local_5 local_;
  protected LMember_5 field_;  // a field or property

  public Name_5(string n) { name_ = n; }

  public override bool IsLocal() { return local_ != null; }
  public override bool IsLocal(Local_5 l) { return local_ == l; }
  public override bool IsRefOutParameter() { return local_ is RefOutParameter_5; }

  public override bool IsConstant() {
    Debug.Assert(local_ != null || field_ != null);   // make sure we were already type checked
    return field_ is ConstField_5;
  }

  public override GType_5 Check(Context_5 ctx, bool read, bool write, bool type_ok) {
    local_ = ctx.FindVar(name_);
    if (local_ != null) {
      // For_5 reads, we add this Name_5 node to the flow graph; for writes,
      // the caller must add a node which defines this Name_5.
      if (read)
        if (AddControl(ctx))
          local_.AddUse(this);
      if (write)
        local_.SetMutable();
      return local_.ReadType();
    }

    GType_5 cl = type_ok ? ctx.program_.FindClass(name_) : null;
    field_ = (LMember_5) ctx.class_.Lookup(this, ctx.class_, false, MemberKind_5.Field_5, name_, null, cl == null);
    if (field_ != null) {
      if (!field_.CheckAccess(this, ctx, write, true, !ctx.IsStatic()))
        return null;
      if (read) {
        // Only property reads have side effects we need to register in the control graph.
        if (field_ is Property_5)
          AddControl(ctx);
      }
      return field_.Type().BaseType();
    }

    return cl;
  }

  public override int Kind() {
    if (local_ != null)
      return ExprKind_5.Local_5;
    if (field_ is Field_5)
      return ExprKind_5.Field_5;
    if (field_ is Property_5)
      return ExprKind_5.Property_5;
    Debug.Assert(field_ == null);
    return ExprKind_5.Type;
  }

  public override Local_5 GetLocal() { return local_; }

  public override GType_5 StorageType() { return local_ != null ? local_.Type() : field_.Type(); }

  public override bool Takes(Local_5 local) {
    return local_ == local && LosesOwnership() && local.Type() is Owning_5;
  }

  public override PropertyOrIndexer_5 GetPropertyOrIndexer() { return field_ as Property_5; }

  public override void Eval1(Env_5 env, out RValue_5 ^v1, out RValue_5 ^v2) { v1 = v2 = null; }

  public override RValue_5 ^EvalGet(Env_5 env, RValue_5 ^v1, RValue_5 ^v2) {
    if (LosesOwnership() && StorageType() is Owning_5)
      return local_ != null ? env.Take_5(local_) : field_.Take_5(env.this_);
    else return local_ != null ? env.Get(local_) : field_.Get(env.this_);
  }

  public override void EvalSet(Env_5 env, RValue_5 ^v1, RValue_5 ^v2, RValue_5 ^val) {
    if (local_ != null)
      env.Set(local_, val);
    else field_.Set((GObject_5) env.this_, val);
  }

  public override Location_5 EvalLocation(Env_5 env, RValue_5 ^v1, RValue_5 ^v2) {
    return local_ != null ? env.GetLocation(local_) : field_.GetLocation((GObject_5) env.this_);
  }

  public override string Emit() {
    if (local_ != null) {
      string s = local_.Emit();
      return local_.IsWrapper() ? s + OwnSuffix(local_.Type()) : s;
    }
    if (field_ != null)
      return field_.Emit() + OwnSuffix(field_.Type());
    return name_;
  }

  public override string EmitSet(string val) {
    if (local_ != null)
      return String.Format("{0} = {1}", local_.Emit(), val);
    Debug.Assert(field_ != null);
    return field_.EmitSet(val);
  }

  public override string EmitLocation() {
    if (local_ != null)
      return "&" + local_.Emit();
    if (field_ != null)
      return "&" + field_.Emit();
    return "&" + name_;
  }
}

class Parenthesized_5 : Expression_5 {
  Expression_5 ^expr_;

  public Parenthesized_5(Expression_5 ^e) { expr_ = e; }

  public override GType_5 Check(Context_5 ctx) { return expr_.Check(ctx); }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_5 ^Eval(Env_5 env) { return expr_.Eval(env); }

  public override string Emit() { return String.Format("({0})", expr_.Emit()); }
}

class PredefinedType_5 : Expression_5 {
  Class_5 type_;

  public PredefinedType_5(Class_5 type) { type_ = type; }

  public override GType_5 Check(Context_5 ctx) { Debug.Assert(false); return null; }

  public override GType_5 Check(Context_5 ctx, bool read, bool write, bool type_ok) {
    Debug.Assert(type_ok);
    return type_;
  }

  public override int Kind() {
    return ExprKind_5.Type;
  }

  public override RValue_5 ^Eval(Env_5 env) { Debug.Assert(false); return null; }

  public override string Emit() { return type_.name_; }
}

class Dot_5 : LValue_5 {
  Expression_5 ^expr_;  // set to null for a static invocation
  GType_5 expr_type_;
  string name_;

  LMember_5 field_;

  public Dot_5(Expression_5 ^expr, string name) { expr_ = expr; name_ = name; }

  public override bool IsConstant() {
    Debug.Assert(field_ != null);   // make sure we were already type checked
    return field_ is ConstField_5;
  }

  public override GType_5 Check(Context_5 ctx, bool read, bool write, bool type_ok) {
    expr_type_ = expr_.Check(ctx, true, false, true);
    if (expr_type_ == null)
      return null;
    bool is_static = (expr_.Kind() == ExprKind_5.Type);
    if (is_static)
      expr_ = null;
    else expr_.HoldRef(ctx);

    field_ = (LMember_5) expr_type_.Lookup(this, ctx.class_, expr_ is Base_5,
                                         MemberKind_5.Field_5, name_, null, true);
    if (field_ == null)
      return null;

    if (!field_.CheckAccess(this, ctx, write, is_static, !is_static))
      return null;

    if (read) {
      // Only property reads have side effects we need to register in the control graph.
      // (For_5 writes the caller, such as Assign_5, will add its own node.)
      if (field_ is Property_5)
        AddControl(ctx);
      if (expr_ != null)
        expr_.ReleaseRef(ctx);
    }

    return field_.Type().BaseType();
  }

  public override void ReleaseAll(Context_5 ctx) {
    if (expr_ != null)
      expr_.ReleaseRef(ctx);
  }

  public override int Kind() {
    if (field_ is Field_5)
      return ExprKind_5.Field_5;
    if (field_ is Property_5)
      return ExprKind_5.Property_5;
    Debug.Assert(false);
    return 0;
  }

  public override GType_5 StorageType() { return field_.Type(); }

  public override PropertyOrIndexer_5 GetPropertyOrIndexer() { return field_ as Property_5; }

  public override void Eval1(Env_5 env, out RValue_5 ^v1, out RValue_5 ^v2) {
    v1 = v2 = null;
    if (expr_ != null) {  // instance field
      v1 = expr_.Eval(env);
      if (v1 is Null_5) {
        Error("attempted to access field of null object");
        Gel_5.Exit();
      }
    }
  }

  public override RValue_5 ^EvalGet(Env_5 env, RValue_5 ^v1, RValue_5 ^v2) {
    GValue_5 obj = v1 == null ? null : v1.Get();
    return LosesOwnership() && field_.Type() is Owning_5 ? field_.Take_5(obj) : field_.Get(obj);
  }

  public override void EvalSet(Env_5 env, RValue_5 ^v1, RValue_5 ^v2, RValue_5 ^val) {
    GObject_5 obj = v1 == null ? null : (GObject_5) v1.Get();
    field_.Set(obj, val);
  }

  public override Location_5 EvalLocation(Env_5 env, RValue_5 ^v1, RValue_5 ^v2) {
    return field_.GetLocation((GObject_5) v1);
  }

  string EmitPrefix() {
    return expr_ != null ?
      expr_.EmitArrow(expr_type_, field_) :  // instance access
      field_.GetClass().name_ + "::";   // static access
  }

  public override string Emit() {
    string s = EmitPrefix() + field_.Emit();
    GType_5 t = field_.Type();
    return field_ is Property_5 ? Hold(t, s) : s + OwnSuffix(t);
  }

  public override string EmitSet(string val) {
    return EmitPrefix() + field_.EmitSet(val);
  }

  public override string EmitLocation() {
    return "&" + EmitPrefix() + field_.Emit();
  }
}

class Mode_5 {
  public const int In = 0,
                   Ref = 1,
                   Out = 2;

  public static string ToString(int mode) {
    switch (mode) {
      case In: return "";
      case Ref: return "ref ";
      case Out: return "out ";
      default: Debug.Assert(false); return null;
    }
  }
}

abstract class Argument_5 : Node_5 {
  protected GType_5 type_;

  public GType_5 Type() { return type_; }

  public abstract int GetMode();
  public string TypeString() { return Mode_5.ToString(GetMode()) + type_.ToString(); }

  public abstract bool Check(Context_5 ctx);
  public abstract void FinishCall(Context_5 ctx);

  public abstract void AddEval(ArrayList a, Env_5 env, GType_5 t);

  public abstract string Emit(GType_5 t);
}

class InArgument_5 : Argument_5 {
  public readonly Expression_5 ^expr_;

  public InArgument_5(Expression_5 ^expr) { expr_ = expr; }
  public InArgument_5(GType_5 type) { type_ = type; }

  public override int GetMode() { return 0; }

  public override bool Check(Context_5 ctx) {
    if (type_ == null)
      type_ = expr_.CheckAndHold(ctx);
    return type_ != null;
  }

  public override void FinishCall(Context_5 ctx) {
    expr_.ReleaseRef(ctx);
  }

  public override void AddEval(ArrayList a, Env_5 env, GType_5 t) {
    a.Add(expr_.Eval(env, t));
  }

  public override string Emit(GType_5 t) {
    return expr_.EmitRef(type_, t);
  }
}

class RefOutArgument_5 : Argument_5 {
  public readonly int mode_;
  public readonly LValue_5 ^lvalue_;

  public RefOutArgument_5(int mode, LValue_5 ^lvalue) { mode_ = mode; lvalue_ = lvalue; }

  public override int GetMode() { return mode_; }

  public override bool Check(Context_5 ctx) {
    type_ = lvalue_.Check(ctx, mode_ == Mode_5.Ref, true, false);
    if (type_ == null)
      return false;
    if (lvalue_.Kind() == ExprKind_5.Indexer_5) {
      Error("can't pass indexer as ref or out argument");
      return false;
    }
    return true;
  }

  public override void FinishCall(Context_5 ctx) {
    AddControl(ctx);
  }

  public override bool Sets(Local_5 local) { return lvalue_.IsLocal(local); }

  public override TypeSet_5 NodeDestroys() { return lvalue_.StorageType().VarDestroys(); }

  public GType_5 StorageType() { return lvalue_.StorageType(); }

  public override void AddEval(ArrayList a, Env_5 env, GType_5 t) {
    a.Add(new LocationRef_5(lvalue_.EvalLocation(env)));
  }

  public override string Emit(GType_5 t) { return lvalue_.EmitLocation(); }
}

class Invocation_5 : Expression_5 {
  Expression_5 ^obj_;    // may be null
  GType_5 obj_type_;
  string name_;
  ArrayList /* of Argument_5 */ ^arguments_;

  Method_5 method_;

  public Invocation_5(Expression_5 ^obj, string name, ArrayList ^arguments) {
    obj_ = obj; name_ = name; arguments_ = arguments;
  }

  public static Method_5 CheckInvoke(Node_5 caller, Context_5 ctx, bool through_base, GType_5 type,
                                   string name, ArrayList /* of Argument_5 */ arguments,
                                   int kind) {
    foreach (Argument_5 arg in arguments)
      if (!arg.Check(ctx))
        return null;

    // Add the caller to the graph; this node represents the invocation itself.
    caller.AddControl(ctx);

    // Now we can release temporary expressions and add control graph nodes representing
    // assignments to ref and out parameters.
    foreach (Argument_5 arg in arguments)
      arg.FinishCall(ctx);

    Method_5 m = (Method_5) type.Lookup(caller, ctx.class_, through_base, kind, name, arguments, true);
    if (m != null)
      for (int i = 0; i < m.parameters_.Count; ++i) {
        Parameter_5 p = m.Param(i);
        if (p.GetMode() == Mode_5.In) {
          InArgument_5 a = (InArgument_5) arguments[i];
          a.expr_.CheckLoseOwnership(a.Type(), p.Type());
        }
      }
    return m;
  }

  public override GType_5 Check(Context_5 ctx) {
    GType_5 t;
    bool is_class = false;  // true when calling a static method using a class name

    if (obj_ == null)
      t = ctx.class_;
    else {
      t = obj_type_ = obj_.Check(ctx, true, false, true);
      if (t == null)
        return null;
      if (obj_.Kind() == ExprKind_5.Type)
        is_class = true;
      else obj_.HoldRef(ctx);
    }

    method_ = CheckInvoke(this, ctx, obj_ is Base_5, t, name_, arguments_, MemberKind_5.Method_5);
    if (method_ == null)
      return null;

    if (method_ is Constructor_5) {
      Error("can't call constructor directly");
      return null;
    }

    if (obj_ == null) {
      if (!method_.IsStatic() && ctx.IsStatic()) {
        Error("can't call instance method in static context");
        return null;
      }
    } else {
      obj_.ReleaseRef(ctx);
      if (is_class) {
        if (!method_.IsStatic()) {
          Error("can't invoke non-static method through class name");
          return null;
        }
      } else {
        if (method_.IsStatic()) {
          Error("can't invoke static method through object");
          return null;
        }
      }
    }

    GType_5 ret = method_.ReturnType();
    if (ret is Owning_5)
      ctx.AddTemporary(this);
    return ret;
  }

  public override GType_5 TemporaryType() { return method_.ReturnType(); }

  public override Method_5 Calls() { return method_; }

  public static RValue_5 ^InvokeMethod(GValue_5 obj, Method_5 m, ArrayList /* of RValue_5 */ values,
                                    bool virtual_ok) {
    if (m.IsVirtual() && virtual_ok) {
      GType_5 t = obj.Type();
      m = (Method_5) t.FindMatchingMember(m, true);
      Debug.Assert(m != null);
    }
    return m.Invoke(obj, values);
  }

  public static RValue_5 ^CallMethod(Env_5 env, GValue_5 obj,
                                  Method_5 m, ArrayList /* of Argument_5 */ args,
                                  bool virtual_ok) {
    ArrayList /* of ValueOrLocation_5 */ ^values = new ArrayList();
    int i;
    for (i = 0 ; i < args.Count ; ++i) {
      Argument_5 a = (Argument_5) args[i];
      a.AddEval(values, env, m.Param(i).Type());
    }
    return InvokeMethod(obj, m, values, virtual_ok);
  }

  public RValue_5 ^Eval(Env_5 env, Expression_5 obj, Method_5 m, ArrayList /* of Argument_5 */ args) {
    RValue_5 ^r;
    GValue_5 v;
    if (m.IsStatic())
      v = null;
    else {
      if (obj == null)
        v = env.this_;
      else {
        r = obj.Eval(env);
        v = r.Get();
        if (v is Null_5) {
          Error("attempted to call method on null object");
          Gel_5.Exit();
        }
      }
    }

    return CallMethod(env, v, m, args, !(obj is Base_5));
  }

  public override RValue_5 ^Eval(Env_5 env) {
    return Eval(env, obj_, method_, arguments_);
  }

  public static string EmitArguments(Method_5 m, ArrayList /* of Argument_5 */ arguments) {
    StringBuilder ^sb = new StringBuilder();
    Debug.Assert(m.parameters_.Count == arguments.Count);
    for (int i = 0; i < arguments.Count; ++i) {
      if (i > 0)
        sb.Append(", ");
      Argument_5 a = (Argument_5)arguments[i];
      sb.Append(a.Emit(m.Param(i).Type()));
    }
    return sb.ToString();
  }

  public override string Emit() {
    StringBuilder ^sb = new StringBuilder();
    if (obj_ != null) {
      if (method_.IsStatic())
        sb.AppendFormat("{0}::", obj_.Emit());
      else if (obj_type_.IsReference())
        sb.Append(obj_.EmitArrow(obj_type_, method_));
      else sb.AppendFormat("({0})->", obj_.Emit(obj_type_, GObject_5.type_));   // box values
    }
    sb.AppendFormat("{0} ({1})", method_.name_, EmitArguments(method_, arguments_));
    return Hold(method_.ReturnType(), sb.ToString());
  }
}

// an expression of the form a[b]
class Sub_5 : LValue_5 {
  readonly Expression_5 ^base_;
  GType_5 base_type_;
  readonly Expression_5 ^index_;
  GType_5 index_type_;

  GType_5 element_type_;    // for array accesses; null for indexers
  Indexer_5 indexer_;

  public Sub_5(Expression_5 ^base_exp, Expression_5 ^index) { base_ = base_exp; index_ = index; }

  public override GType_5 Check(Context_5 ctx, bool read, bool write, bool type_ok) {
    base_type_ = base_.CheckAndHold(ctx);
    if (base_type_ == null)
      return null;

    index_type_ = index_.CheckAndHold(ctx);
    if (index_type_ == null)
      return null;

    if (read)
      ReleaseAll(ctx);

    ArrayType_5 at = base_type_.BaseType() as ArrayType_5;
    if (at != null) {
      if (!index_type_.CheckConvert(this, GInt_5.type_))
        return null;
      element_type_ = at.ElementType();
      return element_type_.BaseType();
    }

    ArrayList ^arguments = new ArrayList();
    arguments.Add(new InArgument_5(index_type_));

    indexer_ = (Indexer_5) base_type_.Lookup(this, ctx.class_, base_ is Base_5,
                                           MemberKind_5.Indexer_5, null, arguments, true);
    if (indexer_ == null)
      return null;

    if (read && !indexer_.CheckAssigning(this, ctx, false) ||
        write && !indexer_.CheckAssigning(this, ctx, true))
      return null;

    if (read)
      AddControl(ctx);

    return indexer_.Type();
  }

  public override void ReleaseAll(Context_5 ctx) {
    base_.ReleaseRef(ctx);
    index_.ReleaseRef(ctx);
  }

  public override int Kind() {
    return element_type_ != null ? ExprKind_5.Field_5 : ExprKind_5.Indexer_5;
  }

  public override GType_5 StorageType() {
    return element_type_ != null ? element_type_ : indexer_.Type();
  }

  public override PropertyOrIndexer_5 GetPropertyOrIndexer() { return indexer_; }

  public override void Eval1(Env_5 env, out RValue_5 ^v1, out RValue_5 ^v2) {
    v1 = base_.Eval(env);
    if (v1 is Null_5) {
      Error("attempted array or indexer access through null");
      Gel_5.Exit();
    }
    v2 = index_.Eval(env);
  }

  int Index(RValue_5 ^v) {
    // ++ We get an ownership error if we combine the following two lines into one; why?
    v = v.Get().Convert(ref v, GInt_5.type_);
    return ((GInt_5) v).i_;
  }

  public override RValue_5 ^EvalGet(Env_5 env, RValue_5 ^v1, RValue_5 ^v2) {
    if (indexer_ == null) {
      GArray_5 arr = (GArray_5) v1.Get();
      int i = Index(v2);
      return LosesOwnership() && element_type_ is Owning_5 ? arr.Take_5(i) : arr.Get(i);
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    return Invocation_5.InvokeMethod(v1.Get(), indexer_.Getter(), args, true);
  }

  public override void EvalSet(Env_5 env, RValue_5 ^v1, RValue_5 ^v2, RValue_5 ^val) {
    if (indexer_ == null) {
      ((GArray_5) v1.Get()).Set(Index(v2), val);
      return;
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    args.Add(val);
    Invocation_5.InvokeMethod(v1.Get(), indexer_.Setter(), args, true);
  }

  public override Location_5 EvalLocation(Env_5 env, RValue_5 ^v1, RValue_5 ^v2) {
    int i = ((GInt_5) v2).i_;
    return ((GArray_5) v1).GetLocation(i);
  }

  string EmitBase() {
    return base_.EmitArrow(base_type_, indexer_);
  }

  string EmitIndex() {
    return index_.Emit(index_type_, indexer_ != null ? indexer_.parameter_.Type() : GInt_5.type_);
  }

  public override string Emit() {
    string get = String.Format("{0}get_Item({1})", EmitBase(), EmitIndex());
    if (element_type_ != null) {
      get = get + OwnSuffix(element_type_);
      if (!element_type_.IsValue())
        get = String.Format("static_cast<{0} >({1})", element_type_.EmitExprType(), get);
      return get;
    } else return Hold(indexer_.Type(), get);
  }

  public override string EmitSet(string val) {
    return String.Format(element_type_ != null ? "{0}get_Item({1}) = {2}" : "{0}set_Item({1}, {2})",
       EmitBase(), EmitIndex(), val);
  }

  public override string EmitLocation() {
    return String.Format("{0}get_location({1})", EmitBase(), EmitIndex());
  }
}

class This_5 : Expression_5 {
  public override GType_5 Check(Context_5 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access this in a static context");
      return null;
    }
    return ctx.class_;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    return new Reference_5(env.this_);
  }

  public override string Emit() { return "this"; }
}

class Base_5 : Expression_5 {
  Class_5 parent_;

  public override GType_5 Check(Context_5 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access base in a static context");
      return null;
    }
    parent_ = ctx.class_.Parent();
    if (parent_ == null) {
      Error("can't access base: class has no parent");
      return null;
    }
    return parent_;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    return new Reference_5(env.this_);
  }

  public override string Emit() { return "this"; }

  public override string EmitArrow(GType_5 t, Member_5 m) {
    return m.GetClass().name_ + "::"; 
  }
}

class New_5 : Expression_5 {
  Expression_5 ^creator_;    // either a pool or null
  TypeExpr_5 ^type_expr_;
  ArrayList /* of Expression_5 */ ^arguments_;

  Class_5 class_;
  Constructor_5 constructor_;

  public New_5(Expression_5 ^creator, TypeExpr_5 ^expr, ArrayList ^arguments) {
    creator_ = creator;
    type_expr_ = expr;
    arguments_ = arguments;
  }

  GType_5 Type() {
    return creator_ == null ? (GType_5) class_.OwningType() : class_;
  }

  public override GType_5 TemporaryType() { return Type(); }    

  public override GType_5 Check(Context_5 ctx) {
    if (creator_ != null) {
      GType_5 c = creator_.Check(ctx);
      if (c == null)
        return null;
      if (!c.BaseType().IsSubtype(PoolClass_5.instance_)) {
        Error("object creator must be a pool");
        return null;
      }
    }
    GType_5 t = type_expr_.Resolve(ctx.program_);
    if (t == null)
      return null;
    class_ = (Class_5) t;
    if (class_.HasAttribute(Attribute_5.Abstract)) {
      Error("can't instantiate abstract class");
      return null;
    }
    if (creator_ != null) {
      class_.NeedDestroy(); // every pool-allocated class needs the _Destroy1 and _Destroy2 methods
      class_.SetVirtual();  // every pool-allocated class must be virtual
    }

    constructor_ = (Constructor_5) Invocation_5.CheckInvoke(this, ctx, false, class_,
                                      class_.name_, arguments_, MemberKind_5.Constructor_5);
    if (constructor_ == null)
      return null;

    GType_5 type = Type();
    if (type is Owning_5)
      ctx.AddTemporary(this);
    return type;
  }

  public override Method_5 Calls() { return constructor_; }

  public override RValue_5 ^Eval(Env_5 env) {
    GValue_5 ^obj = class_.New_5();
    Invocation_5.CallMethod(env, obj, constructor_, arguments_, false);
    return obj;
  }

  public override string Emit() {
    string args = Invocation_5.EmitArguments(constructor_, arguments_);

    return creator_ == null ?
      EmitAllocate(class_.name_, args, LosesOwnership()) :
      String.Format("new ({0}->Alloc(sizeof({1}))) {1}({2})", creator_.Emit(), class_.name_, args);
  }
}

class ArrayInitializer_5 : Expression_5 {
  public readonly ArrayList /* of Expression_5 */ ^initializers_;

  public ArrayInitializer_5(ArrayList ^initializers) { initializers_ = initializers; }

  public override GType_5 Check(Context_5 ctx) {
    Error("only static fields may have array initializers");
    return null;
  }

  public bool CheckElements(Context_5 ctx, GType_5 element_type) {
    foreach (Expression_5 e in initializers_)
      if (!e.CheckConstant() || !e.Check(ctx, element_type))
        return false;
    return true;
  }

  public override RValue_5 ^Eval(Env_5 env) { Debug.Assert(false); return null; }

  public GArray_5 ^Eval(ArrayType_5 type) {
    GArray_5 ^a = new GArray_5(type, initializers_.Count);
    for (int i = 0; i < initializers_.Count; ++i) {
      Expression_5 e = (Expression_5) initializers_[i];
      a.Set(i, e.Eval(Env_5.static_, type.ElementType()));
    }
    return a;
  }

  public override string Emit() { Debug.Assert(false); return null; }

  public void Emit(SourceWriter_5 w) {
    int count = initializers_.Count;
    int per_row = 12;

    w.Write("{ ");
    if (count > per_row) {    // format onto multiple rows
      w.WriteLine("");
      w.AddIndent();
      w.Indent();
    }
    for (int i = 0; i < count; ++i) {
      if (i > 0) {
        w.Write(", ");
        if (i % per_row == 0) {
          w.WriteLine("");
          w.Indent();
        }
      }
      Expression_5 e = (Expression_5) initializers_[i];
      SimpleValue_5 ^v = (SimpleValue_5) e.Eval(Env_5.static_);
      w.Write(v.Emit());
    }
    if (count > per_row) {
      w.SubIndent();
      w.WriteLine("");
    }
    w.Write(" }");
  }
}

class NewArray_5 : Expression_5 {
  TypeExpr_5 ^element_type_expr_;
  int dimensions_;
  ArrayType_5 ^array_type_;

  Expression_5 ^count_;

  public NewArray_5(TypeExpr_5 ^element_type_expr, int dimensions, Expression_5 ^count) {
    element_type_expr_ = element_type_expr;
    dimensions_ = dimensions;
    count_ = count;
  }

  GType_5 Type() {
    return (GType_5) array_type_.OwningType();
  }

  public override GType_5 TemporaryType() { return Type(); }

  public override GType_5 Check(Context_5 ctx) {
    if (element_type_expr_ is ArrayTypeExpr_5) {
      Error("syntax error in new expression");
      return null;
    }
    for (int i = 0; i < dimensions_; ++i)
      element_type_expr_ = new ArrayTypeExpr_5(take element_type_expr_);
    GType_5 element_type = element_type_expr_.Resolve(ctx.program_);
    if (element_type == null)
      return null;
    array_type_ = new ArrayType_5(element_type);

    if (!count_.Check(ctx, GInt_5.type_))
      return null;

    GType_5 t = Type();
    if (t is Owning_5)
      ctx.AddTemporary(this);
    return t;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    return new GArray_5(array_type_, count_.EvalInt(env));
  }

  public override string Emit() {
    GType_5 t = array_type_.ElementType();
    string array_type = GType_5.ConstructType(
      t is Owning_5 ? "_Array" : "_CopyableArray",
      t.EmitGenericType());
    string args = String.Format("&typeid({0}), {1}", t.EmitType(), count_.Emit());
    return EmitAllocate(array_type, args, LosesOwnership());
  }
}

abstract class Unary_5 : Expression_5 {
  protected Expression_5 ^exp_;

  protected Unary_5(Expression_5 ^e) { exp_ = e; }

  public override bool IsConstant() { return exp_.IsConstant(); }
}

// unary minus operator
class Minus_5 : Unary_5 {
  GType_5 type_;

  public Minus_5(Expression_5 ^e) : base(e) { }

  public override GType_5 Check(Context_5 ctx) {
    type_ = exp_.Check(ctx);
    if (type_ != GInt_5.type_ && type_ != GFloat_5.type_ && type_ != GDouble_5.type_) {
      Error("- operator cannot be applied to value of type {0}", type_);
      return null;
    }
    return type_;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    if (type_ == GInt_5.type_) {
    int i = exp_.EvalInt(env);
    return new GInt_5(-i);
  }
    if (type_ == GFloat_5.type_) {
      float f = exp_.EvalFloat(env);
      return new GFloat_5(-f);
    }
    if (type_ == GDouble_5.type_) {
      double d = exp_.EvalDouble(env);
      return new GDouble_5(-d);
    }
    Debug.Assert(false);
    return null;
  }

  public override string Emit() { return "-" + exp_.Emit(); }
}

class Not_5 : Unary_5 {
  public Not_5(Expression_5 ^e) : base(e) { }

  public override GType_5 Check(Context_5 ctx) {
    return exp_.Check(ctx, GBool_5.type_) ? GBool_5.type_ : null;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    bool b = exp_.EvalBool(env);
    return new GBool_5(!b);
  }

  public override string Emit() { return "!" + exp_.Emit(); }
}

// the bitwise complement (~) operator
class Complement_5 : Unary_5 {
  public Complement_5(Expression_5 ^e) : base(e) { }

  public override GType_5 Check(Context_5 ctx) {
    return exp_.Check(ctx, GInt_5.type_) ? GInt_5.type_ : null;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    int i = exp_.EvalInt(env);
    return new GInt_5(~i);
  }

  public override string Emit() { return "~" + exp_.Emit(); }
}

class IncDec_5 : Expression_5 {
  bool pre_;    // true for pre-increment/decrement; false for post-increment/decrement
  bool inc_;
  LValue_5 ^lvalue_;

  public IncDec_5(bool pre, bool inc, LValue_5 ^lvalue) { pre_ = pre; inc_ = inc; lvalue_ = lvalue; }

  public override GType_5 Check(Context_5 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    GType_5 t = lvalue_.Check(ctx, true, true, false);
    if (t == null)
      return null;
    if (lvalue_.Kind() == ExprKind_5.Indexer_5) {
      Error("++ and -- can't yet operate on indexers");
      return null;
    }
    if (t != GInt_5.type_) {
      Error("++ and -- can operate only on integers");
      return null;
    }
    return GInt_5.type_;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    Location_5 loc = lvalue_.EvalLocation(env);
    GInt_5 ^i = (GInt_5) take loc.value_;
    loc.value_ = new GInt_5(inc_ ? i.i_ + 1 : i.i_ - 1);
    return pre_ ? ((GInt_5) loc.value_).Copy() : i;
  }

  string EmitOp() { return inc_ ? "++" : "--"; }

  public override string Emit() {
    return pre_ ? EmitOp() + lvalue_.Emit() : lvalue_.Emit() + EmitOp();
  }
}

abstract class Conversion_5 : Expression_5 {
  protected Expression_5 ^expr_;
  protected TypeExpr_5 ^type_expr_;

  protected GType_5 from_base_;
  protected GType_5 to_type_, to_base_;

  protected Conversion_5(Expression_5 ^expr, TypeExpr_5 ^type_expr) {
    expr_ = expr; type_expr_ = type_expr;
  }

  protected bool CheckConversion(Context_5 ctx, bool subtype_only) {
    GType_5 from = expr_.Check(ctx);
    if (from == null)
      return false;
    from_base_ = from.BaseType();

    to_base_ = type_expr_.Resolve(ctx.program_);
    if (to_base_ == null)
      return false;
    if (!to_base_.IsValue() &&
       (from is Owning_5 || from_base_.IsValue()))
      to_type_ = to_base_.OwningType();
    else to_type_ = to_base_;

    if (!from.CanConvertExplicit(to_type_, subtype_only)) {
      Error("can't convert from {0} to {1}", from_base_, to_base_);
      return false;
    }
    return true;
  }
}

class Cast_5 : Conversion_5 {
  public Cast_5(Expression_5 ^expr, TypeExpr_5 ^type_expr) : base(expr, type_expr) { }

  public override Local_5 GetLocal() { return expr_.GetLocal(); }
  
  public override GType_5 Check(Context_5 ctx) {
    return CheckConversion(ctx, false) ? to_type_ : null;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_5.Local_5 ? ExprKind_5.Local_5 : ExprKind_5.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_5 ^Eval(Env_5 env) {
    RValue_5 ^r = expr_.Eval(env);
    return r.Get().ConvertExplicit(ref r, to_base_);
  }

  public override string Emit() {
    return expr_.EmitExplicit(from_base_, to_type_);
  }
}

class Binary_5 : Expression_5 {
  int op_;
  Expression_5 ^left_, right_;
  GType_5 left_type_, right_type_;
  GType_5 type_;

  const int CONCATENATE = 0;

  public Binary_5(Expression_5 ^left, int op, Expression_5 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public static GType_5 Promote(Syntax_5 caller, GType_5 left, int op, GType_5 right) {
    if (left.CanConvert(GInt_5.type_) && right.CanConvert(GInt_5.type_))
      return GInt_5.type_;
    if (left.CanConvert(GFloat_5.type_) && right.CanConvert(GFloat_5.type_))
      return GFloat_5.type_;
    if (left.CanConvert(GDouble_5.type_) && right.CanConvert(GDouble_5.type_))
      return GDouble_5.type_;
    caller.Error("can't apply operator {0} to operands of type {1} and {2}", OpName(op), left, right);
    return null;
  }

  bool CheckIntArgs() {
    if (left_type_.CheckConvert(this, GInt_5.type_) && right_type_.CheckConvert(this, GInt_5.type_)) {
      type_ = GInt_5.type_;
      return true;
    }
    return false;
  }

  public override GType_5 Check(Context_5 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);

    if (op_ == '+' && (left_type_ == GString_5.type_ || right_type_ == GString_5.type_)) {
      op_ = CONCATENATE;

      // If_5 we'll be calling ToString() on a class, ensure that it will inherit from
      // Object in generated code.
      if (left_type_ != GString_5.type_)
        left_type_.CanConvert(GObject_5.type_);
      if (right_type_ != GString_5.type_)
        right_type_.CanConvert(GObject_5.type_);

      return GString_5.type_;
    }

    switch (op_) {
      case '*':
      case '/':
      case '+':
      case '-':
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_;

      case '%':
      case Parser.OP_LEFT_SHIFT:
      case Parser.OP_RIGHT_SHIFT:
        return CheckIntArgs() ? GInt_5.type_ : null;

      case '&':
      case '|':
        if (left_type_ == GBool_5.type_ && right_type_ == GBool_5.type_)
          type_ = GBool_5.type_;
        else {
          if (!CheckIntArgs())
            return null;
          type_ = GInt_5.type_;
        }
        return type_;

      case '<':
      case Parser.OP_LE:
      case '>':
      case Parser.OP_GE:
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_ == null ? null : GBool_5.type_;

      default:
        Debug.Assert(false);
        return null;
    }
  }

  public static GBool_5 ^BoolOp(bool x, int op, bool y) {
    switch (op) {
      case '&': return new GBool_5(x & y);
      case '|': return new GBool_5(x | y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_5 ^IntOp(int x, int op, int y) {
    switch (op) {
      case '*': return new GInt_5(x * y);
      case '/': return new GInt_5(x / y);
      case '%': return new GInt_5(x % y);
      case '+': return new GInt_5(x + y);
      case '-': return new GInt_5(x - y);
      case Parser.OP_LEFT_SHIFT: return new GInt_5(x << y);
      case Parser.OP_RIGHT_SHIFT: return new GInt_5(x >> y);
      case '&': return new GInt_5(x & y);
      case '|': return new GInt_5(x | y);
      case '<': return new GBool_5(x < y);
      case Parser.OP_LE: return new GBool_5(x <= y);
      case '>': return new GBool_5(x > y);
      case Parser.OP_GE: return new GBool_5(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_5 ^FloatOp(float x, int op, float y) {
    switch (op) {
      case '*': return new GFloat_5(x * y);
      case '/': return new GFloat_5(x / y);
      case '+': return new GFloat_5(x + y);
      case '-': return new GFloat_5(x - y);
      case '<': return new GBool_5(x < y);
      case Parser.OP_LE: return new GBool_5(x <= y);
      case '>': return new GBool_5(x > y);
      case Parser.OP_GE: return new GBool_5(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_5 ^DoubleOp(double x, int op, double y) {
    switch (op) {
      case '*': return new GDouble_5(x * y);
      case '/': return new GDouble_5(x / y);
      case '+': return new GDouble_5(x + y);
      case '-': return new GDouble_5(x - y);
      case '<': return new GBool_5(x < y);
      case Parser.OP_LE: return new GBool_5(x <= y);
      case '>': return new GBool_5(x > y);
      case Parser.OP_GE: return new GBool_5(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public override RValue_5 ^Eval(Env_5 env) {
    if (op_ == CONCATENATE)
      return new GString_5(left_.Eval(env).ToString() + right_.Eval(env).ToString());

    if (type_ == GBool_5.type_)
      return BoolOp(left_.EvalBool(env), op_, right_.EvalBool(env));
    if (type_ == GInt_5.type_)
      return IntOp(left_.EvalInt(env), op_, right_.EvalInt(env));
    if (type_ == GFloat_5.type_)
      return FloatOp(left_.EvalFloat(env), op_, right_.EvalFloat(env));
    if (type_ == GDouble_5.type_)
      return DoubleOp(left_.EvalDouble(env), op_, right_.EvalDouble(env));

    Debug.Assert(false);
    return null;
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  static string OpName(int op) {
    switch (op) {
      case Parser.OP_LEFT_SHIFT: return "<<";
      case Parser.OP_RIGHT_SHIFT: return ">>";
      case Parser.OP_LE: return "<=";
      case Parser.OP_GE: return ">=";
      default: return ((char) op).ToString();
    }
  }

  public override string Emit() {
    if (op_ == CONCATENATE)
      return Hold(GString_5.type_,
        String.Format("String::_Concat({0}, {1})",
          left_.EmitRef(left_type_, GObject_5.type_), right_.Emit(right_type_, GObject_5.type_)));

    return String.Format("{0} {1} {2}",
      left_.EmitRef(left_type_), OpName(op_), right_.Emit() );
  }
}

class Equality_5 : Expression_5 {
  bool equal_;    // true for ==, false for !=
  Expression_5 ^left_, right_;
  GType_5 left_type_, right_type_, type_;

  public Equality_5(Expression_5 ^left, int op, Expression_5 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_EQUAL: equal_ = true; break;
      case Parser.OP_NE: equal_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_5 Check(Context_5 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);
    if (left_type_.IsReference() != right_type_.IsReference()) {
      Error("can't compare types {0} and {1}", left_type_, right_type_);
      return null;
    }
    type_ = left_type_.BaseType().CommonType(this, right_type_.BaseType());
    return type_ == null ? null : GBool_5.type_;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    RValue_5 ^left = left_.Eval(env, type_);
    RValue_5 ^right = right_.Eval(env, type_);
    bool eq = left.Get().DefaultEquals(right.Get());
    return new GBool_5(equal_ ? eq : !eq);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    string emit_left = left_.EmitRef(left_type_);
    string emit_right = right_.Emit();
    if (type_ == GString_5.type_)
      return String.Format("{0}String::_Equals({1}, {2})",
                           equal_ ? "" : "!", emit_left, emit_right);
    return String.Format("{0} {1} {2}", emit_left, equal_ ? "==" : "!=", emit_right);
  }
}

class Is_5 : Conversion_5 {
  public Is_5(Expression_5 ^expr, TypeExpr_5 ^type_expr) : base(expr, type_expr) { }

  public override GType_5 Check(Context_5 ctx) {
    return CheckConversion(ctx, true) ? GBool_5.type_ : null;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    RValue_5 ^r = expr_.Eval(env);
    GValue_5 v = r.Get();
    return new GBool_5(!(v is Null_5) && v.Type().IsSubtype(to_base_));
  }

  public override string Emit() {
    if (from_base_.IsReference()) {
      Class_5 c = (Class_5) to_base_;
      return String.Format("dynamic_cast<{0} *>({1}) != 0", c.name_, expr_.Emit());
    }
    return to_base_ == from_base_ || to_base_ == GObject_5.type_ ? "true" : "false";
  }
}

class As_5 : Conversion_5 {
  public As_5(Expression_5 ^expr, TypeExpr_5 ^type_expr) : base(expr, type_expr) { }

  public override Local_5 GetLocal() { return expr_.GetLocal(); }

  public override GType_5 Check(Context_5 ctx) {
    if (!CheckConversion(ctx, true))
      return null;
    if (!to_base_.IsReference()) {
      Error("as operator must convert to reference type");
      return null;
    }
    return to_type_;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_5.Local_5 ? ExprKind_5.Local_5 : ExprKind_5.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_5 ^Eval(Env_5 env) {
    RValue_5 ^r = expr_.Eval(env);
    return r.Get().Type().IsSubtype(to_base_) ? r : Null_5.Instance.Copy();
  }

  public override string Emit() {
    if (from_base_.CanConvert(to_base_))
      return expr_.Emit(from_base_, to_base_);
    Class_5 c = (Class_5) to_base_;
    return String.Format("dynamic_cast<{0} *>({1})", c.name_, expr_.Emit());
  }
}

// a && or || operator
class LogicalOp_5 : Expression_5 {
  bool and_;  // true => &&, false => ||
  Expression_5 ^left_, right_;
  Joiner_5 ^join_ = new Joiner_5();

  public LogicalOp_5(Expression_5 ^left, int op, Expression_5 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_AND: and_ = true; break;
      case Parser.OP_OR: and_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_5 Check(Context_5 ctx) {
    if (!left_.Check(ctx, GBool_5.type_))
      return null;

    join_.Join(ctx.Prev());
    if (!right_.Check(ctx, GBool_5.type_))
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    return GBool_5.type_;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    bool left = left_.EvalBool(env);
    bool b = and_ ? left && right_.EvalBool(env) : left || right_.EvalBool(env);
    return new GBool_5(b);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    return String.Format("{0} {1} {2}", left_.Emit(), and_ ? "&&" : "||", right_.Emit());
  }

}

// the ?: operator
class Conditional_5 : Expression_5 {
  Expression_5 ^condition_;
  Expression_5 ^if_true_, if_false_;

  GType_5 true_type_, false_type_;
  GType_5 type_;
  Joiner_5 ^join_ = new Joiner_5();

  public Conditional_5(Expression_5 ^condition, Expression_5 ^if_true, Expression_5 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override GType_5 Check(Context_5 ctx) {
    if (!condition_.Check(ctx, GBool_5.type_))
      return null;

    Control_5 c = ctx.Prev();

    true_type_ = if_true_.Check(ctx);
    if (true_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    false_type_ = if_false_.Check(ctx);
    if (false_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    type_ = true_type_.CommonType(this, false_type_);
    return type_;
  }

  public override int Kind() {
    return if_true_.Kind() == ExprKind_5.Local_5 && if_false_.Kind() == ExprKind_5.Local_5 ? ExprKind_5.Local_5 : ExprKind_5.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    if_true_.LoseOwnership();
    if_false_.LoseOwnership();
  }

  public override RValue_5 ^Eval(Env_5 env) {
    return condition_.EvalBool(env) ? if_true_.Eval(env, type_) : if_false_.Eval(env, type_);
  }

  public override string Emit() {
    return String.Format("{0} ? {1} : {2}", condition_.Emit(),
                         if_true_.Emit(true_type_, type_), if_false_.Emit(false_type_, type_));
  }
}

class Assign_5 : Expression_5 {
  LValue_5 ^left_;
  Expression_5 ^right_;

  GType_5 left_type_, right_type_;

  public Assign_5(LValue_5 ^left, Expression_5 ^right) {
    left_ = left; right_ = right;
  }

  public static bool CheckAssign(Syntax_5 caller, GType_5 left_type, Expression_5 right, GType_5 right_type) {
    if (!right_type.CheckConvert(caller, left_type,
      right.Kind() == ExprKind_5.Local_5 ? ConversionContext_5.AssignVar : ConversionContext_5.Other))
      return false;
    right.CheckLoseOwnership(right_type, left_type);
    return true;
  }

  public override GType_5 Check(Context_5 ctx) {
    left_type_ = left_.Check(ctx, false, true, false);
    if (left_type_ == null)
      return null;

    right_type_ = right_.Check(ctx, true, false, false);
    if (right_type_ == null || !CheckAssign(this, left_.StorageType(), right_, right_type_))
      return null;
    right_.HoldRef(ctx);

    AddControl(ctx);
    left_.ReleaseAll(ctx);
    right_.ReleaseRef(ctx);
    return left_type_;
  }

  public override Method_5 Calls() {
    PropertyOrIndexer_5 pi = left_.GetPropertyOrIndexer();
    return pi == null ? null : pi.Setter();
  }

  public override bool Sets(Local_5 local) { return left_.IsLocal(local); }

  public override TypeSet_5 NodeDestroys() {
    return left_.GetPropertyOrIndexer() != null ? TypeSet_5.empty_ : left_.StorageType().VarDestroys();
  }

  public override RValue_5 ^Eval(Env_5 env) {
    RValue_5 ^v1, v2;
    left_.Eval1(env, out v1, out v2);
    RValue_5 ^val = right_.Eval(env, left_type_);
    RValue_5 ^ret = val.CopyRef();
    left_.EvalSet(env, v1, v2, val);
    return ret;
  }

  public override string Emit() {
    return left_.EmitSet(right_.EmitRef(right_type_, left_type_));
  }
}

// a compound assignment operator such as += or -=
class CompoundAssign_5 : Expression_5 {
  LValue_5 ^left_;
  int op_;
  Expression_5 ^right_;

  GType_5 type_;

  public CompoundAssign_5(LValue_5 ^left, int op, Expression_5 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public override GType_5 Check(Context_5 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    type_ = left_.Check(ctx, true, true, false);
    if (type_ == null)
      return null;
    if (left_.Kind() == ExprKind_5.Indexer_5) {
      Error("compound assignments don't yet work on indexers");
      return null;
    }
    if (type_ == GBool_5.type_ && (op_ == '&' || op_ == '|')) {
      if (!right_.Check(ctx, GBool_5.type_))
        return null;
      return type_;
    }
    if (type_ != GInt_5.type_ && type_ != GFloat_5.type_ && type_ != GDouble_5.type_) {
      Error("compound assignment operator {0}= can't operate on object of type {1}", (char) op_, type_);
      return null;
    }
    if (!right_.Check(ctx, type_))
      return null;
    return type_;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    Location_5 loc = left_.EvalLocation(env);
    if (type_ == GBool_5.type_) {
      bool x = ((GBool_5) loc.value_).b_;
      bool y = right_.EvalBool(env);
      loc.value_ = Binary_5.BoolOp(x, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GInt_5.type_) {
      GInt_5 x = (GInt_5) loc.value_;
      int y = right_.EvalInt(env);
      loc.value_ = Binary_5.IntOp(x.i_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GFloat_5.type_) {
      GFloat_5 x = (GFloat_5) loc.value_;
      float y = right_.EvalFloat(env);
      loc.value_ = Binary_5.FloatOp(x.f_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GDouble_5.type_) {
      GDouble_5 x = (GDouble_5) loc.value_;
      double y = right_.EvalDouble(env);
      loc.value_ = Binary_5.DoubleOp(x.d_, op_, y);
      return loc.value_.CopyRef();
    } else {
      Debug.Assert(false);
      return null;
    }
  }

  public override string Emit() {
    return String.Format("{0} {1}= {2}", left_.Emit(), (char) op_, right_.Emit());
  }
}

class Take_5 : Expression_5 {
  LValue_5 ^exp_;
  Owning_5 type_;

  public Take_5(LValue_5 ^exp) { exp_ = exp; }

  public override GType_5 Check(Context_5 ctx) {
    GType_5 t = exp_.Check(ctx);
    if (t == null)
      return null;
    type_ = exp_.StorageType() as Owning_5;
    if (type_ == null) {
      Error("take must be applied to owning pointer");
      return null;
    }
    exp_.LoseOwnership();
    ctx.AddTemporary(this);
    return type_;
  }

  public override GType_5 TemporaryType() { return type_; }

  public override RValue_5 ^Eval(Env_5 env) {
    RValue_5 ^v = exp_.Eval(env);
    exp_.EvalSet(env, Null_5.Instance.Copy());
    return v;
  }

  public override string Emit() {
    return Hold(exp_.StorageType(), exp_.Emit());
  }
}

abstract class Statement_5 : Node_5 {
  public abstract bool Check(Context_5 ctx);
  public abstract RValue_5 ^Eval(Env_5 env);

  public abstract void Emit(SourceWriter_5 w);

  public virtual void EmitEmbedded(SourceWriter_5 w) {
    w.WriteLine("");
    w.AddIndent();
    w.Indent();
    Emit(w);
    w.SubIndent();
  }

  public virtual void EmitInExistingBlock(SourceWriter_5 w) {
    w.Indent();
    Emit(w);
  }
}

class StatementList_5 {
  public readonly ArrayList /* of Statement_5 */ ^statements_ = new ArrayList();

  public void Add(Statement_5 ^s) { statements_.Add(s); }

  public bool Check(Context_5 ctx) {
    bool ok = true;
    foreach (Statement_5 s in statements_)
      ok &= s.Check(ctx);
    return ok;
  }

  public RValue_5 ^Eval(Env_5 env) {
    foreach (Statement_5 s in statements_) {
      RValue_5 ^v = s.Eval(env);
      if (v != null)
        return v;
    }
    return null;
  }

  public void Emit(SourceWriter_5 w) {
    foreach (Statement_5 s in statements_) {
      w.Indent();
      s.Emit(w);
    }
  }
}

class EmptyStatement_5 : InlineStatement_5 {
  public EmptyStatement_5() { }

  public override bool Check(Context_5 ctx) { return true; }
  public override RValue_5 ^Eval(Env_5 env) { return null; }
  public override void EmitInline(SourceWriter_5 w) { }

  public static readonly EmptyStatement_5 ^instance_ = new EmptyStatement_5();
}

// A Scoped_5 is a statement defining one or more local variables.  If_5 a Scoped_5 appears in the
// control graph, then it destroys those variables when traversed.
abstract class Scoped_5 : Statement_5 {
  protected Local_5 start_;   // the first local outside this statement
  protected Local_5 top_;     // the top local defined inside this statement

  TypeSet_5 ^destroys_;

  protected void SetStartVar(Context_5 ctx) { start_ = top_ = ctx.var_; }
  protected void SetTopVar(Context_5 ctx) { top_ = ctx.var_; }

  public Local_5 GetStart() { return start_; }
  public Local_5 GetTop() { return top_; }

  public override TypeSet_5 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_5();
    for (Local_5 l = top_; l != start_; l = l.next_)
        destroys_.Add(l.Type().VarDestroys());
    }
    return destroys_;
  }
}

class Block_5 : Scoped_5 {
  public readonly StatementList_5 ^list_;

  public Block_5(StatementList_5 ^list) { list_ = list; }

  public bool Absent() { return list_ == null; }

  public override bool Check(Context_5 ctx) {
    Context_5 ^ctx1 = new Context_5(ctx);   // don't pass declarations outside block
    SetStartVar(ctx1);

    if (!list_.Check(ctx1))
      return false;

    SetTopVar(ctx1);

    // Add this Block_5 to the control graph; this represents the destruction of variables
    // within the block at block exit.
    AddControl(ctx1);

    return true;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    return list_.Eval(new Env_5(env));
  }

  public static Block_5 ^EmptyBlock() { return new Block_5(new StatementList_5()); }

  public override void Emit(SourceWriter_5 w) {
    w.OpenBrace();
    list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitEmbedded(SourceWriter_5 w) {
    w.Write(" ");
    Emit(w);
  }

  public override void EmitInExistingBlock(SourceWriter_5 w) {
    list_.Emit(w);
  }
}

class MemberKind_5 {
  public const int
    Field_5 = 0,
    Method_5 = 1,
    Property_5 = 2,
    Indexer_5 = 3,
    Constructor_5 = 4;
}

class Named_5 : Node_5 {
  public readonly TypeExpr_5 ^type_expr_;   // may be null for certain objects such as constructors
  protected GType_5 type_;

  public readonly string name_;

  public Named_5(TypeExpr_5 ^type_expr, string name) {
    type_expr_ = type_expr;
    name_ = name;
  }

  public GType_5 Type() { return type_; }

  public virtual bool Resolve(Program_5 program) {
    if (type_expr_ == null || type_ != null)
      return true;
    type_ = type_expr_.Resolve(program);
    return type_ != null;
  }
}

abstract class Member_5 : Named_5 {
  protected Class_5 class_;    // containing class

  public readonly int attributes_;

  protected Member_5(int attributes, TypeExpr_5 ^type_expr, string name) : base(type_expr, name) {
    attributes_ = attributes;
  }

  public abstract int Kind();

  public static string ToString(int kind) {
    switch (kind) {
      case MemberKind_5.Field_5: return "field";
      case MemberKind_5.Method_5: return "method";
      case MemberKind_5.Property_5: return "property";
      case MemberKind_5.Indexer_5: return "indexer";
      case MemberKind_5.Constructor_5: return "constructor";
      default: Debug.Assert(false); return null;
    }
  }

  public string KindString() { return ToString(Kind()); }

  protected abstract int ValidAttributes();

  public Class_5 GetClass() { return class_; }
  public void SetClass(Class_5 cl) { class_ = cl; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public bool IsOverride() { return HasAttribute(Attribute_5.Override); }

  public bool IsProtected() { return HasAttribute(Attribute_5.Protected); }

  public bool IsPublic() { return HasAttribute(Attribute_5.Public); }

  public bool IsPrivate() { return !HasAttribute(Attribute_5.Public | Attribute_5.Protected); }

  public bool IsVirtual() {
    return HasAttribute(Attribute_5.Virtual | Attribute_5.Abstract | Attribute_5.Override);
  }

  static ArrayList ^empty_ = new ArrayList();

  public virtual ArrayList /* of Parameter_5 */ Parameters() { return empty_; }

  public Parameter_5 Param(int i) {
    return (Parameter_5) Parameters()[i];
  }

  public bool IsAccessible(Class_5 from_class, GType_5 through_type, bool through_base) {
    if (IsPublic())
      return true;

    // In GEL2 (as in C# and C++), a class [from_class] can access a protected member of
    // a class C only if [from_class] is a subtype of C and the access is
    // through a subtype of [from_class].  See e.g. C# 3.5.3 "Protected Access for Instance Members".
    if (IsProtected())
      return through_base || from_class.IsSubtype(class_) && through_type.IsSubtype(from_class);

    // default private access
    return from_class == class_;
  }

  public static bool MatchKind(int kind1, int kind2) {
    return kind1 == kind2 ||
           kind1 == MemberKind_5.Field_5 && kind2 == MemberKind_5.Property_5 ||
           kind1 == MemberKind_5.Property_5 && kind2 == MemberKind_5.Field_5;
  }

  public bool MatchSignature(Member_5 m) {
    if (!MatchKind(Kind(), m.Kind()))
      return false;

    if (name_ != m.name_ || Parameters().Count != m.Parameters().Count)
      return false;

    int i = 0;
    foreach (Parameter_5 p in m.Parameters()) {
      Parameter_5 q = Param(i);
      if (!p.Match(q))
        return false;
      ++i;
    }
    return true;
  }

  public bool IsApplicable(ArrayList arguments, out int mismatches) {
    mismatches = 0;
    if (Parameters().Count != arguments.Count)
      return false;
    int i = 0;
    foreach (Argument_5 a in arguments) {
      if (!Param(i).CanReceive(a))
        ++mismatches;
      ++i;
    }
    return true;
  }

  public void ReportMismatches(Syntax_5 caller, ArrayList arguments) {
    Debug.Assert(Parameters().Count == arguments.Count);
    int i = 0;
    foreach (Argument_5 a in arguments) {
      Parameter_5 p = Param(i);
      if (!p.CanReceive(a))
        caller.Error("argument {0}: can't convert from {1} to {2}", i + 1, a.TypeString(), p.TypeString());
      ++i;
    }
  }

  protected virtual void AddOverride(Member_5 m) { }

  bool CheckOverride(Context_5 ctx) {
    Class_5 parent = ctx.class_.Parent();
    Member_5 m = parent != null ? parent.FindMatchingMember(this, false) : null;
    if (m != null) {
      if (this is Field_5) {
        Error("can't define field with same name as field/property in superclass");
        return false;
      }
      if (m is Field_5) {
        Error("can't define property with same name as field in superclass");
        return false;
      }
      if (!HasAttribute(Attribute_5.Override)) {
        Error("must use override keyword to override superclass {0}", KindString());
        return false;
      }
      if (HasAttribute(Attribute_5.Virtual)) {
        Error("{0} with override or abstract keyword cannot be marked virtual", KindString());
        return false;
      }
      if (!m.IsVirtual()) {
        Error("attempting to override non-virtual {0}", KindString());
        return false;
      }
      if (!m.Type().Equals(Type())) {
        Error("can't override {0} with different return type", KindString());
        return false;
      }
      if (m.IsPublic() != IsPublic()) {
        Error("override {0} must have same accessibility as {0} it overrides", KindString());
        return false;
      }
      m.AddOverride(this);
    } else if (HasAttribute(Attribute_5.Override)) {
      Error("can't find {0} to override", KindString());
      return false;
    }
    return true;
  }

  bool CheckAccessibility() {
    int n = 0;
    if ((attributes_ & Attribute_5.Private) != 0)
      ++n;
    if ((attributes_ & Attribute_5.Protected) != 0)
      ++n;
    if ((attributes_ & Attribute_5.Public) != 0)
      ++n;
    if (n > 1) {
      Error("only one access level (private, protected, public) may be specified");
      return false;
    }

    if (IsVirtual() && IsPrivate()) {
      Error("a virtual or abstract {0} may not be private", KindString());
      return false;
    }

    return true;
  }

  public virtual bool Check(Context_5 ctx) {
    if (!AttributeUtil_5.CheckOnly(attributes_, ValidAttributes())) {
      Error("illegal {0} attribute", KindString());
      return false;
    }

    if (HasAttribute(Attribute_5.Abstract) && !ctx.class_.HasAttribute(Attribute_5.Abstract)) {
      Error("an abstract {0} can be defined only in an abstract class", KindString());
      return false;
    }

    if (name_ == class_.name_ && !(this is Constructor_5)) {
      Error("{0} cannot have same name as enclosing class", KindString());
      return false;
    }

    if (class_.GetMatchingMember(this) != this) {
      Error("{0} {1} appears twice in same class", KindString(), name_ != null ? name_ : "");
      return false;
    }

    return CheckOverride(ctx) && CheckAccessibility();
  }
}

// a member which represents a storage location: a field, property, or indexer
abstract class LMember_5 : Member_5 {
  protected LMember_5(int attributes, TypeExpr_5 ^type_expr, string name)
    : base(attributes, type_expr, name) { }

  public bool IsConstOrStatic() {
    return HasAttribute(Attribute_5.Const | Attribute_5.Static);
  }

  protected bool CheckStatic(Syntax_5 caller, bool static_ok, bool instance_ok) {
    if (!static_ok && IsConstOrStatic()) {
      caller.Error("{0} {1} is static", KindString(), name_);
      return false;
    }
    if (!instance_ok && !IsConstOrStatic()) {
      caller.Error("{0} {1} is not static", KindString(), name_);
      return false;
    }
    return true;
  }

  public abstract bool CheckAssigning(Syntax_5 caller, Context_5 ctx, bool assigning);

  public bool CheckAccess(Syntax_5 caller, Context_5 ctx, bool assigning, bool static_ok, bool instance_ok) {
    return CheckStatic(caller, static_ok, instance_ok) && CheckAssigning(caller, ctx, assigning);
  }

  public abstract Location_5 GetLocation(GObject_5 obj);

  // These methods are for fields and properties; indexers have their own versions which take
  // an extra index argument.
  public virtual RValue_5 ^Get(GValue_5 obj) { Debug.Assert(false); return null; }
  public virtual RValue_5 ^Take_5(GValue_5 obj) { Debug.Assert(false); return null; }
  public virtual void Set(GObject_5 obj, RValue_5 ^val)  { Debug.Assert(false); }

  public virtual string Emit()  { Debug.Assert(false); return null; }
  public virtual string EmitSet(string val)  { Debug.Assert(false); return null; }
}

class Field_5 : LMember_5 {
  protected Expression_5 ^initializer_;    // or null if none
  protected GType_5 initializer_type_;

  public Field_5(int attributes, TypeExpr_5 ^type_expr, string name, Expression_5 ^initializer)
  : base(attributes, type_expr, name) {
    initializer_ = initializer;
  }

  // Create a field for an internal class.  Such fields will never be type checked.
  public Field_5(GType_5 type, string name) : this(Attribute_5.Public | Attribute_5.ReadOnly, null, name, null) {
    type_ = type;
  }

  public static Field_5 ^New_5(int attributes, TypeExpr_5 ^type_expr, string name, Expression_5 ^initializer) {
    if ((attributes & Attribute_5.Static) != 0)
      return new StaticField_5(attributes, type_expr, name, initializer);
    if ((attributes & Attribute_5.Const) != 0)
      return new ConstField_5(attributes, type_expr, name, initializer);
    return new Field_5(attributes, type_expr, name, initializer);
  }

  public override int Kind() { return MemberKind_5.Field_5; }

  public Expression_5 Initializer() { return initializer_; }

  protected virtual bool CheckInitializer(Context_5 ctx) {
    if (initializer_ == null)
      return true;

    ctx.EnterExpression();
    initializer_type_ = initializer_.Check(ctx);
    bool b = initializer_type_ != null &&
             Assign_5.CheckAssign(this, type_, initializer_, initializer_type_);
    ctx.FinishExpression();
    return b;
  }

  protected override int ValidAttributes() {
    return Attribute_5.Const | Attribute_5.Private | Attribute_5.Protected | Attribute_5.Public |
           Attribute_5.ReadOnly | Attribute_5.Static;
  }

  public override bool Check(Context_5 ctx) {
    if (!base.Check(ctx))
      return false;

    // We build up a small control graph even when checking field initializers; we do this
    // since expression-checking code uses the graph to determine when temporary
    // ref counts are needed.
    prev_ = unreachable_;
    ctx.SetPrev(this);

    bool b = CheckInitializer(ctx);

    ctx.ClearPrev();
    return b;
  }

  public override bool CheckAssigning(Syntax_5 caller, Context_5 ctx, bool assigning) {
    if (assigning) {
      if (HasAttribute(Attribute_5.Const)) {
        caller.Error("can't assign to const field");
        return false;
      }
      if (HasAttribute(Attribute_5.ReadOnly) &&
          (ctx.class_ != class_ || !(ctx.method_ is Constructor_5)) ) {
        caller.Error("readonly field {0} can only be assigned in constructor", name_);
        return false;
      }
    }
    return true;
  }

  public override RValue_5 ^Get(GValue_5 obj) { return obj.Get(this); }
  public override RValue_5 ^Take_5(GValue_5 obj) { return obj.Take_5(this); }
  public override void Set(GObject_5 obj, RValue_5 ^val) { obj.Set(this, val); }
  public override Location_5 GetLocation(GObject_5 obj) { return obj.GetLocation(this); }

  protected void WriteField(SourceWriter_5 w, bool declaration) {
    w.Indent();
    if (declaration && IsConstOrStatic())
      w.Write("static ");
    w.Write("{0} ", type_.EmitType());
    if (this is ConstField_5)
      w.Write("const ");
    if (!declaration)
      w.Write("{0}::", class_.name_);
    w.Write(name_);
  }

  protected void WriteDeclaration(SourceWriter_5 w) { WriteField(w, true); }
  protected void WriteDefinition(SourceWriter_5 w) { WriteField(w, false); }

  public virtual void EmitDeclaration(SourceWriter_5 w) {
    WriteDeclaration(w);
    w.WriteLine(";");
  }

  public void EmitInitializer(SourceWriter_5 w) {
    w.IWrite("{0} = ", name_);
    if (initializer_ != null)
      w.Write(initializer_.Emit(initializer_type_, type_));
    else w.Write(type_.DefaultValue_5().Emit());
    w.WriteLine(";");
  }

  public virtual void Emit(SourceWriter_5 w) { }

  public override string Emit() { return name_; }

  public override string EmitSet(string val) {
    return String.Format("{0} = {1}", name_, val);
  }
}

class StaticField_5 : Field_5 {
  protected Location_5 ^loc_;

  public StaticField_5(int attributes, TypeExpr_5 ^type_expr, string name, Expression_5 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_5 ctx) {
    if (!base.Check(ctx))
      return false;
    loc_ = new Location_5(Type().DefaultValue_5().Copy());
    return true;
  }

  protected override bool CheckInitializer(Context_5 ctx) {
    ArrayInitializer_5 ai = initializer_ as ArrayInitializer_5;
    if (ai != null) {
      GType_5 type = type_;
      Owning_5 o = type as Owning_5;
      type = (o != null) ? o.BaseType() : null;
      ArrayType_5 at = type as ArrayType_5;
      if (at == null) {
        Error("only owning arrays may have initializers");
        return false;
      }
      return ai.CheckElements(ctx, at.ElementType());
    }

    return base.CheckInitializer(ctx);
  }

  public virtual void Init() {
    ArrayInitializer_5 ai = initializer_ as ArrayInitializer_5;
    if (ai != null)
      loc_.value_ = ai.Eval((ArrayType_5) type_.BaseType());
    else if (initializer_ != null)
      loc_.value_ = initializer_.Eval(Env_5.static_, type_);
  }

  public override RValue_5 ^Get(GValue_5 obj) { return loc_.Get().CopyRef(); }
  public override RValue_5 ^Take_5(GValue_5 obj) { return take loc_.value_; }
  public override void Set(GObject_5 obj, RValue_5 ^val) { loc_.value_ = val; }
  public override Location_5 GetLocation(GObject_5 obj) { return loc_; }

  public override void Emit(SourceWriter_5 w) {
    ArrayInitializer_5 ai = initializer_ as ArrayInitializer_5;
    if (ai != null) {
      GType_5 element_type = ((ArrayType_5) type_.BaseType()).ElementType();
      string varname = String.Format("_{0}_{1}", class_.name_, name_);
      w.Write("{0} {1}[] = ", element_type.EmitGenericType(), varname);
      ai.Emit(w);
      w.WriteLine(";");
      WriteDefinition(w);
      w.Write("(new {0}", GType_5.ConstructType("_StaticArray", element_type.EmitGenericType()));
      w.Write("(&typeid({0}), {1}, {2}))", element_type.EmitType(), ai.initializers_.Count, varname);
    } else {
      WriteDefinition(w);
      if (initializer_ != null)
        initializer_.EmitAsInitializer(w, initializer_type_, type_);
    }
    w.WriteLine(";");
    w.WriteLine("");
  }
}

class ConstField_5 : Field_5 {
  protected SimpleValue_5 ^value_;

  public ConstField_5(int attributes, TypeExpr_5 ^type_expr, string name, Expression_5 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_5 ctx) {
    if (!base.Check(ctx))
      return false;
    return initializer_.CheckConstant();
  }

  SimpleValue_5 ^Get() {
    if (value_ == DefaultValue_5.instance_) {
      Error("circular dependency among constant fields");
      Gel_5.Exit();
    }
    if (value_ == null) {
      value_ = new DefaultValue_5();    // marker used to catch circular const references
      value_ = (SimpleValue_5)initializer_.Eval(Env_5.static_, type_);
    }
    return value_.Copy();
  }

  public override RValue_5 ^Get(GValue_5 obj) {
    return Get();
  }

  public override void Set(GObject_5 obj, RValue_5 ^val) { Debug.Assert(false); }
  public override Location_5 GetLocation(GObject_5 obj) { Debug.Assert(false); return null; }

  public override void EmitDeclaration(SourceWriter_5 w) {
    WriteDeclaration(w);
    if (type_ is IntegralType_5)
      w.Write(" = {0}", Get().Emit());
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_5 w) {
    WriteDefinition(w);
    if (!(type_ is IntegralType_5)) {
      w.WriteLine(" = {0};", Get().Emit());
    }
    w.WriteLine(";");
  }
}

class ExpressionTraverser_5 : Traverser_5 {
  readonly Control_5 start_;
  Local_5 local_;
  GType_5 type_;
  bool assign_;
  bool destroy_;

  public ExpressionTraverser_5(Control_5 start, Local_5 local, GType_5 type) {
    start_ = start; local_ = local; type_ = type;
  }

  public override int Handle(Control_5 control) {
    if (control == start_)
      return Cut;
    Node_5 node = control as Node_5;
    if (node != null) {
      if (!destroy_ && node.CanDestroy(type_))
        destroy_ = true;
      else if (local_ != null && node.Sets(local_))
        assign_ = true;
    }
    return Continue_5;
  }

  // Return_5 true if the given expression needs a reference count while we evaluate
  // the control graph nodes between [start] and [end].
  // A local variable needs a ref count if it is assigned to and the object
  // the variable previously pointed to might possibly be destroyed.
  // Any other expression needs a ref count if the object it evaluates to
  // might possibly be destroyed.
  public static bool NeedRef(Control_5 start, Control_5 end, Expression_5 expr, GType_5 type) {
    Debug.Assert(start != null && end != null);
    if (start == end || !type.IsOwned() || expr is This_5 || expr is Base_5)
      return false;
    Local_5 local = expr.GetLocal();
    ExpressionTraverser_5 ^et = new ExpressionTraverser_5(start, local, type);
    end.Traverse(et, Control_5.GetMarkerValue());
    return et.destroy_ && (local == null || et.assign_);
  }
}

abstract class LocalHandler_5 {
  public abstract bool Handle(Local_5 local, Node_5 node, Name_5 use);
}

class LocalChecker_5 : LocalHandler_5 {
  public override bool Handle(Local_5 local, Node_5 node, Name_5 use) {
    if (node == Control_5.unreachable_) {
      if (use != null)
        use.Error("variable {0} may be used before it is assigned a value", use.name_);
      else
        local.Error("out parameter {0} must be assigned before leaving method", local.name_);
      return false;
    }
    if (node.Takes(local)) {
      Name_5 name = (Name_5) node;
      name.Error("can't transfer ownership from {0}: value may be used again", name.name_);
      return false;
    }
    return true;
  }
}

class LocalRefAnalyzer_5 : LocalHandler_5 {
  public override bool Handle(Local_5 local, Node_5 node, Name_5 use) {
    Debug.Assert(node != Control_5.unreachable_);
    if (node.CanDestroy(local.Type())) {
      local.NeedsRef();
      return false;   // abort search
    }
    return true;
  }
}

class LocalTraverser_5 : Traverser_5 {
  readonly Local_5 local_;
  readonly LocalHandler_5 handler_;
  Name_5 use_;

  public LocalTraverser_5(Local_5 local, LocalHandler_5 handler) {
    local_ = local;
    handler_ = handler;
  }

  public void SetUse(Name_5 use) { use_ = use; }

  public override int Handle(Control_5 control) {
    Node_5 node = control as Node_5;
    if (node == null)
      return Continue_5;

    if (node.Sets(local_))
      return Cut;

    return handler_.Handle(local_, node, use_) ? Continue_5 : Abort;
  }
}

class Local_5 : Named_5 {
  protected Expression_5 ^initializer_;    // or null if none
  protected GType_5 initializer_type_;

  public Local_5 next_;    // next variable upward in scope chain

  NonOwningArrayList /* of Name_5 */ ^uses_ = new NonOwningArrayList();    // all uses of this variable

  protected bool mutable_;   // true if this local may ever change after it's first initialized

  protected bool needs_ref_;    // true if this variable needs a reference count in emitted code

  public Expression_5 Initializer() { return initializer_; }

  public void NeedsRef() { needs_ref_ = true; }

  public virtual string Emit() { return name_; }

  // Return_5 true if we represent this local using a smart pointer wrapper (i.e.
  // _Ptr, _Own, _OwnRef or _Ref).
  public virtual bool IsWrapper() {
    return type_ is Owning_5 || type_ == GString_5.type_ || needs_ref_;
  }

  public Local_5(TypeExpr_5 ^type_expr, string name, Expression_5 ^initializer) : base(type_expr, name) {
    initializer_ = initializer;
    next_ = null;
  }

  public bool Check(Context_5 ctx) {
    Local_5 decl = ctx.FindVar(name_);
    if (decl != null) {
      Error("error: variable already defined");
      return false;
    }

    if (initializer_ != null) {
      ctx.EnterExpression();
      initializer_type_ = initializer_.Check(ctx);
      bool ok = initializer_type_ != null &&
                Assign_5.CheckAssign(this, type_, initializer_, initializer_type_);

      // Add this Local_5 to the control graph.  We need to do this before calling
      // FinishExpression since the Local_5 will be initialized before temporaries 
      // are destroyed.
      AddControl(ctx);

      ctx.FinishExpression();
      if (!ok)
        return false;
    }

    next_ = ctx.var_;
    ctx.SetVar(this);

    ctx.method_.AddVar(this);
    return true;
  }

  public override bool Sets(Local_5 local) {
    return this == local && initializer_ != null;
  }

  public virtual GType_5 ReadType() {
    return type_;
  }

  public void AddUse(Name_5 name) {
    uses_.Add(name);
  }

  public void SetMutable() { mutable_ = true; }

  // Traverse the control graph nodes where this local is live, calling the given
  // LocalHandler_5's Handle method on each node.
  public bool Traverse(Method_5 method, LocalHandler_5 h) {
    LocalTraverser_5 ^t = new LocalTraverser_5(this, h);
    int marker = Control_5.GetMarkerValue();
    foreach (Name_5 name in uses_) {
      t.SetUse(name);
      if (!name.prev_.Traverse(t, marker))
        return false;
    }

    Parameter_5 p = this as Parameter_5;
    if (p != null && p.GetMode() == Mode_5.Out) {
      t.SetUse(null);
      if (!method.exit_.Traverse(t, marker))
        return false;
    }
    return true;
  }

  // check variable usage once control flow graph is complete
  public bool CheckUsage(Method_5 method) {
    return Traverse(method, new LocalChecker_5());
  }

  // Determine whether this Local_5 needs a reference count.  This_5 can happen only after
  // we've built up a control graph for all methods.
  public void ComputeRef(Method_5 method) {
    // For_5 now, a variable of type object always needs a reference count since it may
    // contain a string and we don't yet detect string destruction in the graph traversal.
    if (type_ == GObject_5.type_)
      NeedsRef();
    else if (type_.IsOwned())
      Traverse(method, new LocalRefAnalyzer_5());
  }

  public void EvalInit(Env_5 env) {
    env.Add(this, initializer_ != null ? initializer_.Eval(env, type_) : null);
  }

  protected virtual string EmitDeclarationType() {
    return IsWrapper() ? type_.EmitType() : type_.EmitExprType();
  }

  public virtual string EmitDeclarationName() { return name_; }

  public void EmitDeclaration(SourceWriter_5 w) {
    w.Write("{0} {1}", EmitDeclarationType(), EmitDeclarationName());
  }

  public void EmitInitializer(SourceWriter_5 w) {
    if (initializer_ != null)
      initializer_.EmitAsInitializer(w, initializer_type_, type_);
  }
}

class Parameter_5 : Local_5 {
  public Parameter_5(TypeExpr_5 ^type_expr, string name) : base(type_expr, name, null) { }

  // We represent some parameters using both a C++ parameter and a C++ local, which
  // have different types; we call these dual parameters.  For_5 such parameters
  // param_name_ is the C++ parameter name.
  string param_name_;

  public static Parameter_5 ^New_5(int mode, TypeExpr_5 ^type_expr, string name) {
    return mode == 0 ? new Parameter_5(type_expr, name) :
                               new RefOutParameter_5(mode, type_expr, name);
  }

  public virtual int GetMode() { return 0; }
  public string TypeString() { return Mode_5.ToString(GetMode()) + type_.ToString(); }

  public virtual Parameter_5 ^Copy() {
    return new Parameter_5(new TypeLiteral_5(type_), name_);
  }

  public virtual bool CanReceive(Argument_5 a) {
    return a.GetMode() == 0 && a.Type().CanConvert(type_, ConversionContext_5.MethodArg);
  }

  public bool Match(Parameter_5 p) {
    return GetMode() == p.GetMode() && type_.Equals(p.type_);
  }

  public override bool IsWrapper() {
    return type_ is Owning_5 || type_ == GString_5.type_ || mutable_ && needs_ref_;
  }

  public void CheckParameterUsage(Method_5 method) {
    if (type_ is Owning_5 && !(this is RefOutParameter_5)) {
      // We need both a C++ parameter and a C++ local: the parameter type can't be
      // _Own<>, since _Own has no public copy constructor and GCC doesn't allow passing
      // by value when a class's copy constructor is private.
      string n = name_;
      do {
        n = "_" + n;
      } while (method.HasLocal(n));
      param_name_ = n;
    }
  }

  protected override string EmitDeclarationType() {
    // For_5 owning parameters the declaration type is the expression type since we can't
    // pass _Own<> by value.
    return type_ is Owning_5 ? type_.EmitExprType() : base.EmitDeclarationType();
  }

  public override string EmitDeclarationName() {
    return param_name_ != null ? param_name_ : name_;
  }

  public void EmitExtraDeclaration(SourceWriter_5 w) {
    if (param_name_ != null)
      w.IWriteLine("{0} {1}({2});", type_.EmitType(), name_, param_name_);
  }
}

class RefOutParameter_5 : Parameter_5 {
  public readonly int mode_;
  public override int GetMode() { return mode_; }

  public RefOutParameter_5(int mode, TypeExpr_5 ^type_expr, string name) : base(type_expr, name) {
    mode_ = mode;
    mutable_ = true;
  }

  public override Parameter_5 ^Copy() { Debug.Assert(false); return null; }

  public override bool CanReceive(Argument_5 a) {
    if (mode_ != a.GetMode())
      return false;
    RefOutArgument_5 ra = (RefOutArgument_5) a;
    return type_.Equals(ra.StorageType());
  }

  public override GType_5 ReadType() {
    // If_5 a ref parameter has an owning type, we require the user to use the take operator to take
    // ownership of the value, since taking ownership has the visible side effect of clearing the
    // value the ref parameter points to.
    return mode_ == Mode_5.Ref ? type_.BaseType() : type_;
  }

  public override string Emit() {
    return "(*" + name_ + ")";
  }

  protected override string EmitDeclarationType() {
    return type_.EmitType() + " *";
  }
}

abstract class InlineStatement_5 : Statement_5 {
  public abstract void EmitInline(SourceWriter_5 w);

  public override void Emit(SourceWriter_5 w) {
    EmitInline(w);
    w.WriteLine(";");
  }
}

class VariableDeclaration_5 : InlineStatement_5 {
  ArrayList /* of Local_5 */ ^locals_ = new ArrayList();

  public VariableDeclaration_5(TypeExpr_5 ^type_expr, string name, Expression_5 ^initializer) {
    locals_.Add(new Local_5(type_expr, name, initializer));
  }

  public void Add(string name, Expression_5 ^initializer) {
    TypeExpr_5 ^t = ((Local_5) locals_[0]).type_expr_.Copy();
    locals_.Add(new Local_5(t, name, initializer));
  }

  public override bool Check(Context_5 ctx) {
    // local variables are not resolved during the Resolve phase, so we must resolve them here
    foreach (Local_5 l in locals_)
      if (!l.Resolve(ctx.program_) || !l.Check(ctx))
        return false;

    return true;
  }

  // Return_5 the type of all variables in this VariableDeclaration_5.
  public GType_5 Type() { return ((Local_5) locals_[0]).Type(); }

  public override RValue_5 ^Eval(Env_5 env) {
    foreach (Local_5 l in locals_)
      l.EvalInit(env);
    return null;
  }

  void Emit(SourceWriter_5 w, bool in_line) {
    if (in_line)
      Debug.Assert(locals_.Count == 1);

    foreach (Local_5 l in locals_) {
      l.EmitDeclaration(w);
      l.EmitInitializer(w);
      if (!in_line)
        w.WriteLine(";");
    }
  }

  public override void EmitInline(SourceWriter_5 w) { Emit(w, true); }
  public override void Emit(SourceWriter_5 w) { Emit(w, false); }
}

class ExpressionStatement_5 : InlineStatement_5 {
  Expression_5 ^exp_;

  public ExpressionStatement_5(Expression_5 ^e) {
    exp_ = e;
  }

  public override bool Check(Context_5 ctx) {
    if (exp_.CheckTop(ctx) == null)
      return false;
    exp_.SetUnused();
    return true;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    exp_.Eval(env);   // discard expression value
    return null;
  }

  public override void EmitInline(SourceWriter_5 w) {
    w.Write(exp_.Emit());
  }

}

class If_5 : Statement_5 {
  Expression_5 ^condition_;
  Statement_5 ^if_true_;
  Statement_5 ^if_false_;
  Joiner_5 ^join_ = new Joiner_5();

  public If_5(Expression_5 ^condition, Statement_5 ^if_true, Statement_5 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override bool Check(Context_5 ctx) {
    if (!condition_.Check(ctx, GBool_5.type_))
      return false;

    Control_5 c = ctx.Prev();

    if (!if_true_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    if (if_false_ != null && !if_false_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());
    return true;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    if (condition_.EvalBool(env))
      return if_true_.Eval(env);
    else
      return if_false_ != null ? if_false_.Eval(env) : null;
  }

  public override void Emit(SourceWriter_5 w) {
    w.Write("if ({0})", condition_.Emit());
    if_true_.EmitEmbedded(w);
    if (if_false_ != null) {
      w.IWrite("else");
      if_false_.EmitEmbedded(w);
    }
  }

}

class DefaultValue_5 : SimpleValue_5 {
  public DefaultValue_5() { }
  public static readonly DefaultValue_5 ^instance_ = new DefaultValue_5();

  public override SimpleValue_5 ^Copy() { Debug.Assert(false); return null; }
  public override GType_5 Type()  { Debug.Assert(false); return null; }
  public override string Emit() { Debug.Assert(false); return null; }
}

// A section in a switch statement.
//
// In GEL2, unlike C# and C++, local variables declared in a switch section are visible only
// in that section.  There doesn't seem to be much point in allowing sections to share locals
// since GEL2 (like C#) doesn't allow control to fall through from one section to the next.  This_5 also
// makes compiling to C++ slightly easier since C++ doesn't allow local variables in switch sections
// other than the last to have initializers (see e.g. C++ Primer, 4th ed., 6.6.5 "Variable Definitions
// inside a switch").

class SwitchSection_5 : Node_5 {
  ArrayList /* of Expression_5 */ ^cases_;     // null represents default:
  public readonly Block_5 ^block_;

  ArrayList /* of GValue_5 */ ^values_ = new ArrayList();

  public SwitchSection_5(ArrayList ^cases, StatementList_5 ^statements) {
    cases_ = cases;
    block_ = new Block_5(statements);
  }

  public bool Check(Context_5 ctx, GType_5 switch_type, OwningHashtable all_values, out bool is_default) {
    is_default = false;
    foreach (Expression_5 e in cases_) {
      GValue_5 ^v;
      if (e == null) {
        is_default = true;
        v = new DefaultValue_5();
      } else {
        if (!e.Check(ctx, switch_type) || !e.CheckConstant())
          return false;
        v = (GValue_5) e.Eval(Env_5.static_, switch_type);
      }
      if (all_values.ContainsKey(v)) {
        Error("switch statement cannot contain the same value twice");
        return false;
      }
      all_values.Set(v, null);
      values_.Add(v);
    }
    return block_.Check(ctx);
  }

  public bool Match(GValue_5 v) {
    foreach (GValue_5 val in values_)
      if (val.Equals(v))
        return true;
    return false;
  }

  public void Emit(SourceWriter_5 w) {
    foreach (Expression_5 c in cases_)
      if (c == null)
        w.IWriteLine("default:");
      else w.IWriteLine("case {0}:", c.Emit());
    w.Indent();
    block_.Emit(w);
  }

  public void EmitString(SourceWriter_5 w) {
    w.IWrite("if (");
    for (int i = 0 ; i < values_.Count ; ++i) {
      if (i > 0) {
        w.WriteLine(" ||");
        w.IWrite("    ");
      }
      w.Write("_s->_Equals({0})", 
              GString_5.EmitStringConst(((GString_5) values_[i]).s_));
    }
    w.Write(") ");
    block_.Emit(w);
  }
}

abstract class Escapable_5 : Scoped_5 {
  public readonly Joiner_5 ^exit_ = new Joiner_5();
}

class Switch_5 : Escapable_5 {
  Expression_5 ^expr_;
  GType_5 type_;
  ArrayList /* of SwitchSection_5 */ ^sections_;
  SwitchSection_5 default_;    // or null if no default section

  public Switch_5(Expression_5 ^expr, ArrayList ^sections) { expr_ = expr; sections_ = sections; }

  public override bool Check(Context_5 ctx) {
    SetStartVar(ctx);
    type_ = expr_.CheckTop(ctx);
    if (type_ == null)
      return false;
    if (type_ != GInt_5.type_ && type_ != GChar_5.type_ && type_ != GString_5.type_) {
      Error("switch expression must be of type int, char or string");
      return false;
    }
    Context_5 ^ctx1 = new Context_5(ctx, this);
    OwningHashtable ^values = new OwningHashtable();
    Control_5 c = ctx1.Prev();
    foreach (SwitchSection_5 s in sections_) {
      bool is_default;
      ctx1.SetPrev(c);
      if (!s.Check(ctx1, type_, values, out is_default))
        return false;
      if (is_default)
        default_ = s;
      if (ctx1.Prev() != unreachable_) {
        s.Error("switch case may not fall through to following case");
        return false;
      }
    }
    if (default_ == null)
      exit_.Join(c);
    ctx1.SetPrev(exit_.Combine());
    return true;
  }

  SwitchSection_5 FindSection(GValue_5 v) {
    foreach (SwitchSection_5 s in sections_)
      if (s.Match(v))
        return s;
    return default_;
  }

  RValue_5 ^CatchBreak(RValue_5 ^v) {
    return v is BreakValue_5 ? null : v;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    RValue_5 ^v = expr_.Eval(env);
    if (v == null)
      return null;
    SwitchSection_5 s = FindSection(v.Get());
    if (s == null)
      return null;
    return CatchBreak(s.block_.Eval(env));
  }

  public override void Emit(SourceWriter_5 w) {
    if (type_ == GString_5.type_) {
      // For_5 now, we implement a switch on strings using a sequence of if statements.  We wrap
      // the sequence in a dummy switch statement so that break statements will work properly.
      // If_5 the switch statement has just a default: label then the Microsoft C++ compiler issues
      // a warning, and if it has just a case 0: label then the compiler doesn't realize that the
      // case will always be executed, which may lead to warnings about not all code paths returning
      // a value.  So we use both default: and case 0:, which seems to work fine.
      w.Write("switch (0) ");
      w.OpenBrace();
      w.IWriteLine("case 0:");
      w.IWriteLine("default:");
      w.IWriteLine("StringPtr _s = {0};", expr_.Emit());
      foreach (SwitchSection_5 s in sections_)
        if (s != default_)
          s.EmitString(w);
      if (default_ != null)
        default_.block_.Emit(w);
      w.CloseBrace();
    } else {
      w.Write("switch ({0}) ", expr_.Emit());
      w.OpenBrace();

      foreach (SwitchSection_5 s in sections_)
        s.Emit(w);

      w.CloseBrace();
    }
  }
}

abstract class Loop_5 : Escapable_5 {
  public readonly Joiner_5 ^loop_ = new Joiner_5();
}

abstract class ForOrWhile_5 : Loop_5 {
  protected Expression_5 ^condition_;
  protected Statement_5 ^statement_;

  protected ForOrWhile_5(Expression_5 ^condition, Statement_5 ^statement) {
    condition_ = condition; statement_ = statement;
  }

  protected abstract InlineStatement_5 Initializer();
  protected abstract InlineStatement_5 Iterator();

  public override bool Check(Context_5 prev_ctx) {
    Context_5 ^ctx = new Context_5(prev_ctx, this);   // initializer may declare new local variable
    SetStartVar(ctx);
    if (!Initializer().Check(ctx))
      return false;
    SetTopVar(ctx);

    loop_.AddControl(ctx);

    if (!condition_.CheckTop(ctx, GBool_5.type_))
      return false;

    if (!condition_.IsTrueLiteral())  // we may exit the loop at this point
      exit_.Join(ctx.Prev());  

    if (!statement_.Check(ctx))
      return false;

    if (!Iterator().Check(ctx))
      return false;

    loop_.Join(ctx.Prev());  // loop back to top

    ctx.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy any local defined in an initializer above.
    AddControl(ctx);

    return true;
  }

  public override RValue_5 ^Eval(Env_5 outer_env) {
    Env_5 ^env = new Env_5(outer_env);   // initializer may declare new local
    for (Initializer().Eval(env); condition_.EvalBool(env); Iterator().Eval(env)) {
      RValue_5 ^v = statement_.Eval(env);
      if (v is BreakValue_5)
        break;
      if (v is ContinueValue_5)
        continue;
      if (v != null)
        return v;
    }
    return null;
  }
}

class While_5 : ForOrWhile_5 {
  public While_5(Expression_5 ^condition, Statement_5 ^statement) : base(condition, statement) { }

  protected override InlineStatement_5 Initializer()  { return EmptyStatement_5.instance_; }
  protected override InlineStatement_5 Iterator()  { return EmptyStatement_5.instance_; }

  public override void Emit(SourceWriter_5 w) {
    w.Write("while ({0})", condition_.Emit());
    statement_.EmitEmbedded(w);
  }
}

class For_5 : ForOrWhile_5 {
  InlineStatement_5 ^initializer_;
  InlineStatement_5 ^iterator_;

  public For_5(InlineStatement_5 ^initializer, Expression_5 ^condition, InlineStatement_5 ^iterator,
             Statement_5 ^statement)
    : base(condition != null ? condition : new Literal_5(new GBool_5(true)),
           statement) {
    initializer_ = initializer != null ? initializer : new EmptyStatement_5();
    iterator_ = iterator != null ? iterator : new EmptyStatement_5();
  }

  protected override InlineStatement_5 Initializer()  { return initializer_; }
  protected override InlineStatement_5 Iterator()  { return iterator_; }

  public override void Emit(SourceWriter_5 w) {
    w.Write("for (");
    initializer_.EmitInline(w);
    w.Write("; {0}; ", condition_.Emit());
    iterator_.EmitInline(w);
    w.Write(")");
    statement_.EmitEmbedded(w);
  }
}

class Do_5 : Loop_5 {
  Statement_5 ^statement_;
  Expression_5 ^condition_;

  Joiner_5 ^join_ = new Joiner_5();

  public Do_5(Statement_5 ^statement, Expression_5 ^condition) {
    statement_ = statement;
    condition_ = condition;
  }

  public override bool Check(Context_5 ctx) {
    join_.AddControl(ctx);

    Context_5 ^ctx1 = new Context_5(ctx, this);
    SetStartVar(ctx);

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx.Prev());  // continue statements jump here
    ctx.SetPrev(loop_.Combine());

    if (!condition_.CheckTop(ctx, GBool_5.type_))
      return false;

    if (!condition_.IsFalseLiteral())
      join_.Join(ctx.Prev());   // loop back to top
    if (!condition_.IsTrueLiteral())
      exit_.Join(ctx.Prev());   // fall through to exit
    ctx.SetPrev(exit_.Combine());

    return true;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    do {
      RValue_5 ^v = statement_.Eval(env);
      if (v is BreakValue_5)
        break;
      if (v is ContinueValue_5)
        continue;
      if (v != null)
        return v;
    } while (condition_.EvalBool(env));
    return null;
  }

  public override void Emit(SourceWriter_5 w) {
    w.IWrite("do");
    statement_.EmitEmbedded(w);
    w.IWriteLine("while ({0});", condition_.Emit());
  }
}

// A helper class for ForEach_5: a node defining a single variable in the control graph.
class Definer_5 : Node_5 {
  Local_5 local_;

  public Definer_5(Local_5 local) { local_ = local; }

  public override bool Sets(Local_5 local) {
    return local_ == local;
  }
}

class ForEach_5 : Loop_5 {
  Local_5 ^local_;
  Expression_5 ^expr_;
  GType_5 expr_type_;
  Statement_5 ^statement_;

  Property_5 count_;
  Indexer_5 indexer_;

  Definer_5 ^definer_;

  public ForEach_5(TypeExpr_5 ^type_expr, string name, Expression_5 ^expr, Statement_5 ^statement) {
    local_ = new Local_5(type_expr, name, null);
    expr_ = expr;
    statement_ = statement;
  }

  public override bool Check(Context_5 ctx) {
    if (!local_.Resolve(ctx.program_))
      return false;

    expr_type_ = expr_.CheckTop(ctx);
    if (expr_type_ == null)
      return false;

    count_ = expr_type_.Lookup(this, ctx.class_, false, MemberKind_5.Property_5, "Count", null, false) as Property_5;
    if (count_ == null) {
      Error("object enumerable by foreach must have an accessible property Count");
      return false;
    }
    if (count_.Type() != GInt_5.type_) {
      Error("object enumerable by foreach must have a property Count of type int");
      return false;
    }

    ArrayList ^args = new ArrayList();
    args.Add(new InArgument_5(GInt_5.type_));
    indexer_ = (Indexer_5) expr_type_.Lookup(this, ctx.class_, false, MemberKind_5.Indexer_5, null, args, false);
    if (indexer_ == null) {
      Error("object enumerable by foreach must have an accessible indexer on integers");
      return false;
    }
    if (!indexer_.CheckAssigning(this, ctx, false))
      return false;

    GType_5 indexer_type = indexer_.Type();
    GType_5 iterator_type = local_.Type();
    if (!indexer_type.CanConvertExplicit(iterator_type, false)) {
      Error("enumeration type {0} is not explicitly convertible to iteration variable type {1}",
        indexer_type, iterator_type);
      return false;
    }

    Context_5 ^ctx1 = new Context_5(ctx, this);

    SetStartVar(ctx1);
    if (!local_.Check(ctx1))   // will add local to scope chain
      return false;
    SetTopVar(ctx1);

    // Add a control graph node representing the creation of the local above.
    definer_ = new Definer_5(local_);
    definer_.AddControl(ctx1);

    loop_.AddControl(ctx1);   // continue statements jump here

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx1.Prev());   // loop back to top

    exit_.Join(loop_);  // any loop iteration may exit

    ctx1.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy the local variable created above.
    AddControl(ctx1);

    return true;
  }

  public override RValue_5 ^Eval(Env_5 outer_env) {
    RValue_5 ^r = expr_.Eval(outer_env);
    GValue_5 e = r.Get();
    if (e is Null_5) {
      Error("foreach: can't iterate over null object");
      Gel_5.Exit();
    }

    int count = ((GInt_5) count_.Get(e)).i_;

    Env_5 ^env = new Env_5(outer_env);
    env.Add(local_, null);
    for (int i = 0 ; i < count ; ++i) {
      RValue_5 ^v = indexer_.Get(e, new GInt_5(i));
      env.Set(local_, v.Get().ConvertExplicit(ref v, local_.Type()));
      RValue_5 ^s = statement_.Eval(env);
      if (s is BreakValue_5)
        break;
      if (s is ContinueValue_5)
        continue;
      if (s != null)
        return s;
    }
    return null;
  }

  public override void Emit(SourceWriter_5 w) {
    w.OpenBrace();
    w.IWriteLine("{0} _collection = {1};", expr_type_.BaseType().EmitType(), expr_.Emit());
    w.IWriteLine("int _count = _collection->get_Count();");
    w.IWrite("for (int _i = 0 ; _i < _count ; ++_i) ");
    w.OpenBrace();
    w.Indent();
    local_.EmitDeclaration(w);
    w.WriteLine(" = {0}; ",
      Expression_5.EmitExplicit(indexer_.Type(), local_.Type(), "_collection->get_Item(_i)", true));
    statement_.EmitInExistingBlock(w);
    w.CloseBrace();
    w.CloseBrace();
  }
}

class BreakValue_5 : GValue_5 {
  public BreakValue_5() { }

  public static readonly BreakValue_5 ^instance_ = new BreakValue_5();

  public override GType_5 Type()  { Debug.Assert(false); return null; }
}

abstract class BreakOrContinue_5 : Scoped_5 {
  protected void Link(Context_5 ctx, Scoped_5 target, Joiner_5 joiner) {
    // When traversed in the control graph, we destroy all variables in the scopes we are exiting,
    // excluding variables defined in the containing Escapable_5 or Loop_5.
    start_ = target.GetTop();
    SetTopVar(ctx);

    prev_ = ctx.Prev();
    if (prev_ != unreachable_)
      joiner.Join(this);

    ctx.SetPrev(unreachable_);
  }
}

class Break_5 : BreakOrContinue_5 {
  public override bool Check(Context_5 ctx) {
    Escapable_5 e = ctx.escape_;
    if (e == null) {
      Error("break statement must appear inside a while, do, for, foreach or switch statement");
      return false;
    }
    Link(ctx, e, e.exit_);
    return true;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    return new BreakValue_5();
  }

  public override void Emit(SourceWriter_5 w) {
    w.WriteLine("break;");
  }
}

class ContinueValue_5 : GValue_5 {
  public ContinueValue_5() { }

  public static readonly ContinueValue_5 ^instance_ = new ContinueValue_5();

  public override GType_5 Type()  { Debug.Assert(false); return null; }
}

class Continue_5 : BreakOrContinue_5 {
  public override bool Check(Context_5 ctx) {
    Loop_5 l = ctx.loop_;
    if (l == null) {
      Error("continue statement must appear inside a while, do, for or foreach statement");
      return false;
    }
    Link(ctx, l, l.loop_);
    return true;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    return new ContinueValue_5();
  }

  public override void Emit(SourceWriter_5 w) {
    w.WriteLine("continue;");
  }
}

class Return_5 : Statement_5 {
  Expression_5 ^exp_;    // null if no return value
  GType_5 exp_type_;
  GType_5 type_;

  public Return_5(Expression_5 ^exp) {
    exp_ = exp;
  }

  public override bool Check(Context_5 ctx) {
    if (exp_ == null) {
      if (ctx.method_.ReturnType() != Void_5.type_) {
        Error("error: returning value from function returning void");
        return false;
      }
    } else {
      type_ = ctx.method_.ReturnType();
      ctx.EnterExpression();
      exp_type_ = exp_.CheckAndHold(ctx);
      if (exp_type_ == null ||
          !exp_type_.CheckConvert(this, type_,
            exp_.IsRefOutParameter() ? ConversionContext_5.AssignVar : ConversionContext_5.Other))
        return false;
      exp_.CheckLoseOwnership(exp_type_, type_);
      ctx.FinishExpression();
      exp_.ReleaseRef(ctx);
    }

    ctx.method_.JoinReturn(ctx);
    ctx.SetPrev(unreachable_);
    return true;
  }

  public override RValue_5 ^Eval(Env_5 env) {
    return exp_ != null ? exp_.Eval(env, type_)
                        : Null_5.Instance.Copy();    // an arbitrary value
  }

  public override void Emit(SourceWriter_5 w) {
    if (exp_ != null && exp_.NeedsRef(exp_type_)) {
      // If_5 exp_ needs a reference count, that reference count needs to survive the destruction
      // of temporaries, so we can't simply emit a temporary reference count wrapper.  For_5 example,
      // when compiling the expression "return (new Foo()).Fun();", if Fun() returns a Foo then we
      // need a wrapper, and we can't generate "return _Ptr<Fun>(Foo().Fun()).Get()" since the _Ptr<Fun>
      // wrapper will be destroyed before the temporary Foo() object is destroyed.  So we need to
      // use an extra variable here.
      w.OpenBrace();
      w.IWriteLine("{0} __ret = {1};", exp_type_.EmitType(), exp_.Emit());
      w.IWriteLine("return __ret.Get();");
      w.CloseBrace();
    } else {
      w.Write("return ");
      if (exp_ != null)
        w.Write(exp_.Emit(exp_type_, type_));
      w.WriteLine(";");
    }
  }
}

class Attribute_5 {
  public const int Abstract = 1,
  Const = 2,
  Extern = 4,
  Override = 8,
  Private = 16,
  Protected = 32,
  Public = 64,
  ReadOnly = 128,
  Ref = 256,
  Static = 512,
  Virtual = 1024,
  Setter = 2048;
}

class AttributeUtil_5 {
  public static bool CheckOnly(int a, int allowed) {
    return (a & ~allowed) == 0;
  }
}

class MethodTraverser_5 : Traverser_5 {
  Method_5 method_;

  public MethodTraverser_5(Method_5 method) { method_ = method; }

  public override int Handle(Control_5 control) {
    if (control == Control_5.unreachable_)
      return Cut;

    Node_5 node = control as Node_5;
    if (node != null) {
      Method_5 c = node.Calls();
      if (c != null)
        method_.calls_.Add(c);
      method_.internal_destroys_.Add(node.NodeDestroys());
    }

    return Continue_5;
  }
}

class Method_5 : Member_5 {
  public readonly ArrayList /* of Parameter_5 */ ^parameters_;

  protected Block_5 ^body_;

  public Joiner_5 ^exit_ = new Joiner_5();

  // all parameters and locals defined in this method
  readonly NonOwningArrayList /* of Local_5 */ ^locals_ = new NonOwningArrayList();

  NonOwningArrayList /* of Method_5 */ ^overrides_;   // list of all overrides (virtual methods only)

  // methods called from this method
  public readonly NonOwningArrayList /* of Method_5 */ ^calls_ = new NonOwningArrayList();

  // Types destroyed inside this method, not including types destroyed through
  // calls to other methods.
  public readonly TypeSet_5 ^internal_destroys_ = new TypeSet_5();

  // Types destroyed inside this method or in any methods called by this method.
  TypeSet_5 ^destroys_;

  TypeSet_5 ^parameter_destroys_;

  // A marker used when performing a depth-first search of the method graph to compute destroys_.
  int method_marker_;

  public Method_5(int attributes, TypeExpr_5 ^return_type_expr,
                string name, ArrayList /* of Parameter_5 */ ^parameters, Block_5 ^body)
    : base(attributes, return_type_expr, name) {
    parameters_ = parameters;
    body_ = body;
  }

  public override int Kind() { return MemberKind_5.Method_5; }

  public GType_5 ReturnType() { return type_; }

  public override ArrayList Parameters() {
    return parameters_;
  }

  public bool IsExtern() { return class_.IsExtern(); }

  public bool IsStatic() {
    return HasAttribute(Attribute_5.Static);
  }

  public override bool Resolve(Program_5 program) {
    if (!base.Resolve(program))
      return false;
    foreach (Parameter_5 p in parameters_)
      if (!p.Resolve(program))
        return false;
    return true;
  }

  public void AddVar(Local_5 v) {
    locals_.Add(v);
  }

  public override bool Sets(Local_5 local) {
    foreach (Parameter_5 p in parameters_)
      if (p == local && p.GetMode() != Mode_5.Out)
        return true;
    return false;
  }

  public void JoinReturn(Context_5 ctx) {
    exit_.Join(ctx.Prev());
  }

  public const int kValidAttributes =
    Attribute_5.Abstract | Attribute_5.Override |
    Attribute_5.Private | Attribute_5.Protected | Attribute_5.Public |
    Attribute_5.Static | Attribute_5.Virtual | Attribute_5.Setter;

  protected override int ValidAttributes() {
    return kValidAttributes;
  }

  // overridden by Constructor_5 subclass
  protected virtual bool CheckEntry(Context_5 ctx) { return true; }

  // overridden by Constructor_5 subclass
  public override bool Check(Context_5 prev_ctx) {
    if (!base.Check(prev_ctx))
      return false;

    bool abstract_or_extern = HasAttribute(Attribute_5.Abstract) || IsExtern();

    if (body_.Absent()) {
      if (!abstract_or_extern) {
        Error("a method without a body must be abstract or extern");
        return false;
      }
      return true;
    } 

    if (abstract_or_extern) {
      Error("an abstract or extern method cannot have a body");
      return false;
    }

    Context_5 ^ctx = new Context_5(prev_ctx, this);

    prev_ = unreachable_;
    ctx.SetPrev(this);    // begin the control graph with this Method_5

    foreach (Parameter_5 p in parameters_)
      if (!p.Check(ctx))
        return false;

    if (!CheckEntry(ctx))
      return false;

    if (!body_.Check(ctx))
      return false;

    if (!(this is Constructor_5) && type_ != Void_5.type_ && ctx.Prev() != unreachable_) {
      Error("method must return a value");
      return false;
    }
    JoinReturn(ctx);

    ctx.ClearPrev();  // control graph is complete

    // Traverse the control graph to build calls_ and internal_destroys_.
    MethodTraverser_5 ^mt = new MethodTraverser_5(this);
    exit_.Traverse(mt, Control_5.GetMarkerValue());

    bool ok = true;
    foreach (Local_5 v in locals_)    // for all locals and parameters
      ok &= v.CheckUsage(this);

    foreach (Parameter_5 p in parameters_)
      p.CheckParameterUsage(this);

    return ok;
  }

  // Determine whether each local variable needs a reference count.
  protected void ComputeRefs() {
    foreach (Local_5 v in locals_)
      v.ComputeRef(this);
  }

  // Return_5 true if this method has a local or parameter with the given name.
  public bool HasLocal(string name) {
    foreach (Local_5 l in locals_)
      if (l.name_ == name)
        return true;
    return false;
  }

  public override TypeSet_5 NodeDestroys() {
    if (parameter_destroys_ == null) {
      parameter_destroys_ = new TypeSet_5();
    foreach (Parameter_5 p in parameters_)
        parameter_destroys_.Add(p.Type().VarDestroys());
    }
    return parameter_destroys_;
  }

  protected override void AddOverride(Member_5 m) {
    if (overrides_ == null)
      overrides_ = new NonOwningArrayList();
    overrides_.Add((Method_5) m);
  }

  bool Visit(int marker, TypeSet_5 set) {
    if (method_marker_ == marker)
      return true;

    method_marker_ = marker;
    set.Add(internal_destroys_);
    if (set.IsObject())
      return false;   // we already have object; no point in traversing further

    foreach (Method_5 m in calls_)
      if (!m.Visit(marker, set))
        return false;

    if (overrides_ != null)
      foreach (Method_5 m in overrides_)
        if (!m.Visit(marker, set))
          return false;

    return true;
  }

  public TypeSet_5 Destroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_5();
      Visit(Control_5.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  // overridden by Constructor_5 subclass
  public virtual RValue_5 ^Eval(Env_5 env) {
    return body_.Eval(env);
  }

  public RValue_5 ^Invoke(GValue_5 obj, ArrayList /* of ValueOrLocation_5 */ values) {
    if (body_.Absent()) { // an external method
      ValueList_5 ^list = new ValueList_5(values);
      if (IsStatic())
        return class_.InvokeStatic(this, list);   // let the class handle it
      return obj.Invoke(this, list);   // let the object handle it
    }

    Env_5 ^env = new Env_5(obj);
    Debug.Assert(values.Count == parameters_.Count);
    for (int i = 0 ; i < values.Count ; ++i)
      env.Add((Parameter_5) parameters_[i], (ValueOrLocation_5) values.Take(i));

    return Eval(env);
  }

  protected void EmitParameterNames(SourceWriter_5 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      w.Write(Param(i).EmitDeclarationName());
    }
    w.Write(")");
  }

  protected void EmitParameters(SourceWriter_5 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      Param(i).EmitDeclaration(w);
    }
    w.Write(") ");
  }

  void EmitAttributes(SourceWriter_5 w, bool declaration) {
    w.Indent();
    if (!IsStatic() && !IsVirtual())
      return;

    if (!declaration)
      w.Write("/* ");
    if (IsStatic())
      w.Write("static ");
    if (IsVirtual())
      w.Write("virtual ");
    if (!declaration)
      w.Write("*/ ");
  }

  void EmitSignature(SourceWriter_5 w, bool declaration) {
    EmitAttributes(w, declaration);
    w.Write("{0} ", type_.EmitReturnType());
    if (!declaration)
      w.Write("{0}::", class_.name_);
    if (HasAttribute(Attribute_5.Setter))
      w.Write("_");
    w.Write(name_);
    EmitParameters(w);
  }

  public virtual void EmitDeclaration(SourceWriter_5 w) {
    ComputeRefs();
    EmitSignature(w, true);
    if (body_.Absent())
      w.Write("= 0");
    w.WriteLine(";");

    if (HasAttribute(Attribute_5.Setter)) {
      w.WriteLine("");
      EmitAttributes(w, true);
      w.Write("{0} ", Param(parameters_.Count - 1).Type().EmitType());
      w.Write(name_);
      EmitParameters(w);
      w.OpenBrace();
      w.IWrite("_{0}", name_);
      EmitParameterNames(w);
      w.WriteLine(";");
      w.IWriteLine("return value;");
      w.CloseBrace();
    }
  }

  protected void EmitExtraDeclarations(SourceWriter_5 w) {
    foreach (Parameter_5 p in parameters_)
      p.EmitExtraDeclaration(w);
  }

  public virtual void Emit(SourceWriter_5 w) {
    if (!body_.Absent()) {
      EmitSignature(w, false);
      w.OpenBrace();
      EmitExtraDeclarations(w);
      body_.list_.Emit(w);
      w.CloseBrace();
      w.WriteLine("");
    }
    if (Gel_5.print_type_sets_)
      Console.WriteLine("{0}.{1}: {2}", class_.name_, name_, Destroys());
  }
}

class Constructor_5 : Method_5 {
  bool call_base_;
  ArrayList /* of Argument_5 */ ^initializer_params_;

  Constructor_5 initializer_;

  bool invoked_;  // true if another constructor invokes this one using : base() or : this()

  public Constructor_5(int attributes, string name, ArrayList ^parameters,
                     bool call_base, ArrayList ^initializer_params, Block_5 ^body)
    : base(attributes, null, name, parameters, body) {
    call_base_ = call_base;
    initializer_params_ = initializer_params;
  }

  public Constructor_5(int attributes, string name, ArrayList ^parameters, Block_5 ^body)
    : this(attributes, name, parameters, true, new ArrayList(), body) { }

  public override int Kind() { return MemberKind_5.Constructor_5; }

  protected override int ValidAttributes() {
    return Attribute_5.Private | Attribute_5.Protected | Attribute_5.Public;
  }

  public override bool Check(Context_5 ctx) {
    if (name_ != class_.name_) {
      Error("constructor name must match class name");
      return false;
    }
    return base.Check(ctx);
  }

  protected override bool CheckEntry(Context_5 ctx) {
    Class_5 c = call_base_ ? class_.Parent() : class_;
    if (c != null || initializer_params_.Count > 0) {
      initializer_ = (Constructor_5) Invocation_5.CheckInvoke(this, ctx, call_base_, c,
                                      c.name_, initializer_params_, MemberKind_5.Constructor_5);
      if (initializer_ == null)
        return false;
      if (initializer_ == this) {
        Error("constructor initializer invokes itself");
        return false;
      }
      initializer_.invoked_ = true;
    }
    return true;
  }

  // A Constructor_5 node in the control graph represents the call to the base constructor;
  // this node gets added when we call Invocation_5.CheckInvoke() above.
  public override Method_5 Calls() { return initializer_; }

  public override RValue_5 ^Eval(Env_5 env) {
    if (initializer_ == null || initializer_.class_ != class_) {
      // run instance variable initializers
      foreach (Field_5 f in class_.fields_)
        if (!f.IsConstOrStatic() && f.Initializer() != null)
          ((GObject_5) env.this_).Set(f, f.Initializer().Eval(Env_5.static_, f.Type()));
    }
    if (initializer_ != null)
      Invocation_5.CallMethod(env, env.this_, initializer_, initializer_params_, false);
    return body_.Eval(env);
  }

  void EmitInitializerArgs(SourceWriter_5 w) {
    w.WriteLine("({0});", Invocation_5.EmitArguments(initializer_, initializer_params_));
  }

  void EmitConstructorBody(SourceWriter_5 w) {
    w.OpenBrace();
    EmitExtraDeclarations(w);
    if (call_base_) {
      if (class_.constructors_.Count > 1)
        w.IWriteLine("_Init();");
      else class_.EmitInitializers(w);

      Class_5 parent = class_.Parent();
      if (parent != GObject_5.type_) {
        w.IWrite("{0}::_Construct", parent.name_);
        EmitInitializerArgs(w);
      }
    } else {
      w.IWrite("_Construct");
      EmitInitializerArgs(w);
    }

    body_.list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitDeclaration(SourceWriter_5 w) {
    ComputeRefs();

    // If_5 we're invoked by some other constructor then we need to declare a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void _Construct");
      EmitParameters(w);
      w.WriteLine(";");
    }

    // Now declare the actual C++ constructor.
    w.IWrite(name_);
    EmitParameters(w);
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_5 w) {
    // If_5 we're invoked by some other constructor then we need to emit a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void {0}::_Construct", name_);
      EmitParameters(w);
      EmitConstructorBody(w);
      w.WriteLine("");
    }

    // Now emit the actual C++ constructor.
    w.IWrite("{0}::{1}", name_, name_);
    EmitParameters(w);
    Class_5 parent = class_.Parent();
    if (parent != GObject_5.type_)
      w.Write(": {0}((Dummy *) 0) ", parent.name_);

    if (invoked_) {   // call the _Construct method we just generated
      w.Write("{ _Construct");
      EmitParameterNames(w);
      w.WriteLine("; }");
    } else EmitConstructorBody(w);
    w.WriteLine("");
  }
}

abstract class PropertyOrIndexer_5 : LMember_5 {
  // If_5 a get accessor is not declared at all, then get_block_ will be null; if it is
  // declared, but has an empty body ("get;") then get_block_ will be a Block_5 whose list_ is
  // null.  We need to distinguish these cases since for abstract or extern properties the
  // presence of a get accessor with an empty body indicates that a property is readable.
  // (set_block_ works similarly.)
  Block_5 ^get_block_, set_block_;

  protected Method_5 getter_, setter_;

  protected PropertyOrIndexer_5(int attributes, TypeExpr_5 ^type_expr, string name,
                              string id1, Block_5 ^block1, string id2, Block_5 ^block2)
    : base(attributes, type_expr, name) {
    StoreAccessor(id1, block1);
    if (id2 != null)
      StoreAccessor(id2, block2);
    if (id1 == id2)
      Error("can't have two {0} accessors", id1);
  }

  void StoreAccessor(string id, Block_5 ^block) {
    // Note that we don't have scanner tokens GET and SET since these are not keywords in GEL2.
    switch (id) {
      case "get": get_block_ = block; return;
      case "set": set_block_ = block; return;
    }
    Error("expected get or set");
  }

  public Method_5 Getter() { return getter_; }
  public Method_5 Setter() { return setter_; }

  protected abstract string BaseName();

  ArrayList ^CopyParameters() {
    ArrayList ^a = new ArrayList();
    foreach (Parameter_5 p in Parameters())
      a.Add(p.Copy());
    return a;
  }

  public override bool Check(Context_5 ctx) {
    if (!base.Check(ctx))
      return false;

    if (get_block_ != null) {
      Method_5 ^m = new Method_5(attributes_, new TypeLiteral_5(type_), "get_" + BaseName(), CopyParameters(), take get_block_);
      getter_ = m;
      class_.Add(m);
      if (!getter_.Resolve(ctx.program_) || !getter_.Check(ctx))
        return false;
    }

    if (set_block_ != null) {
      ArrayList ^set_params = CopyParameters();
      set_params.Add(new Parameter_5(new TypeLiteral_5(type_), "value"));
      Method_5 ^m = new Method_5(attributes_ | Attribute_5.Setter,
                           new TypeLiteral_5(Void_5.type_), "set_" + BaseName(), set_params, take set_block_);
      setter_ = m;
      class_.Add(m);
      if (!setter_.Resolve(ctx.program_) || !setter_.Check(ctx))
        return false;
    }

    return true;
  }

  public override bool CheckAssigning(Syntax_5 caller, Context_5 ctx, bool assigning) {
    if (assigning && set_block_ == null && setter_ == null) {
      caller.Error("can't assign to read-only {0}", KindString());
      return false;
    }
    if (!assigning && get_block_ == null && getter_ == null) {
      caller.Error("can't read from write-only {0}", KindString());
      return false;
    }
    return true;
  }

  public override Location_5 GetLocation(GObject_5 obj) { Debug.Assert(false); return null; }
}

class Property_5 : PropertyOrIndexer_5 {
  public Property_5(int attributes, TypeExpr_5 ^type_expr, string name,
                  string id1, Block_5 ^block1, string id2, Block_5 ^block2)
    : base(attributes, type_expr, name, id1, block1, id2, block2) { }

  public override int Kind() { return MemberKind_5.Property_5; }

  protected override int ValidAttributes() {
    return Method_5.kValidAttributes;
  }

  protected override string BaseName() { return name_; }

  public override RValue_5 ^Get(GValue_5 obj) {
    return Invocation_5.InvokeMethod(obj, getter_, new ArrayList(), true);
  }

  public override void Set(GObject_5 obj, RValue_5 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(val);
    Invocation_5.InvokeMethod(obj, setter_, a, true);
  }

  public override string Emit() {
    return String.Format("get_{0}()", name_);
  }

  public override string EmitSet(string val) {
    return String.Format("set_{0}({1})", name_, val);
  }
}

class Indexer_5 : PropertyOrIndexer_5 {
  public readonly Parameter_5 parameter_;

  ArrayList /* of Parameter_5 */ ^parameters_;

  public Indexer_5(int attributes, TypeExpr_5 ^type_expr, Parameter_5 ^parameter,
                 string id1, Block_5 ^block1, string id2, Block_5 ^block2)
    : base(attributes, type_expr, null, id1, block1, id2, block2) {
    parameter_ = parameter;

    parameters_ = new ArrayList();
    parameters_.Add(parameter);
  }

  public override int Kind() { return MemberKind_5.Indexer_5; }

  public override bool Resolve(Program_5 program) {
    return base.Resolve(program) && parameter_.Resolve(program);
  }

  protected override int ValidAttributes() {
    return Attribute_5.Abstract | Attribute_5.Override |
    Attribute_5.Private | Attribute_5.Protected | Attribute_5.Public | Attribute_5.Virtual;
  }

  protected override string BaseName() { return "Item"; }

  public override bool Check(Context_5 ctx) {
    if (parameter_ is RefOutParameter_5) {
      Error("indexer parameter may not be ref or out");
      return false;
    }

    return base.Check(ctx);
  }

  public override ArrayList /* of Parameter_5 */ Parameters() {
    return parameters_; 
  }

  public RValue_5 ^Get(GValue_5 obj, RValue_5 ^index) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    return Invocation_5.InvokeMethod(obj, getter_, a, true);
  }

  public void Set(GObject_5 obj, RValue_5 ^index, RValue_5 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    a.Add(val);
    Invocation_5.InvokeMethod(obj, setter_, a, true);
  }
}

class Class_5 : Ownable_5 {
  Syntax_5 ^syntax_ = new Syntax_5();
  Program_5 program_;   // containing program
  int attributes_;
  public readonly string name_;
  string parent_name_;    // or null if not specified

  Class_5 parent_;

  public readonly NonOwningArrayList /* of Field_5 */ ^fields_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Method_5 */ ^methods_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Property_5 */ ^properties_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Indexer_5 */ ^indexers_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Constructor_5 */ ^constructors_ = new NonOwningArrayList();

  public readonly ArrayList /* of Member_5 */ ^members_ = new ArrayList();

  public readonly ArrayList /* of Temporaries_5 */ ^temporaries_ = new ArrayList();

  public readonly NonOwningArrayList /* of Class_5 */ ^subclasses_ = new NonOwningArrayList();
  bool emitted_;

  // If_5 virtual_ is true, then this class needs a vtable; we set this for a class C
  // in any of the following cases:
  // - the program converts some type T to C ^ (for then a C ^ may hold a T, and when
  // the owning pointer is destroyed we need to know which destructor to call)
  // - the program explicitly converts from C to some other type (so we need RTTI for C)
  bool virtual_;
  
  // If_5 object_inherit_ is true, then this class must derive from Object in generated C++
  // code; we set this for a class C in any of the following cases:
  // - a member lookup in C yields a member in Object
  // - the program converts from C to Object or from Object to C
  // - the class is used in a generic context, i.e. in the type C [] or C ^ [].  All such types
  //   use the generic compiled classes Array<Object> / Array<_Own<Object>>, and so in this case we need
  //   to be able to cast between C and Object.
  //
  // If_5 object_inherit_ is true then this class and all its superclasses will have vtables since
  // the C++ Object class has a vtable.
  bool object_inherit_;

  bool need_destroy_;  // true if we need to emit _Destroy methods for this class

  // The set of types which may be destroyed when an instance of this class is destroyed.
  TypeSet_5 ^destroys_;

  // A marker used in performing a depth-first search to construct the destroys_ type set.
  int marker_;

  protected Class_5(string name) { name_ = name; }

  public static Class_5 New_5(int attributes, string name, string parent_name) {
    Class_5 c = Internal_5.Find(name);
    if (c == null) {
      Class_5 ^c1 = new Class_5(name);
      c = c1;
      Gel_5.program_.AddOwn(c1);
    }

    c.attributes_ = attributes;
    c.parent_name_ = parent_name;

    return c;
  }

  public override bool IsOwned() { return true; }

  public Program_5 GetProgram() { return program_; }
  public void SetProgram(Program_5 p) { program_ = p; }

  public bool IsExtern() { return HasAttribute(Attribute_5.Extern); }

  public override Class_5 Parent() { return parent_; }

  public override string ToString() { return name_; }

  public override ArrayList Members() { return members_; }

  public override SimpleValue_5 DefaultValue_5() { return Null_5.Instance; }

  public override void SetVirtual() { virtual_ = true; }
  public override void SetObjectInherit() { object_inherit_ = true;  }
  public void NeedDestroy() { need_destroy_ = true; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public virtual GValue_5 ^New_5() { return new GObject_5(this); }
  public virtual RValue_5 ^InvokeStatic(Method_5 m, ValueList_5 args) { Debug.Assert(false); return null; }

  public void Add(Field_5 ^f) { f.SetClass(this); fields_.Add(f); members_.Add(f);  }

  public virtual void Add(Method_5 ^m) { m.SetClass(this); methods_.Add(m); members_.Add(m);  }

  public void Add(Property_5 ^p) { p.SetClass(this); properties_.Add(p); members_.Add(p);  }

  public void Add(Indexer_5 ^i) { i.SetClass(this); indexers_.Add(i); members_.Add(i); }

  public void AddConstructor(Constructor_5 ^c) { c.SetClass(this); constructors_.Add(c); members_.Add(c);  }

  public NonOwningArrayList /* of Member_5 */ ^FindAbstractMembers() {
    NonOwningArrayList /* of Member_5 */ ^a;
    if (parent_ != null)  {
      a = parent_.FindAbstractMembers();

      // remove members overridden in this class
      int i = 0;
      while (i < a.Count) {
        Member_5 m = (Member_5) a[i];
        Member_5 n = GetMatchingMember(m);
        if (n != null) {
          Debug.Assert(n.HasAttribute(Attribute_5.Abstract | Attribute_5.Override));
          a.RemoveAt(i);
        } else ++i;
      }
    } else a = new NonOwningArrayList();

    // add abstract members from this class
    foreach (Member_5 m in members_) {
      if (m.HasAttribute(Attribute_5.Abstract))
        a.Add(m);
    }

    return a;
  }

  public bool ResolveAll(Program_5 program) {
    if (parent_name_ != null) {
      parent_ = program.FindClass(parent_name_);
      if (parent_ == null) {
        syntax_.Error("can't find parent class {0}", parent_name_);
        return false;
      }
    } else if (this == GObject_5.type_)
      parent_ = null;
    else parent_ = GObject_5.type_;
    if (parent_ != null)
      parent_.subclasses_.Add(this);

    foreach (Member_5 m in members_)
      if (!m.Resolve(program))
        return false;

    if (!IsExtern() && constructors_.Count == 0)
      // add a default constructor
      AddConstructor(new Constructor_5(Attribute_5.Public, name_, new ArrayList(), Block_5.EmptyBlock()));

    return true;
  }

  // In our first checking pass we check all constant fields since we may need to evaluate them
  // in the course of checking other code.
  public bool Check1(Context_5 prev_ctx) {
    if (!AttributeUtil_5.CheckOnly(attributes_,
         Attribute_5.Abstract | Attribute_5.Extern | Attribute_5.Public)) {
      syntax_.Error("illegal class attribute");
      return false;
    }

    if (prev_ctx.program_.FindClass(name_) != this) {
      syntax_.Error("can't have two classes named {0}", name_);
      return false;
    }

    Context_5 ^ctx = new Context_5(prev_ctx, this);
    bool ok = true;
    foreach (Field_5 f in fields_) {
      ConstField_5 cf = f as ConstField_5;
      if (cf != null)
        ok &= cf.Check(ctx);
    }
    return ok;
  }

  public bool Check(Context_5 prev_ctx) {
    Context_5 ^ctx = new Context_5(prev_ctx, this);

    bool ok = true;

    foreach (Member_5 m in members_)
      if (m is Field_5 && !(m is ConstField_5) || m is Method_5)
        ok &= m.Check(ctx);

    // We need to check properties and indexers separately since they add methods to the members_
    // array as they are checked.
    foreach (Property_5 p in properties_)
      ok &= p.Check(ctx);
    foreach (Indexer_5 i in indexers_)
      ok &= i.Check(ctx);

    if (!HasAttribute(Attribute_5.Abstract)) {
      NonOwningArrayList ^a = FindAbstractMembers();
      if (a.Count > 0) {
        foreach (Member_5 m in a)
          syntax_.Error("class does not define inherited abstract {0} {1}", m.KindString(), m.name_);
        ok = false;
      }
    }

    return ok;
  }

  public void GetMainMethod(NonOwningArrayList /* of Method_5 */ result) {
    foreach (Method_5 m in methods_)
      if (m.name_ == "Main" && m.IsPublic() && m.IsStatic() && m.ReturnType() == Void_5.type_) {
        int c = m.parameters_.Count;
        if (c > 1)
          continue;
        if (c == 1) {
          Parameter_5 p = m.Param(0);
          if (p.GetMode() != 0 || !p.Type().Equals(new ArrayType_5(GString_5.type_)) )
            continue;
        }
        result.Add(m);
      }
  }

  public override void FindTypeDestroys(int marker, TypeSet_5 set) {
    if (marker_ == marker)
      return;
    marker_ = marker;
    set.Add(this);
    for (Class_5 c = this; c != null; c = c.parent_) {
      if (c != this && c.marker_ == marker)
        break;
      foreach (Field_5 f in c.fields_)
        if (!f.IsConstOrStatic())
          f.Type().FindVarDestroys(marker, set);
    }
    foreach (Class_5 c in subclasses_)
      c.FindTypeDestroys(marker, set);
  }

  public override TypeSet_5 TypeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_5();
      FindTypeDestroys(Control_5.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  public Temporaries_5 NewTemporaries() {
    Temporaries_5 ^t = new Temporaries_5();
    Temporaries_5 ret = t;
    temporaries_.Add(t);
    return ret;
  }

  public void StaticInit() {
    foreach (Field_5 f in fields_) {
      StaticField_5 sf = f as StaticField_5;
      if (sf != null)
        sf.Init();
    }
  }

  public override string EmitTypeName() { return name_; }

  int EmitAccess(SourceWriter_5 w, int old_access, int new_access) {
    new_access = (new_access & Attribute_5.Public) != 0 ? Attribute_5.Public : Attribute_5.Protected;

    if (new_access != old_access) {
      switch (new_access) {
        case Attribute_5.Protected:
          w.Indent(-1);
          w.WriteLine("protected:");
          break;
        case Attribute_5.Public:
          w.Indent(-1);
          w.WriteLine("public:");
          break;
        default:
          Debug.Assert(false);
          break;
      }
    }

    return new_access;
  }

  public void EmitInitializers(SourceWriter_5 w) {
    foreach (Field_5 f in fields_)
      if (!f.IsConstOrStatic())
        f.EmitInitializer(w);
  }

  // Return_5 true if this top-level class must inherit from Object.
  bool ObjectInherit() {
    if (object_inherit_)
      return true;
    foreach (Class_5 c in subclasses_)
      if (c.ObjectInherit())
        return true;
    return false;
  }

  public void EmitDeclaration(SourceWriter_5 w) {
    if (emitted_ || IsExtern())
      return;

    // C++ requires a parent class to appear before its subclasses in a source file.
    parent_.EmitDeclaration(w);

    emitted_ = true;

    w.Write("class {0} ", name_);
    if (parent_ != null)
      w.Write(": public {0} ",
              parent_ == GObject_5.type_ && !ObjectInherit() ? "_Object" : parent_.name_);
    w.OpenBrace();

    int access = 0;

    if (fields_.Count > 0) {
      foreach (Field_5 f in fields_) {
        access = EmitAccess(w, access, f.attributes_);
        f.EmitDeclaration(w);
      }
      w.WriteLine("");
    }

    if (subclasses_.Count > 0) {
      access = EmitAccess(w, access, Attribute_5.Protected);
      w.IWrite("{0}(Dummy *dummy) ", name_);
      if (parent_ != GObject_5.type_)
        w.Write(": {0}(dummy) ", parent_.name_);
      w.WriteLine("{ }");
      w.WriteLine("");
    }

    // If_5 we have more than one constructor, emit an _Init() method which constructors can
    // call to initialize instance variables.
    if (constructors_.Count > 1) {
      access = EmitAccess(w, access, Attribute_5.Protected);
      w.IWriteLine("void _Init();");
      w.WriteLine("");
    }

    foreach (Constructor_5 c in constructors_) {
      access = EmitAccess(w, access, c.attributes_);
      c.EmitDeclaration(w);
    }

    if (virtual_) {
      access = EmitAccess(w, access, Attribute_5.Public);
      w.IWrite("virtual ~{0}()", name_);
      w.WriteLine(" { }");
      w.WriteLine("");
    }

    if (need_destroy_) {
      access = EmitAccess(w, access, Attribute_5.Public);
      w.IWriteLine("GEL_OBJECT({0})", name_);
      w.WriteLine("");
    }

    foreach (Method_5 m in methods_) {
      access = EmitAccess(w, access, m.attributes_);
      m.EmitDeclaration(w);
    }

    w.SubIndent();
    w.WriteLine("};");
    w.WriteLine("");
  }

  public void Emit(SourceWriter_5 w) {
    if (IsExtern())
      return;

    if (fields_.Count > 0) {
      foreach (Field_5 f in fields_)
        f.Emit(w);
      w.WriteLine("");
    }

    if (constructors_.Count > 1) {
      w.IWrite("void {0}::_Init() ", name_);
      w.OpenBrace();
      EmitInitializers(w);
      w.CloseBrace();
      w.WriteLine("");
    }

    foreach (Constructor_5 c in constructors_)
      c.Emit(w);

    foreach (Method_5 m in methods_)
      m.Emit(w);

    if (Gel_5.print_type_sets_)
      Console.WriteLine("~{0}: {1}", name_, TypeDestroys());
  }
}

class ClassPtr_5 {
  public readonly Class_5 class_;

  public ClassPtr_5(Class_5 c) { class_ = c; }
}

class ValueList_5 {
  public ArrayList list_;
  public ValueList_5(ArrayList list) { list_ = list; }

  public GValue_5 Object(int i) { return ((RValue_5) list_[i]).Get(); }
  public bool Bool(int i) { return ((GBool_5) list_[i]).b_; }
  public int Int(int i) { return ((GInt_5) list_[i]).i_; }
  public char Char(int i) { return ((GChar_5) list_[i]).c_; }
  public string GetString(int i) { return ((GString_5) list_[i]).s_; }
}

class Internal_5 : Class_5 {
  static NonOwningArrayList /* of Internal_5 */ ^all_ = new NonOwningArrayList();

  protected Internal_5(string name) : base(name) { }

  public static Internal_5 Find(string name) {
    foreach (Internal_5 p in all_)
      if (p.name_ == name)
        return p;
    return null;
  }

  static void Add(Internal_5 p) { all_.Add(p); }

  public static void Init() {
    Add(GObject_5.type_);
    Add(GArray_5.array_class_);
    Add(GBool_5.type_);
    Add(GChar_5.type_);
    Add(GDouble_5.type_);
    Add(GFloat_5.type_);
    Add(GInt_5.type_);
    Add(GString_5.type_);
    Add(GStringBuilder_5.type_);
    Add(PoolClass_5.instance_);
    Add(DebugClass_5.instance_);
    Add(EnvironmentClass_5.instance_);

    Add(ConsoleClass_5.instance_);
    Add(FileClass_5.instance_);
    Add(PathClass_5.instance_);
    Add(GStreamReader_5.type_);
  }
}

class ObjectClass_5 : Internal_5 {
  public Method_5 equals_;
  public Method_5 get_hash_code_;
  public Method_5 to_string_;

  public ObjectClass_5() : base("Object") { }

  public override void Add(Method_5 ^m) {
    switch (m.name_) {
      case "Equals": equals_ = m; break;
      case "GetHashCode": get_hash_code_ = m; break;
      case "ToString": to_string_ = m; break;
    }
    base.Add(m);
  }
}

class ArrayClass_5 : Internal_5 {
  public ArrayClass_5() : base("Array") { }
}

abstract class SimpleType_5 : Internal_5 {
  protected SimpleType_5(string name) : base(name) { }

  public override bool IsOwned() { return false; }
  public override bool IsReference() { return false; }
  public override bool IsValue() { return true; }

  public override string EmitExprType() { return EmitType(); }
  public override string EmitType() { Debug.Assert(false); return null; }
}

abstract class IntegralType_5 : SimpleType_5 {
  protected IntegralType_5(string name) : base(name) { }
}

class BoolClass_5 : IntegralType_5 {
  public BoolClass_5() : base("Bool") { }

  static GBool_5 ^default_ = new GBool_5(false);
  public override SimpleValue_5 DefaultValue_5() { return default_; }

  public override string ToString() { return "bool"; }

  public override string EmitType() { return "bool"; }
}

class CharClass_5 : IntegralType_5 {
  public CharClass_5() : base("Char") { }

  static GChar_5 ^default_ = new GChar_5('\0');

  public override SimpleValue_5 DefaultValue_5() { return default_; }

  public override bool CanConvert1(GType_5 t) { return t == GInt_5.type_; }

  public override string ToString() { return "char"; }

  public override RValue_5 ^InvokeStatic(Method_5 m, ValueList_5 args) {
    switch (m.name_) {
      case "IsDigit": return new GBool_5(Char.IsDigit(args.Char(0)));
      case "IsLetter": return new GBool_5(Char.IsLetter(args.Char(0)));
      case "IsWhiteSpace": return new GBool_5(Char.IsWhiteSpace(args.Char(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "wchar_t"; }
}

class IntClass_5 : IntegralType_5 {
  public IntClass_5() : base("Int") { }

  static GInt_5 ^default_ = new GInt_5(0);

  public override SimpleValue_5 DefaultValue_5() { return default_; }

  public override bool CanConvert1(GType_5 t) {
    return t == GFloat_5.type_ || t == GDouble_5.type_;
  }

  protected override bool CanConvertExplicit1(GType_5 t) {
    return t == GChar_5.type_;
  }

  public override string ToString() { return "int"; }

  public override RValue_5 ^InvokeStatic(Method_5 m, ValueList_5 args) {
    switch (m.name_) {
      case "Parse": return new GInt_5(int.Parse(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "int"; }
}

class FloatClass_5 : SimpleType_5 {
  public FloatClass_5() : base("Single") { }

  static GFloat_5 ^default_ = new GFloat_5(0.0f);

  public override SimpleValue_5 DefaultValue_5() { return default_; }

  public override bool CanConvert1(GType_5 t) {
    return t == GDouble_5.type_;
  }

  protected override bool CanConvertExplicit1(GType_5 t) {
    return t == GInt_5.type_;
  }

  public override string ToString() { return "float"; }

  public override string EmitType() { return "float"; }
}

class DoubleClass_5 : SimpleType_5 {
  public DoubleClass_5() : base("Double") { }

  static GDouble_5 ^default_ = new GDouble_5(0.0d);

  public override SimpleValue_5 DefaultValue_5() { return default_; }

  protected override bool CanConvertExplicit1(GType_5 t) {
    return t == GInt_5.type_ || t == GFloat_5.type_;
  }

  public override string ToString() { return "double"; }

  public override string EmitType() { return "double"; }
}

class StringClass_5 : Internal_5 {
  public StringClass_5() : base("String") { }

  public override bool IsOwned() { return false; }
  public override bool IsValue() { return true; }

  public override string ToString() { return "string"; }

  public override string EmitType() {
    return "_Ref<String>";
  }

  public override string EmitReturnType() {
    return EmitType();
  }

  public override string EmitGenericType() {
    return EmitType();
  }

  public override RValue_5 ^InvokeStatic(Method_5 m, ValueList_5 args) {
    switch (m.name_) {
      case "Format": return new GString_5(String.Format(args.GetString(0), args.Object(1)));
      default: Debug.Assert(false); return null;
    }
  }
}

class StringBuilderClass_5 : Internal_5 {
  public StringBuilderClass_5() : base("StringBuilder") { }
  public override GValue_5 ^New_5() { return new GStringBuilder_5(); }
}

class GStringBuilder_5 : GValue_5 {
  readonly StringBuilder ^b_ = new StringBuilder();

  public static readonly StringBuilderClass_5 ^type_ = new StringBuilderClass_5();

  public override GType_5 Type() { return type_; }

  public override RValue_5 ^Invoke(Method_5 m, ValueList_5 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "Append": b_.Append(args.Char(0)); return null;
      case "ToString": return new GString_5(b_.ToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class PoolClass_5 : Internal_5 {
  public PoolClass_5() : base("Pool") { }

  public static PoolClass_5 ^instance_ = new PoolClass_5();
}

class DebugClass_5 : Internal_5 {
  public DebugClass_5() : base("Debug") { }
  public static readonly DebugClass_5 ^instance_ = new DebugClass_5();
  
  public override RValue_5 ^InvokeStatic(Method_5 m, ValueList_5 args) {
    switch (m.name_) {
      case "Assert": Debug.Assert(args.Bool(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

class EnvironmentClass_5 : Internal_5 {
  public EnvironmentClass_5() : base("Environment") { }
  public static readonly EnvironmentClass_5 ^instance_ = new EnvironmentClass_5();

  public override RValue_5 ^InvokeStatic(Method_5 m, ValueList_5 args) {
    switch (m.name_) {
      case "Exit": Environment.Exit(args.Int(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

// built-in I/O classes

class ConsoleClass_5 : Internal_5 {
  public ConsoleClass_5() : base("Console") { }

  public override RValue_5 ^InvokeStatic(Method_5 m, ValueList_5 args) {
    switch (m.name_) {
      case "Write":
        switch (m.parameters_.Count) {
          case 1: Console.Write(args.Object(0)); return null;
          case 2: Console.Write(args.GetString(0), args.Object(1)); return null;
          case 3: Console.Write(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      case "WriteLine":
        switch (m.parameters_.Count) {
          case 1: Console.WriteLine(args.Object(0)); return null;
          case 2: Console.WriteLine(args.GetString(0), args.Object(1)); return null;
          case 3: Console.WriteLine(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly ConsoleClass_5 ^instance_ = new ConsoleClass_5();
}

class FileClass_5 : Internal_5 {
  public FileClass_5() : base("File") { }

  public override RValue_5 ^InvokeStatic(Method_5 m, ValueList_5 args) {
    switch (m.name_) {
      case "Delete": File.Delete(args.GetString(0)); return null;
      case "Exists": return new GBool_5(File.Exists(args.ToString()));
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly FileClass_5 ^instance_ = new FileClass_5();
}

class PathClass_5 : Internal_5 {
  public PathClass_5() : base("Path") { }

  public override RValue_5 ^InvokeStatic(Method_5 m, ValueList_5 args) {
    switch (m.name_) {
      case "GetTempFileName": return new GString_5(Path.GetTempFileName());
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly PathClass_5 ^instance_ = new PathClass_5();
}

class StreamReaderClass_5 : Internal_5 {
  public StreamReaderClass_5() : base("StreamReader") { }
  public override GValue_5 ^New_5() { return new GStreamReader_5(); }
}

class GStreamReader_5 : GValue_5 {
  StreamReader ^reader_;

  public static readonly StreamReaderClass_5 ^type_ = new StreamReaderClass_5();

  public override GType_5 Type() { return type_; }

  public override RValue_5 ^Invoke(Method_5 m, ValueList_5 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StreamReader": reader_ = new StreamReader(args.GetString(0)); return null;
      case "Read": return new GInt_5(reader_.Read());
      case "Peek": return new GInt_5(reader_.Peek());
      default: Debug.Assert(false); return null;
    }
  }
}

class Program_5 {
  ArrayList /* of string */ ^gel_import_ = new ArrayList();
  ArrayList /* of string */ ^cpp_import_ = new ArrayList();

  static Scanner_5 ^scanner_;

  NonOwningArrayList ^classes_ = new NonOwningArrayList();
  ArrayList ^own_classes_ = new ArrayList();

  public bool crt_alloc_;
  public bool debug_;
  public bool safe_ = true;

  public Control_5 prev_;   // previous node in control flow graph, used during graph construction

  public void Import(string s) {
    ArrayList a = null;
    string extension = Path.GetExtension(s);
    switch (extension) {
      case ".gel": a = gel_import_; break;
      case ".cpp": a = cpp_import_; break;
      default:
        new Syntax_5().Error("can't import file with extension {0}", extension);
        Environment.Exit(0);
        break;
    }
    foreach (string i in a)
      if (i == s)
        return;   // already imported
    a.Add(s);
  }

  public void FindAndImport(string s) {
    // First look relative to the importing file.
    string dir = Path.GetDirectoryName(Gel_5.CurrentFile());
    string s1 = Path.Combine(dir, s);
    if (!File.Exists(s1)) {
      // Now look relative to the GEL2 directory.
      s1 = Path.Combine(Gel_5.gel_directory_, s);
      if (!File.Exists(s1)) {
        new Syntax_5().Error("import not found: ", s);
        Environment.Exit(0);
      }
    }
    Import(s1);
  }
  
  public void Add(Class_5 c) {
    c.SetProgram(this);
    classes_.Add(c);
  }

  public void AddOwn(Class_5 ^c) {
    own_classes_.Add(c);
  }

  public Class_5 FindClass(string name) {
    foreach (Class_5 c in classes_)
      if (c.name_ == name)
        return c;
    return null;
  }

  public string CurrentFile() {
    return scanner_.filename_;
  }

  public int Line() {
    return scanner_.Line();
  }

  string Builtin(string module) {
    string file = String.Format("{0}.gel", module);
    return Path.Combine(Gel_5.gel_directory_, file);
  }

  public bool Parse() {
    Parser ^parser = new Parser();
    for (int i = 0; i < gel_import_.Count; ++i) {
      string file = (string) gel_import_[i];
      scanner_ = new Scanner_5(file);
      parser.yyParse(scanner_);
      if (i == 0) {
        Import(Builtin("internal"));
        Import(Builtin("library"));
      }
    }
    return true;
  }

  public bool Resolve() {
    foreach (Class_5 c in classes_)
      if (!c.ResolveAll(this))
        return false;

    return true;
  }

  public bool Check() {
    Context_5 ^ctx = new Context_5(this);
    bool ok = true;

    // Make a first checking pass where we check only constant fields.
    foreach (Class_5 c in classes_)
      ok &= c.Check1(ctx);

    foreach (Class_5 c in classes_)
      ok &= c.Check(ctx);

    return ok;
  }

  Method_5 FindMain() {
    NonOwningArrayList ^methods = new NonOwningArrayList();
    foreach (Class_5 c in classes_) {
      c.GetMainMethod(methods);
    }
    if (methods.Count == 0) {
      Console.WriteLine("no Main() method found");
      return null;
    }
    if (methods.Count > 1) {
      Console.WriteLine("error: found more than one Main() method");
      return null;
    }
    return (Method_5) methods[0];
  }

  public void Eval(ArrayList /* of string */ args) {
    Method_5 m = FindMain();
    if (m == null)
      return;
    ArrayList ^a = new ArrayList();
    if (m.parameters_.Count > 0) {   // Main() takes a string[] argument
      GArray_5 ^arr = new GArray_5(new ArrayType_5(GString_5.type_), args.Count);
      for (int i = 0 ; i < args.Count ; ++i)
        arr.Set(i, new GString_5((string) args[i]));
      a.Add(arr);
    }
    foreach (Class_5 c in classes_)
      c.StaticInit();
    m.Invoke(null, a);
  }

  void EmitMain(SourceWriter_5 w, Method_5 main) {
    bool args = main.parameters_.Count > 0;
    w.Write("int main({0}) ", args ? "int argc, char *argv[]" : "");
    w.OpenBrace();
    w.IWriteLine("return gel_runmain({0}::Main{1});", main.GetClass().name_, args ? ", argc, argv" : "");
    w.CloseBrace();
  }

  public bool Emit(SourceWriter_5 w) {
    Method_5 main = FindMain();
    if (main == null)
      return false;

    w.WriteLine("#define MEMORY_OWN 1");
    if (safe_)
      w.WriteLine("#define MEMORY_SAFE 1");
    if (crt_alloc_)
      w.WriteLine("#define MEMORY_CRT 1");

    foreach (string f in cpp_import_)
      w.WriteLine("#include {0}", GString_5.EmitString(f));

    // We undefine NULL since Gel_5 code may legitimately define fields or variables with that name.
    // Generated code uses 0, not NULL, to indicate the null pointer.
    w.WriteLine("#undef NULL");

    w.WriteLine("");

    // Forward-declare all classes since C++ requires a class to be declared before its name can
    // be used as a type.
    foreach (Class_5 c in classes_)
      if (!(c.HasAttribute(Attribute_5.Extern)))
        w.WriteLine("class {0};", c.name_);
    w.WriteLine("");

    foreach (Class_5 c in classes_)
      c.EmitDeclaration(w);

    foreach (Class_5 c in classes_)
      c.Emit(w);

    EmitMain(w, main);
    return true;
  }

  // Emit C++ code.
  public bool Generate(string basename) {
    string cpp_file = basename + ".cpp";
    StreamWriter ^w = new StreamWriter(cpp_file);
    bool ok = Emit(new SourceWriter_5(w));
    w.Close();
    return ok;
  }

  static string[] ^vsdirs = { "Microsoft Visual Studio 8",
                            "Microsoft Visual Studio .NET 2003",
                            "Microsoft Visual Studio .NET 2002" };

  string VsVars(int i) {
    return String.Format("C:\\Program_5 Files\\{0}\\Common7\\Tools\\vsvars32.bat", vsdirs[i]);
  }

  string FindVsVars() {
    for (int i = 0; i < vsdirs.Length; ++i) {
      string f = VsVars(i);
      if (File.Exists(f))
        return f;
    }

    Console.WriteLine("Error: unable to find vsvars32.bat at any of the following locations:");
    Console.WriteLine("");
    for (int i = 0; i < vsdirs.Length; ++i)
      Console.WriteLine(VsVars(i));
    Console.WriteLine("");
    Console.WriteLine("Your Visual Studio installation may be invalid.  Aborting compilation.");
    return null;
  }

  // Report compilation error. Print error message from a file
  void ReportCompilationError(string error_msg_file) {
      Console.WriteLine(
        "Error: unable to compile generated C++ code.  You may have found a bug in the GEL2 compiler.");
      Console.WriteLine("C++ compiler output follows:");
      Console.WriteLine("");
      Console.WriteLine((new StreamReader(error_msg_file)).ReadToEnd());
  }

  void UnixCppCompile(string basename) {
    string command_out = Path.GetTempFileName();
    string dbg_options = debug_ ? "-g -DDEBUG" : "-O2 -DNDEBUG";
    StringBuilder ^sb = new StringBuilder();
    // -o basename, use basename as the executable name
    // -Werror, make all warnings into hard errors
    sb.AppendFormat("/usr/bin/g++ -o {0} -Werror {1} {2}.cpp",
                    basename, dbg_options, basename);

    // Append redirection of output
    sb.AppendFormat(" > {0} 2>&1", command_out);
 
    string sh_cmd = sb.ToString();

    if (Gel_5.verbose_) 
      Console.WriteLine(sh_cmd);
  
    if (Process.System(sh_cmd) !=0) {
      ReportCompilationError(command_out);
    }
    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".o");
  }

  // Run vsvars32.bat and the run the given command, redirecting output to a file.
  // We must always redirect output since vsvars32 prints a message "Setting environment..."
  // which we don't want users to see.
  int VsRun(string vsvars, string command, string output) {
    command = String.Format("(\"{0}\" & {1}) > \"{2}\"", 
                            vsvars, command, output);
    return Process.System(command);
  }

  void VsCppCompile(string basename) {
    string vsvars = FindVsVars();
    if (vsvars == null)
      return;
    string command_out = Path.GetTempFileName();

    string options = debug_ ?
      //  /MDd - runtime library: multithreaded debug DLL
      //  /Od - optimization: disabled
      //  /ZI - debug information format: Program_5 Database for Edit & Continue_5
      "/MDd /Od /ZI /D \"_DEBUG\"" :

      //  /MD - runtime library: multithreaded DLL
      //  /O2 - optimization: Maximize Speed
      //  /GL - optimization: Whole Program_5 Optimization
      "/MD /O2 /GL /D \"NDEBUG\"";

    StringBuilder ^sb = new StringBuilder();
    //  /WX - treat warnings as errors
    sb.AppendFormat("cl /nologo /WX {0} {1}.cpp", options, basename);
    string mode = debug_ ? "debug" : "release";
    if (!crt_alloc_)
      sb.AppendFormat(" {0}\\{1}\\dlmalloc.obj", Gel_5.gel_directory_, mode);
    sb.Append(" user32.lib shell32.lib shlwapi.lib");
    string command = sb.ToString();
    if (Gel_5.verbose_)
      Console.WriteLine(command);

    if (VsRun(vsvars, command, command_out) != 0) {
      ReportCompilationError(command_out);
    } else {
      // Run the manifest tool to embed the linker-generated manifest into the executable file;
      // this allows the executable to find the C runtime DLL even when the manifest file is absent.
      string mt_command = String.Format("mt -nologo -manifest {0}.exe.manifest -outputresource:\"{0}.exe;#1\"",
                              basename);
      if (Gel_5.verbose_)
        Console.WriteLine(mt_command);
      if (VsRun(vsvars, mt_command, command_out) != 0)
        Console.WriteLine("warning: could not run manifest tool");
    }

    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".obj");
    File.Delete(basename + ".exe.manifest");
  }

  // Invoke the C++ compiler to generate a native executable.
  void CppCompile(string basename) {
    if (Environment.OSVersion.Platform == PlatformID.Win32NT) 
      VsCppCompile(basename);
    else
      UnixCppCompile(basename);
  }

  public void Compile(string output, bool cpp_only) {
    if (output == null)
      output = Path.GetFileNameWithoutExtension((string) gel_import_[0]);
    if (Generate(output) && !cpp_only)
      CppCompile(output);
  }
}

class Scanner_5 : yyInput {
  public readonly string filename_;

  int line_;
  public int Line() { return line_; }

  StreamReader ^sr_;
  int token_;
  object ^ value_;

  int next_token_ = -1;
  object ^ next_value_;

  public Scanner_5 (string filename) {
    filename_ = filename;
    sr_ = new StreamReader(filename);
    line_ = 1;
  }

  public override int GetToken () {
    return token_;
  }

  public override object ^ GetValue () {
    return take value_;
  }

  int Read() {
    int i = sr_.Read();
    if (i == '\n')
      ++line_;
    return i;
  }

  bool Read(out char c) {
    int i = Read();
    c = (char) i;
    return i != -1;
  }

  char Peek() {
    return (char) sr_.Peek();
  }

  string ReadWord(char first) {
    StringBuilder ^sb = new StringBuilder();
    if (first != '\0')
      sb.Append(first);
    while (true) {
      char c = Peek();
      if (!Char.IsLetter(c) && !Char.IsDigit(c) && c != '_')
        break;
      sb.Append(c);
      Read();
    }
    return sb.ToString();
  }

  // Read to the end of the current line.
  string ReadLine() {
    StringBuilder ^sb = new StringBuilder();
    char c;
    while (Read(out c)) {
      if (c == '\n')
        break;
      sb.Append(c);
    }
    return sb.ToString();
  }

  // Read a comment delimited by /* ... */, assuming we've already read the opening /*.
  // Returns true on success, or false on EOF.
  bool ReadDelimitedComment() {
    char prev = (char) 0;
    while (true) {
      char c;
      if (!Read(out c)) {
        Console.WriteLine("warning: unterminated comment at end of file");
        return false;
      }
      if (c == '/' && prev == '*')
        return true;
      prev = c;
    }
  }

  // Preprocess input, handling whitespace, comments and directives; return the first
  // character not eaten by preprocessing, or -1 on EOF.
  int GetChar() {
    while (true) {
      int i = Read();
      if (i == -1)
        return -1;   // end of input
      if (i == 0)
        continue;   // end of this file; move on
      char c = (char) i;

      if (c == '\n' && Peek() == '#') {
        Read();
        string directive = ReadWord('\0');
        if (directive == "line") {
          ReadLine();
          continue;
        }
        Console.WriteLine("error: unknown preprocessing directive {0}", directive);
        Environment.Exit(0);
      }

      if (Char.IsWhiteSpace(c))
        continue;

      if (c == '/') {
        switch (Peek()) {
          case '/':  // single-line comment
            Read();
            int line = line_;
            string s = ReadLine();
            if (Gel_5.error_test_ && s.StartsWith(" error"))
              Gel_5.expected_error_lines_.Add(line);
            continue;

          case '*':  // comment delimited by /* ... */
            Read();   // move past opening '*'
            if (!ReadDelimitedComment())
              return (char) 0;
            continue;
        }
      }

      return c;
    }
  }

  bool IsDigit(char c, bool hex) {
    if (Char.IsDigit(c))
      return true;
    if (!hex)
      return false;
    return (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');
  }

  // Read a number, possibly including a decimal point and/or exponent.
  string ReadNumber(char first, bool hex, out bool real) {
    bool dot = false, exp = false;
    StringBuilder ^sb = new StringBuilder();
    sb.Append(first);
    if (first == '.')
      dot = true;

    while (true) {
      bool need_digit = false;
      char c = Peek();
      if (c == '.' && !hex && !dot && !exp) {
        sb.Append(c);
        Read();
        dot = true;
        c = Peek();
        need_digit = true;
      }
      else if ((c == 'e' || c == 'E') && !hex && !exp) {
        sb.Append(c);
        Read();
        exp = true;
        c = Peek();
        if (c == '+' || c == '-') {
          sb.Append(c);
          Read();
          c = Peek();
        }
        need_digit = true;
      }
      if (!IsDigit(c, hex)) {
        if (!need_digit)
          break;
        real = false;
        return null;
      }
      sb.Append(c);
      Read();
    }

    real = dot || exp;
    return sb.ToString();
  }

  int ParseNumber(char first, out object ^val) {
    bool hex = false;
    if (first == '0') {
      char p = Peek();
      if (p == 'x' || p == 'X') {
        Read();
        hex = true;
      }
    }
    bool real;
    string s = ReadNumber(first, hex, out real);
    if (s == null) {
      val = null;
      return Parser.SCAN_ERROR;
    }
    if (!hex) {
      switch (Peek()) {
        case 'F':
        case 'f':
          Read();
          val = Single.Parse(s);
          return Parser.FLOAT_LITERAL;
        case 'D':
        case 'd':
          Read();
          real = true;
        break;
    }
    }
    if (real) {
      val = Double.Parse(s);
      return Parser.DOUBLE_LITERAL;
    }
    val = int.Parse(s, hex ? NumberStyles.HexNumber : NumberStyles.Integer);
    return Parser.INT_LITERAL;
  }

  int ParseWord(char first, out object ^val) {
    string s = ReadWord(first);

    val = null;
    switch (s) {
      case "abstract": return Parser.ABSTRACT;
      case "as": return Parser.AS;
      case "base": return Parser.BASE;
      case "bool": return Parser.BOOL;
      case "break": return Parser.BREAK;
      case "case": return Parser.CASE;
      case "char": return Parser.CHAR;
      case "class": return Parser.CLASS;
      case "const": return Parser.CONST_TOKEN;
      case "continue": return Parser.CONTINUE;
      case "default": return Parser.DEFAULT;
      case "do": return Parser.DO;
      case "double": return Parser.DOUBLE;
      case "else": return Parser.ELSE;
      case "extern": return Parser.EXTERN;
      case "false": return Parser.FALSE_TOKEN;
      case "float": return Parser.FLOAT;
      case "for": return Parser.FOR;
      case "foreach": return Parser.FOREACH;
      case "if": return Parser.IF;
      case "import": return Parser.IMPORT;
      case "in": return Parser.IN_TOKEN;
      case "int": return Parser.INT;
      case "is": return Parser.IS;
      case "new": return Parser.NEW;
      case "null": return Parser.NULL;
      case "object": return Parser.OBJECT;
      case "out": return Parser.OUT_TOKEN;
      case "override": return Parser.OVERRIDE;
      case "pool": return Parser.POOL;
      case "private": return Parser.PRIVATE;
      case "protected": return Parser.PROTECTED;
      case "public": return Parser.PUBLIC;
      case "readonly": return Parser.READONLY;
      case "ref": return Parser.REF;
      case "return": return Parser.RETURN;
      case "short": return Parser.SHORT;
      case "static": return Parser.STATIC;
      case "string": return Parser.STRING;
      case "switch": return Parser.SWITCH;
      case "take": return Parser.TAKE;
      case "this": return Parser.THIS_TOKEN;
      case "true": return Parser.TRUE_TOKEN;
      case "virtual": return Parser.VIRTUAL;
      case "void": return Parser.VOID_TOKEN;
      case "while": return Parser.WHILE;
      default:
        val = s;
        return Parser.ID;
    }
  }

  bool ParseEscape(ref char c) {
    if (!Read(out c))
      return false;
    switch (c) {
      case '\'':
      case '\"':
      case '\\':
        break;
      case '0': c = '\0'; break;
      case 'n': c = '\n'; break;
      case 'r': c = '\r'; break;
      case 't': c = '\t'; break;
      default: return false;
    }
    return true;
  }

  int ParseChar(out object ^val) {
    val = null;
    char c;
    if (!Read(out c))
      return Parser.SCAN_ERROR;
    if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
    char d;
    if (!Read(out d) || d != '\'')
      return Parser.SCAN_ERROR;
    val = c;
    return Parser.CHAR_LITERAL;
  }

  int ParseString(out object ^val) {
    val = null;
    StringBuilder ^sb = new StringBuilder();
    while (true) {
      char c;
      if (!Read(out c))
        return Parser.SCAN_ERROR;
      if (c == '"')
        break;
      if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
      sb.Append(c);
    }
    val = sb.ToString();
    return Parser.STRING_LITERAL;
  }

  int ReadToken(out object ^val) {
    val = null;

    int i = GetChar();
    if (i == -1)
      return -1;
    char c = (char) i;

    if (Char.IsDigit(c) || c == '.' && Char.IsDigit(Peek()))
      return ParseNumber(c, out val);

    if (Char.IsLetter(c) || c == '_')
      return ParseWord(c, out val);

    if (c == '\'')
      return ParseChar(out val);

    if (c == '"')
      return ParseString(out val);

    char peek = Peek();
    int token = 0;
    switch (c.ToString() + peek.ToString()) {
      case "++": token = Parser.PLUS_PLUS; break;
      case "--": token = Parser.MINUS_MINUS; break;
      case "&&": token = Parser.OP_AND; break;
      case "||": token = Parser.OP_OR; break;
      case "==": token = Parser.OP_EQUAL; break;
      case "!=": token = Parser.OP_NE; break;
      case "<=": token = Parser.OP_LE; break;
      case "<<": token = Parser.OP_LEFT_SHIFT; break;
      case ">=": token = Parser.OP_GE; break;
      case ">>": token = Parser.OP_RIGHT_SHIFT; break;
      case "*=": token = Parser.STAR_EQUAL; break;
      case "/=": token = Parser.SLASH_EQUAL; break;
      case "%=": token = Parser.PERCENT_EQUAL; break;
      case "+=": token = Parser.PLUS_EQUAL; break;
      case "-=": token = Parser.MINUS_EQUAL; break;
      case "&=": token = Parser.AND_EQUAL; break;
      case "|=": token = Parser.OR_EQUAL; break;

      // Return_5 [] as a single token; this lets the parser distinguish the cases
      // "foo[] a;" and "foo[x] = 4" as soon as it reads the first token after the identifier "foo".
      case "[]": token = Parser.ARRAY_TYPE; break;
    }
    if (token != 0) {
      Read();
    } else token = c;

    val = token;
    return token;
  }

  public override bool Advance () {
    if (next_token_ != -1) {
      token_ = next_token_;
      value_ = take next_value_;
      next_token_ = -1;
    } else {
      token_ = ReadToken(out value_);
      if (token_ == -1) return false;
    }

    if (token_ == ')') {
      // We need to read one token ahead to determine whether this close parenthesis
      // ends a type cast.  See e.g. the discussion in the Cast_5 Expressions section
      // of the C# specification.
      next_token_ = ReadToken(out next_value_);
      switch (next_token_) {
        case -1:  // end of file
          break;
        case '!':
        case '(':
        case Parser.ID:
        case Parser.INT_LITERAL:
        case Parser.CHAR_LITERAL:
        case Parser.STRING_LITERAL:
          token_ = Parser.CAST_CLOSE_PAREN;
          break;
        default:
          if (next_token_ >= Parser.FIRST_KEYWORD && next_token_ <= Parser.LAST_KEYWORD &&
              next_token_ != Parser.AS && next_token_ != Parser.IS)
            token_ = Parser.CAST_CLOSE_PAREN;
          break;
      }
    }
    return true;
  }

  public override void Fatal() {
    new Syntax_5().Error("irrecoverable syntax error");
    Environment.Exit(1);
  }

}

class Gel_5 {
  public static bool verbose_;

  public static bool error_test_;
  public static bool print_type_sets_;

  public static readonly ArrayList /* of int */ ^expected_error_lines_ = new ArrayList();
  public static readonly ArrayList /* of int */ ^error_lines_ = new ArrayList();

  public static Program_5 ^program_;

  public static readonly string gel_directory_ = GetLibraryPath();

  static string GetLibraryPath() {
    return Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName); 
  }

  public static string CurrentFile() {
    return program_ == null ? "" : program_.CurrentFile();
  }

  public static int Line() {
    return program_ == null ? 0 : program_.Line();
  }

  public static void Exit() { Environment.Exit(0); }

  // Given two sorted ArrayLists a, b of ints, return an ArrayList containing all ints which appear
  // in [a] but not in [b].
  ArrayList ^Diff(ArrayList a, ArrayList b) {
    ArrayList ^ret = new ArrayList();
    int bi = 0;
    foreach (int i in a) {
      while (bi < b.Count && (int) b[bi] < i)
        ++bi;
      if (bi >= b.Count || (int) b[bi] > i)
        ret.Add(i);
    }
    return ret;
  }

  void WriteLineNumbers(ArrayList a) {
    for (int i = 0; i < a.Count; ++i) {
      if (i > 0)
        Console.Write(", ");
      Console.Write(a[i]);
    }
    Console.WriteLine("");
  }

  void ErrorTestReport() {
    Console.WriteLine("");
    ArrayList ^e = Diff(error_lines_, expected_error_lines_);
    if (e.Count > 0) {
      Console.Write("unexpected error at line ");
      WriteLineNumbers(e);
    }
    ArrayList ^e2 = Diff(expected_error_lines_, error_lines_);
    if (e2.Count > 0) {
      Console.Write("expected error at line ");
      WriteLineNumbers(e2);
    }
    if (e.Count == 0 && e2.Count == 0)
      Console.WriteLine("all errors expected");
  }

  void Usage_5() {
    Console.WriteLine("usage: gel <source-file> ... [args]");
    Console.WriteLine("       gel -c [-d] [-o <name>] [-u] [-v] [-cpp] <source-file> ...");
    Console.WriteLine("");
    Console.WriteLine("   -c: compile to native executable");
    Console.WriteLine("   -d: debug mode: disable optimizations, link with debug build of C runtime");
    Console.WriteLine("   -o: specify output filename");
    Console.WriteLine("   -u: unsafe: skip reference count checks");
    Console.WriteLine("   -v: verbose: display command used to invoke C++ compiler");
    Console.WriteLine(" -cpp: compile to C++ only");
  }

  public void Run(string[] args) {
    if (args.Length < 1) {
      Usage_5();
      return;
    }

    Internal_5.Init();

    program_ = new Program_5();
    bool compile = false;
    bool cpp_only = false;
    string output = null;
    int i;
    for (i = 0; i < args.Length && args[i].StartsWith("-"); ++i)
      switch (args[i]) {
        case "-c": compile = true; break;
        case "-d": program_.debug_ = true; break;
        case "-e": error_test_ = true; break;
        case "-o":
          if (++i >= args.Length) {
            Usage_5();
            return;
          }
          output = Path.GetFileNameWithoutExtension(args[i]);
          break;
        case "-u": program_.safe_ = false; break;
        case "-v": verbose_ = true; break;
        case "-cpp": cpp_only = true; break;
        case "-crt": program_.crt_alloc_ = true; break;
        case "-typeset": print_type_sets_ = true; break;
        default:
          Console.WriteLine("unrecognized option: {0}", args[i]);
          return;
      }

    for (; i < args.Length ; ++i)
      if (args[i].EndsWith(".gel"))
        program_.Import(args[i]);
      else {
        if (args[i] == "-")   // marker indicating end of source files
          ++i;
        break;
      }

    ArrayList ^program_args = new ArrayList();
    if (compile) {
      if (i < args.Length) {
        Console.WriteLine("file to compile has unrecognized extension: {0}", args[i]);
        return;
      }
    } else {
      for (; i < args.Length; ++i)
        program_args.Add(args[i]);
    }

    if (!program_.Parse())
      return;

    bool ok = program_.Resolve() && program_.Check();
    if (error_test_)
      ErrorTestReport();
    if (!ok)
      return;

    if (compile)
      program_.Compile(output, cpp_only);
    else program_.Eval(program_args);
  }

  public static void Main_5(string[] args) {
    new Gel_5().Run(args);
  }
}
/*
Copyright (c) 2006 Google Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

class Syntax_6 {
  public readonly string file_;
  public readonly int line_;

  public Syntax_6() { file_ = Gel_6.CurrentFile(); line_ = Gel_6.Line(); }

  static void Report(string file, int line, string type) {
    Console.Write("{0}({1}): ", file, line);
    Console.Write("{0}: ", type);
    if (Gel_6.error_test_)
      Gel_6.error_lines_.Add(line);
  }

  public void Error(string message) {
    Report(file_, line_, "error");
    Console.WriteLine(message);
  }

  public void Error(string format, object arg) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg);
  }

  public void Error(string format, object arg1, object arg2) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2);
  }

  public void Error(string format, object arg1, object arg2, object arg3) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2, arg3);
  }

  public void Warning(string message) {
    Report(file_, line_, "warning");
    Console.WriteLine(message);
  }
}

abstract class TypeExpr_6 : Syntax_6 {
  public abstract GType_6 Resolve(Program_6 program);
  public abstract TypeExpr_6 ^Copy();
}

class ConversionContext_6 {
  public const int Other = 0,
                   AssignVar = 1,
                   MethodArg = 2;
}

// GEL2 includes the following kinds of types:
// - simple types (int, bool, char, float, double): SimpleType_6
// - owned types (including array types): ArrayType_6 or Class_6 with Owned() => true
// - owning types: Owning_6
// - string: GString_6
// - null type: NullType_6
// - void: VoidType_6

abstract class GType_6 {
  public virtual bool IsOwned() { return false; }

  // A reference type is an owned, owning, string or null type.
  public virtual bool IsReference() { return true; }

  // A value type is a simple or string type.
  public virtual bool IsValue() { return false; }

  public virtual Class_6 Parent() { return GObject_6.type_; }
  
  // If_6 this is an owning type T ^ then return T; otherwise return this.
  public virtual GType_6 BaseType() { return this; }

  // Return_6 the set of types which may be destroyed when a variable of this type
  // is destroyed.
  public virtual TypeSet_6 VarDestroys() { return TypeSet_6.empty_; }

  // Return_6 the set of types which may be destroyed when a value of this concrete type
  // is destroyed.
  public virtual TypeSet_6 TypeDestroys() { return TypeSet_6.empty_; }

  public virtual void FindVarDestroys(int marker, TypeSet_6 set) { }

  public virtual void FindTypeDestroys(int marker, TypeSet_6 set) { }

  public virtual bool IsSubtype(GType_6 type) {
    for (GType_6 t = this; t != null ; t = t.Parent())
      if (type.Equals(t))
        return true;
    return false;
  }

  public virtual Owning_6 OwningType() { Debug.Assert(false); return null; }

  protected virtual bool CanConvertOwnership(GType_6 t, int context) {
    bool from_owning = this is Owning_6;
    bool to_owning = t is Owning_6;
    if (IsValue() && t.BaseType() == GObject_6.type_) {
      Debug.Assert(!from_owning);
      // boxing conversion yields an owning pointer; string->object conversion may
      // yield an owning or non-owning pointer
      return to_owning || context == ConversionContext_6.MethodArg || this == GString_6.type_;
    }
    if (BaseType() == GObject_6.type_ && t.IsValue()) {
      Debug.Assert(!to_owning);
      return true;  // an unboxing or object->string conversion, OK in any context
    }
    return from_owning == to_owning ||
           from_owning && !to_owning &&
             (context == ConversionContext_6.AssignVar || context == ConversionContext_6.MethodArg);
  }

  // Ensure that this class will inherit from Object in generated C++ code.
  public virtual void SetObjectInherit() { }

  // Return_6 true if there is a non-subtyping implicit conversion from this to t.
  public virtual bool CanConvert1(GType_6 t) { return false; }

  // Return_6 true if there is a non-subtyping explicit conversion from this to t.
  protected virtual bool CanConvertExplicit1(GType_6 t) { return false; }

  // Return_6 true if this type can be converted to type [to].
  public bool CanConvert(GType_6 to, int context, bool is_explicit, bool subtype_only) {
    if (!CanConvertOwnership(to, context))
      return false;

    GType_6 from_base = BaseType();
    GType_6 to_base = to.BaseType();
    if (from_base.Equals(to_base))
      return true;   // identity conversion

    // If_6 we ever perform a conversion to C ^, then C must have a vtable so that we can call
    // a virtual destructor when an owning pointer is destroyed.
    if (to is Owning_6 && this != Null_6.type_)
      to_base.SetVirtual();

    // If_6 we ever perform an explicit conversion from a class, that class must
    // have a vtable so that every instance of the class will have run-time type information.
    if (is_explicit)
      from_base.SetVirtual();

    // If_6 we ever convert between C and Object, then C must derive from Object in generated code.
    if (from_base == GObject_6.type_)
      to_base.SetObjectInherit();
    else if (to_base == GObject_6.type_)
      from_base.SetObjectInherit();

    return from_base.IsSubtype(to_base) ||
           !subtype_only && from_base.CanConvert1(to_base) ||
           is_explicit && (to_base.IsSubtype(from_base) ||
                           !subtype_only && from_base.CanConvertExplicit1(to_base));
  }

  public bool CanConvert(GType_6 t, int context) { return CanConvert(t, context, false, false); }
  public bool CanConvert(GType_6 t) { return CanConvert(t, ConversionContext_6.Other); }

  public bool CanConvertExplicit(GType_6 t, bool subtype_only) {
    return CanConvert(t, ConversionContext_6.Other, true, subtype_only);
  }

  public bool CheckConvert(Syntax_6 caller, GType_6 t, int context) {
    if (!CanConvert(t, context)) {
      caller.Error("can't convert {0} to {1}", this, t);
      return false;
    }
    return true;
  }

  public bool CheckConvert(Syntax_6 caller, GType_6 t) {
    return CheckConvert(caller, t, ConversionContext_6.Other);
  }

  // Return_6 a type to which the types [this] and t can both be implicitly converted.
  public GType_6 CommonType(Syntax_6 caller, GType_6 t) {
    if (CanConvert(t))
      return t;
    if (t.CanConvert(this))
      return this;
    caller.Error("incompatible types: {0} and {1}", this, t);
    return null;
  }

  public abstract SimpleValue_6 DefaultValue_6();

  static ArrayList ^empty_array_ = new ArrayList();
  public virtual ArrayList /* of Member_6 */ Members() { return empty_array_; }

  public Member_6 GetMatchingMember(Member_6 m1) {
    foreach (Member_6 m in Members())
      if (m.MatchSignature(m1))
        return m;
    return null;
  }

  // Find a match for m in this type or its ancestors, ignoring private members and
  // optionally ignoring overrides.
  public Member_6 FindMatchingMember(Member_6 m, bool override_ok) {
    for (GType_6 t = this ; t != null ; t = t.Parent()) {
      Member_6 m1 = t.GetMatchingMember(m);
      if (m1 != null && !m1.IsPrivate() && (override_ok || !m1.IsOverride()))
        return m1;
    }
    return null;
  }

  int Score(bool accessible, int mismatches) {
    return (accessible ? 0 : 100) + mismatches;
  }

  public Member_6 Lookup(Syntax_6 caller, Class_6 from_class, bool through_base,
                       int kind, string name, ArrayList /* of Argument_6 */ arguments, bool report_error) {
    Member_6 m1 = null;   // the best match we've found so far
    bool found_any = false;
    bool accessible = false;
    int score = -1;

    GType_6 this_type = BaseType();
    GType_6 t;
    for (t = this_type; t != null; t = (kind == MemberKind_6.Constructor_6 ? null : t.Parent())) {
      foreach (Member_6 m in t.Members())
        if (Member_6.MatchKind(m.Kind(), kind) && m.name_ == name && !m.IsOverride()) {
          found_any = true;
          int mismatches = 0;
          if (arguments != null && !m.IsApplicable(arguments, out mismatches))
            continue; // wrong argument count
          bool new_accessible = m.IsAccessible(from_class, this_type, through_base);
          int new_score = Score(new_accessible, mismatches);
          if (new_score == 0 && score == 0) {
            if (report_error)
              caller.Error("{0}: ambiguous {1} call", name, Member_6.ToString(kind));
            return null;
          }
          if (score == -1 || new_score < score) {
            m1 = m;
            score = new_score;
            accessible = new_accessible;
          }
        }
      if (score == 0)
        break;
    }

    if (score != 0) {
      if (report_error) {
        string k = Member_6.ToString(kind);
        if (!found_any)
          caller.Error("{0}: {1} not found", name, k);
        else if (score == -1) {
          string a = String.Format("{0} argument{1}", arguments.Count, arguments.Count == 1 ? "" : "s");
          caller.Error("{0}: no {1} overload takes {2}", name, k, a);
        } else if (!accessible)
          caller.Error("{0}: can't access {1} {2}",
                       name, m1.IsProtected() ? "protected" : "private", k);
        else {
          caller.Error("{0}: the best overloaded {1} match has some invalid arguments", name, k);
          m1.ReportMismatches(caller, arguments);
        }
      }
      return null;
    }

    // If_6 we've found a member of the Object class, then we're using this class as an object,
    // so in generated code it must ultimately inherit from Object, not _Object.
    if (t == GObject_6.type_)
      this_type.SetObjectInherit();

    if (through_base) {
      // As_6 a special case, whenever we're accessing through base we find the member which will
      // actually be invoked; this is not necessarily the same as the member we've just found
      // if the member is virtual.
      m1 = FindMatchingMember(m1, true);
      Debug.Assert(m1 != null);
    }

    return m1;
  }

  public virtual void SetVirtual() { }

  // Emit the name of the C++ class we use to hold instances of this type.
  public virtual string EmitTypeName() { Debug.Assert(false); return null; }

  // Return_6 a C++ type of the form "T<U>".  If_6 U ends with a '>', we emit an
  // extra space to avoid emitting the token >>, which will cause GCC to complain.
  public static string ConstructType(string generic, string type) {
    return String.Format("{0}<{1}{2}>", generic, type,
                         type.EndsWith(">") ? " " : "");
  }

  string EmitNonOwningPointer(string name) {
    if (Gel_6.program_.safe_)
      return ConstructType(this == GObject_6.type_ ? "_PtrRef" : "_Ptr", name);
    return String.Format("{0} *", name);
  }

  // Emit a C++ type used for variables holding instances of this type.
  public virtual string EmitType() {
    return EmitNonOwningPointer(EmitTypeName());
  }

  // Emit a C++ type used for expressions holding instances of this type.
  public virtual string EmitExprType() {
    return EmitTypeName() + " *";
  }

  public virtual string EmitReturnType() {
    return EmitExprType();
  }

  public virtual string EmitGenericType() {
    return IsReference() ? EmitNonOwningPointer("Object") : EmitType();
  }
}

class TypeSet_6 {
  NonOwningArrayList /* of GType_6 */ ^types_ = new NonOwningArrayList();

  public static readonly TypeSet_6 ^empty_ = new TypeSet_6();

  public void Add(GType_6 type) {
    for (int i = 0; i < types_.Count; ++i) {
      GType_6 t = (GType_6) types_[i];
      if (type.IsSubtype(t))
        return;
      if (t.IsSubtype(type)) {
        types_[i++] = type;
        while (i < types_.Count) {
          t = (GType_6) types_[i];
          if (t.IsSubtype(type))
            types_.RemoveAt(i);
          else ++i;
        }
        return;
      }
    }
    types_.Add(type);
  }

  public void Add(TypeSet_6 set) {
    foreach (GType_6 t in set.types_)
      Add(t);
  }

  public bool Contains(GType_6 type) {
    foreach (GType_6 t in types_)
      if (type.IsSubtype(t))
        return true;
    return false;
  }

  public bool IsObject() {
    return types_.Count > 0 && types_[0] == GObject_6.type_;
  }

  public override string ToString() {
    StringBuilder ^sb = new StringBuilder();
    sb.Append("{");
    foreach (GType_6 t in types_)
      sb.AppendFormat(" {0}", t.ToString());
    sb.Append(" }");
    return sb.ToString();
  }
}

class VoidType_6 : GType_6 {
  public override bool IsReference() { Debug.Assert(false); return false; }

  public override SimpleValue_6 DefaultValue_6() { Debug.Assert(false); return null; }

  public override string ToString() { return "void"; }

  public override string EmitExprType() { return "void"; }
  public override string EmitType() { return "void"; }
}

class Void_6 {
  public static readonly GType_6 ^type_ = new VoidType_6();
}

// an RValue_6, a Location_6 containing an RValue_6, or a LocationRef_6 pointing to a Location_6 containing an RValue_6
abstract class ValueOrLocation_6 {
  public abstract GValue_6 Get();
}

// a GValue_6 or a reference to a GValue_6
abstract class RValue_6 : ValueOrLocation_6 {
  public abstract RValue_6 ^CopyRef();
}

abstract class GValue_6 : RValue_6 {
  public override GValue_6 Get() { return this; }

  public abstract GType_6 Type();

  public override RValue_6 ^CopyRef() { return new Reference_6(this); }

  public virtual RValue_6 ^Get(Field_6 field) { Debug.Assert(false); return null; }
  public virtual RValue_6 ^Take_6(Field_6 field) { Debug.Assert(false); return null; }

  public virtual RValue_6 ^ConvertExplicit(ref RValue_6 ^this_own, GType_6 t) {
    // try implicit conversion
    RValue_6 ^v = Convert(ref this_own, t);
    if (v != this || Type().IsSubtype(t) )
      return v;

    Console.WriteLine("type cast failed: object of type {0} is not a {1}", Type(), t);
    Gel_6.Exit();
    return null;
  }

  // Implicitly convert this value to type t.
  public virtual RValue_6 ^Convert(ref RValue_6 ^this_own, GType_6 t) {
    return take this_own;
  }

  public virtual bool DefaultEquals(object o) { return Equals(o); }
  public virtual int DefaultHashCode() { return GetHashCode(); }
  public virtual string DefaultToString() { return ToString(); }

  public virtual RValue_6 ^Invoke(Method_6 m, ValueList_6 args) {
    switch (m.name_) {
      case "Equals": return new GBool_6(DefaultEquals(args.Object(0)));
      case "GetHashCode": return new GInt_6(DefaultHashCode());
      case "ToString": return new GString_6(DefaultToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class Reference_6 : RValue_6 {
  public readonly GValue_6 value_;    // a reference value, never a SimpleValue_6

  public Reference_6(GValue_6 v) { value_ = v; }

  public override GValue_6 Get() { return value_; }

  public override RValue_6 ^CopyRef() { return new Reference_6(value_); }
}

abstract class SimpleValue_6 : GValue_6 {
  public abstract SimpleValue_6 ^Copy();
  public override RValue_6 ^CopyRef() { return Copy(); }
  public abstract string Emit();
}

class GBool_6 : SimpleValue_6 {
  public readonly bool b_;

  public GBool_6(bool b) { b_ = b; }

  public override bool Equals(object o) {
    GBool_6 b = o as GBool_6;
    return b != null && b.b_ == b_;
  }

  public override int GetHashCode() { return b_.GetHashCode(); }

  public override SimpleValue_6 ^Copy() { return new GBool_6(b_); }

  public static readonly BoolClass_6 ^type_ = new BoolClass_6();

  public override GType_6 Type() { return type_; }

  public override string ToString() { return b_.ToString(); }

  public override string Emit() { return b_ ? "true" : "false"; }
}

class GInt_6 : SimpleValue_6 {
  public readonly int i_;

  public GInt_6(int i) { i_ = i; }

  public static readonly IntClass_6 ^type_ = new IntClass_6();

  public override GType_6 Type() { return type_; }

  public override bool Equals(object o) {
    GInt_6 i = o as GInt_6;
    return i != null && i.i_ == i_;
  }

  public override int GetHashCode() { return i_.GetHashCode(); }

  public override SimpleValue_6 ^Copy() { return new GInt_6(i_); }

  public override RValue_6 ^Convert(ref RValue_6 ^this_own, GType_6 t) {
    if (t == GFloat_6.type_)
      return new GFloat_6(i_);
    if (t == GDouble_6.type_)
      return new GDouble_6(i_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_6 ^ConvertExplicit(ref RValue_6 ^this_own, GType_6 t) {
    return t == GChar_6.type_ ? new GChar_6((char) i_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return i_.ToString(); }

  public override string Emit() { return i_.ToString(); }
}

class GFloat_6 : SimpleValue_6 {
  public readonly float f_;

  public GFloat_6(float f) { f_ = f; }

  public static readonly FloatClass_6 ^type_ = new FloatClass_6();

  public override GType_6 Type() { return type_; }

  public override bool Equals(object o) {
    GFloat_6 f = o as GFloat_6;
    return f != null && f.f_ == f_;
  }

  public override int GetHashCode() { return f_.GetHashCode(); }

  public override SimpleValue_6 ^Copy() { return new GFloat_6(f_); }

  public override RValue_6 ^Convert(ref RValue_6 ^this_own, GType_6 t) {
    if (t == GDouble_6.type_)
      return new GDouble_6(f_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_6 ^ConvertExplicit(ref RValue_6 ^this_own, GType_6 t) {
    return t == GInt_6.type_ ? new GInt_6((int) f_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return f_.ToString(); }

  public override string Emit() {
    string s = f_.ToString();
    return s + (s.IndexOf('.') == -1 ? ".0f" : "f");
  }
}

class GDouble_6 : SimpleValue_6 {
  public readonly double d_;

  public GDouble_6(double d) { d_ = d; }

  public static readonly DoubleClass_6 ^type_ = new DoubleClass_6();

  public override GType_6 Type() { return type_; }

  public override bool Equals(object o) {
    GDouble_6 d = o as GDouble_6;
    return d != null && d.d_ == d_;
  }

  public override int GetHashCode() { return d_.GetHashCode(); }

  public override SimpleValue_6 ^Copy() { return new GDouble_6(d_); }

  public override RValue_6 ^ConvertExplicit(ref RValue_6 ^this_own, GType_6 t) {
    if (t == GInt_6.type_)
      return new GInt_6((int) d_);
    if (t == GFloat_6.type_)
      return new GFloat_6((float) d_);
    return base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return d_.ToString(); }

  public override string Emit() {
    string s = d_.ToString();
    if (s.IndexOf('.') == -1)
      s = s + ".0";
    return s;
  }
}

class GChar_6 : SimpleValue_6 {
  public readonly char c_;

  public GChar_6(char c) { c_ = c; }

  public static readonly CharClass_6 ^type_ = new CharClass_6();

  public override GType_6 Type() { return type_; }

  public override bool Equals(object o) {
    GChar_6 c = o as GChar_6;
    return c != null && c.c_ == c_;
  }

  public override int GetHashCode() { return c_.GetHashCode(); }

  public override SimpleValue_6 ^Copy() { return new GChar_6(c_); }

  public override RValue_6 ^Convert(ref RValue_6 ^this_own, GType_6 t) {
    return t == GInt_6.type_ ? new GInt_6(c_) : base.Convert(ref this_own, t);
  }

  public override string ToString() { return c_.ToString(); }

  public static string Emit(char c) {
    switch (c) {
      case '\0': return "\\0";
      case '\n': return "\\n";
      case '\r': return "\\r";
      case '\t': return "\\t";
      case '\'': return "\\'";
      case '\"': return "\\\"";
      case '\\': return "\\\\";
    }
    if (c < 32) {
      Debug.Assert(false); return null;
    }
    return c.ToString();
  }

  public override string Emit() {
    return String.Format("'{0}'", Emit(c_));
  }
}

abstract class LocationOrRef_6 : ValueOrLocation_6 {
  public abstract Location_6 GetLoc();
}

class Location_6 : LocationOrRef_6 {
  public RValue_6 ^value_;

  public Location_6(RValue_6 ^val) { value_ = val; }

  public override GValue_6 Get() { return value_.Get(); }

  public override Location_6 GetLoc() { return this; }
}

// We allocate a LocationRef_6 when we need an owning reference to a Location_6 which we don't own.
class LocationRef_6 : LocationOrRef_6 {
  public readonly Location_6 location_;

  public LocationRef_6(Location_6 loc) { location_ = loc; }

  public override GValue_6 Get() { return location_.Get(); }

  public override Location_6 GetLoc() { return location_; }
}

class MapNode_6 {
  public readonly MapNode_6 ^next_;
  public readonly object key_;
  public ValueOrLocation_6 ^value_;   // (must appear after next_ so it will be destroyed first)

  public MapNode_6(object key, ValueOrLocation_6 ^value, MapNode_6 ^next) {
    key_ = key; value_ = value; next_ = next;
  }
}

class Map_6 {
  MapNode_6 ^nodes_;

  protected MapNode_6 Find1(object key) {
    for (MapNode_6 n = nodes_; n != null; n = n.next_)
      if (n.key_ == key)
        return n;
    return null;
  }

  protected virtual MapNode_6 Find(object key) {
    MapNode_6 n = Find1(key);
    Debug.Assert(n != null);
    return n;
  }

  public RValue_6 ^Get(object key) {
    return Find(key).value_.Get().CopyRef();
  }

  public RValue_6 ^Take_6(object key) {
    MapNode_6 n = Find(key);
    LocationOrRef_6 l = n.value_ as LocationOrRef_6;
    if (l != null)
      return take l.GetLoc().value_;
    return (RValue_6) take n.value_;
  }

  public void Set(object key, RValue_6 ^val) {
    MapNode_6 n = Find(key);
    LocationOrRef_6 l = n.value_ as LocationOrRef_6;
    if (l != null)
      l.GetLoc().value_ = val;
    else n.value_ = val;
  }

  public void Add(object key, ValueOrLocation_6 ^val) {
    nodes_ = new MapNode_6(key, val, take nodes_);
  }

  public Location_6 GetLocation(object key) {
    MapNode_6 n = Find(key);
    LocationOrRef_6 l = n.value_ as LocationOrRef_6;
    if (l != null)
      return l.GetLoc();
    Location_6 ^loc1 = new Location_6((RValue_6) take n.value_);
    Location_6 loc = loc1;
    n.value_ = loc1;
    return loc;
  }
}

class GObject_6 : GValue_6 {
  public readonly Class_6 class_;   // the class of this object

  Map_6 ^map_ = new Map_6();

  public GObject_6(Class_6 cl) {
    class_ = cl;
    while (cl != null) {
      foreach (Field_6 f in cl.fields_)
        map_.Add(f, f.Type().DefaultValue_6().Copy() );
      cl = cl.Parent();
    }
  }

  // the type of this object
  public override GType_6 Type() { return class_; }

  public override RValue_6 ^Get(Field_6 field) { return map_.Get(field); }
  public override RValue_6 ^Take_6(Field_6 field) { return map_.Take_6(field); }
  public void Set(Field_6 field, RValue_6 ^val) { map_.Set(field, val); }
  public Location_6 GetLocation(Field_6 field) { return map_.GetLocation(field); }

  public override int DefaultHashCode() { return base.GetHashCode(); }
  public override int GetHashCode() {
    GInt_6 ^i = (GInt_6) Invocation_6.InvokeMethod(this, GObject_6.type_.get_hash_code_, new ArrayList(), true);
    return i.i_;
  }

  public override bool DefaultEquals(object o) { return base.Equals(o); }
  public override bool Equals(object o) {
    GValue_6 v = o as GValue_6;
    if (v == null)
      return false;

    ArrayList ^args = new ArrayList();
    args.Add(v.CopyRef());
    GBool_6 ^b = (GBool_6) Invocation_6.InvokeMethod(this, GObject_6.type_.equals_, args, true);
    return b.b_;
  }

  public override string DefaultToString() { return String.Format("<object {0}>", class_.name_); }
  public override string ToString() {
    GString_6 ^s = (GString_6) Invocation_6.InvokeMethod(this, GObject_6.type_.to_string_, new ArrayList(), true);
    return s.s_;
  }

  // the Object class
  public static readonly ObjectClass_6 ^type_ = new ObjectClass_6();
}

class NullType_6 : GType_6 {
  public override string ToString() { return "null_type"; }

  public override SimpleValue_6 DefaultValue_6() { Debug.Assert(false); return null; }

  public override bool IsSubtype(GType_6 t1) {
    return t1.IsReference();
  }

  protected override bool CanConvertOwnership(GType_6 t, int context) {
    return true;    // conversion from null type to owning type is okay
  }

  public override string EmitType() { Debug.Assert(false); return null; }
}

class Null_6 : SimpleValue_6 {
  public Null_6() { }

  public static readonly NullType_6 ^type_ = new NullType_6();

  public override GType_6 Type() { return type_; }

  public override bool Equals(object o) {
    return o is Null_6;
  }

  public override SimpleValue_6 ^Copy() { return new Null_6(); }

  public override int GetHashCode() { return 0; }

  public static readonly Null_6 ^Instance = new Null_6();

  public override string ToString() { return ""; }

  public override string Emit() { return "0"; }
}

class Owning_6 : GType_6 {
  GType_6 base_type_;

  public Owning_6(GType_6 type) {
    base_type_ = type;
  }

  public override Class_6 Parent() { Debug.Assert(false); return null; }

  public override SimpleValue_6 DefaultValue_6() { return Null_6.Instance; }

  public override GType_6 BaseType() { return base_type_; }

  public override TypeSet_6 VarDestroys() { return base_type_.TypeDestroys(); }

  public override void FindVarDestroys(int marker, TypeSet_6 set) {
    base_type_.FindTypeDestroys(marker, set);
  }

  public override bool Equals(object o) {
    Owning_6 t = o as Owning_6;
    return t != null && t.base_type_.Equals(base_type_);
  }

  public override int GetHashCode() { return base_type_.GetHashCode() * 87; }

  public override string ToString() { return base_type_.ToString() + " ^"; }

  public override string EmitTypeName() {
    return base_type_.EmitTypeName();
  }

  string EmitType(string name) {
    return ConstructType(base_type_ == GObject_6.type_ ? "_OwnRef" : "_Own", name);
  }

  public override string EmitType() {
    // We represent an object ^ using a _OwnRef<Object>.
    // We represent a Foo ^ using an _Own<Foo>.
    return EmitType(EmitTypeName());
  }

  public override string EmitGenericType() {
    // We represent an object ^ [] using an _Array<_OwnRef<Object>>.
    // We represent a Foo ^ [] using an _Array<_Own<Object>>.
    return EmitType("Object");
  }
}

class OwningExpr_6 : TypeExpr_6 {
  readonly TypeExpr_6 ^expr_;

  public OwningExpr_6(TypeExpr_6 ^expr) { expr_ = expr; }

  public override TypeExpr_6 ^Copy() { return new OwningExpr_6(expr_.Copy()); }

  public override GType_6 Resolve(Program_6 program) {
    GType_6 t = expr_.Resolve(program);
    if (t == null)
        return null;
    if (t.IsValue()) {
      Error("^ cannot be applied to primitive types or strings");
      return null;
    }
    return t.OwningType();
  }
}

class GString_6 : SimpleValue_6 {
  public readonly string s_;

  public GString_6(string s) { s_ = s; }

  public static readonly StringClass_6 ^type_ = new StringClass_6();

  public override GType_6 Type() { return type_; }

  public override bool Equals(object o) {
    GString_6 s = o as GString_6;
    return s != null && s.s_ == s_;
  }

  public override SimpleValue_6 ^Copy() { return new GString_6(s_); }

  public override int GetHashCode() { return s_.GetHashCode(); }

  public override string ToString() { return s_; }

  public override RValue_6 ^Invoke(Method_6 m, ValueList_6 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StartsWith": return new GBool_6(s_.StartsWith(args.GetString(0)));
      case "EndsWith": return new GBool_6(s_.EndsWith(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public static string EmitStringConst(string s) {
    return String.Format("L{0}", EmitString(s));
  }

  public static string EmitString(string s) {
    StringBuilder ^sb = new StringBuilder();
    sb.Append('"');
    for (int i = 0; i < s.Length; ++i)
      sb.Append(GChar_6.Emit(s[i]));
    sb.Append('"');
    return sb.ToString();
  }

  public override string Emit() {
    string s = String.Format("new String({0})", EmitStringConst(s_));
    s = String.Format("_Ref<String>({0}).Get()", s);
    return s;
  }
}

abstract class Ownable_6 : GType_6 {
  Owning_6 ^owning_type_;

  public override Owning_6 OwningType() {
    if (owning_type_ == null)
      owning_type_ = new Owning_6(this);
    return owning_type_;
  }
}

class ArrayType_6 : Ownable_6 {
  GType_6 element_type_;

  public ArrayType_6(GType_6 type) {
    element_type_ = type;

    // Any type used generically must inherit from Object in C++ code.
    type.BaseType().SetObjectInherit();
  }

  public override bool IsOwned() { return true; }

  public override Class_6 Parent() { return GArray_6.array_class_; }

  public override SimpleValue_6 DefaultValue_6() { return Null_6.Instance; }

  public GType_6 ElementType() { return element_type_; }

  public override bool Equals(object o) {
    ArrayType_6 t = o as ArrayType_6;
    return (t != null && t.element_type_.Equals(element_type_));
  }

  public override TypeSet_6 TypeDestroys() { return element_type_.VarDestroys(); }

  public override void FindTypeDestroys(int marker, TypeSet_6 set) {
    element_type_.FindVarDestroys(marker, set);
  }

  public override int GetHashCode() { return element_type_.GetHashCode() * 77; }

  public override string EmitTypeName() {
    return ConstructType("_Array", element_type_.EmitGenericType());  
  }

  public override string ToString() {
    return element_type_.ToString() + "[]";
  }
}

class ArrayTypeExpr_6 : TypeExpr_6 {
  readonly TypeExpr_6 ^expr_;
  GType_6 ^type_;

  public ArrayTypeExpr_6(TypeExpr_6 ^expr) { expr_ = expr; }

  public override TypeExpr_6 ^Copy() { return new ArrayTypeExpr_6(expr_.Copy()); }

  public override GType_6 Resolve(Program_6 program) {
    GType_6 t = expr_.Resolve(program);
    return t == null ? null : (type_ = new ArrayType_6(t));
  }
}

class GArray_6 : GValue_6 {
  ArrayType_6 type_;

  ValueOrLocation_6^[] ^elements_;   // each element is a GValue_6 or a Location_6

  public override GType_6 Type() { return type_; }

  public GArray_6(ArrayType_6 type, int count) {
    type_ = type;
    elements_ = new ValueOrLocation_6^[count];
    for (int i = 0 ; i < count ; ++i)
      elements_[i] = type_.ElementType().DefaultValue_6().Copy();
  }

  void CheckIndex(int index) {
    if (index < 0 || index >= elements_.Length) {
      Console.WriteLine("error: array access out of bounds");
      Gel_6.Exit();
    }
  }

  public RValue_6 ^Get(int index) {
    CheckIndex(index);
    return elements_[index].Get().CopyRef();
  }

  public RValue_6 ^Take_6(int index) {
    CheckIndex(index);
    Location_6 loc = elements_[index] as Location_6;
    if (loc != null)
      return take loc.value_;
    return (RValue_6) (take elements_[index]);
  }

  public void Set(int index, RValue_6 ^val) {
    CheckIndex(index);
    Location_6 loc = elements_[index] as Location_6;
    if (loc != null)
      loc.value_ = val;
    else elements_[index] = val;
  }

  public Location_6 GetLocation(int index) {
    CheckIndex(index);
    Location_6 loc = elements_[index] as Location_6;
    if (loc != null)
      return loc;
    Location_6 ^loc1 = new Location_6((RValue_6) take elements_[index]);
    loc = loc1;
    elements_[index] = loc1;
    return loc;
  }

  public static readonly ArrayClass_6 ^array_class_ = new ArrayClass_6();

  public override RValue_6 ^Invoke(Method_6 m, ValueList_6 args) {
    if (m.GetClass() != array_class_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "CopyTo":
        GArray_6 a = (GArray_6) args.Object(0);
        if (!type_.Equals(a.type_)) {
          Console.WriteLine("error: can't copy between arrays of different types");
          Gel_6.Exit();
        }
        if (a.type_.ElementType() is Owning_6) {
          Console.WriteLine("error: can't copy to owning array");
          Gel_6.Exit();
        }
        // should check for index out of bounds here!
        int dest = args.Int(1);
        for (int i = 0 ; i < elements_.Length ; ++i)
          a.Set(dest + i, Get(i));
        return null;
      case "get_Length":
        return new GInt_6(elements_.Length);
      default:
        Debug.Assert(false); return null;
    }
  }
}

// A control graph object representing temporary variables destroyed when a top-level
// expression completes evaluation. 
class Temporaries_6 : Node_6 {
  NonOwningArrayList /* of GType_6 */ ^types_ = new NonOwningArrayList();
  TypeSet_6 ^destroys_;

  public void Add(GType_6 t) {
    Debug.Assert(t is Owning_6);
    types_.Add(t.BaseType());
  }

  public override TypeSet_6 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_6();
    foreach (GType_6 t in types_)
        destroys_.Add(t.TypeDestroys());
    }
    return destroys_;
  }
}

class Context_6 {
  public readonly Program_6 program_;   // containing program
  public readonly Class_6 class_;       // containing class
  public readonly Method_6 method_;     // containing method
  public readonly Escapable_6 escape_;  // containing switch, while, do, for, or foreach
  public readonly Loop_6 loop_;         // containing while, do, for, or foreach
  public Local_6 var_;    // chain of local variable declarations

  // subexpressions of the current top-level expression possibly yielding temporary objects
  NonOwningArrayList /* of Expression_6 */ ^temporaries_ = new NonOwningArrayList();

  public Context_6(Program_6 program) { program_ = program; }

  public Context_6(Class_6 cl) { program_ = cl.GetProgram(); class_ = cl; }

  // Copy a context; new variable declarations in either copy will not be visible in the other.
  public Context_6(Context_6 cx) {
    program_ = cx.program_;
    class_ = cx.class_;
    method_ = cx.method_;
    escape_ = cx.escape_;
    loop_ = cx.loop_;
    var_ = cx.var_;
  }

  public Context_6(Context_6 cx, Class_6 c) : this(cx) { class_ = c; }

  public Context_6(Context_6 cx, Method_6 m) : this(cx) { method_ = m; }

  public Context_6(Context_6 cx, Loop_6 l) : this(cx) {
    escape_ = l;
    loop_ = l;
  }

  public Context_6(Context_6 cx, Switch_6 s) : this(cx) { escape_ = s; }

  public bool IsStatic() { return method_ == null || method_.IsStatic(); }

  public void SetVar(Local_6 var) {
    var_ = var;
  }

  public Local_6 FindVar(string name) {
    for (Local_6 v = var_; v != null; v = v.next_)
      if (v.name_ == name)
        return v;
    return null;
  }

  public Control_6 Prev() { return program_.prev_; }

  public void SetPrev(Control_6 c) {
    Debug.Assert(c != null);
    program_.prev_ = c;
  }

  public void ClearPrev() { program_.prev_ = null; }

  // Called when we begin type-checking a top-level expression.
  public void EnterExpression() {
    Debug.Assert(temporaries_.Count == 0);
  }

  public void AddTemporary(Expression_6 e) {
    temporaries_.Add(e);
  }

  // Called when we've finished type-checking a top-level expression.
  public void FinishExpression() {
    Temporaries_6 t = null;
    foreach (Expression_6 e in temporaries_)
      if (!e.LosesOwnership()) {
        if (t == null)
          t = class_.NewTemporaries();
        t.Add(e.TemporaryType());
      }
    if (t != null)
      t.AddControl(this);
    temporaries_.Clear();
  }
}

class Env_6 : Map_6 {
  public readonly GValue_6 this_;
  readonly Env_6 next_;

  public Env_6(GValue_6 _this) { this_ = _this; next_ = null; }
  public Env_6(Env_6 next) { this_ = next.this_; next_ = next; }

  protected override MapNode_6 Find(object key) {
    for (Env_6 e = this; e != null; e = e.next_) {
      MapNode_6 n = e.Find1(key);
      if (n != null)
        return n;
    }
    Debug.Assert(false);
    return null;
  }

  public static readonly Env_6 ^static_ = new Env_6((GValue_6) null);
}

class TypeLiteral_6 : TypeExpr_6 {
  public readonly GType_6 type_;

  public TypeLiteral_6(GType_6 type) { type_ = type; }

  public override GType_6 Resolve(Program_6 program) {
    return type_;
  }

  public override TypeExpr_6 ^Copy() { return new TypeLiteral_6(type_); }
}

class TypeName_6 : TypeExpr_6 {
  string name_;

  public TypeName_6(string name) { name_ = name; }

  public override GType_6 Resolve(Program_6 program) {
    GType_6 type = program.FindClass(name_);
    if (type == null)
      Error("unknown type: {0}", name_);
    return type;
  }

  public override TypeExpr_6 ^Copy() { return new TypeName_6(name_); }
}

abstract class Traverser_6 {
  // Handle a graph item found in a depth first search; returns one of the exit codes below.
  public abstract int Handle(Control_6 control);

  public const int Continue_6 = 0,  // continue searching, including children of this node
                   Cut = 1,       // continue searching, excluding children of this node
                   Abort = 2;     // abort the search

}

// an item in the control graph: either a Node_6 or Joiner_6
abstract class Control_6 : Syntax_6 {
  public int marker_ = 0;    // marker for depth first search of control flow graph

  static int marker_value_ = 0;
  public static int GetMarkerValue() { return ++marker_value_; }

  // A node representing unreachability.  We could represent this using null, but it's
  // clearer to have this be explicit. 
  public static readonly Node_6 ^unreachable_ = new Node_6();

  // A helper function for Traverse.  If_6 we return true then we should cut the
  // traversal at this point.
  protected bool Visit(Traverser_6 traverser, int marker, out bool ok) {
    ok = true;
    if (marker_ == marker)
      return true;  // we've already seen this node
    marker_ = marker;
    int code = traverser.Handle(this);
    if (code == Traverser_6.Abort)
      ok = false;
    return (code != Traverser_6.Continue_6);
  }

  // Perform a depth-first search of the graph starting with this item, calling the
  // given Traverser_6 for each Node_6 found.  Returns false if the search was aborted.
  public abstract bool Traverse(Traverser_6 traverser, int marker);
}

// A node in the control graph.
class Node_6 : Control_6 {
  public Control_6 prev_;   // previous item in graph

  // add this node to the control graph
  public bool AddControl(Context_6 ctx) {
    Control_6 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      prev_ = prev;
      ctx.SetPrev(this);
      return true;
    }
    else return false;
  }

  // If_6 this node calls a method or constructor then return it; otherwise return null.
  // implementers: LValue_6, Invocation_6, New_6, Assign_6, Constructor_6
  public virtual Method_6 Calls() { return null; }

  // Return_6 the set of types which this node may destroy.
  // implementers: Assign_6, RefOutArgument_6, Scoped_6, Temporaries_6
  public virtual TypeSet_6 NodeDestroys() { return TypeSet_6.empty_; }

  // Return_6 true if this node assigns a value to the given Local_6.
  // implementers: Assign_6, RefOutArgument_6, VariableDeclaration_6, Method_6, ForEach_6
  public virtual bool Sets(Local_6 local) { return false; }

  // Return_6 true if this node takes ownership from the given local.
  // implementers: Name_6
  public virtual bool Takes(Local_6 local) { return false; }

  public bool CanDestroy(GType_6 type) {
    Method_6 m = Calls();
    if (m != null && m.Destroys().Contains(type))
      return true;
    return NodeDestroys().Contains(type);
  }

  public override bool Traverse(Traverser_6 traverser, int marker) {
    Node_6 n = this;
    Control_6 prev = null;

    // Traverse nodes iteratively until we come to a Join; this efficiently avoids
    // making a recursive call on each successive node.
    while (n != null) {
      bool ok;
      if (n.Visit(traverser, marker, out ok))
        return ok;
      prev = n.prev_;
      n = prev as Node_6;
    }
    Debug.Assert(prev != null);  // a Traverser_6 must end traversal before we run off the end
    return prev.Traverse(traverser, marker);
  }
}

class Joiner_6 : Control_6 {
  NonOwningArrayList /* of Control_6 */ ^prev_ = new NonOwningArrayList();

  public void Join(Control_6 c) {
    Debug.Assert(c != null);
    if (c == unreachable_)
      return;
    if (prev_.Count == 0 || c != prev_[0])
      prev_.Add(c);
  }

  // add this joiner to the control graph
  public void AddControl(Context_6 ctx) {
    Control_6 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      Join(prev);
      ctx.SetPrev(this);
    }
  }

  // Once we've finished merging paths into a Joiner_6, if the Joiner_6 points to only a single path
  // then as an optimization we can discard the Joiner_6 and just use that path instead.
  public Control_6 Combine() {
    switch (prev_.Count) {
      case 0:
        prev_ = null;
        return unreachable_;
      case 1:
        Control_6 c = (Control_6) prev_[0];
        prev_ = null;
        return c;
      default: return this;
    }
  }

  public override bool Traverse(Traverser_6 traverser, int marker) {
    bool ok;
    if (Visit(traverser, marker, out ok))
      return ok;

    foreach (Control_6 p in prev_)
      if (!p.Traverse(traverser, marker))
        return false;  // aborted
    return true;
  }
}

class ExprKind_6 {
  public const int Value = 0,

  // either a local variable, or an expression whose value is derived from local variables
                   Local_6 = 1,

                   Field_6 = 2,
                   Property_6 = 3,
                   Indexer_6 = 4,
                   Type = 5;
}

class SourceWriter_6 {
  public readonly StreamWriter writer_;
  int indent_ = 0;

  public SourceWriter_6(StreamWriter writer) { writer_ = writer; }

  public void AddIndent() { ++indent_; }
  public void SubIndent() { --indent_; }

  public void Indent(int adjust) {
    for (int i = 0; i < 2 * indent_ + adjust; ++i)
      writer_.Write(' ');
  }

  public void Indent() { Indent(0); }

  public void Write(string s) { writer_.Write(s); }
  public void Write(string s, object arg) { writer_.Write(s, arg); }
  public void Write(string s, object arg1, object arg2) { writer_.Write(s, arg1, arg2); }
  public void Write(string s, object arg1, object arg2, object arg3) { writer_.Write(s, arg1, arg2, arg3); }

  public void IWrite(string s) { Indent(); Write(s); }
  public void IWrite(string s, object arg) { Indent(); Write(s, arg); }
  public void IWrite(string s, object arg1, object arg2) { Indent(); Write(s, arg1, arg2); }
  public void IWrite(string s, object arg1, object arg2, object arg3) { Indent(); Write(s, arg1, arg2, arg3); }

  public void WriteLine(string s) { writer_.WriteLine(s); }
  public void WriteLine(string s, object arg) { writer_.WriteLine(s, arg); }
  public void WriteLine(string s, object arg1, object arg2) { writer_.WriteLine(s, arg1, arg2); }
  public void WriteLine(string s, object arg1, object arg2, object arg3) { writer_.WriteLine(s, arg1, arg2, arg3); }

  public void IWriteLine(string s) { Indent(); WriteLine(s); }
  public void IWriteLine(string s, object arg) { Indent(); WriteLine(s, arg); }
  public void IWriteLine(string s, object arg1, object arg2) { Indent(); WriteLine(s, arg1, arg2); }
  public void IWriteLine(string s, object arg1, object arg2, object arg3) { Indent(); WriteLine(s, arg1, arg2, arg3); }

  public void OpenBrace() { WriteLine("{"); AddIndent(); }
  public void CloseBrace() { SubIndent(); IWriteLine("}"); }
}

class Usage_6 {
  public const int Used = 0, LosesOwnership = 1, Unused = 2;
}

abstract class Expression_6 : Node_6 {
  protected int usage_ = Usage_6.Used;

  // start_ and end_ mark the points in the control graph where this expression is evaluated and used,
  // respectively.  If_6 this expression's type is owned, we use this information to determine whether
  // we need to emit a reference count for this expression.
  Control_6 start_;
  Control_6 end_;

  public abstract GType_6 Check(Context_6 ctx);

  public GType_6 CheckTop(Context_6 ctx) {
    ctx.EnterExpression();
    GType_6 t = Check(ctx);
    ctx.FinishExpression();
    return t;
  }

  public GType_6 CheckAndHold(Context_6 ctx) {
    GType_6 t = Check(ctx);
    if (t != null)
      HoldRef(ctx);
    return t;
  }

  // A fancier checking protocol implemented by lvalues and used by certain callers.
  public virtual GType_6 Check(Context_6 ctx, bool read, bool write, bool type_ok) {
    return Check(ctx);
  }

  public virtual int Kind() { return ExprKind_6.Value; }
  public virtual bool IsRefOutParameter() { return false; }

  public virtual bool IsTrueLiteral() { return false; }
  public virtual bool IsFalseLiteral() { return false; }

  // If_6 this expression is a local variable (possibly cast to a different type),
  // then return that local; otherwise return null.
  public virtual Local_6 GetLocal() { return null; }

  // Return_6 the type of an expression yielding a temporary object.
  // (It might be convenient to generalize this to be able to return any expression's type.)
  public virtual GType_6 TemporaryType() { Debug.Assert(false); return null; }

  public void HoldRef(Context_6 ctx) {
    start_ = ctx.Prev();
    Debug.Assert(start_ != null);
  }

  public void ReleaseRef(Context_6 ctx) {
    end_ = ctx.Prev();
    Debug.Assert(end_ != null);
  }

  public abstract RValue_6 ^Eval(Env_6 env);

  public bool Check(Context_6 ctx, GType_6 t2) {
    GType_6 t = Check(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public bool CheckTop(Context_6 ctx, GType_6 t2) {
    GType_6 t = CheckTop(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public RValue_6 ^Eval(Env_6 env, GType_6 t) {
    RValue_6 ^r = Eval(env);
    GValue_6 v = r.Get();
    return v.Convert(ref r, t);
  }

  public bool EvalBool(Env_6 env) { return ((GBool_6) Eval(env)).b_; }

  public int EvalInt(Env_6 env) {
    RValue_6 ^r = Eval(env, GInt_6.type_);
    GInt_6 i = (GInt_6) r;
    return i.i_;
  }

  public double EvalDouble(Env_6 env) { return ((GDouble_6) Eval(env, GDouble_6.type_)).d_; }
  public float EvalFloat(Env_6 env) { return ((GFloat_6) Eval(env, GFloat_6.type_)).f_; }
  public string EvalString(Env_6 env) { return ((GString_6) Eval(env)).s_; }

  public virtual bool IsConstant() {
    return false;
  }

  public bool CheckConstant() {
    if (IsConstant())
      return true;
    Error("expression must be a constant");
    return false;
  }

  public bool LosesOwnership() { return usage_ == Usage_6.LosesOwnership; }

  public virtual void LoseOwnership() {
    usage_ = Usage_6.LosesOwnership;
  }

  public void SetUnused() {
    Debug.Assert(usage_ == Usage_6.Used);
    usage_ = Usage_6.Unused;
  }

  protected static string EmitAllocate(string type, string args, bool lose_ownership) {
    // If_6 an allocated object never loses ownership then it can be stack allocated.  We
    // can't emit "&Foo(...)" since standard C++ doesn't allow us to take the address
    // of a temporary (both GCC and Visual C++ will allow this, but will emit a warning).
    // So instead we call a function _Addr() to get the address.
    return String.Format(
      !lose_ownership ? "{0}({1})._Addr<{0} *>()" : "new {0}({1})",
      type, args);
  }

  public void CheckLoseOwnership(GType_6 from, GType_6 to) {
    if (to is Owning_6)
      LoseOwnership();
  }

  public abstract string Emit();    // return a C++ expression representing this GEL2 expression

  public bool NeedsRef(GType_6 type) {
    return Gel_6.program_.safe_ && type.IsOwned() && ExpressionTraverser_6.NeedRef(start_, end_, this, type);
  }

  // Emit this expression, adding a reference-counting _Ptr wrapper if needed.
  public string EmitRef(GType_6 type) {
    string s = Emit();
    if (NeedsRef(type))
      s = String.Format("{0}({1}).Get()", type.EmitType(), s);
    return s;
  }

  // Emit an implicit conversion from type [source] to type [dest].
  public static string EmitImplicit(GType_6 source, GType_6 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (!source.IsReference() && dest == GObject_6.type_) {   // a boxing conversion
      Class_6 c = (Class_6) source;
      return EmitAllocate(c.name_, val, loses_ownership);
    }

    if (source == GInt_6.type_ && dest == GFloat_6.type_)
      // an implicit conversion in GEL2, but C++ compilers may warn if we don't use a cast
      return String.Format("static_cast<float>({0})", val);
    
    return val;
  }

  // Emit this expression, converting implicitly from type [source] to type [dest].
  public string Emit(GType_6 source, GType_6 dest) {
    return EmitImplicit(source, dest, Emit(), LosesOwnership());
  }

  public string EmitRef(GType_6 source, GType_6 dest) {
    return EmitImplicit(source, dest, EmitRef(source), LosesOwnership());
  }

  public static string EmitExplicit(GType_6 source, GType_6 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (source.CanConvert(dest)) {
      string v = EmitImplicit(source, dest, val, loses_ownership);
      if (v != val)
        return v;

      // There's nothing to do, but we emit a static_cast anyway since a GEL2 programmer
      // may use a type cast for method call disambiguation; we want to pass such casts onward.
      return String.Format("static_cast<{0} >({1})", dest.EmitExprType(), val);
    }

    if (source.IsReference() && dest.IsReference()) {
      string s = String.Format("_Cast<{0} *>({1})", dest.EmitTypeName(), val);
      ArrayType_6 at = dest as ArrayType_6;
      if (at != null) {
        GType_6 element_type = at.ElementType();
        if (element_type.IsReference())
          s = String.Format("({0})->CheckType(&typeid({1}))", s, element_type.EmitType());
      }
      return s;
    }

    if (source == GObject_6.type_ && !dest.IsReference())  // unboxing conversion
      return String.Format("_Unbox<{0} *>({1})->Value()", ((Class_6) dest).name_, val);

    if (!source.IsReference() && !dest.IsReference())
      return String.Format("static_cast<{0}>({1})", dest.EmitType(), val);

    Debug.Assert(false);
    return null;
  }

  public string EmitExplicit(GType_6 source, GType_6 dest) {
    return EmitExplicit(source, dest, Emit(), LosesOwnership());
  }

  public virtual string EmitArrow(GType_6 t, Member_6 m) {
    return String.Format("({0})->", EmitRef(t));
  }

  // Emit this expression as a local or field initializer, implicitly casting to [type].
  public void EmitAsInitializer(SourceWriter_6 w, GType_6 initializer_type, GType_6 type) {
    // For_6 owning variables, we must emit an initializer of the form "Foo var(val)" since
    // _Own has no copy constructor and hence GCC won't allow "Foo var = val".  For_6 other
    // variables either form is valid, but we emit the second form since it looks clearer.
    w.Write(type is Owning_6 ? "({0})" : " = {0}", Emit(initializer_type, type));
  }

  // Given a value retrieved from a variable, emit an accessor call if needed.
  protected string OwnSuffix(GType_6 t) {
    if (t is Owning_6)
      return LosesOwnership() ? ".Take_6()" : ".Get()";
    if (t == GString_6.type_ || Gel_6.program_.safe_ && t.IsReference() )
      return ".Get()";
    return "";
  }

  // Given a value returned from a function call, emit a wrapper and/or accessor call if needed.
  protected string Hold(GType_6 t, string s) {
    if (t == GString_6.type_)
      return s + ".Get()";
    if (t is Owning_6)
      switch (usage_) {
        case Usage_6.Used:  // does not lose ownership; we need a freeing wrapper
          return String.Format("{0}({1}).Get()", t.EmitType(), s);
        case Usage_6.LosesOwnership:
          return s;
        case Usage_6.Unused:  // a top-level owning expression
          return "delete " + s;
        default: Debug.Assert(false); break;
      }
    return s;
  }
}

class Literal_6 : Expression_6 {
  public readonly SimpleValue_6 ^value_;

  public Literal_6(SimpleValue_6 ^v) { value_ = v; }

  public override bool IsTrueLiteral() {
    GBool_6 b = value_ as GBool_6;
    return b != null && b.b_;
  }

  public override bool IsFalseLiteral() {
    GBool_6 b = value_ as GBool_6;
    return b != null && !b.b_;
  }

  public override GType_6 Check(Context_6 ctx) { return value_.Type(); }

  public override RValue_6 ^Eval(Env_6 env) { return value_.Copy(); }

  public override bool IsConstant() { return true; }

  public override string Emit() { return value_.Emit(); }
}

// An LValue_6 is an expression which can be assigned to: a Name_6, Dot_6, or Sub_6.
//
// In the control graph, an LValue_6 represents a read; if an LValue_6 is written then
// some other node (e.g. an Assign_6) will appear representing the write.
abstract class LValue_6 : Expression_6 {
  public override GType_6 Check(Context_6 ctx) {
    return Check(ctx, true, false, false);
  }

  public abstract override GType_6 Check(Context_6 ctx, bool read, bool write, bool type_ok);

  public abstract GType_6 StorageType();

  public virtual bool IsLocal() { return false; }
  public virtual bool IsLocal(Local_6 l) { return false; }

  public abstract PropertyOrIndexer_6 GetPropertyOrIndexer();

  public override Method_6 Calls() {
    PropertyOrIndexer_6 pi = GetPropertyOrIndexer();
    return pi == null ? null : pi.Getter();
  }

  public virtual void ReleaseAll(Context_6 ctx) { }

  // For_6 LValues, evaluation proceeds in two stages: the caller first calls Eval1(), then
  // passes the resulting values to EvalGet(), EvalSet() and/or EvalLocation().  This_6 lets
  // us evaluate the left side of an assignment expression before evaluating the right side,
  // and also lets us get and then set an indexer without evaluating its expression twice.

  public abstract void Eval1(Env_6 env, out RValue_6 ^v1, out RValue_6 ^v2);
  public abstract RValue_6 ^EvalGet(Env_6 env, RValue_6 ^v1, RValue_6 ^v2);
  public abstract void EvalSet(Env_6 env, RValue_6 ^v1, RValue_6 ^v2, RValue_6 ^val);
  public abstract Location_6 EvalLocation(Env_6 env, RValue_6 ^v1, RValue_6 ^v2);

  public override RValue_6 ^Eval(Env_6 env) {
    RValue_6 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalGet(env, val1, val2);
  }

  public void EvalSet(Env_6 env, RValue_6 ^v) {
    RValue_6 ^val1, val2;
    Eval1(env, out val1, out val2);
    EvalSet(env, val1, val2, v);
  }

  public Location_6 EvalLocation(Env_6 env) {
    RValue_6 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalLocation(env, val1, val2);
  }

  public abstract string EmitSet(string val);

  public abstract string EmitLocation();
}

class Name_6 : LValue_6 {
  public readonly string name_;

  protected Local_6 local_;
  protected LMember_6 field_;  // a field or property

  public Name_6(string n) { name_ = n; }

  public override bool IsLocal() { return local_ != null; }
  public override bool IsLocal(Local_6 l) { return local_ == l; }
  public override bool IsRefOutParameter() { return local_ is RefOutParameter_6; }

  public override bool IsConstant() {
    Debug.Assert(local_ != null || field_ != null);   // make sure we were already type checked
    return field_ is ConstField_6;
  }

  public override GType_6 Check(Context_6 ctx, bool read, bool write, bool type_ok) {
    local_ = ctx.FindVar(name_);
    if (local_ != null) {
      // For_6 reads, we add this Name_6 node to the flow graph; for writes,
      // the caller must add a node which defines this Name_6.
      if (read)
        if (AddControl(ctx))
          local_.AddUse(this);
      if (write)
        local_.SetMutable();
      return local_.ReadType();
    }

    GType_6 cl = type_ok ? ctx.program_.FindClass(name_) : null;
    field_ = (LMember_6) ctx.class_.Lookup(this, ctx.class_, false, MemberKind_6.Field_6, name_, null, cl == null);
    if (field_ != null) {
      if (!field_.CheckAccess(this, ctx, write, true, !ctx.IsStatic()))
        return null;
      if (read) {
        // Only property reads have side effects we need to register in the control graph.
        if (field_ is Property_6)
          AddControl(ctx);
      }
      return field_.Type().BaseType();
    }

    return cl;
  }

  public override int Kind() {
    if (local_ != null)
      return ExprKind_6.Local_6;
    if (field_ is Field_6)
      return ExprKind_6.Field_6;
    if (field_ is Property_6)
      return ExprKind_6.Property_6;
    Debug.Assert(field_ == null);
    return ExprKind_6.Type;
  }

  public override Local_6 GetLocal() { return local_; }

  public override GType_6 StorageType() { return local_ != null ? local_.Type() : field_.Type(); }

  public override bool Takes(Local_6 local) {
    return local_ == local && LosesOwnership() && local.Type() is Owning_6;
  }

  public override PropertyOrIndexer_6 GetPropertyOrIndexer() { return field_ as Property_6; }

  public override void Eval1(Env_6 env, out RValue_6 ^v1, out RValue_6 ^v2) { v1 = v2 = null; }

  public override RValue_6 ^EvalGet(Env_6 env, RValue_6 ^v1, RValue_6 ^v2) {
    if (LosesOwnership() && StorageType() is Owning_6)
      return local_ != null ? env.Take_6(local_) : field_.Take_6(env.this_);
    else return local_ != null ? env.Get(local_) : field_.Get(env.this_);
  }

  public override void EvalSet(Env_6 env, RValue_6 ^v1, RValue_6 ^v2, RValue_6 ^val) {
    if (local_ != null)
      env.Set(local_, val);
    else field_.Set((GObject_6) env.this_, val);
  }

  public override Location_6 EvalLocation(Env_6 env, RValue_6 ^v1, RValue_6 ^v2) {
    return local_ != null ? env.GetLocation(local_) : field_.GetLocation((GObject_6) env.this_);
  }

  public override string Emit() {
    if (local_ != null) {
      string s = local_.Emit();
      return local_.IsWrapper() ? s + OwnSuffix(local_.Type()) : s;
    }
    if (field_ != null)
      return field_.Emit() + OwnSuffix(field_.Type());
    return name_;
  }

  public override string EmitSet(string val) {
    if (local_ != null)
      return String.Format("{0} = {1}", local_.Emit(), val);
    Debug.Assert(field_ != null);
    return field_.EmitSet(val);
  }

  public override string EmitLocation() {
    if (local_ != null)
      return "&" + local_.Emit();
    if (field_ != null)
      return "&" + field_.Emit();
    return "&" + name_;
  }
}

class Parenthesized_6 : Expression_6 {
  Expression_6 ^expr_;

  public Parenthesized_6(Expression_6 ^e) { expr_ = e; }

  public override GType_6 Check(Context_6 ctx) { return expr_.Check(ctx); }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_6 ^Eval(Env_6 env) { return expr_.Eval(env); }

  public override string Emit() { return String.Format("({0})", expr_.Emit()); }
}

class PredefinedType_6 : Expression_6 {
  Class_6 type_;

  public PredefinedType_6(Class_6 type) { type_ = type; }

  public override GType_6 Check(Context_6 ctx) { Debug.Assert(false); return null; }

  public override GType_6 Check(Context_6 ctx, bool read, bool write, bool type_ok) {
    Debug.Assert(type_ok);
    return type_;
  }

  public override int Kind() {
    return ExprKind_6.Type;
  }

  public override RValue_6 ^Eval(Env_6 env) { Debug.Assert(false); return null; }

  public override string Emit() { return type_.name_; }
}

class Dot_6 : LValue_6 {
  Expression_6 ^expr_;  // set to null for a static invocation
  GType_6 expr_type_;
  string name_;

  LMember_6 field_;

  public Dot_6(Expression_6 ^expr, string name) { expr_ = expr; name_ = name; }

  public override bool IsConstant() {
    Debug.Assert(field_ != null);   // make sure we were already type checked
    return field_ is ConstField_6;
  }

  public override GType_6 Check(Context_6 ctx, bool read, bool write, bool type_ok) {
    expr_type_ = expr_.Check(ctx, true, false, true);
    if (expr_type_ == null)
      return null;
    bool is_static = (expr_.Kind() == ExprKind_6.Type);
    if (is_static)
      expr_ = null;
    else expr_.HoldRef(ctx);

    field_ = (LMember_6) expr_type_.Lookup(this, ctx.class_, expr_ is Base_6,
                                         MemberKind_6.Field_6, name_, null, true);
    if (field_ == null)
      return null;

    if (!field_.CheckAccess(this, ctx, write, is_static, !is_static))
      return null;

    if (read) {
      // Only property reads have side effects we need to register in the control graph.
      // (For_6 writes the caller, such as Assign_6, will add its own node.)
      if (field_ is Property_6)
        AddControl(ctx);
      if (expr_ != null)
        expr_.ReleaseRef(ctx);
    }

    return field_.Type().BaseType();
  }

  public override void ReleaseAll(Context_6 ctx) {
    if (expr_ != null)
      expr_.ReleaseRef(ctx);
  }

  public override int Kind() {
    if (field_ is Field_6)
      return ExprKind_6.Field_6;
    if (field_ is Property_6)
      return ExprKind_6.Property_6;
    Debug.Assert(false);
    return 0;
  }

  public override GType_6 StorageType() { return field_.Type(); }

  public override PropertyOrIndexer_6 GetPropertyOrIndexer() { return field_ as Property_6; }

  public override void Eval1(Env_6 env, out RValue_6 ^v1, out RValue_6 ^v2) {
    v1 = v2 = null;
    if (expr_ != null) {  // instance field
      v1 = expr_.Eval(env);
      if (v1 is Null_6) {
        Error("attempted to access field of null object");
        Gel_6.Exit();
      }
    }
  }

  public override RValue_6 ^EvalGet(Env_6 env, RValue_6 ^v1, RValue_6 ^v2) {
    GValue_6 obj = v1 == null ? null : v1.Get();
    return LosesOwnership() && field_.Type() is Owning_6 ? field_.Take_6(obj) : field_.Get(obj);
  }

  public override void EvalSet(Env_6 env, RValue_6 ^v1, RValue_6 ^v2, RValue_6 ^val) {
    GObject_6 obj = v1 == null ? null : (GObject_6) v1.Get();
    field_.Set(obj, val);
  }

  public override Location_6 EvalLocation(Env_6 env, RValue_6 ^v1, RValue_6 ^v2) {
    return field_.GetLocation((GObject_6) v1);
  }

  string EmitPrefix() {
    return expr_ != null ?
      expr_.EmitArrow(expr_type_, field_) :  // instance access
      field_.GetClass().name_ + "::";   // static access
  }

  public override string Emit() {
    string s = EmitPrefix() + field_.Emit();
    GType_6 t = field_.Type();
    return field_ is Property_6 ? Hold(t, s) : s + OwnSuffix(t);
  }

  public override string EmitSet(string val) {
    return EmitPrefix() + field_.EmitSet(val);
  }

  public override string EmitLocation() {
    return "&" + EmitPrefix() + field_.Emit();
  }
}

class Mode_6 {
  public const int In = 0,
                   Ref = 1,
                   Out = 2;

  public static string ToString(int mode) {
    switch (mode) {
      case In: return "";
      case Ref: return "ref ";
      case Out: return "out ";
      default: Debug.Assert(false); return null;
    }
  }
}

abstract class Argument_6 : Node_6 {
  protected GType_6 type_;

  public GType_6 Type() { return type_; }

  public abstract int GetMode();
  public string TypeString() { return Mode_6.ToString(GetMode()) + type_.ToString(); }

  public abstract bool Check(Context_6 ctx);
  public abstract void FinishCall(Context_6 ctx);

  public abstract void AddEval(ArrayList a, Env_6 env, GType_6 t);

  public abstract string Emit(GType_6 t);
}

class InArgument_6 : Argument_6 {
  public readonly Expression_6 ^expr_;

  public InArgument_6(Expression_6 ^expr) { expr_ = expr; }
  public InArgument_6(GType_6 type) { type_ = type; }

  public override int GetMode() { return 0; }

  public override bool Check(Context_6 ctx) {
    if (type_ == null)
      type_ = expr_.CheckAndHold(ctx);
    return type_ != null;
  }

  public override void FinishCall(Context_6 ctx) {
    expr_.ReleaseRef(ctx);
  }

  public override void AddEval(ArrayList a, Env_6 env, GType_6 t) {
    a.Add(expr_.Eval(env, t));
  }

  public override string Emit(GType_6 t) {
    return expr_.EmitRef(type_, t);
  }
}

class RefOutArgument_6 : Argument_6 {
  public readonly int mode_;
  public readonly LValue_6 ^lvalue_;

  public RefOutArgument_6(int mode, LValue_6 ^lvalue) { mode_ = mode; lvalue_ = lvalue; }

  public override int GetMode() { return mode_; }

  public override bool Check(Context_6 ctx) {
    type_ = lvalue_.Check(ctx, mode_ == Mode_6.Ref, true, false);
    if (type_ == null)
      return false;
    if (lvalue_.Kind() == ExprKind_6.Indexer_6) {
      Error("can't pass indexer as ref or out argument");
      return false;
    }
    return true;
  }

  public override void FinishCall(Context_6 ctx) {
    AddControl(ctx);
  }

  public override bool Sets(Local_6 local) { return lvalue_.IsLocal(local); }

  public override TypeSet_6 NodeDestroys() { return lvalue_.StorageType().VarDestroys(); }

  public GType_6 StorageType() { return lvalue_.StorageType(); }

  public override void AddEval(ArrayList a, Env_6 env, GType_6 t) {
    a.Add(new LocationRef_6(lvalue_.EvalLocation(env)));
  }

  public override string Emit(GType_6 t) { return lvalue_.EmitLocation(); }
}

class Invocation_6 : Expression_6 {
  Expression_6 ^obj_;    // may be null
  GType_6 obj_type_;
  string name_;
  ArrayList /* of Argument_6 */ ^arguments_;

  Method_6 method_;

  public Invocation_6(Expression_6 ^obj, string name, ArrayList ^arguments) {
    obj_ = obj; name_ = name; arguments_ = arguments;
  }

  public static Method_6 CheckInvoke(Node_6 caller, Context_6 ctx, bool through_base, GType_6 type,
                                   string name, ArrayList /* of Argument_6 */ arguments,
                                   int kind) {
    foreach (Argument_6 arg in arguments)
      if (!arg.Check(ctx))
        return null;

    // Add the caller to the graph; this node represents the invocation itself.
    caller.AddControl(ctx);

    // Now we can release temporary expressions and add control graph nodes representing
    // assignments to ref and out parameters.
    foreach (Argument_6 arg in arguments)
      arg.FinishCall(ctx);

    Method_6 m = (Method_6) type.Lookup(caller, ctx.class_, through_base, kind, name, arguments, true);
    if (m != null)
      for (int i = 0; i < m.parameters_.Count; ++i) {
        Parameter_6 p = m.Param(i);
        if (p.GetMode() == Mode_6.In) {
          InArgument_6 a = (InArgument_6) arguments[i];
          a.expr_.CheckLoseOwnership(a.Type(), p.Type());
        }
      }
    return m;
  }

  public override GType_6 Check(Context_6 ctx) {
    GType_6 t;
    bool is_class = false;  // true when calling a static method using a class name

    if (obj_ == null)
      t = ctx.class_;
    else {
      t = obj_type_ = obj_.Check(ctx, true, false, true);
      if (t == null)
        return null;
      if (obj_.Kind() == ExprKind_6.Type)
        is_class = true;
      else obj_.HoldRef(ctx);
    }

    method_ = CheckInvoke(this, ctx, obj_ is Base_6, t, name_, arguments_, MemberKind_6.Method_6);
    if (method_ == null)
      return null;

    if (method_ is Constructor_6) {
      Error("can't call constructor directly");
      return null;
    }

    if (obj_ == null) {
      if (!method_.IsStatic() && ctx.IsStatic()) {
        Error("can't call instance method in static context");
        return null;
      }
    } else {
      obj_.ReleaseRef(ctx);
      if (is_class) {
        if (!method_.IsStatic()) {
          Error("can't invoke non-static method through class name");
          return null;
        }
      } else {
        if (method_.IsStatic()) {
          Error("can't invoke static method through object");
          return null;
        }
      }
    }

    GType_6 ret = method_.ReturnType();
    if (ret is Owning_6)
      ctx.AddTemporary(this);
    return ret;
  }

  public override GType_6 TemporaryType() { return method_.ReturnType(); }

  public override Method_6 Calls() { return method_; }

  public static RValue_6 ^InvokeMethod(GValue_6 obj, Method_6 m, ArrayList /* of RValue_6 */ values,
                                    bool virtual_ok) {
    if (m.IsVirtual() && virtual_ok) {
      GType_6 t = obj.Type();
      m = (Method_6) t.FindMatchingMember(m, true);
      Debug.Assert(m != null);
    }
    return m.Invoke(obj, values);
  }

  public static RValue_6 ^CallMethod(Env_6 env, GValue_6 obj,
                                  Method_6 m, ArrayList /* of Argument_6 */ args,
                                  bool virtual_ok) {
    ArrayList /* of ValueOrLocation_6 */ ^values = new ArrayList();
    int i;
    for (i = 0 ; i < args.Count ; ++i) {
      Argument_6 a = (Argument_6) args[i];
      a.AddEval(values, env, m.Param(i).Type());
    }
    return InvokeMethod(obj, m, values, virtual_ok);
  }

  public RValue_6 ^Eval(Env_6 env, Expression_6 obj, Method_6 m, ArrayList /* of Argument_6 */ args) {
    RValue_6 ^r;
    GValue_6 v;
    if (m.IsStatic())
      v = null;
    else {
      if (obj == null)
        v = env.this_;
      else {
        r = obj.Eval(env);
        v = r.Get();
        if (v is Null_6) {
          Error("attempted to call method on null object");
          Gel_6.Exit();
        }
      }
    }

    return CallMethod(env, v, m, args, !(obj is Base_6));
  }

  public override RValue_6 ^Eval(Env_6 env) {
    return Eval(env, obj_, method_, arguments_);
  }

  public static string EmitArguments(Method_6 m, ArrayList /* of Argument_6 */ arguments) {
    StringBuilder ^sb = new StringBuilder();
    Debug.Assert(m.parameters_.Count == arguments.Count);
    for (int i = 0; i < arguments.Count; ++i) {
      if (i > 0)
        sb.Append(", ");
      Argument_6 a = (Argument_6)arguments[i];
      sb.Append(a.Emit(m.Param(i).Type()));
    }
    return sb.ToString();
  }

  public override string Emit() {
    StringBuilder ^sb = new StringBuilder();
    if (obj_ != null) {
      if (method_.IsStatic())
        sb.AppendFormat("{0}::", obj_.Emit());
      else if (obj_type_.IsReference())
        sb.Append(obj_.EmitArrow(obj_type_, method_));
      else sb.AppendFormat("({0})->", obj_.Emit(obj_type_, GObject_6.type_));   // box values
    }
    sb.AppendFormat("{0} ({1})", method_.name_, EmitArguments(method_, arguments_));
    return Hold(method_.ReturnType(), sb.ToString());
  }
}

// an expression of the form a[b]
class Sub_6 : LValue_6 {
  readonly Expression_6 ^base_;
  GType_6 base_type_;
  readonly Expression_6 ^index_;
  GType_6 index_type_;

  GType_6 element_type_;    // for array accesses; null for indexers
  Indexer_6 indexer_;

  public Sub_6(Expression_6 ^base_exp, Expression_6 ^index) { base_ = base_exp; index_ = index; }

  public override GType_6 Check(Context_6 ctx, bool read, bool write, bool type_ok) {
    base_type_ = base_.CheckAndHold(ctx);
    if (base_type_ == null)
      return null;

    index_type_ = index_.CheckAndHold(ctx);
    if (index_type_ == null)
      return null;

    if (read)
      ReleaseAll(ctx);

    ArrayType_6 at = base_type_.BaseType() as ArrayType_6;
    if (at != null) {
      if (!index_type_.CheckConvert(this, GInt_6.type_))
        return null;
      element_type_ = at.ElementType();
      return element_type_.BaseType();
    }

    ArrayList ^arguments = new ArrayList();
    arguments.Add(new InArgument_6(index_type_));

    indexer_ = (Indexer_6) base_type_.Lookup(this, ctx.class_, base_ is Base_6,
                                           MemberKind_6.Indexer_6, null, arguments, true);
    if (indexer_ == null)
      return null;

    if (read && !indexer_.CheckAssigning(this, ctx, false) ||
        write && !indexer_.CheckAssigning(this, ctx, true))
      return null;

    if (read)
      AddControl(ctx);

    return indexer_.Type();
  }

  public override void ReleaseAll(Context_6 ctx) {
    base_.ReleaseRef(ctx);
    index_.ReleaseRef(ctx);
  }

  public override int Kind() {
    return element_type_ != null ? ExprKind_6.Field_6 : ExprKind_6.Indexer_6;
  }

  public override GType_6 StorageType() {
    return element_type_ != null ? element_type_ : indexer_.Type();
  }

  public override PropertyOrIndexer_6 GetPropertyOrIndexer() { return indexer_; }

  public override void Eval1(Env_6 env, out RValue_6 ^v1, out RValue_6 ^v2) {
    v1 = base_.Eval(env);
    if (v1 is Null_6) {
      Error("attempted array or indexer access through null");
      Gel_6.Exit();
    }
    v2 = index_.Eval(env);
  }

  int Index(RValue_6 ^v) {
    // ++ We get an ownership error if we combine the following two lines into one; why?
    v = v.Get().Convert(ref v, GInt_6.type_);
    return ((GInt_6) v).i_;
  }

  public override RValue_6 ^EvalGet(Env_6 env, RValue_6 ^v1, RValue_6 ^v2) {
    if (indexer_ == null) {
      GArray_6 arr = (GArray_6) v1.Get();
      int i = Index(v2);
      return LosesOwnership() && element_type_ is Owning_6 ? arr.Take_6(i) : arr.Get(i);
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    return Invocation_6.InvokeMethod(v1.Get(), indexer_.Getter(), args, true);
  }

  public override void EvalSet(Env_6 env, RValue_6 ^v1, RValue_6 ^v2, RValue_6 ^val) {
    if (indexer_ == null) {
      ((GArray_6) v1.Get()).Set(Index(v2), val);
      return;
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    args.Add(val);
    Invocation_6.InvokeMethod(v1.Get(), indexer_.Setter(), args, true);
  }

  public override Location_6 EvalLocation(Env_6 env, RValue_6 ^v1, RValue_6 ^v2) {
    int i = ((GInt_6) v2).i_;
    return ((GArray_6) v1).GetLocation(i);
  }

  string EmitBase() {
    return base_.EmitArrow(base_type_, indexer_);
  }

  string EmitIndex() {
    return index_.Emit(index_type_, indexer_ != null ? indexer_.parameter_.Type() : GInt_6.type_);
  }

  public override string Emit() {
    string get = String.Format("{0}get_Item({1})", EmitBase(), EmitIndex());
    if (element_type_ != null) {
      get = get + OwnSuffix(element_type_);
      if (!element_type_.IsValue())
        get = String.Format("static_cast<{0} >({1})", element_type_.EmitExprType(), get);
      return get;
    } else return Hold(indexer_.Type(), get);
  }

  public override string EmitSet(string val) {
    return String.Format(element_type_ != null ? "{0}get_Item({1}) = {2}" : "{0}set_Item({1}, {2})",
       EmitBase(), EmitIndex(), val);
  }

  public override string EmitLocation() {
    return String.Format("{0}get_location({1})", EmitBase(), EmitIndex());
  }
}

class This_6 : Expression_6 {
  public override GType_6 Check(Context_6 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access this in a static context");
      return null;
    }
    return ctx.class_;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    return new Reference_6(env.this_);
  }

  public override string Emit() { return "this"; }
}

class Base_6 : Expression_6 {
  Class_6 parent_;

  public override GType_6 Check(Context_6 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access base in a static context");
      return null;
    }
    parent_ = ctx.class_.Parent();
    if (parent_ == null) {
      Error("can't access base: class has no parent");
      return null;
    }
    return parent_;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    return new Reference_6(env.this_);
  }

  public override string Emit() { return "this"; }

  public override string EmitArrow(GType_6 t, Member_6 m) {
    return m.GetClass().name_ + "::"; 
  }
}

class New_6 : Expression_6 {
  Expression_6 ^creator_;    // either a pool or null
  TypeExpr_6 ^type_expr_;
  ArrayList /* of Expression_6 */ ^arguments_;

  Class_6 class_;
  Constructor_6 constructor_;

  public New_6(Expression_6 ^creator, TypeExpr_6 ^expr, ArrayList ^arguments) {
    creator_ = creator;
    type_expr_ = expr;
    arguments_ = arguments;
  }

  GType_6 Type() {
    return creator_ == null ? (GType_6) class_.OwningType() : class_;
  }

  public override GType_6 TemporaryType() { return Type(); }    

  public override GType_6 Check(Context_6 ctx) {
    if (creator_ != null) {
      GType_6 c = creator_.Check(ctx);
      if (c == null)
        return null;
      if (!c.BaseType().IsSubtype(PoolClass_6.instance_)) {
        Error("object creator must be a pool");
        return null;
      }
    }
    GType_6 t = type_expr_.Resolve(ctx.program_);
    if (t == null)
      return null;
    class_ = (Class_6) t;
    if (class_.HasAttribute(Attribute_6.Abstract)) {
      Error("can't instantiate abstract class");
      return null;
    }
    if (creator_ != null) {
      class_.NeedDestroy(); // every pool-allocated class needs the _Destroy1 and _Destroy2 methods
      class_.SetVirtual();  // every pool-allocated class must be virtual
    }

    constructor_ = (Constructor_6) Invocation_6.CheckInvoke(this, ctx, false, class_,
                                      class_.name_, arguments_, MemberKind_6.Constructor_6);
    if (constructor_ == null)
      return null;

    GType_6 type = Type();
    if (type is Owning_6)
      ctx.AddTemporary(this);
    return type;
  }

  public override Method_6 Calls() { return constructor_; }

  public override RValue_6 ^Eval(Env_6 env) {
    GValue_6 ^obj = class_.New_6();
    Invocation_6.CallMethod(env, obj, constructor_, arguments_, false);
    return obj;
  }

  public override string Emit() {
    string args = Invocation_6.EmitArguments(constructor_, arguments_);

    return creator_ == null ?
      EmitAllocate(class_.name_, args, LosesOwnership()) :
      String.Format("new ({0}->Alloc(sizeof({1}))) {1}({2})", creator_.Emit(), class_.name_, args);
  }
}

class ArrayInitializer_6 : Expression_6 {
  public readonly ArrayList /* of Expression_6 */ ^initializers_;

  public ArrayInitializer_6(ArrayList ^initializers) { initializers_ = initializers; }

  public override GType_6 Check(Context_6 ctx) {
    Error("only static fields may have array initializers");
    return null;
  }

  public bool CheckElements(Context_6 ctx, GType_6 element_type) {
    foreach (Expression_6 e in initializers_)
      if (!e.CheckConstant() || !e.Check(ctx, element_type))
        return false;
    return true;
  }

  public override RValue_6 ^Eval(Env_6 env) { Debug.Assert(false); return null; }

  public GArray_6 ^Eval(ArrayType_6 type) {
    GArray_6 ^a = new GArray_6(type, initializers_.Count);
    for (int i = 0; i < initializers_.Count; ++i) {
      Expression_6 e = (Expression_6) initializers_[i];
      a.Set(i, e.Eval(Env_6.static_, type.ElementType()));
    }
    return a;
  }

  public override string Emit() { Debug.Assert(false); return null; }

  public void Emit(SourceWriter_6 w) {
    int count = initializers_.Count;
    int per_row = 12;

    w.Write("{ ");
    if (count > per_row) {    // format onto multiple rows
      w.WriteLine("");
      w.AddIndent();
      w.Indent();
    }
    for (int i = 0; i < count; ++i) {
      if (i > 0) {
        w.Write(", ");
        if (i % per_row == 0) {
          w.WriteLine("");
          w.Indent();
        }
      }
      Expression_6 e = (Expression_6) initializers_[i];
      SimpleValue_6 ^v = (SimpleValue_6) e.Eval(Env_6.static_);
      w.Write(v.Emit());
    }
    if (count > per_row) {
      w.SubIndent();
      w.WriteLine("");
    }
    w.Write(" }");
  }
}

class NewArray_6 : Expression_6 {
  TypeExpr_6 ^element_type_expr_;
  int dimensions_;
  ArrayType_6 ^array_type_;

  Expression_6 ^count_;

  public NewArray_6(TypeExpr_6 ^element_type_expr, int dimensions, Expression_6 ^count) {
    element_type_expr_ = element_type_expr;
    dimensions_ = dimensions;
    count_ = count;
  }

  GType_6 Type() {
    return (GType_6) array_type_.OwningType();
  }

  public override GType_6 TemporaryType() { return Type(); }

  public override GType_6 Check(Context_6 ctx) {
    if (element_type_expr_ is ArrayTypeExpr_6) {
      Error("syntax error in new expression");
      return null;
    }
    for (int i = 0; i < dimensions_; ++i)
      element_type_expr_ = new ArrayTypeExpr_6(take element_type_expr_);
    GType_6 element_type = element_type_expr_.Resolve(ctx.program_);
    if (element_type == null)
      return null;
    array_type_ = new ArrayType_6(element_type);

    if (!count_.Check(ctx, GInt_6.type_))
      return null;

    GType_6 t = Type();
    if (t is Owning_6)
      ctx.AddTemporary(this);
    return t;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    return new GArray_6(array_type_, count_.EvalInt(env));
  }

  public override string Emit() {
    GType_6 t = array_type_.ElementType();
    string array_type = GType_6.ConstructType(
      t is Owning_6 ? "_Array" : "_CopyableArray",
      t.EmitGenericType());
    string args = String.Format("&typeid({0}), {1}", t.EmitType(), count_.Emit());
    return EmitAllocate(array_type, args, LosesOwnership());
  }
}

abstract class Unary_6 : Expression_6 {
  protected Expression_6 ^exp_;

  protected Unary_6(Expression_6 ^e) { exp_ = e; }

  public override bool IsConstant() { return exp_.IsConstant(); }
}

// unary minus operator
class Minus_6 : Unary_6 {
  GType_6 type_;

  public Minus_6(Expression_6 ^e) : base(e) { }

  public override GType_6 Check(Context_6 ctx) {
    type_ = exp_.Check(ctx);
    if (type_ != GInt_6.type_ && type_ != GFloat_6.type_ && type_ != GDouble_6.type_) {
      Error("- operator cannot be applied to value of type {0}", type_);
      return null;
    }
    return type_;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    if (type_ == GInt_6.type_) {
    int i = exp_.EvalInt(env);
    return new GInt_6(-i);
  }
    if (type_ == GFloat_6.type_) {
      float f = exp_.EvalFloat(env);
      return new GFloat_6(-f);
    }
    if (type_ == GDouble_6.type_) {
      double d = exp_.EvalDouble(env);
      return new GDouble_6(-d);
    }
    Debug.Assert(false);
    return null;
  }

  public override string Emit() { return "-" + exp_.Emit(); }
}

class Not_6 : Unary_6 {
  public Not_6(Expression_6 ^e) : base(e) { }

  public override GType_6 Check(Context_6 ctx) {
    return exp_.Check(ctx, GBool_6.type_) ? GBool_6.type_ : null;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    bool b = exp_.EvalBool(env);
    return new GBool_6(!b);
  }

  public override string Emit() { return "!" + exp_.Emit(); }
}

// the bitwise complement (~) operator
class Complement_6 : Unary_6 {
  public Complement_6(Expression_6 ^e) : base(e) { }

  public override GType_6 Check(Context_6 ctx) {
    return exp_.Check(ctx, GInt_6.type_) ? GInt_6.type_ : null;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    int i = exp_.EvalInt(env);
    return new GInt_6(~i);
  }

  public override string Emit() { return "~" + exp_.Emit(); }
}

class IncDec_6 : Expression_6 {
  bool pre_;    // true for pre-increment/decrement; false for post-increment/decrement
  bool inc_;
  LValue_6 ^lvalue_;

  public IncDec_6(bool pre, bool inc, LValue_6 ^lvalue) { pre_ = pre; inc_ = inc; lvalue_ = lvalue; }

  public override GType_6 Check(Context_6 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    GType_6 t = lvalue_.Check(ctx, true, true, false);
    if (t == null)
      return null;
    if (lvalue_.Kind() == ExprKind_6.Indexer_6) {
      Error("++ and -- can't yet operate on indexers");
      return null;
    }
    if (t != GInt_6.type_) {
      Error("++ and -- can operate only on integers");
      return null;
    }
    return GInt_6.type_;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    Location_6 loc = lvalue_.EvalLocation(env);
    GInt_6 ^i = (GInt_6) take loc.value_;
    loc.value_ = new GInt_6(inc_ ? i.i_ + 1 : i.i_ - 1);
    return pre_ ? ((GInt_6) loc.value_).Copy() : i;
  }

  string EmitOp() { return inc_ ? "++" : "--"; }

  public override string Emit() {
    return pre_ ? EmitOp() + lvalue_.Emit() : lvalue_.Emit() + EmitOp();
  }
}

abstract class Conversion_6 : Expression_6 {
  protected Expression_6 ^expr_;
  protected TypeExpr_6 ^type_expr_;

  protected GType_6 from_base_;
  protected GType_6 to_type_, to_base_;

  protected Conversion_6(Expression_6 ^expr, TypeExpr_6 ^type_expr) {
    expr_ = expr; type_expr_ = type_expr;
  }

  protected bool CheckConversion(Context_6 ctx, bool subtype_only) {
    GType_6 from = expr_.Check(ctx);
    if (from == null)
      return false;
    from_base_ = from.BaseType();

    to_base_ = type_expr_.Resolve(ctx.program_);
    if (to_base_ == null)
      return false;
    if (!to_base_.IsValue() &&
       (from is Owning_6 || from_base_.IsValue()))
      to_type_ = to_base_.OwningType();
    else to_type_ = to_base_;

    if (!from.CanConvertExplicit(to_type_, subtype_only)) {
      Error("can't convert from {0} to {1}", from_base_, to_base_);
      return false;
    }
    return true;
  }
}

class Cast_6 : Conversion_6 {
  public Cast_6(Expression_6 ^expr, TypeExpr_6 ^type_expr) : base(expr, type_expr) { }

  public override Local_6 GetLocal() { return expr_.GetLocal(); }
  
  public override GType_6 Check(Context_6 ctx) {
    return CheckConversion(ctx, false) ? to_type_ : null;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_6.Local_6 ? ExprKind_6.Local_6 : ExprKind_6.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_6 ^Eval(Env_6 env) {
    RValue_6 ^r = expr_.Eval(env);
    return r.Get().ConvertExplicit(ref r, to_base_);
  }

  public override string Emit() {
    return expr_.EmitExplicit(from_base_, to_type_);
  }
}

class Binary_6 : Expression_6 {
  int op_;
  Expression_6 ^left_, right_;
  GType_6 left_type_, right_type_;
  GType_6 type_;

  const int CONCATENATE = 0;

  public Binary_6(Expression_6 ^left, int op, Expression_6 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public static GType_6 Promote(Syntax_6 caller, GType_6 left, int op, GType_6 right) {
    if (left.CanConvert(GInt_6.type_) && right.CanConvert(GInt_6.type_))
      return GInt_6.type_;
    if (left.CanConvert(GFloat_6.type_) && right.CanConvert(GFloat_6.type_))
      return GFloat_6.type_;
    if (left.CanConvert(GDouble_6.type_) && right.CanConvert(GDouble_6.type_))
      return GDouble_6.type_;
    caller.Error("can't apply operator {0} to operands of type {1} and {2}", OpName(op), left, right);
    return null;
  }

  bool CheckIntArgs() {
    if (left_type_.CheckConvert(this, GInt_6.type_) && right_type_.CheckConvert(this, GInt_6.type_)) {
      type_ = GInt_6.type_;
      return true;
    }
    return false;
  }

  public override GType_6 Check(Context_6 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);

    if (op_ == '+' && (left_type_ == GString_6.type_ || right_type_ == GString_6.type_)) {
      op_ = CONCATENATE;

      // If_6 we'll be calling ToString() on a class, ensure that it will inherit from
      // Object in generated code.
      if (left_type_ != GString_6.type_)
        left_type_.CanConvert(GObject_6.type_);
      if (right_type_ != GString_6.type_)
        right_type_.CanConvert(GObject_6.type_);

      return GString_6.type_;
    }

    switch (op_) {
      case '*':
      case '/':
      case '+':
      case '-':
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_;

      case '%':
      case Parser.OP_LEFT_SHIFT:
      case Parser.OP_RIGHT_SHIFT:
        return CheckIntArgs() ? GInt_6.type_ : null;

      case '&':
      case '|':
        if (left_type_ == GBool_6.type_ && right_type_ == GBool_6.type_)
          type_ = GBool_6.type_;
        else {
          if (!CheckIntArgs())
            return null;
          type_ = GInt_6.type_;
        }
        return type_;

      case '<':
      case Parser.OP_LE:
      case '>':
      case Parser.OP_GE:
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_ == null ? null : GBool_6.type_;

      default:
        Debug.Assert(false);
        return null;
    }
  }

  public static GBool_6 ^BoolOp(bool x, int op, bool y) {
    switch (op) {
      case '&': return new GBool_6(x & y);
      case '|': return new GBool_6(x | y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_6 ^IntOp(int x, int op, int y) {
    switch (op) {
      case '*': return new GInt_6(x * y);
      case '/': return new GInt_6(x / y);
      case '%': return new GInt_6(x % y);
      case '+': return new GInt_6(x + y);
      case '-': return new GInt_6(x - y);
      case Parser.OP_LEFT_SHIFT: return new GInt_6(x << y);
      case Parser.OP_RIGHT_SHIFT: return new GInt_6(x >> y);
      case '&': return new GInt_6(x & y);
      case '|': return new GInt_6(x | y);
      case '<': return new GBool_6(x < y);
      case Parser.OP_LE: return new GBool_6(x <= y);
      case '>': return new GBool_6(x > y);
      case Parser.OP_GE: return new GBool_6(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_6 ^FloatOp(float x, int op, float y) {
    switch (op) {
      case '*': return new GFloat_6(x * y);
      case '/': return new GFloat_6(x / y);
      case '+': return new GFloat_6(x + y);
      case '-': return new GFloat_6(x - y);
      case '<': return new GBool_6(x < y);
      case Parser.OP_LE: return new GBool_6(x <= y);
      case '>': return new GBool_6(x > y);
      case Parser.OP_GE: return new GBool_6(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_6 ^DoubleOp(double x, int op, double y) {
    switch (op) {
      case '*': return new GDouble_6(x * y);
      case '/': return new GDouble_6(x / y);
      case '+': return new GDouble_6(x + y);
      case '-': return new GDouble_6(x - y);
      case '<': return new GBool_6(x < y);
      case Parser.OP_LE: return new GBool_6(x <= y);
      case '>': return new GBool_6(x > y);
      case Parser.OP_GE: return new GBool_6(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public override RValue_6 ^Eval(Env_6 env) {
    if (op_ == CONCATENATE)
      return new GString_6(left_.Eval(env).ToString() + right_.Eval(env).ToString());

    if (type_ == GBool_6.type_)
      return BoolOp(left_.EvalBool(env), op_, right_.EvalBool(env));
    if (type_ == GInt_6.type_)
      return IntOp(left_.EvalInt(env), op_, right_.EvalInt(env));
    if (type_ == GFloat_6.type_)
      return FloatOp(left_.EvalFloat(env), op_, right_.EvalFloat(env));
    if (type_ == GDouble_6.type_)
      return DoubleOp(left_.EvalDouble(env), op_, right_.EvalDouble(env));

    Debug.Assert(false);
    return null;
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  static string OpName(int op) {
    switch (op) {
      case Parser.OP_LEFT_SHIFT: return "<<";
      case Parser.OP_RIGHT_SHIFT: return ">>";
      case Parser.OP_LE: return "<=";
      case Parser.OP_GE: return ">=";
      default: return ((char) op).ToString();
    }
  }

  public override string Emit() {
    if (op_ == CONCATENATE)
      return Hold(GString_6.type_,
        String.Format("String::_Concat({0}, {1})",
          left_.EmitRef(left_type_, GObject_6.type_), right_.Emit(right_type_, GObject_6.type_)));

    return String.Format("{0} {1} {2}",
      left_.EmitRef(left_type_), OpName(op_), right_.Emit() );
  }
}

class Equality_6 : Expression_6 {
  bool equal_;    // true for ==, false for !=
  Expression_6 ^left_, right_;
  GType_6 left_type_, right_type_, type_;

  public Equality_6(Expression_6 ^left, int op, Expression_6 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_EQUAL: equal_ = true; break;
      case Parser.OP_NE: equal_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_6 Check(Context_6 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);
    if (left_type_.IsReference() != right_type_.IsReference()) {
      Error("can't compare types {0} and {1}", left_type_, right_type_);
      return null;
    }
    type_ = left_type_.BaseType().CommonType(this, right_type_.BaseType());
    return type_ == null ? null : GBool_6.type_;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    RValue_6 ^left = left_.Eval(env, type_);
    RValue_6 ^right = right_.Eval(env, type_);
    bool eq = left.Get().DefaultEquals(right.Get());
    return new GBool_6(equal_ ? eq : !eq);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    string emit_left = left_.EmitRef(left_type_);
    string emit_right = right_.Emit();
    if (type_ == GString_6.type_)
      return String.Format("{0}String::_Equals({1}, {2})",
                           equal_ ? "" : "!", emit_left, emit_right);
    return String.Format("{0} {1} {2}", emit_left, equal_ ? "==" : "!=", emit_right);
  }
}

class Is_6 : Conversion_6 {
  public Is_6(Expression_6 ^expr, TypeExpr_6 ^type_expr) : base(expr, type_expr) { }

  public override GType_6 Check(Context_6 ctx) {
    return CheckConversion(ctx, true) ? GBool_6.type_ : null;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    RValue_6 ^r = expr_.Eval(env);
    GValue_6 v = r.Get();
    return new GBool_6(!(v is Null_6) && v.Type().IsSubtype(to_base_));
  }

  public override string Emit() {
    if (from_base_.IsReference()) {
      Class_6 c = (Class_6) to_base_;
      return String.Format("dynamic_cast<{0} *>({1}) != 0", c.name_, expr_.Emit());
    }
    return to_base_ == from_base_ || to_base_ == GObject_6.type_ ? "true" : "false";
  }
}

class As_6 : Conversion_6 {
  public As_6(Expression_6 ^expr, TypeExpr_6 ^type_expr) : base(expr, type_expr) { }

  public override Local_6 GetLocal() { return expr_.GetLocal(); }

  public override GType_6 Check(Context_6 ctx) {
    if (!CheckConversion(ctx, true))
      return null;
    if (!to_base_.IsReference()) {
      Error("as operator must convert to reference type");
      return null;
    }
    return to_type_;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_6.Local_6 ? ExprKind_6.Local_6 : ExprKind_6.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_6 ^Eval(Env_6 env) {
    RValue_6 ^r = expr_.Eval(env);
    return r.Get().Type().IsSubtype(to_base_) ? r : Null_6.Instance.Copy();
  }

  public override string Emit() {
    if (from_base_.CanConvert(to_base_))
      return expr_.Emit(from_base_, to_base_);
    Class_6 c = (Class_6) to_base_;
    return String.Format("dynamic_cast<{0} *>({1})", c.name_, expr_.Emit());
  }
}

// a && or || operator
class LogicalOp_6 : Expression_6 {
  bool and_;  // true => &&, false => ||
  Expression_6 ^left_, right_;
  Joiner_6 ^join_ = new Joiner_6();

  public LogicalOp_6(Expression_6 ^left, int op, Expression_6 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_AND: and_ = true; break;
      case Parser.OP_OR: and_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_6 Check(Context_6 ctx) {
    if (!left_.Check(ctx, GBool_6.type_))
      return null;

    join_.Join(ctx.Prev());
    if (!right_.Check(ctx, GBool_6.type_))
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    return GBool_6.type_;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    bool left = left_.EvalBool(env);
    bool b = and_ ? left && right_.EvalBool(env) : left || right_.EvalBool(env);
    return new GBool_6(b);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    return String.Format("{0} {1} {2}", left_.Emit(), and_ ? "&&" : "||", right_.Emit());
  }

}

// the ?: operator
class Conditional_6 : Expression_6 {
  Expression_6 ^condition_;
  Expression_6 ^if_true_, if_false_;

  GType_6 true_type_, false_type_;
  GType_6 type_;
  Joiner_6 ^join_ = new Joiner_6();

  public Conditional_6(Expression_6 ^condition, Expression_6 ^if_true, Expression_6 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override GType_6 Check(Context_6 ctx) {
    if (!condition_.Check(ctx, GBool_6.type_))
      return null;

    Control_6 c = ctx.Prev();

    true_type_ = if_true_.Check(ctx);
    if (true_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    false_type_ = if_false_.Check(ctx);
    if (false_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    type_ = true_type_.CommonType(this, false_type_);
    return type_;
  }

  public override int Kind() {
    return if_true_.Kind() == ExprKind_6.Local_6 && if_false_.Kind() == ExprKind_6.Local_6 ? ExprKind_6.Local_6 : ExprKind_6.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    if_true_.LoseOwnership();
    if_false_.LoseOwnership();
  }

  public override RValue_6 ^Eval(Env_6 env) {
    return condition_.EvalBool(env) ? if_true_.Eval(env, type_) : if_false_.Eval(env, type_);
  }

  public override string Emit() {
    return String.Format("{0} ? {1} : {2}", condition_.Emit(),
                         if_true_.Emit(true_type_, type_), if_false_.Emit(false_type_, type_));
  }
}

class Assign_6 : Expression_6 {
  LValue_6 ^left_;
  Expression_6 ^right_;

  GType_6 left_type_, right_type_;

  public Assign_6(LValue_6 ^left, Expression_6 ^right) {
    left_ = left; right_ = right;
  }

  public static bool CheckAssign(Syntax_6 caller, GType_6 left_type, Expression_6 right, GType_6 right_type) {
    if (!right_type.CheckConvert(caller, left_type,
      right.Kind() == ExprKind_6.Local_6 ? ConversionContext_6.AssignVar : ConversionContext_6.Other))
      return false;
    right.CheckLoseOwnership(right_type, left_type);
    return true;
  }

  public override GType_6 Check(Context_6 ctx) {
    left_type_ = left_.Check(ctx, false, true, false);
    if (left_type_ == null)
      return null;

    right_type_ = right_.Check(ctx, true, false, false);
    if (right_type_ == null || !CheckAssign(this, left_.StorageType(), right_, right_type_))
      return null;
    right_.HoldRef(ctx);

    AddControl(ctx);
    left_.ReleaseAll(ctx);
    right_.ReleaseRef(ctx);
    return left_type_;
  }

  public override Method_6 Calls() {
    PropertyOrIndexer_6 pi = left_.GetPropertyOrIndexer();
    return pi == null ? null : pi.Setter();
  }

  public override bool Sets(Local_6 local) { return left_.IsLocal(local); }

  public override TypeSet_6 NodeDestroys() {
    return left_.GetPropertyOrIndexer() != null ? TypeSet_6.empty_ : left_.StorageType().VarDestroys();
  }

  public override RValue_6 ^Eval(Env_6 env) {
    RValue_6 ^v1, v2;
    left_.Eval1(env, out v1, out v2);
    RValue_6 ^val = right_.Eval(env, left_type_);
    RValue_6 ^ret = val.CopyRef();
    left_.EvalSet(env, v1, v2, val);
    return ret;
  }

  public override string Emit() {
    return left_.EmitSet(right_.EmitRef(right_type_, left_type_));
  }
}

// a compound assignment operator such as += or -=
class CompoundAssign_6 : Expression_6 {
  LValue_6 ^left_;
  int op_;
  Expression_6 ^right_;

  GType_6 type_;

  public CompoundAssign_6(LValue_6 ^left, int op, Expression_6 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public override GType_6 Check(Context_6 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    type_ = left_.Check(ctx, true, true, false);
    if (type_ == null)
      return null;
    if (left_.Kind() == ExprKind_6.Indexer_6) {
      Error("compound assignments don't yet work on indexers");
      return null;
    }
    if (type_ == GBool_6.type_ && (op_ == '&' || op_ == '|')) {
      if (!right_.Check(ctx, GBool_6.type_))
        return null;
      return type_;
    }
    if (type_ != GInt_6.type_ && type_ != GFloat_6.type_ && type_ != GDouble_6.type_) {
      Error("compound assignment operator {0}= can't operate on object of type {1}", (char) op_, type_);
      return null;
    }
    if (!right_.Check(ctx, type_))
      return null;
    return type_;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    Location_6 loc = left_.EvalLocation(env);
    if (type_ == GBool_6.type_) {
      bool x = ((GBool_6) loc.value_).b_;
      bool y = right_.EvalBool(env);
      loc.value_ = Binary_6.BoolOp(x, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GInt_6.type_) {
      GInt_6 x = (GInt_6) loc.value_;
      int y = right_.EvalInt(env);
      loc.value_ = Binary_6.IntOp(x.i_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GFloat_6.type_) {
      GFloat_6 x = (GFloat_6) loc.value_;
      float y = right_.EvalFloat(env);
      loc.value_ = Binary_6.FloatOp(x.f_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GDouble_6.type_) {
      GDouble_6 x = (GDouble_6) loc.value_;
      double y = right_.EvalDouble(env);
      loc.value_ = Binary_6.DoubleOp(x.d_, op_, y);
      return loc.value_.CopyRef();
    } else {
      Debug.Assert(false);
      return null;
    }
  }

  public override string Emit() {
    return String.Format("{0} {1}= {2}", left_.Emit(), (char) op_, right_.Emit());
  }
}

class Take_6 : Expression_6 {
  LValue_6 ^exp_;
  Owning_6 type_;

  public Take_6(LValue_6 ^exp) { exp_ = exp; }

  public override GType_6 Check(Context_6 ctx) {
    GType_6 t = exp_.Check(ctx);
    if (t == null)
      return null;
    type_ = exp_.StorageType() as Owning_6;
    if (type_ == null) {
      Error("take must be applied to owning pointer");
      return null;
    }
    exp_.LoseOwnership();
    ctx.AddTemporary(this);
    return type_;
  }

  public override GType_6 TemporaryType() { return type_; }

  public override RValue_6 ^Eval(Env_6 env) {
    RValue_6 ^v = exp_.Eval(env);
    exp_.EvalSet(env, Null_6.Instance.Copy());
    return v;
  }

  public override string Emit() {
    return Hold(exp_.StorageType(), exp_.Emit());
  }
}

abstract class Statement_6 : Node_6 {
  public abstract bool Check(Context_6 ctx);
  public abstract RValue_6 ^Eval(Env_6 env);

  public abstract void Emit(SourceWriter_6 w);

  public virtual void EmitEmbedded(SourceWriter_6 w) {
    w.WriteLine("");
    w.AddIndent();
    w.Indent();
    Emit(w);
    w.SubIndent();
  }

  public virtual void EmitInExistingBlock(SourceWriter_6 w) {
    w.Indent();
    Emit(w);
  }
}

class StatementList_6 {
  public readonly ArrayList /* of Statement_6 */ ^statements_ = new ArrayList();

  public void Add(Statement_6 ^s) { statements_.Add(s); }

  public bool Check(Context_6 ctx) {
    bool ok = true;
    foreach (Statement_6 s in statements_)
      ok &= s.Check(ctx);
    return ok;
  }

  public RValue_6 ^Eval(Env_6 env) {
    foreach (Statement_6 s in statements_) {
      RValue_6 ^v = s.Eval(env);
      if (v != null)
        return v;
    }
    return null;
  }

  public void Emit(SourceWriter_6 w) {
    foreach (Statement_6 s in statements_) {
      w.Indent();
      s.Emit(w);
    }
  }
}

class EmptyStatement_6 : InlineStatement_6 {
  public EmptyStatement_6() { }

  public override bool Check(Context_6 ctx) { return true; }
  public override RValue_6 ^Eval(Env_6 env) { return null; }
  public override void EmitInline(SourceWriter_6 w) { }

  public static readonly EmptyStatement_6 ^instance_ = new EmptyStatement_6();
}

// A Scoped_6 is a statement defining one or more local variables.  If_6 a Scoped_6 appears in the
// control graph, then it destroys those variables when traversed.
abstract class Scoped_6 : Statement_6 {
  protected Local_6 start_;   // the first local outside this statement
  protected Local_6 top_;     // the top local defined inside this statement

  TypeSet_6 ^destroys_;

  protected void SetStartVar(Context_6 ctx) { start_ = top_ = ctx.var_; }
  protected void SetTopVar(Context_6 ctx) { top_ = ctx.var_; }

  public Local_6 GetStart() { return start_; }
  public Local_6 GetTop() { return top_; }

  public override TypeSet_6 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_6();
    for (Local_6 l = top_; l != start_; l = l.next_)
        destroys_.Add(l.Type().VarDestroys());
    }
    return destroys_;
  }
}

class Block_6 : Scoped_6 {
  public readonly StatementList_6 ^list_;

  public Block_6(StatementList_6 ^list) { list_ = list; }

  public bool Absent() { return list_ == null; }

  public override bool Check(Context_6 ctx) {
    Context_6 ^ctx1 = new Context_6(ctx);   // don't pass declarations outside block
    SetStartVar(ctx1);

    if (!list_.Check(ctx1))
      return false;

    SetTopVar(ctx1);

    // Add this Block_6 to the control graph; this represents the destruction of variables
    // within the block at block exit.
    AddControl(ctx1);

    return true;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    return list_.Eval(new Env_6(env));
  }

  public static Block_6 ^EmptyBlock() { return new Block_6(new StatementList_6()); }

  public override void Emit(SourceWriter_6 w) {
    w.OpenBrace();
    list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitEmbedded(SourceWriter_6 w) {
    w.Write(" ");
    Emit(w);
  }

  public override void EmitInExistingBlock(SourceWriter_6 w) {
    list_.Emit(w);
  }
}

class MemberKind_6 {
  public const int
    Field_6 = 0,
    Method_6 = 1,
    Property_6 = 2,
    Indexer_6 = 3,
    Constructor_6 = 4;
}

class Named_6 : Node_6 {
  public readonly TypeExpr_6 ^type_expr_;   // may be null for certain objects such as constructors
  protected GType_6 type_;

  public readonly string name_;

  public Named_6(TypeExpr_6 ^type_expr, string name) {
    type_expr_ = type_expr;
    name_ = name;
  }

  public GType_6 Type() { return type_; }

  public virtual bool Resolve(Program_6 program) {
    if (type_expr_ == null || type_ != null)
      return true;
    type_ = type_expr_.Resolve(program);
    return type_ != null;
  }
}

abstract class Member_6 : Named_6 {
  protected Class_6 class_;    // containing class

  public readonly int attributes_;

  protected Member_6(int attributes, TypeExpr_6 ^type_expr, string name) : base(type_expr, name) {
    attributes_ = attributes;
  }

  public abstract int Kind();

  public static string ToString(int kind) {
    switch (kind) {
      case MemberKind_6.Field_6: return "field";
      case MemberKind_6.Method_6: return "method";
      case MemberKind_6.Property_6: return "property";
      case MemberKind_6.Indexer_6: return "indexer";
      case MemberKind_6.Constructor_6: return "constructor";
      default: Debug.Assert(false); return null;
    }
  }

  public string KindString() { return ToString(Kind()); }

  protected abstract int ValidAttributes();

  public Class_6 GetClass() { return class_; }
  public void SetClass(Class_6 cl) { class_ = cl; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public bool IsOverride() { return HasAttribute(Attribute_6.Override); }

  public bool IsProtected() { return HasAttribute(Attribute_6.Protected); }

  public bool IsPublic() { return HasAttribute(Attribute_6.Public); }

  public bool IsPrivate() { return !HasAttribute(Attribute_6.Public | Attribute_6.Protected); }

  public bool IsVirtual() {
    return HasAttribute(Attribute_6.Virtual | Attribute_6.Abstract | Attribute_6.Override);
  }

  static ArrayList ^empty_ = new ArrayList();

  public virtual ArrayList /* of Parameter_6 */ Parameters() { return empty_; }

  public Parameter_6 Param(int i) {
    return (Parameter_6) Parameters()[i];
  }

  public bool IsAccessible(Class_6 from_class, GType_6 through_type, bool through_base) {
    if (IsPublic())
      return true;

    // In GEL2 (as in C# and C++), a class [from_class] can access a protected member of
    // a class C only if [from_class] is a subtype of C and the access is
    // through a subtype of [from_class].  See e.g. C# 3.5.3 "Protected Access for Instance Members".
    if (IsProtected())
      return through_base || from_class.IsSubtype(class_) && through_type.IsSubtype(from_class);

    // default private access
    return from_class == class_;
  }

  public static bool MatchKind(int kind1, int kind2) {
    return kind1 == kind2 ||
           kind1 == MemberKind_6.Field_6 && kind2 == MemberKind_6.Property_6 ||
           kind1 == MemberKind_6.Property_6 && kind2 == MemberKind_6.Field_6;
  }

  public bool MatchSignature(Member_6 m) {
    if (!MatchKind(Kind(), m.Kind()))
      return false;

    if (name_ != m.name_ || Parameters().Count != m.Parameters().Count)
      return false;

    int i = 0;
    foreach (Parameter_6 p in m.Parameters()) {
      Parameter_6 q = Param(i);
      if (!p.Match(q))
        return false;
      ++i;
    }
    return true;
  }

  public bool IsApplicable(ArrayList arguments, out int mismatches) {
    mismatches = 0;
    if (Parameters().Count != arguments.Count)
      return false;
    int i = 0;
    foreach (Argument_6 a in arguments) {
      if (!Param(i).CanReceive(a))
        ++mismatches;
      ++i;
    }
    return true;
  }

  public void ReportMismatches(Syntax_6 caller, ArrayList arguments) {
    Debug.Assert(Parameters().Count == arguments.Count);
    int i = 0;
    foreach (Argument_6 a in arguments) {
      Parameter_6 p = Param(i);
      if (!p.CanReceive(a))
        caller.Error("argument {0}: can't convert from {1} to {2}", i + 1, a.TypeString(), p.TypeString());
      ++i;
    }
  }

  protected virtual void AddOverride(Member_6 m) { }

  bool CheckOverride(Context_6 ctx) {
    Class_6 parent = ctx.class_.Parent();
    Member_6 m = parent != null ? parent.FindMatchingMember(this, false) : null;
    if (m != null) {
      if (this is Field_6) {
        Error("can't define field with same name as field/property in superclass");
        return false;
      }
      if (m is Field_6) {
        Error("can't define property with same name as field in superclass");
        return false;
      }
      if (!HasAttribute(Attribute_6.Override)) {
        Error("must use override keyword to override superclass {0}", KindString());
        return false;
      }
      if (HasAttribute(Attribute_6.Virtual)) {
        Error("{0} with override or abstract keyword cannot be marked virtual", KindString());
        return false;
      }
      if (!m.IsVirtual()) {
        Error("attempting to override non-virtual {0}", KindString());
        return false;
      }
      if (!m.Type().Equals(Type())) {
        Error("can't override {0} with different return type", KindString());
        return false;
      }
      if (m.IsPublic() != IsPublic()) {
        Error("override {0} must have same accessibility as {0} it overrides", KindString());
        return false;
      }
      m.AddOverride(this);
    } else if (HasAttribute(Attribute_6.Override)) {
      Error("can't find {0} to override", KindString());
      return false;
    }
    return true;
  }

  bool CheckAccessibility() {
    int n = 0;
    if ((attributes_ & Attribute_6.Private) != 0)
      ++n;
    if ((attributes_ & Attribute_6.Protected) != 0)
      ++n;
    if ((attributes_ & Attribute_6.Public) != 0)
      ++n;
    if (n > 1) {
      Error("only one access level (private, protected, public) may be specified");
      return false;
    }

    if (IsVirtual() && IsPrivate()) {
      Error("a virtual or abstract {0} may not be private", KindString());
      return false;
    }

    return true;
  }

  public virtual bool Check(Context_6 ctx) {
    if (!AttributeUtil_6.CheckOnly(attributes_, ValidAttributes())) {
      Error("illegal {0} attribute", KindString());
      return false;
    }

    if (HasAttribute(Attribute_6.Abstract) && !ctx.class_.HasAttribute(Attribute_6.Abstract)) {
      Error("an abstract {0} can be defined only in an abstract class", KindString());
      return false;
    }

    if (name_ == class_.name_ && !(this is Constructor_6)) {
      Error("{0} cannot have same name as enclosing class", KindString());
      return false;
    }

    if (class_.GetMatchingMember(this) != this) {
      Error("{0} {1} appears twice in same class", KindString(), name_ != null ? name_ : "");
      return false;
    }

    return CheckOverride(ctx) && CheckAccessibility();
  }
}

// a member which represents a storage location: a field, property, or indexer
abstract class LMember_6 : Member_6 {
  protected LMember_6(int attributes, TypeExpr_6 ^type_expr, string name)
    : base(attributes, type_expr, name) { }

  public bool IsConstOrStatic() {
    return HasAttribute(Attribute_6.Const | Attribute_6.Static);
  }

  protected bool CheckStatic(Syntax_6 caller, bool static_ok, bool instance_ok) {
    if (!static_ok && IsConstOrStatic()) {
      caller.Error("{0} {1} is static", KindString(), name_);
      return false;
    }
    if (!instance_ok && !IsConstOrStatic()) {
      caller.Error("{0} {1} is not static", KindString(), name_);
      return false;
    }
    return true;
  }

  public abstract bool CheckAssigning(Syntax_6 caller, Context_6 ctx, bool assigning);

  public bool CheckAccess(Syntax_6 caller, Context_6 ctx, bool assigning, bool static_ok, bool instance_ok) {
    return CheckStatic(caller, static_ok, instance_ok) && CheckAssigning(caller, ctx, assigning);
  }

  public abstract Location_6 GetLocation(GObject_6 obj);

  // These methods are for fields and properties; indexers have their own versions which take
  // an extra index argument.
  public virtual RValue_6 ^Get(GValue_6 obj) { Debug.Assert(false); return null; }
  public virtual RValue_6 ^Take_6(GValue_6 obj) { Debug.Assert(false); return null; }
  public virtual void Set(GObject_6 obj, RValue_6 ^val)  { Debug.Assert(false); }

  public virtual string Emit()  { Debug.Assert(false); return null; }
  public virtual string EmitSet(string val)  { Debug.Assert(false); return null; }
}

class Field_6 : LMember_6 {
  protected Expression_6 ^initializer_;    // or null if none
  protected GType_6 initializer_type_;

  public Field_6(int attributes, TypeExpr_6 ^type_expr, string name, Expression_6 ^initializer)
  : base(attributes, type_expr, name) {
    initializer_ = initializer;
  }

  // Create a field for an internal class.  Such fields will never be type checked.
  public Field_6(GType_6 type, string name) : this(Attribute_6.Public | Attribute_6.ReadOnly, null, name, null) {
    type_ = type;
  }

  public static Field_6 ^New_6(int attributes, TypeExpr_6 ^type_expr, string name, Expression_6 ^initializer) {
    if ((attributes & Attribute_6.Static) != 0)
      return new StaticField_6(attributes, type_expr, name, initializer);
    if ((attributes & Attribute_6.Const) != 0)
      return new ConstField_6(attributes, type_expr, name, initializer);
    return new Field_6(attributes, type_expr, name, initializer);
  }

  public override int Kind() { return MemberKind_6.Field_6; }

  public Expression_6 Initializer() { return initializer_; }

  protected virtual bool CheckInitializer(Context_6 ctx) {
    if (initializer_ == null)
      return true;

    ctx.EnterExpression();
    initializer_type_ = initializer_.Check(ctx);
    bool b = initializer_type_ != null &&
             Assign_6.CheckAssign(this, type_, initializer_, initializer_type_);
    ctx.FinishExpression();
    return b;
  }

  protected override int ValidAttributes() {
    return Attribute_6.Const | Attribute_6.Private | Attribute_6.Protected | Attribute_6.Public |
           Attribute_6.ReadOnly | Attribute_6.Static;
  }

  public override bool Check(Context_6 ctx) {
    if (!base.Check(ctx))
      return false;

    // We build up a small control graph even when checking field initializers; we do this
    // since expression-checking code uses the graph to determine when temporary
    // ref counts are needed.
    prev_ = unreachable_;
    ctx.SetPrev(this);

    bool b = CheckInitializer(ctx);

    ctx.ClearPrev();
    return b;
  }

  public override bool CheckAssigning(Syntax_6 caller, Context_6 ctx, bool assigning) {
    if (assigning) {
      if (HasAttribute(Attribute_6.Const)) {
        caller.Error("can't assign to const field");
        return false;
      }
      if (HasAttribute(Attribute_6.ReadOnly) &&
          (ctx.class_ != class_ || !(ctx.method_ is Constructor_6)) ) {
        caller.Error("readonly field {0} can only be assigned in constructor", name_);
        return false;
      }
    }
    return true;
  }

  public override RValue_6 ^Get(GValue_6 obj) { return obj.Get(this); }
  public override RValue_6 ^Take_6(GValue_6 obj) { return obj.Take_6(this); }
  public override void Set(GObject_6 obj, RValue_6 ^val) { obj.Set(this, val); }
  public override Location_6 GetLocation(GObject_6 obj) { return obj.GetLocation(this); }

  protected void WriteField(SourceWriter_6 w, bool declaration) {
    w.Indent();
    if (declaration && IsConstOrStatic())
      w.Write("static ");
    w.Write("{0} ", type_.EmitType());
    if (this is ConstField_6)
      w.Write("const ");
    if (!declaration)
      w.Write("{0}::", class_.name_);
    w.Write(name_);
  }

  protected void WriteDeclaration(SourceWriter_6 w) { WriteField(w, true); }
  protected void WriteDefinition(SourceWriter_6 w) { WriteField(w, false); }

  public virtual void EmitDeclaration(SourceWriter_6 w) {
    WriteDeclaration(w);
    w.WriteLine(";");
  }

  public void EmitInitializer(SourceWriter_6 w) {
    w.IWrite("{0} = ", name_);
    if (initializer_ != null)
      w.Write(initializer_.Emit(initializer_type_, type_));
    else w.Write(type_.DefaultValue_6().Emit());
    w.WriteLine(";");
  }

  public virtual void Emit(SourceWriter_6 w) { }

  public override string Emit() { return name_; }

  public override string EmitSet(string val) {
    return String.Format("{0} = {1}", name_, val);
  }
}

class StaticField_6 : Field_6 {
  protected Location_6 ^loc_;

  public StaticField_6(int attributes, TypeExpr_6 ^type_expr, string name, Expression_6 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_6 ctx) {
    if (!base.Check(ctx))
      return false;
    loc_ = new Location_6(Type().DefaultValue_6().Copy());
    return true;
  }

  protected override bool CheckInitializer(Context_6 ctx) {
    ArrayInitializer_6 ai = initializer_ as ArrayInitializer_6;
    if (ai != null) {
      GType_6 type = type_;
      Owning_6 o = type as Owning_6;
      type = (o != null) ? o.BaseType() : null;
      ArrayType_6 at = type as ArrayType_6;
      if (at == null) {
        Error("only owning arrays may have initializers");
        return false;
      }
      return ai.CheckElements(ctx, at.ElementType());
    }

    return base.CheckInitializer(ctx);
  }

  public virtual void Init() {
    ArrayInitializer_6 ai = initializer_ as ArrayInitializer_6;
    if (ai != null)
      loc_.value_ = ai.Eval((ArrayType_6) type_.BaseType());
    else if (initializer_ != null)
      loc_.value_ = initializer_.Eval(Env_6.static_, type_);
  }

  public override RValue_6 ^Get(GValue_6 obj) { return loc_.Get().CopyRef(); }
  public override RValue_6 ^Take_6(GValue_6 obj) { return take loc_.value_; }
  public override void Set(GObject_6 obj, RValue_6 ^val) { loc_.value_ = val; }
  public override Location_6 GetLocation(GObject_6 obj) { return loc_; }

  public override void Emit(SourceWriter_6 w) {
    ArrayInitializer_6 ai = initializer_ as ArrayInitializer_6;
    if (ai != null) {
      GType_6 element_type = ((ArrayType_6) type_.BaseType()).ElementType();
      string varname = String.Format("_{0}_{1}", class_.name_, name_);
      w.Write("{0} {1}[] = ", element_type.EmitGenericType(), varname);
      ai.Emit(w);
      w.WriteLine(";");
      WriteDefinition(w);
      w.Write("(new {0}", GType_6.ConstructType("_StaticArray", element_type.EmitGenericType()));
      w.Write("(&typeid({0}), {1}, {2}))", element_type.EmitType(), ai.initializers_.Count, varname);
    } else {
      WriteDefinition(w);
      if (initializer_ != null)
        initializer_.EmitAsInitializer(w, initializer_type_, type_);
    }
    w.WriteLine(";");
    w.WriteLine("");
  }
}

class ConstField_6 : Field_6 {
  protected SimpleValue_6 ^value_;

  public ConstField_6(int attributes, TypeExpr_6 ^type_expr, string name, Expression_6 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_6 ctx) {
    if (!base.Check(ctx))
      return false;
    return initializer_.CheckConstant();
  }

  SimpleValue_6 ^Get() {
    if (value_ == DefaultValue_6.instance_) {
      Error("circular dependency among constant fields");
      Gel_6.Exit();
    }
    if (value_ == null) {
      value_ = new DefaultValue_6();    // marker used to catch circular const references
      value_ = (SimpleValue_6)initializer_.Eval(Env_6.static_, type_);
    }
    return value_.Copy();
  }

  public override RValue_6 ^Get(GValue_6 obj) {
    return Get();
  }

  public override void Set(GObject_6 obj, RValue_6 ^val) { Debug.Assert(false); }
  public override Location_6 GetLocation(GObject_6 obj) { Debug.Assert(false); return null; }

  public override void EmitDeclaration(SourceWriter_6 w) {
    WriteDeclaration(w);
    if (type_ is IntegralType_6)
      w.Write(" = {0}", Get().Emit());
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_6 w) {
    WriteDefinition(w);
    if (!(type_ is IntegralType_6)) {
      w.WriteLine(" = {0};", Get().Emit());
    }
    w.WriteLine(";");
  }
}

class ExpressionTraverser_6 : Traverser_6 {
  readonly Control_6 start_;
  Local_6 local_;
  GType_6 type_;
  bool assign_;
  bool destroy_;

  public ExpressionTraverser_6(Control_6 start, Local_6 local, GType_6 type) {
    start_ = start; local_ = local; type_ = type;
  }

  public override int Handle(Control_6 control) {
    if (control == start_)
      return Cut;
    Node_6 node = control as Node_6;
    if (node != null) {
      if (!destroy_ && node.CanDestroy(type_))
        destroy_ = true;
      else if (local_ != null && node.Sets(local_))
        assign_ = true;
    }
    return Continue_6;
  }

  // Return_6 true if the given expression needs a reference count while we evaluate
  // the control graph nodes between [start] and [end].
  // A local variable needs a ref count if it is assigned to and the object
  // the variable previously pointed to might possibly be destroyed.
  // Any other expression needs a ref count if the object it evaluates to
  // might possibly be destroyed.
  public static bool NeedRef(Control_6 start, Control_6 end, Expression_6 expr, GType_6 type) {
    Debug.Assert(start != null && end != null);
    if (start == end || !type.IsOwned() || expr is This_6 || expr is Base_6)
      return false;
    Local_6 local = expr.GetLocal();
    ExpressionTraverser_6 ^et = new ExpressionTraverser_6(start, local, type);
    end.Traverse(et, Control_6.GetMarkerValue());
    return et.destroy_ && (local == null || et.assign_);
  }
}

abstract class LocalHandler_6 {
  public abstract bool Handle(Local_6 local, Node_6 node, Name_6 use);
}

class LocalChecker_6 : LocalHandler_6 {
  public override bool Handle(Local_6 local, Node_6 node, Name_6 use) {
    if (node == Control_6.unreachable_) {
      if (use != null)
        use.Error("variable {0} may be used before it is assigned a value", use.name_);
      else
        local.Error("out parameter {0} must be assigned before leaving method", local.name_);
      return false;
    }
    if (node.Takes(local)) {
      Name_6 name = (Name_6) node;
      name.Error("can't transfer ownership from {0}: value may be used again", name.name_);
      return false;
    }
    return true;
  }
}

class LocalRefAnalyzer_6 : LocalHandler_6 {
  public override bool Handle(Local_6 local, Node_6 node, Name_6 use) {
    Debug.Assert(node != Control_6.unreachable_);
    if (node.CanDestroy(local.Type())) {
      local.NeedsRef();
      return false;   // abort search
    }
    return true;
  }
}

class LocalTraverser_6 : Traverser_6 {
  readonly Local_6 local_;
  readonly LocalHandler_6 handler_;
  Name_6 use_;

  public LocalTraverser_6(Local_6 local, LocalHandler_6 handler) {
    local_ = local;
    handler_ = handler;
  }

  public void SetUse(Name_6 use) { use_ = use; }

  public override int Handle(Control_6 control) {
    Node_6 node = control as Node_6;
    if (node == null)
      return Continue_6;

    if (node.Sets(local_))
      return Cut;

    return handler_.Handle(local_, node, use_) ? Continue_6 : Abort;
  }
}

class Local_6 : Named_6 {
  protected Expression_6 ^initializer_;    // or null if none
  protected GType_6 initializer_type_;

  public Local_6 next_;    // next variable upward in scope chain

  NonOwningArrayList /* of Name_6 */ ^uses_ = new NonOwningArrayList();    // all uses of this variable

  protected bool mutable_;   // true if this local may ever change after it's first initialized

  protected bool needs_ref_;    // true if this variable needs a reference count in emitted code

  public Expression_6 Initializer() { return initializer_; }

  public void NeedsRef() { needs_ref_ = true; }

  public virtual string Emit() { return name_; }

  // Return_6 true if we represent this local using a smart pointer wrapper (i.e.
  // _Ptr, _Own, _OwnRef or _Ref).
  public virtual bool IsWrapper() {
    return type_ is Owning_6 || type_ == GString_6.type_ || needs_ref_;
  }

  public Local_6(TypeExpr_6 ^type_expr, string name, Expression_6 ^initializer) : base(type_expr, name) {
    initializer_ = initializer;
    next_ = null;
  }

  public bool Check(Context_6 ctx) {
    Local_6 decl = ctx.FindVar(name_);
    if (decl != null) {
      Error("error: variable already defined");
      return false;
    }

    if (initializer_ != null) {
      ctx.EnterExpression();
      initializer_type_ = initializer_.Check(ctx);
      bool ok = initializer_type_ != null &&
                Assign_6.CheckAssign(this, type_, initializer_, initializer_type_);

      // Add this Local_6 to the control graph.  We need to do this before calling
      // FinishExpression since the Local_6 will be initialized before temporaries 
      // are destroyed.
      AddControl(ctx);

      ctx.FinishExpression();
      if (!ok)
        return false;
    }

    next_ = ctx.var_;
    ctx.SetVar(this);

    ctx.method_.AddVar(this);
    return true;
  }

  public override bool Sets(Local_6 local) {
    return this == local && initializer_ != null;
  }

  public virtual GType_6 ReadType() {
    return type_;
  }

  public void AddUse(Name_6 name) {
    uses_.Add(name);
  }

  public void SetMutable() { mutable_ = true; }

  // Traverse the control graph nodes where this local is live, calling the given
  // LocalHandler_6's Handle method on each node.
  public bool Traverse(Method_6 method, LocalHandler_6 h) {
    LocalTraverser_6 ^t = new LocalTraverser_6(this, h);
    int marker = Control_6.GetMarkerValue();
    foreach (Name_6 name in uses_) {
      t.SetUse(name);
      if (!name.prev_.Traverse(t, marker))
        return false;
    }

    Parameter_6 p = this as Parameter_6;
    if (p != null && p.GetMode() == Mode_6.Out) {
      t.SetUse(null);
      if (!method.exit_.Traverse(t, marker))
        return false;
    }
    return true;
  }

  // check variable usage once control flow graph is complete
  public bool CheckUsage(Method_6 method) {
    return Traverse(method, new LocalChecker_6());
  }

  // Determine whether this Local_6 needs a reference count.  This_6 can happen only after
  // we've built up a control graph for all methods.
  public void ComputeRef(Method_6 method) {
    // For_6 now, a variable of type object always needs a reference count since it may
    // contain a string and we don't yet detect string destruction in the graph traversal.
    if (type_ == GObject_6.type_)
      NeedsRef();
    else if (type_.IsOwned())
      Traverse(method, new LocalRefAnalyzer_6());
  }

  public void EvalInit(Env_6 env) {
    env.Add(this, initializer_ != null ? initializer_.Eval(env, type_) : null);
  }

  protected virtual string EmitDeclarationType() {
    return IsWrapper() ? type_.EmitType() : type_.EmitExprType();
  }

  public virtual string EmitDeclarationName() { return name_; }

  public void EmitDeclaration(SourceWriter_6 w) {
    w.Write("{0} {1}", EmitDeclarationType(), EmitDeclarationName());
  }

  public void EmitInitializer(SourceWriter_6 w) {
    if (initializer_ != null)
      initializer_.EmitAsInitializer(w, initializer_type_, type_);
  }
}

class Parameter_6 : Local_6 {
  public Parameter_6(TypeExpr_6 ^type_expr, string name) : base(type_expr, name, null) { }

  // We represent some parameters using both a C++ parameter and a C++ local, which
  // have different types; we call these dual parameters.  For_6 such parameters
  // param_name_ is the C++ parameter name.
  string param_name_;

  public static Parameter_6 ^New_6(int mode, TypeExpr_6 ^type_expr, string name) {
    return mode == 0 ? new Parameter_6(type_expr, name) :
                               new RefOutParameter_6(mode, type_expr, name);
  }

  public virtual int GetMode() { return 0; }
  public string TypeString() { return Mode_6.ToString(GetMode()) + type_.ToString(); }

  public virtual Parameter_6 ^Copy() {
    return new Parameter_6(new TypeLiteral_6(type_), name_);
  }

  public virtual bool CanReceive(Argument_6 a) {
    return a.GetMode() == 0 && a.Type().CanConvert(type_, ConversionContext_6.MethodArg);
  }

  public bool Match(Parameter_6 p) {
    return GetMode() == p.GetMode() && type_.Equals(p.type_);
  }

  public override bool IsWrapper() {
    return type_ is Owning_6 || type_ == GString_6.type_ || mutable_ && needs_ref_;
  }

  public void CheckParameterUsage(Method_6 method) {
    if (type_ is Owning_6 && !(this is RefOutParameter_6)) {
      // We need both a C++ parameter and a C++ local: the parameter type can't be
      // _Own<>, since _Own has no public copy constructor and GCC doesn't allow passing
      // by value when a class's copy constructor is private.
      string n = name_;
      do {
        n = "_" + n;
      } while (method.HasLocal(n));
      param_name_ = n;
    }
  }

  protected override string EmitDeclarationType() {
    // For_6 owning parameters the declaration type is the expression type since we can't
    // pass _Own<> by value.
    return type_ is Owning_6 ? type_.EmitExprType() : base.EmitDeclarationType();
  }

  public override string EmitDeclarationName() {
    return param_name_ != null ? param_name_ : name_;
  }

  public void EmitExtraDeclaration(SourceWriter_6 w) {
    if (param_name_ != null)
      w.IWriteLine("{0} {1}({2});", type_.EmitType(), name_, param_name_);
  }
}

class RefOutParameter_6 : Parameter_6 {
  public readonly int mode_;
  public override int GetMode() { return mode_; }

  public RefOutParameter_6(int mode, TypeExpr_6 ^type_expr, string name) : base(type_expr, name) {
    mode_ = mode;
    mutable_ = true;
  }

  public override Parameter_6 ^Copy() { Debug.Assert(false); return null; }

  public override bool CanReceive(Argument_6 a) {
    if (mode_ != a.GetMode())
      return false;
    RefOutArgument_6 ra = (RefOutArgument_6) a;
    return type_.Equals(ra.StorageType());
  }

  public override GType_6 ReadType() {
    // If_6 a ref parameter has an owning type, we require the user to use the take operator to take
    // ownership of the value, since taking ownership has the visible side effect of clearing the
    // value the ref parameter points to.
    return mode_ == Mode_6.Ref ? type_.BaseType() : type_;
  }

  public override string Emit() {
    return "(*" + name_ + ")";
  }

  protected override string EmitDeclarationType() {
    return type_.EmitType() + " *";
  }
}

abstract class InlineStatement_6 : Statement_6 {
  public abstract void EmitInline(SourceWriter_6 w);

  public override void Emit(SourceWriter_6 w) {
    EmitInline(w);
    w.WriteLine(";");
  }
}

class VariableDeclaration_6 : InlineStatement_6 {
  ArrayList /* of Local_6 */ ^locals_ = new ArrayList();

  public VariableDeclaration_6(TypeExpr_6 ^type_expr, string name, Expression_6 ^initializer) {
    locals_.Add(new Local_6(type_expr, name, initializer));
  }

  public void Add(string name, Expression_6 ^initializer) {
    TypeExpr_6 ^t = ((Local_6) locals_[0]).type_expr_.Copy();
    locals_.Add(new Local_6(t, name, initializer));
  }

  public override bool Check(Context_6 ctx) {
    // local variables are not resolved during the Resolve phase, so we must resolve them here
    foreach (Local_6 l in locals_)
      if (!l.Resolve(ctx.program_) || !l.Check(ctx))
        return false;

    return true;
  }

  // Return_6 the type of all variables in this VariableDeclaration_6.
  public GType_6 Type() { return ((Local_6) locals_[0]).Type(); }

  public override RValue_6 ^Eval(Env_6 env) {
    foreach (Local_6 l in locals_)
      l.EvalInit(env);
    return null;
  }

  void Emit(SourceWriter_6 w, bool in_line) {
    if (in_line)
      Debug.Assert(locals_.Count == 1);

    foreach (Local_6 l in locals_) {
      l.EmitDeclaration(w);
      l.EmitInitializer(w);
      if (!in_line)
        w.WriteLine(";");
    }
  }

  public override void EmitInline(SourceWriter_6 w) { Emit(w, true); }
  public override void Emit(SourceWriter_6 w) { Emit(w, false); }
}

class ExpressionStatement_6 : InlineStatement_6 {
  Expression_6 ^exp_;

  public ExpressionStatement_6(Expression_6 ^e) {
    exp_ = e;
  }

  public override bool Check(Context_6 ctx) {
    if (exp_.CheckTop(ctx) == null)
      return false;
    exp_.SetUnused();
    return true;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    exp_.Eval(env);   // discard expression value
    return null;
  }

  public override void EmitInline(SourceWriter_6 w) {
    w.Write(exp_.Emit());
  }

}

class If_6 : Statement_6 {
  Expression_6 ^condition_;
  Statement_6 ^if_true_;
  Statement_6 ^if_false_;
  Joiner_6 ^join_ = new Joiner_6();

  public If_6(Expression_6 ^condition, Statement_6 ^if_true, Statement_6 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override bool Check(Context_6 ctx) {
    if (!condition_.Check(ctx, GBool_6.type_))
      return false;

    Control_6 c = ctx.Prev();

    if (!if_true_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    if (if_false_ != null && !if_false_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());
    return true;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    if (condition_.EvalBool(env))
      return if_true_.Eval(env);
    else
      return if_false_ != null ? if_false_.Eval(env) : null;
  }

  public override void Emit(SourceWriter_6 w) {
    w.Write("if ({0})", condition_.Emit());
    if_true_.EmitEmbedded(w);
    if (if_false_ != null) {
      w.IWrite("else");
      if_false_.EmitEmbedded(w);
    }
  }

}

class DefaultValue_6 : SimpleValue_6 {
  public DefaultValue_6() { }
  public static readonly DefaultValue_6 ^instance_ = new DefaultValue_6();

  public override SimpleValue_6 ^Copy() { Debug.Assert(false); return null; }
  public override GType_6 Type()  { Debug.Assert(false); return null; }
  public override string Emit() { Debug.Assert(false); return null; }
}

// A section in a switch statement.
//
// In GEL2, unlike C# and C++, local variables declared in a switch section are visible only
// in that section.  There doesn't seem to be much point in allowing sections to share locals
// since GEL2 (like C#) doesn't allow control to fall through from one section to the next.  This_6 also
// makes compiling to C++ slightly easier since C++ doesn't allow local variables in switch sections
// other than the last to have initializers (see e.g. C++ Primer, 4th ed., 6.6.5 "Variable Definitions
// inside a switch").

class SwitchSection_6 : Node_6 {
  ArrayList /* of Expression_6 */ ^cases_;     // null represents default:
  public readonly Block_6 ^block_;

  ArrayList /* of GValue_6 */ ^values_ = new ArrayList();

  public SwitchSection_6(ArrayList ^cases, StatementList_6 ^statements) {
    cases_ = cases;
    block_ = new Block_6(statements);
  }

  public bool Check(Context_6 ctx, GType_6 switch_type, OwningHashtable all_values, out bool is_default) {
    is_default = false;
    foreach (Expression_6 e in cases_) {
      GValue_6 ^v;
      if (e == null) {
        is_default = true;
        v = new DefaultValue_6();
      } else {
        if (!e.Check(ctx, switch_type) || !e.CheckConstant())
          return false;
        v = (GValue_6) e.Eval(Env_6.static_, switch_type);
      }
      if (all_values.ContainsKey(v)) {
        Error("switch statement cannot contain the same value twice");
        return false;
      }
      all_values.Set(v, null);
      values_.Add(v);
    }
    return block_.Check(ctx);
  }

  public bool Match(GValue_6 v) {
    foreach (GValue_6 val in values_)
      if (val.Equals(v))
        return true;
    return false;
  }

  public void Emit(SourceWriter_6 w) {
    foreach (Expression_6 c in cases_)
      if (c == null)
        w.IWriteLine("default:");
      else w.IWriteLine("case {0}:", c.Emit());
    w.Indent();
    block_.Emit(w);
  }

  public void EmitString(SourceWriter_6 w) {
    w.IWrite("if (");
    for (int i = 0 ; i < values_.Count ; ++i) {
      if (i > 0) {
        w.WriteLine(" ||");
        w.IWrite("    ");
      }
      w.Write("_s->_Equals({0})", 
              GString_6.EmitStringConst(((GString_6) values_[i]).s_));
    }
    w.Write(") ");
    block_.Emit(w);
  }
}

abstract class Escapable_6 : Scoped_6 {
  public readonly Joiner_6 ^exit_ = new Joiner_6();
}

class Switch_6 : Escapable_6 {
  Expression_6 ^expr_;
  GType_6 type_;
  ArrayList /* of SwitchSection_6 */ ^sections_;
  SwitchSection_6 default_;    // or null if no default section

  public Switch_6(Expression_6 ^expr, ArrayList ^sections) { expr_ = expr; sections_ = sections; }

  public override bool Check(Context_6 ctx) {
    SetStartVar(ctx);
    type_ = expr_.CheckTop(ctx);
    if (type_ == null)
      return false;
    if (type_ != GInt_6.type_ && type_ != GChar_6.type_ && type_ != GString_6.type_) {
      Error("switch expression must be of type int, char or string");
      return false;
    }
    Context_6 ^ctx1 = new Context_6(ctx, this);
    OwningHashtable ^values = new OwningHashtable();
    Control_6 c = ctx1.Prev();
    foreach (SwitchSection_6 s in sections_) {
      bool is_default;
      ctx1.SetPrev(c);
      if (!s.Check(ctx1, type_, values, out is_default))
        return false;
      if (is_default)
        default_ = s;
      if (ctx1.Prev() != unreachable_) {
        s.Error("switch case may not fall through to following case");
        return false;
      }
    }
    if (default_ == null)
      exit_.Join(c);
    ctx1.SetPrev(exit_.Combine());
    return true;
  }

  SwitchSection_6 FindSection(GValue_6 v) {
    foreach (SwitchSection_6 s in sections_)
      if (s.Match(v))
        return s;
    return default_;
  }

  RValue_6 ^CatchBreak(RValue_6 ^v) {
    return v is BreakValue_6 ? null : v;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    RValue_6 ^v = expr_.Eval(env);
    if (v == null)
      return null;
    SwitchSection_6 s = FindSection(v.Get());
    if (s == null)
      return null;
    return CatchBreak(s.block_.Eval(env));
  }

  public override void Emit(SourceWriter_6 w) {
    if (type_ == GString_6.type_) {
      // For_6 now, we implement a switch on strings using a sequence of if statements.  We wrap
      // the sequence in a dummy switch statement so that break statements will work properly.
      // If_6 the switch statement has just a default: label then the Microsoft C++ compiler issues
      // a warning, and if it has just a case 0: label then the compiler doesn't realize that the
      // case will always be executed, which may lead to warnings about not all code paths returning
      // a value.  So we use both default: and case 0:, which seems to work fine.
      w.Write("switch (0) ");
      w.OpenBrace();
      w.IWriteLine("case 0:");
      w.IWriteLine("default:");
      w.IWriteLine("StringPtr _s = {0};", expr_.Emit());
      foreach (SwitchSection_6 s in sections_)
        if (s != default_)
          s.EmitString(w);
      if (default_ != null)
        default_.block_.Emit(w);
      w.CloseBrace();
    } else {
      w.Write("switch ({0}) ", expr_.Emit());
      w.OpenBrace();

      foreach (SwitchSection_6 s in sections_)
        s.Emit(w);

      w.CloseBrace();
    }
  }
}

abstract class Loop_6 : Escapable_6 {
  public readonly Joiner_6 ^loop_ = new Joiner_6();
}

abstract class ForOrWhile_6 : Loop_6 {
  protected Expression_6 ^condition_;
  protected Statement_6 ^statement_;

  protected ForOrWhile_6(Expression_6 ^condition, Statement_6 ^statement) {
    condition_ = condition; statement_ = statement;
  }

  protected abstract InlineStatement_6 Initializer();
  protected abstract InlineStatement_6 Iterator();

  public override bool Check(Context_6 prev_ctx) {
    Context_6 ^ctx = new Context_6(prev_ctx, this);   // initializer may declare new local variable
    SetStartVar(ctx);
    if (!Initializer().Check(ctx))
      return false;
    SetTopVar(ctx);

    loop_.AddControl(ctx);

    if (!condition_.CheckTop(ctx, GBool_6.type_))
      return false;

    if (!condition_.IsTrueLiteral())  // we may exit the loop at this point
      exit_.Join(ctx.Prev());  

    if (!statement_.Check(ctx))
      return false;

    if (!Iterator().Check(ctx))
      return false;

    loop_.Join(ctx.Prev());  // loop back to top

    ctx.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy any local defined in an initializer above.
    AddControl(ctx);

    return true;
  }

  public override RValue_6 ^Eval(Env_6 outer_env) {
    Env_6 ^env = new Env_6(outer_env);   // initializer may declare new local
    for (Initializer().Eval(env); condition_.EvalBool(env); Iterator().Eval(env)) {
      RValue_6 ^v = statement_.Eval(env);
      if (v is BreakValue_6)
        break;
      if (v is ContinueValue_6)
        continue;
      if (v != null)
        return v;
    }
    return null;
  }
}

class While_6 : ForOrWhile_6 {
  public While_6(Expression_6 ^condition, Statement_6 ^statement) : base(condition, statement) { }

  protected override InlineStatement_6 Initializer()  { return EmptyStatement_6.instance_; }
  protected override InlineStatement_6 Iterator()  { return EmptyStatement_6.instance_; }

  public override void Emit(SourceWriter_6 w) {
    w.Write("while ({0})", condition_.Emit());
    statement_.EmitEmbedded(w);
  }
}

class For_6 : ForOrWhile_6 {
  InlineStatement_6 ^initializer_;
  InlineStatement_6 ^iterator_;

  public For_6(InlineStatement_6 ^initializer, Expression_6 ^condition, InlineStatement_6 ^iterator,
             Statement_6 ^statement)
    : base(condition != null ? condition : new Literal_6(new GBool_6(true)),
           statement) {
    initializer_ = initializer != null ? initializer : new EmptyStatement_6();
    iterator_ = iterator != null ? iterator : new EmptyStatement_6();
  }

  protected override InlineStatement_6 Initializer()  { return initializer_; }
  protected override InlineStatement_6 Iterator()  { return iterator_; }

  public override void Emit(SourceWriter_6 w) {
    w.Write("for (");
    initializer_.EmitInline(w);
    w.Write("; {0}; ", condition_.Emit());
    iterator_.EmitInline(w);
    w.Write(")");
    statement_.EmitEmbedded(w);
  }
}

class Do_6 : Loop_6 {
  Statement_6 ^statement_;
  Expression_6 ^condition_;

  Joiner_6 ^join_ = new Joiner_6();

  public Do_6(Statement_6 ^statement, Expression_6 ^condition) {
    statement_ = statement;
    condition_ = condition;
  }

  public override bool Check(Context_6 ctx) {
    join_.AddControl(ctx);

    Context_6 ^ctx1 = new Context_6(ctx, this);
    SetStartVar(ctx);

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx.Prev());  // continue statements jump here
    ctx.SetPrev(loop_.Combine());

    if (!condition_.CheckTop(ctx, GBool_6.type_))
      return false;

    if (!condition_.IsFalseLiteral())
      join_.Join(ctx.Prev());   // loop back to top
    if (!condition_.IsTrueLiteral())
      exit_.Join(ctx.Prev());   // fall through to exit
    ctx.SetPrev(exit_.Combine());

    return true;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    do {
      RValue_6 ^v = statement_.Eval(env);
      if (v is BreakValue_6)
        break;
      if (v is ContinueValue_6)
        continue;
      if (v != null)
        return v;
    } while (condition_.EvalBool(env));
    return null;
  }

  public override void Emit(SourceWriter_6 w) {
    w.IWrite("do");
    statement_.EmitEmbedded(w);
    w.IWriteLine("while ({0});", condition_.Emit());
  }
}

// A helper class for ForEach_6: a node defining a single variable in the control graph.
class Definer_6 : Node_6 {
  Local_6 local_;

  public Definer_6(Local_6 local) { local_ = local; }

  public override bool Sets(Local_6 local) {
    return local_ == local;
  }
}

class ForEach_6 : Loop_6 {
  Local_6 ^local_;
  Expression_6 ^expr_;
  GType_6 expr_type_;
  Statement_6 ^statement_;

  Property_6 count_;
  Indexer_6 indexer_;

  Definer_6 ^definer_;

  public ForEach_6(TypeExpr_6 ^type_expr, string name, Expression_6 ^expr, Statement_6 ^statement) {
    local_ = new Local_6(type_expr, name, null);
    expr_ = expr;
    statement_ = statement;
  }

  public override bool Check(Context_6 ctx) {
    if (!local_.Resolve(ctx.program_))
      return false;

    expr_type_ = expr_.CheckTop(ctx);
    if (expr_type_ == null)
      return false;

    count_ = expr_type_.Lookup(this, ctx.class_, false, MemberKind_6.Property_6, "Count", null, false) as Property_6;
    if (count_ == null) {
      Error("object enumerable by foreach must have an accessible property Count");
      return false;
    }
    if (count_.Type() != GInt_6.type_) {
      Error("object enumerable by foreach must have a property Count of type int");
      return false;
    }

    ArrayList ^args = new ArrayList();
    args.Add(new InArgument_6(GInt_6.type_));
    indexer_ = (Indexer_6) expr_type_.Lookup(this, ctx.class_, false, MemberKind_6.Indexer_6, null, args, false);
    if (indexer_ == null) {
      Error("object enumerable by foreach must have an accessible indexer on integers");
      return false;
    }
    if (!indexer_.CheckAssigning(this, ctx, false))
      return false;

    GType_6 indexer_type = indexer_.Type();
    GType_6 iterator_type = local_.Type();
    if (!indexer_type.CanConvertExplicit(iterator_type, false)) {
      Error("enumeration type {0} is not explicitly convertible to iteration variable type {1}",
        indexer_type, iterator_type);
      return false;
    }

    Context_6 ^ctx1 = new Context_6(ctx, this);

    SetStartVar(ctx1);
    if (!local_.Check(ctx1))   // will add local to scope chain
      return false;
    SetTopVar(ctx1);

    // Add a control graph node representing the creation of the local above.
    definer_ = new Definer_6(local_);
    definer_.AddControl(ctx1);

    loop_.AddControl(ctx1);   // continue statements jump here

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx1.Prev());   // loop back to top

    exit_.Join(loop_);  // any loop iteration may exit

    ctx1.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy the local variable created above.
    AddControl(ctx1);

    return true;
  }

  public override RValue_6 ^Eval(Env_6 outer_env) {
    RValue_6 ^r = expr_.Eval(outer_env);
    GValue_6 e = r.Get();
    if (e is Null_6) {
      Error("foreach: can't iterate over null object");
      Gel_6.Exit();
    }

    int count = ((GInt_6) count_.Get(e)).i_;

    Env_6 ^env = new Env_6(outer_env);
    env.Add(local_, null);
    for (int i = 0 ; i < count ; ++i) {
      RValue_6 ^v = indexer_.Get(e, new GInt_6(i));
      env.Set(local_, v.Get().ConvertExplicit(ref v, local_.Type()));
      RValue_6 ^s = statement_.Eval(env);
      if (s is BreakValue_6)
        break;
      if (s is ContinueValue_6)
        continue;
      if (s != null)
        return s;
    }
    return null;
  }

  public override void Emit(SourceWriter_6 w) {
    w.OpenBrace();
    w.IWriteLine("{0} _collection = {1};", expr_type_.BaseType().EmitType(), expr_.Emit());
    w.IWriteLine("int _count = _collection->get_Count();");
    w.IWrite("for (int _i = 0 ; _i < _count ; ++_i) ");
    w.OpenBrace();
    w.Indent();
    local_.EmitDeclaration(w);
    w.WriteLine(" = {0}; ",
      Expression_6.EmitExplicit(indexer_.Type(), local_.Type(), "_collection->get_Item(_i)", true));
    statement_.EmitInExistingBlock(w);
    w.CloseBrace();
    w.CloseBrace();
  }
}

class BreakValue_6 : GValue_6 {
  public BreakValue_6() { }

  public static readonly BreakValue_6 ^instance_ = new BreakValue_6();

  public override GType_6 Type()  { Debug.Assert(false); return null; }
}

abstract class BreakOrContinue_6 : Scoped_6 {
  protected void Link(Context_6 ctx, Scoped_6 target, Joiner_6 joiner) {
    // When traversed in the control graph, we destroy all variables in the scopes we are exiting,
    // excluding variables defined in the containing Escapable_6 or Loop_6.
    start_ = target.GetTop();
    SetTopVar(ctx);

    prev_ = ctx.Prev();
    if (prev_ != unreachable_)
      joiner.Join(this);

    ctx.SetPrev(unreachable_);
  }
}

class Break_6 : BreakOrContinue_6 {
  public override bool Check(Context_6 ctx) {
    Escapable_6 e = ctx.escape_;
    if (e == null) {
      Error("break statement must appear inside a while, do, for, foreach or switch statement");
      return false;
    }
    Link(ctx, e, e.exit_);
    return true;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    return new BreakValue_6();
  }

  public override void Emit(SourceWriter_6 w) {
    w.WriteLine("break;");
  }
}

class ContinueValue_6 : GValue_6 {
  public ContinueValue_6() { }

  public static readonly ContinueValue_6 ^instance_ = new ContinueValue_6();

  public override GType_6 Type()  { Debug.Assert(false); return null; }
}

class Continue_6 : BreakOrContinue_6 {
  public override bool Check(Context_6 ctx) {
    Loop_6 l = ctx.loop_;
    if (l == null) {
      Error("continue statement must appear inside a while, do, for or foreach statement");
      return false;
    }
    Link(ctx, l, l.loop_);
    return true;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    return new ContinueValue_6();
  }

  public override void Emit(SourceWriter_6 w) {
    w.WriteLine("continue;");
  }
}

class Return_6 : Statement_6 {
  Expression_6 ^exp_;    // null if no return value
  GType_6 exp_type_;
  GType_6 type_;

  public Return_6(Expression_6 ^exp) {
    exp_ = exp;
  }

  public override bool Check(Context_6 ctx) {
    if (exp_ == null) {
      if (ctx.method_.ReturnType() != Void_6.type_) {
        Error("error: returning value from function returning void");
        return false;
      }
    } else {
      type_ = ctx.method_.ReturnType();
      ctx.EnterExpression();
      exp_type_ = exp_.CheckAndHold(ctx);
      if (exp_type_ == null ||
          !exp_type_.CheckConvert(this, type_,
            exp_.IsRefOutParameter() ? ConversionContext_6.AssignVar : ConversionContext_6.Other))
        return false;
      exp_.CheckLoseOwnership(exp_type_, type_);
      ctx.FinishExpression();
      exp_.ReleaseRef(ctx);
    }

    ctx.method_.JoinReturn(ctx);
    ctx.SetPrev(unreachable_);
    return true;
  }

  public override RValue_6 ^Eval(Env_6 env) {
    return exp_ != null ? exp_.Eval(env, type_)
                        : Null_6.Instance.Copy();    // an arbitrary value
  }

  public override void Emit(SourceWriter_6 w) {
    if (exp_ != null && exp_.NeedsRef(exp_type_)) {
      // If_6 exp_ needs a reference count, that reference count needs to survive the destruction
      // of temporaries, so we can't simply emit a temporary reference count wrapper.  For_6 example,
      // when compiling the expression "return (new Foo()).Fun();", if Fun() returns a Foo then we
      // need a wrapper, and we can't generate "return _Ptr<Fun>(Foo().Fun()).Get()" since the _Ptr<Fun>
      // wrapper will be destroyed before the temporary Foo() object is destroyed.  So we need to
      // use an extra variable here.
      w.OpenBrace();
      w.IWriteLine("{0} __ret = {1};", exp_type_.EmitType(), exp_.Emit());
      w.IWriteLine("return __ret.Get();");
      w.CloseBrace();
    } else {
      w.Write("return ");
      if (exp_ != null)
        w.Write(exp_.Emit(exp_type_, type_));
      w.WriteLine(";");
    }
  }
}

class Attribute_6 {
  public const int Abstract = 1,
  Const = 2,
  Extern = 4,
  Override = 8,
  Private = 16,
  Protected = 32,
  Public = 64,
  ReadOnly = 128,
  Ref = 256,
  Static = 512,
  Virtual = 1024,
  Setter = 2048;
}

class AttributeUtil_6 {
  public static bool CheckOnly(int a, int allowed) {
    return (a & ~allowed) == 0;
  }
}

class MethodTraverser_6 : Traverser_6 {
  Method_6 method_;

  public MethodTraverser_6(Method_6 method) { method_ = method; }

  public override int Handle(Control_6 control) {
    if (control == Control_6.unreachable_)
      return Cut;

    Node_6 node = control as Node_6;
    if (node != null) {
      Method_6 c = node.Calls();
      if (c != null)
        method_.calls_.Add(c);
      method_.internal_destroys_.Add(node.NodeDestroys());
    }

    return Continue_6;
  }
}

class Method_6 : Member_6 {
  public readonly ArrayList /* of Parameter_6 */ ^parameters_;

  protected Block_6 ^body_;

  public Joiner_6 ^exit_ = new Joiner_6();

  // all parameters and locals defined in this method
  readonly NonOwningArrayList /* of Local_6 */ ^locals_ = new NonOwningArrayList();

  NonOwningArrayList /* of Method_6 */ ^overrides_;   // list of all overrides (virtual methods only)

  // methods called from this method
  public readonly NonOwningArrayList /* of Method_6 */ ^calls_ = new NonOwningArrayList();

  // Types destroyed inside this method, not including types destroyed through
  // calls to other methods.
  public readonly TypeSet_6 ^internal_destroys_ = new TypeSet_6();

  // Types destroyed inside this method or in any methods called by this method.
  TypeSet_6 ^destroys_;

  TypeSet_6 ^parameter_destroys_;

  // A marker used when performing a depth-first search of the method graph to compute destroys_.
  int method_marker_;

  public Method_6(int attributes, TypeExpr_6 ^return_type_expr,
                string name, ArrayList /* of Parameter_6 */ ^parameters, Block_6 ^body)
    : base(attributes, return_type_expr, name) {
    parameters_ = parameters;
    body_ = body;
  }

  public override int Kind() { return MemberKind_6.Method_6; }

  public GType_6 ReturnType() { return type_; }

  public override ArrayList Parameters() {
    return parameters_;
  }

  public bool IsExtern() { return class_.IsExtern(); }

  public bool IsStatic() {
    return HasAttribute(Attribute_6.Static);
  }

  public override bool Resolve(Program_6 program) {
    if (!base.Resolve(program))
      return false;
    foreach (Parameter_6 p in parameters_)
      if (!p.Resolve(program))
        return false;
    return true;
  }

  public void AddVar(Local_6 v) {
    locals_.Add(v);
  }

  public override bool Sets(Local_6 local) {
    foreach (Parameter_6 p in parameters_)
      if (p == local && p.GetMode() != Mode_6.Out)
        return true;
    return false;
  }

  public void JoinReturn(Context_6 ctx) {
    exit_.Join(ctx.Prev());
  }

  public const int kValidAttributes =
    Attribute_6.Abstract | Attribute_6.Override |
    Attribute_6.Private | Attribute_6.Protected | Attribute_6.Public |
    Attribute_6.Static | Attribute_6.Virtual | Attribute_6.Setter;

  protected override int ValidAttributes() {
    return kValidAttributes;
  }

  // overridden by Constructor_6 subclass
  protected virtual bool CheckEntry(Context_6 ctx) { return true; }

  // overridden by Constructor_6 subclass
  public override bool Check(Context_6 prev_ctx) {
    if (!base.Check(prev_ctx))
      return false;

    bool abstract_or_extern = HasAttribute(Attribute_6.Abstract) || IsExtern();

    if (body_.Absent()) {
      if (!abstract_or_extern) {
        Error("a method without a body must be abstract or extern");
        return false;
      }
      return true;
    } 

    if (abstract_or_extern) {
      Error("an abstract or extern method cannot have a body");
      return false;
    }

    Context_6 ^ctx = new Context_6(prev_ctx, this);

    prev_ = unreachable_;
    ctx.SetPrev(this);    // begin the control graph with this Method_6

    foreach (Parameter_6 p in parameters_)
      if (!p.Check(ctx))
        return false;

    if (!CheckEntry(ctx))
      return false;

    if (!body_.Check(ctx))
      return false;

    if (!(this is Constructor_6) && type_ != Void_6.type_ && ctx.Prev() != unreachable_) {
      Error("method must return a value");
      return false;
    }
    JoinReturn(ctx);

    ctx.ClearPrev();  // control graph is complete

    // Traverse the control graph to build calls_ and internal_destroys_.
    MethodTraverser_6 ^mt = new MethodTraverser_6(this);
    exit_.Traverse(mt, Control_6.GetMarkerValue());

    bool ok = true;
    foreach (Local_6 v in locals_)    // for all locals and parameters
      ok &= v.CheckUsage(this);

    foreach (Parameter_6 p in parameters_)
      p.CheckParameterUsage(this);

    return ok;
  }

  // Determine whether each local variable needs a reference count.
  protected void ComputeRefs() {
    foreach (Local_6 v in locals_)
      v.ComputeRef(this);
  }

  // Return_6 true if this method has a local or parameter with the given name.
  public bool HasLocal(string name) {
    foreach (Local_6 l in locals_)
      if (l.name_ == name)
        return true;
    return false;
  }

  public override TypeSet_6 NodeDestroys() {
    if (parameter_destroys_ == null) {
      parameter_destroys_ = new TypeSet_6();
    foreach (Parameter_6 p in parameters_)
        parameter_destroys_.Add(p.Type().VarDestroys());
    }
    return parameter_destroys_;
  }

  protected override void AddOverride(Member_6 m) {
    if (overrides_ == null)
      overrides_ = new NonOwningArrayList();
    overrides_.Add((Method_6) m);
  }

  bool Visit(int marker, TypeSet_6 set) {
    if (method_marker_ == marker)
      return true;

    method_marker_ = marker;
    set.Add(internal_destroys_);
    if (set.IsObject())
      return false;   // we already have object; no point in traversing further

    foreach (Method_6 m in calls_)
      if (!m.Visit(marker, set))
        return false;

    if (overrides_ != null)
      foreach (Method_6 m in overrides_)
        if (!m.Visit(marker, set))
          return false;

    return true;
  }

  public TypeSet_6 Destroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_6();
      Visit(Control_6.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  // overridden by Constructor_6 subclass
  public virtual RValue_6 ^Eval(Env_6 env) {
    return body_.Eval(env);
  }

  public RValue_6 ^Invoke(GValue_6 obj, ArrayList /* of ValueOrLocation_6 */ values) {
    if (body_.Absent()) { // an external method
      ValueList_6 ^list = new ValueList_6(values);
      if (IsStatic())
        return class_.InvokeStatic(this, list);   // let the class handle it
      return obj.Invoke(this, list);   // let the object handle it
    }

    Env_6 ^env = new Env_6(obj);
    Debug.Assert(values.Count == parameters_.Count);
    for (int i = 0 ; i < values.Count ; ++i)
      env.Add((Parameter_6) parameters_[i], (ValueOrLocation_6) values.Take(i));

    return Eval(env);
  }

  protected void EmitParameterNames(SourceWriter_6 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      w.Write(Param(i).EmitDeclarationName());
    }
    w.Write(")");
  }

  protected void EmitParameters(SourceWriter_6 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      Param(i).EmitDeclaration(w);
    }
    w.Write(") ");
  }

  void EmitAttributes(SourceWriter_6 w, bool declaration) {
    w.Indent();
    if (!IsStatic() && !IsVirtual())
      return;

    if (!declaration)
      w.Write("/* ");
    if (IsStatic())
      w.Write("static ");
    if (IsVirtual())
      w.Write("virtual ");
    if (!declaration)
      w.Write("*/ ");
  }

  void EmitSignature(SourceWriter_6 w, bool declaration) {
    EmitAttributes(w, declaration);
    w.Write("{0} ", type_.EmitReturnType());
    if (!declaration)
      w.Write("{0}::", class_.name_);
    if (HasAttribute(Attribute_6.Setter))
      w.Write("_");
    w.Write(name_);
    EmitParameters(w);
  }

  public virtual void EmitDeclaration(SourceWriter_6 w) {
    ComputeRefs();
    EmitSignature(w, true);
    if (body_.Absent())
      w.Write("= 0");
    w.WriteLine(";");

    if (HasAttribute(Attribute_6.Setter)) {
      w.WriteLine("");
      EmitAttributes(w, true);
      w.Write("{0} ", Param(parameters_.Count - 1).Type().EmitType());
      w.Write(name_);
      EmitParameters(w);
      w.OpenBrace();
      w.IWrite("_{0}", name_);
      EmitParameterNames(w);
      w.WriteLine(";");
      w.IWriteLine("return value;");
      w.CloseBrace();
    }
  }

  protected void EmitExtraDeclarations(SourceWriter_6 w) {
    foreach (Parameter_6 p in parameters_)
      p.EmitExtraDeclaration(w);
  }

  public virtual void Emit(SourceWriter_6 w) {
    if (!body_.Absent()) {
      EmitSignature(w, false);
      w.OpenBrace();
      EmitExtraDeclarations(w);
      body_.list_.Emit(w);
      w.CloseBrace();
      w.WriteLine("");
    }
    if (Gel_6.print_type_sets_)
      Console.WriteLine("{0}.{1}: {2}", class_.name_, name_, Destroys());
  }
}

class Constructor_6 : Method_6 {
  bool call_base_;
  ArrayList /* of Argument_6 */ ^initializer_params_;

  Constructor_6 initializer_;

  bool invoked_;  // true if another constructor invokes this one using : base() or : this()

  public Constructor_6(int attributes, string name, ArrayList ^parameters,
                     bool call_base, ArrayList ^initializer_params, Block_6 ^body)
    : base(attributes, null, name, parameters, body) {
    call_base_ = call_base;
    initializer_params_ = initializer_params;
  }

  public Constructor_6(int attributes, string name, ArrayList ^parameters, Block_6 ^body)
    : this(attributes, name, parameters, true, new ArrayList(), body) { }

  public override int Kind() { return MemberKind_6.Constructor_6; }

  protected override int ValidAttributes() {
    return Attribute_6.Private | Attribute_6.Protected | Attribute_6.Public;
  }

  public override bool Check(Context_6 ctx) {
    if (name_ != class_.name_) {
      Error("constructor name must match class name");
      return false;
    }
    return base.Check(ctx);
  }

  protected override bool CheckEntry(Context_6 ctx) {
    Class_6 c = call_base_ ? class_.Parent() : class_;
    if (c != null || initializer_params_.Count > 0) {
      initializer_ = (Constructor_6) Invocation_6.CheckInvoke(this, ctx, call_base_, c,
                                      c.name_, initializer_params_, MemberKind_6.Constructor_6);
      if (initializer_ == null)
        return false;
      if (initializer_ == this) {
        Error("constructor initializer invokes itself");
        return false;
      }
      initializer_.invoked_ = true;
    }
    return true;
  }

  // A Constructor_6 node in the control graph represents the call to the base constructor;
  // this node gets added when we call Invocation_6.CheckInvoke() above.
  public override Method_6 Calls() { return initializer_; }

  public override RValue_6 ^Eval(Env_6 env) {
    if (initializer_ == null || initializer_.class_ != class_) {
      // run instance variable initializers
      foreach (Field_6 f in class_.fields_)
        if (!f.IsConstOrStatic() && f.Initializer() != null)
          ((GObject_6) env.this_).Set(f, f.Initializer().Eval(Env_6.static_, f.Type()));
    }
    if (initializer_ != null)
      Invocation_6.CallMethod(env, env.this_, initializer_, initializer_params_, false);
    return body_.Eval(env);
  }

  void EmitInitializerArgs(SourceWriter_6 w) {
    w.WriteLine("({0});", Invocation_6.EmitArguments(initializer_, initializer_params_));
  }

  void EmitConstructorBody(SourceWriter_6 w) {
    w.OpenBrace();
    EmitExtraDeclarations(w);
    if (call_base_) {
      if (class_.constructors_.Count > 1)
        w.IWriteLine("_Init();");
      else class_.EmitInitializers(w);

      Class_6 parent = class_.Parent();
      if (parent != GObject_6.type_) {
        w.IWrite("{0}::_Construct", parent.name_);
        EmitInitializerArgs(w);
      }
    } else {
      w.IWrite("_Construct");
      EmitInitializerArgs(w);
    }

    body_.list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitDeclaration(SourceWriter_6 w) {
    ComputeRefs();

    // If_6 we're invoked by some other constructor then we need to declare a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void _Construct");
      EmitParameters(w);
      w.WriteLine(";");
    }

    // Now declare the actual C++ constructor.
    w.IWrite(name_);
    EmitParameters(w);
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_6 w) {
    // If_6 we're invoked by some other constructor then we need to emit a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void {0}::_Construct", name_);
      EmitParameters(w);
      EmitConstructorBody(w);
      w.WriteLine("");
    }

    // Now emit the actual C++ constructor.
    w.IWrite("{0}::{1}", name_, name_);
    EmitParameters(w);
    Class_6 parent = class_.Parent();
    if (parent != GObject_6.type_)
      w.Write(": {0}((Dummy *) 0) ", parent.name_);

    if (invoked_) {   // call the _Construct method we just generated
      w.Write("{ _Construct");
      EmitParameterNames(w);
      w.WriteLine("; }");
    } else EmitConstructorBody(w);
    w.WriteLine("");
  }
}

abstract class PropertyOrIndexer_6 : LMember_6 {
  // If_6 a get accessor is not declared at all, then get_block_ will be null; if it is
  // declared, but has an empty body ("get;") then get_block_ will be a Block_6 whose list_ is
  // null.  We need to distinguish these cases since for abstract or extern properties the
  // presence of a get accessor with an empty body indicates that a property is readable.
  // (set_block_ works similarly.)
  Block_6 ^get_block_, set_block_;

  protected Method_6 getter_, setter_;

  protected PropertyOrIndexer_6(int attributes, TypeExpr_6 ^type_expr, string name,
                              string id1, Block_6 ^block1, string id2, Block_6 ^block2)
    : base(attributes, type_expr, name) {
    StoreAccessor(id1, block1);
    if (id2 != null)
      StoreAccessor(id2, block2);
    if (id1 == id2)
      Error("can't have two {0} accessors", id1);
  }

  void StoreAccessor(string id, Block_6 ^block) {
    // Note that we don't have scanner tokens GET and SET since these are not keywords in GEL2.
    switch (id) {
      case "get": get_block_ = block; return;
      case "set": set_block_ = block; return;
    }
    Error("expected get or set");
  }

  public Method_6 Getter() { return getter_; }
  public Method_6 Setter() { return setter_; }

  protected abstract string BaseName();

  ArrayList ^CopyParameters() {
    ArrayList ^a = new ArrayList();
    foreach (Parameter_6 p in Parameters())
      a.Add(p.Copy());
    return a;
  }

  public override bool Check(Context_6 ctx) {
    if (!base.Check(ctx))
      return false;

    if (get_block_ != null) {
      Method_6 ^m = new Method_6(attributes_, new TypeLiteral_6(type_), "get_" + BaseName(), CopyParameters(), take get_block_);
      getter_ = m;
      class_.Add(m);
      if (!getter_.Resolve(ctx.program_) || !getter_.Check(ctx))
        return false;
    }

    if (set_block_ != null) {
      ArrayList ^set_params = CopyParameters();
      set_params.Add(new Parameter_6(new TypeLiteral_6(type_), "value"));
      Method_6 ^m = new Method_6(attributes_ | Attribute_6.Setter,
                           new TypeLiteral_6(Void_6.type_), "set_" + BaseName(), set_params, take set_block_);
      setter_ = m;
      class_.Add(m);
      if (!setter_.Resolve(ctx.program_) || !setter_.Check(ctx))
        return false;
    }

    return true;
  }

  public override bool CheckAssigning(Syntax_6 caller, Context_6 ctx, bool assigning) {
    if (assigning && set_block_ == null && setter_ == null) {
      caller.Error("can't assign to read-only {0}", KindString());
      return false;
    }
    if (!assigning && get_block_ == null && getter_ == null) {
      caller.Error("can't read from write-only {0}", KindString());
      return false;
    }
    return true;
  }

  public override Location_6 GetLocation(GObject_6 obj) { Debug.Assert(false); return null; }
}

class Property_6 : PropertyOrIndexer_6 {
  public Property_6(int attributes, TypeExpr_6 ^type_expr, string name,
                  string id1, Block_6 ^block1, string id2, Block_6 ^block2)
    : base(attributes, type_expr, name, id1, block1, id2, block2) { }

  public override int Kind() { return MemberKind_6.Property_6; }

  protected override int ValidAttributes() {
    return Method_6.kValidAttributes;
  }

  protected override string BaseName() { return name_; }

  public override RValue_6 ^Get(GValue_6 obj) {
    return Invocation_6.InvokeMethod(obj, getter_, new ArrayList(), true);
  }

  public override void Set(GObject_6 obj, RValue_6 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(val);
    Invocation_6.InvokeMethod(obj, setter_, a, true);
  }

  public override string Emit() {
    return String.Format("get_{0}()", name_);
  }

  public override string EmitSet(string val) {
    return String.Format("set_{0}({1})", name_, val);
  }
}

class Indexer_6 : PropertyOrIndexer_6 {
  public readonly Parameter_6 parameter_;

  ArrayList /* of Parameter_6 */ ^parameters_;

  public Indexer_6(int attributes, TypeExpr_6 ^type_expr, Parameter_6 ^parameter,
                 string id1, Block_6 ^block1, string id2, Block_6 ^block2)
    : base(attributes, type_expr, null, id1, block1, id2, block2) {
    parameter_ = parameter;

    parameters_ = new ArrayList();
    parameters_.Add(parameter);
  }

  public override int Kind() { return MemberKind_6.Indexer_6; }

  public override bool Resolve(Program_6 program) {
    return base.Resolve(program) && parameter_.Resolve(program);
  }

  protected override int ValidAttributes() {
    return Attribute_6.Abstract | Attribute_6.Override |
    Attribute_6.Private | Attribute_6.Protected | Attribute_6.Public | Attribute_6.Virtual;
  }

  protected override string BaseName() { return "Item"; }

  public override bool Check(Context_6 ctx) {
    if (parameter_ is RefOutParameter_6) {
      Error("indexer parameter may not be ref or out");
      return false;
    }

    return base.Check(ctx);
  }

  public override ArrayList /* of Parameter_6 */ Parameters() {
    return parameters_; 
  }

  public RValue_6 ^Get(GValue_6 obj, RValue_6 ^index) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    return Invocation_6.InvokeMethod(obj, getter_, a, true);
  }

  public void Set(GObject_6 obj, RValue_6 ^index, RValue_6 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    a.Add(val);
    Invocation_6.InvokeMethod(obj, setter_, a, true);
  }
}

class Class_6 : Ownable_6 {
  Syntax_6 ^syntax_ = new Syntax_6();
  Program_6 program_;   // containing program
  int attributes_;
  public readonly string name_;
  string parent_name_;    // or null if not specified

  Class_6 parent_;

  public readonly NonOwningArrayList /* of Field_6 */ ^fields_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Method_6 */ ^methods_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Property_6 */ ^properties_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Indexer_6 */ ^indexers_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Constructor_6 */ ^constructors_ = new NonOwningArrayList();

  public readonly ArrayList /* of Member_6 */ ^members_ = new ArrayList();

  public readonly ArrayList /* of Temporaries_6 */ ^temporaries_ = new ArrayList();

  public readonly NonOwningArrayList /* of Class_6 */ ^subclasses_ = new NonOwningArrayList();
  bool emitted_;

  // If_6 virtual_ is true, then this class needs a vtable; we set this for a class C
  // in any of the following cases:
  // - the program converts some type T to C ^ (for then a C ^ may hold a T, and when
  // the owning pointer is destroyed we need to know which destructor to call)
  // - the program explicitly converts from C to some other type (so we need RTTI for C)
  bool virtual_;
  
  // If_6 object_inherit_ is true, then this class must derive from Object in generated C++
  // code; we set this for a class C in any of the following cases:
  // - a member lookup in C yields a member in Object
  // - the program converts from C to Object or from Object to C
  // - the class is used in a generic context, i.e. in the type C [] or C ^ [].  All such types
  //   use the generic compiled classes Array<Object> / Array<_Own<Object>>, and so in this case we need
  //   to be able to cast between C and Object.
  //
  // If_6 object_inherit_ is true then this class and all its superclasses will have vtables since
  // the C++ Object class has a vtable.
  bool object_inherit_;

  bool need_destroy_;  // true if we need to emit _Destroy methods for this class

  // The set of types which may be destroyed when an instance of this class is destroyed.
  TypeSet_6 ^destroys_;

  // A marker used in performing a depth-first search to construct the destroys_ type set.
  int marker_;

  protected Class_6(string name) { name_ = name; }

  public static Class_6 New_6(int attributes, string name, string parent_name) {
    Class_6 c = Internal_6.Find(name);
    if (c == null) {
      Class_6 ^c1 = new Class_6(name);
      c = c1;
      Gel_6.program_.AddOwn(c1);
    }

    c.attributes_ = attributes;
    c.parent_name_ = parent_name;

    return c;
  }

  public override bool IsOwned() { return true; }

  public Program_6 GetProgram() { return program_; }
  public void SetProgram(Program_6 p) { program_ = p; }

  public bool IsExtern() { return HasAttribute(Attribute_6.Extern); }

  public override Class_6 Parent() { return parent_; }

  public override string ToString() { return name_; }

  public override ArrayList Members() { return members_; }

  public override SimpleValue_6 DefaultValue_6() { return Null_6.Instance; }

  public override void SetVirtual() { virtual_ = true; }
  public override void SetObjectInherit() { object_inherit_ = true;  }
  public void NeedDestroy() { need_destroy_ = true; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public virtual GValue_6 ^New_6() { return new GObject_6(this); }
  public virtual RValue_6 ^InvokeStatic(Method_6 m, ValueList_6 args) { Debug.Assert(false); return null; }

  public void Add(Field_6 ^f) { f.SetClass(this); fields_.Add(f); members_.Add(f);  }

  public virtual void Add(Method_6 ^m) { m.SetClass(this); methods_.Add(m); members_.Add(m);  }

  public void Add(Property_6 ^p) { p.SetClass(this); properties_.Add(p); members_.Add(p);  }

  public void Add(Indexer_6 ^i) { i.SetClass(this); indexers_.Add(i); members_.Add(i); }

  public void AddConstructor(Constructor_6 ^c) { c.SetClass(this); constructors_.Add(c); members_.Add(c);  }

  public NonOwningArrayList /* of Member_6 */ ^FindAbstractMembers() {
    NonOwningArrayList /* of Member_6 */ ^a;
    if (parent_ != null)  {
      a = parent_.FindAbstractMembers();

      // remove members overridden in this class
      int i = 0;
      while (i < a.Count) {
        Member_6 m = (Member_6) a[i];
        Member_6 n = GetMatchingMember(m);
        if (n != null) {
          Debug.Assert(n.HasAttribute(Attribute_6.Abstract | Attribute_6.Override));
          a.RemoveAt(i);
        } else ++i;
      }
    } else a = new NonOwningArrayList();

    // add abstract members from this class
    foreach (Member_6 m in members_) {
      if (m.HasAttribute(Attribute_6.Abstract))
        a.Add(m);
    }

    return a;
  }

  public bool ResolveAll(Program_6 program) {
    if (parent_name_ != null) {
      parent_ = program.FindClass(parent_name_);
      if (parent_ == null) {
        syntax_.Error("can't find parent class {0}", parent_name_);
        return false;
      }
    } else if (this == GObject_6.type_)
      parent_ = null;
    else parent_ = GObject_6.type_;
    if (parent_ != null)
      parent_.subclasses_.Add(this);

    foreach (Member_6 m in members_)
      if (!m.Resolve(program))
        return false;

    if (!IsExtern() && constructors_.Count == 0)
      // add a default constructor
      AddConstructor(new Constructor_6(Attribute_6.Public, name_, new ArrayList(), Block_6.EmptyBlock()));

    return true;
  }

  // In our first checking pass we check all constant fields since we may need to evaluate them
  // in the course of checking other code.
  public bool Check1(Context_6 prev_ctx) {
    if (!AttributeUtil_6.CheckOnly(attributes_,
         Attribute_6.Abstract | Attribute_6.Extern | Attribute_6.Public)) {
      syntax_.Error("illegal class attribute");
      return false;
    }

    if (prev_ctx.program_.FindClass(name_) != this) {
      syntax_.Error("can't have two classes named {0}", name_);
      return false;
    }

    Context_6 ^ctx = new Context_6(prev_ctx, this);
    bool ok = true;
    foreach (Field_6 f in fields_) {
      ConstField_6 cf = f as ConstField_6;
      if (cf != null)
        ok &= cf.Check(ctx);
    }
    return ok;
  }

  public bool Check(Context_6 prev_ctx) {
    Context_6 ^ctx = new Context_6(prev_ctx, this);

    bool ok = true;

    foreach (Member_6 m in members_)
      if (m is Field_6 && !(m is ConstField_6) || m is Method_6)
        ok &= m.Check(ctx);

    // We need to check properties and indexers separately since they add methods to the members_
    // array as they are checked.
    foreach (Property_6 p in properties_)
      ok &= p.Check(ctx);
    foreach (Indexer_6 i in indexers_)
      ok &= i.Check(ctx);

    if (!HasAttribute(Attribute_6.Abstract)) {
      NonOwningArrayList ^a = FindAbstractMembers();
      if (a.Count > 0) {
        foreach (Member_6 m in a)
          syntax_.Error("class does not define inherited abstract {0} {1}", m.KindString(), m.name_);
        ok = false;
      }
    }

    return ok;
  }

  public void GetMainMethod(NonOwningArrayList /* of Method_6 */ result) {
    foreach (Method_6 m in methods_)
      if (m.name_ == "Main" && m.IsPublic() && m.IsStatic() && m.ReturnType() == Void_6.type_) {
        int c = m.parameters_.Count;
        if (c > 1)
          continue;
        if (c == 1) {
          Parameter_6 p = m.Param(0);
          if (p.GetMode() != 0 || !p.Type().Equals(new ArrayType_6(GString_6.type_)) )
            continue;
        }
        result.Add(m);
      }
  }

  public override void FindTypeDestroys(int marker, TypeSet_6 set) {
    if (marker_ == marker)
      return;
    marker_ = marker;
    set.Add(this);
    for (Class_6 c = this; c != null; c = c.parent_) {
      if (c != this && c.marker_ == marker)
        break;
      foreach (Field_6 f in c.fields_)
        if (!f.IsConstOrStatic())
          f.Type().FindVarDestroys(marker, set);
    }
    foreach (Class_6 c in subclasses_)
      c.FindTypeDestroys(marker, set);
  }

  public override TypeSet_6 TypeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_6();
      FindTypeDestroys(Control_6.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  public Temporaries_6 NewTemporaries() {
    Temporaries_6 ^t = new Temporaries_6();
    Temporaries_6 ret = t;
    temporaries_.Add(t);
    return ret;
  }

  public void StaticInit() {
    foreach (Field_6 f in fields_) {
      StaticField_6 sf = f as StaticField_6;
      if (sf != null)
        sf.Init();
    }
  }

  public override string EmitTypeName() { return name_; }

  int EmitAccess(SourceWriter_6 w, int old_access, int new_access) {
    new_access = (new_access & Attribute_6.Public) != 0 ? Attribute_6.Public : Attribute_6.Protected;

    if (new_access != old_access) {
      switch (new_access) {
        case Attribute_6.Protected:
          w.Indent(-1);
          w.WriteLine("protected:");
          break;
        case Attribute_6.Public:
          w.Indent(-1);
          w.WriteLine("public:");
          break;
        default:
          Debug.Assert(false);
          break;
      }
    }

    return new_access;
  }

  public void EmitInitializers(SourceWriter_6 w) {
    foreach (Field_6 f in fields_)
      if (!f.IsConstOrStatic())
        f.EmitInitializer(w);
  }

  // Return_6 true if this top-level class must inherit from Object.
  bool ObjectInherit() {
    if (object_inherit_)
      return true;
    foreach (Class_6 c in subclasses_)
      if (c.ObjectInherit())
        return true;
    return false;
  }

  public void EmitDeclaration(SourceWriter_6 w) {
    if (emitted_ || IsExtern())
      return;

    // C++ requires a parent class to appear before its subclasses in a source file.
    parent_.EmitDeclaration(w);

    emitted_ = true;

    w.Write("class {0} ", name_);
    if (parent_ != null)
      w.Write(": public {0} ",
              parent_ == GObject_6.type_ && !ObjectInherit() ? "_Object" : parent_.name_);
    w.OpenBrace();

    int access = 0;

    if (fields_.Count > 0) {
      foreach (Field_6 f in fields_) {
        access = EmitAccess(w, access, f.attributes_);
        f.EmitDeclaration(w);
      }
      w.WriteLine("");
    }

    if (subclasses_.Count > 0) {
      access = EmitAccess(w, access, Attribute_6.Protected);
      w.IWrite("{0}(Dummy *dummy) ", name_);
      if (parent_ != GObject_6.type_)
        w.Write(": {0}(dummy) ", parent_.name_);
      w.WriteLine("{ }");
      w.WriteLine("");
    }

    // If_6 we have more than one constructor, emit an _Init() method which constructors can
    // call to initialize instance variables.
    if (constructors_.Count > 1) {
      access = EmitAccess(w, access, Attribute_6.Protected);
      w.IWriteLine("void _Init();");
      w.WriteLine("");
    }

    foreach (Constructor_6 c in constructors_) {
      access = EmitAccess(w, access, c.attributes_);
      c.EmitDeclaration(w);
    }

    if (virtual_) {
      access = EmitAccess(w, access, Attribute_6.Public);
      w.IWrite("virtual ~{0}()", name_);
      w.WriteLine(" { }");
      w.WriteLine("");
    }

    if (need_destroy_) {
      access = EmitAccess(w, access, Attribute_6.Public);
      w.IWriteLine("GEL_OBJECT({0})", name_);
      w.WriteLine("");
    }

    foreach (Method_6 m in methods_) {
      access = EmitAccess(w, access, m.attributes_);
      m.EmitDeclaration(w);
    }

    w.SubIndent();
    w.WriteLine("};");
    w.WriteLine("");
  }

  public void Emit(SourceWriter_6 w) {
    if (IsExtern())
      return;

    if (fields_.Count > 0) {
      foreach (Field_6 f in fields_)
        f.Emit(w);
      w.WriteLine("");
    }

    if (constructors_.Count > 1) {
      w.IWrite("void {0}::_Init() ", name_);
      w.OpenBrace();
      EmitInitializers(w);
      w.CloseBrace();
      w.WriteLine("");
    }

    foreach (Constructor_6 c in constructors_)
      c.Emit(w);

    foreach (Method_6 m in methods_)
      m.Emit(w);

    if (Gel_6.print_type_sets_)
      Console.WriteLine("~{0}: {1}", name_, TypeDestroys());
  }
}

class ClassPtr_6 {
  public readonly Class_6 class_;

  public ClassPtr_6(Class_6 c) { class_ = c; }
}

class ValueList_6 {
  public ArrayList list_;
  public ValueList_6(ArrayList list) { list_ = list; }

  public GValue_6 Object(int i) { return ((RValue_6) list_[i]).Get(); }
  public bool Bool(int i) { return ((GBool_6) list_[i]).b_; }
  public int Int(int i) { return ((GInt_6) list_[i]).i_; }
  public char Char(int i) { return ((GChar_6) list_[i]).c_; }
  public string GetString(int i) { return ((GString_6) list_[i]).s_; }
}

class Internal_6 : Class_6 {
  static NonOwningArrayList /* of Internal_6 */ ^all_ = new NonOwningArrayList();

  protected Internal_6(string name) : base(name) { }

  public static Internal_6 Find(string name) {
    foreach (Internal_6 p in all_)
      if (p.name_ == name)
        return p;
    return null;
  }

  static void Add(Internal_6 p) { all_.Add(p); }

  public static void Init() {
    Add(GObject_6.type_);
    Add(GArray_6.array_class_);
    Add(GBool_6.type_);
    Add(GChar_6.type_);
    Add(GDouble_6.type_);
    Add(GFloat_6.type_);
    Add(GInt_6.type_);
    Add(GString_6.type_);
    Add(GStringBuilder_6.type_);
    Add(PoolClass_6.instance_);
    Add(DebugClass_6.instance_);
    Add(EnvironmentClass_6.instance_);

    Add(ConsoleClass_6.instance_);
    Add(FileClass_6.instance_);
    Add(PathClass_6.instance_);
    Add(GStreamReader_6.type_);
  }
}

class ObjectClass_6 : Internal_6 {
  public Method_6 equals_;
  public Method_6 get_hash_code_;
  public Method_6 to_string_;

  public ObjectClass_6() : base("Object") { }

  public override void Add(Method_6 ^m) {
    switch (m.name_) {
      case "Equals": equals_ = m; break;
      case "GetHashCode": get_hash_code_ = m; break;
      case "ToString": to_string_ = m; break;
    }
    base.Add(m);
  }
}

class ArrayClass_6 : Internal_6 {
  public ArrayClass_6() : base("Array") { }
}

abstract class SimpleType_6 : Internal_6 {
  protected SimpleType_6(string name) : base(name) { }

  public override bool IsOwned() { return false; }
  public override bool IsReference() { return false; }
  public override bool IsValue() { return true; }

  public override string EmitExprType() { return EmitType(); }
  public override string EmitType() { Debug.Assert(false); return null; }
}

abstract class IntegralType_6 : SimpleType_6 {
  protected IntegralType_6(string name) : base(name) { }
}

class BoolClass_6 : IntegralType_6 {
  public BoolClass_6() : base("Bool") { }

  static GBool_6 ^default_ = new GBool_6(false);
  public override SimpleValue_6 DefaultValue_6() { return default_; }

  public override string ToString() { return "bool"; }

  public override string EmitType() { return "bool"; }
}

class CharClass_6 : IntegralType_6 {
  public CharClass_6() : base("Char") { }

  static GChar_6 ^default_ = new GChar_6('\0');

  public override SimpleValue_6 DefaultValue_6() { return default_; }

  public override bool CanConvert1(GType_6 t) { return t == GInt_6.type_; }

  public override string ToString() { return "char"; }

  public override RValue_6 ^InvokeStatic(Method_6 m, ValueList_6 args) {
    switch (m.name_) {
      case "IsDigit": return new GBool_6(Char.IsDigit(args.Char(0)));
      case "IsLetter": return new GBool_6(Char.IsLetter(args.Char(0)));
      case "IsWhiteSpace": return new GBool_6(Char.IsWhiteSpace(args.Char(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "wchar_t"; }
}

class IntClass_6 : IntegralType_6 {
  public IntClass_6() : base("Int") { }

  static GInt_6 ^default_ = new GInt_6(0);

  public override SimpleValue_6 DefaultValue_6() { return default_; }

  public override bool CanConvert1(GType_6 t) {
    return t == GFloat_6.type_ || t == GDouble_6.type_;
  }

  protected override bool CanConvertExplicit1(GType_6 t) {
    return t == GChar_6.type_;
  }

  public override string ToString() { return "int"; }

  public override RValue_6 ^InvokeStatic(Method_6 m, ValueList_6 args) {
    switch (m.name_) {
      case "Parse": return new GInt_6(int.Parse(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "int"; }
}

class FloatClass_6 : SimpleType_6 {
  public FloatClass_6() : base("Single") { }

  static GFloat_6 ^default_ = new GFloat_6(0.0f);

  public override SimpleValue_6 DefaultValue_6() { return default_; }

  public override bool CanConvert1(GType_6 t) {
    return t == GDouble_6.type_;
  }

  protected override bool CanConvertExplicit1(GType_6 t) {
    return t == GInt_6.type_;
  }

  public override string ToString() { return "float"; }

  public override string EmitType() { return "float"; }
}

class DoubleClass_6 : SimpleType_6 {
  public DoubleClass_6() : base("Double") { }

  static GDouble_6 ^default_ = new GDouble_6(0.0d);

  public override SimpleValue_6 DefaultValue_6() { return default_; }

  protected override bool CanConvertExplicit1(GType_6 t) {
    return t == GInt_6.type_ || t == GFloat_6.type_;
  }

  public override string ToString() { return "double"; }

  public override string EmitType() { return "double"; }
}

class StringClass_6 : Internal_6 {
  public StringClass_6() : base("String") { }

  public override bool IsOwned() { return false; }
  public override bool IsValue() { return true; }

  public override string ToString() { return "string"; }

  public override string EmitType() {
    return "_Ref<String>";
  }

  public override string EmitReturnType() {
    return EmitType();
  }

  public override string EmitGenericType() {
    return EmitType();
  }

  public override RValue_6 ^InvokeStatic(Method_6 m, ValueList_6 args) {
    switch (m.name_) {
      case "Format": return new GString_6(String.Format(args.GetString(0), args.Object(1)));
      default: Debug.Assert(false); return null;
    }
  }
}

class StringBuilderClass_6 : Internal_6 {
  public StringBuilderClass_6() : base("StringBuilder") { }
  public override GValue_6 ^New_6() { return new GStringBuilder_6(); }
}

class GStringBuilder_6 : GValue_6 {
  readonly StringBuilder ^b_ = new StringBuilder();

  public static readonly StringBuilderClass_6 ^type_ = new StringBuilderClass_6();

  public override GType_6 Type() { return type_; }

  public override RValue_6 ^Invoke(Method_6 m, ValueList_6 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "Append": b_.Append(args.Char(0)); return null;
      case "ToString": return new GString_6(b_.ToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class PoolClass_6 : Internal_6 {
  public PoolClass_6() : base("Pool") { }

  public static PoolClass_6 ^instance_ = new PoolClass_6();
}

class DebugClass_6 : Internal_6 {
  public DebugClass_6() : base("Debug") { }
  public static readonly DebugClass_6 ^instance_ = new DebugClass_6();
  
  public override RValue_6 ^InvokeStatic(Method_6 m, ValueList_6 args) {
    switch (m.name_) {
      case "Assert": Debug.Assert(args.Bool(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

class EnvironmentClass_6 : Internal_6 {
  public EnvironmentClass_6() : base("Environment") { }
  public static readonly EnvironmentClass_6 ^instance_ = new EnvironmentClass_6();

  public override RValue_6 ^InvokeStatic(Method_6 m, ValueList_6 args) {
    switch (m.name_) {
      case "Exit": Environment.Exit(args.Int(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

// built-in I/O classes

class ConsoleClass_6 : Internal_6 {
  public ConsoleClass_6() : base("Console") { }

  public override RValue_6 ^InvokeStatic(Method_6 m, ValueList_6 args) {
    switch (m.name_) {
      case "Write":
        switch (m.parameters_.Count) {
          case 1: Console.Write(args.Object(0)); return null;
          case 2: Console.Write(args.GetString(0), args.Object(1)); return null;
          case 3: Console.Write(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      case "WriteLine":
        switch (m.parameters_.Count) {
          case 1: Console.WriteLine(args.Object(0)); return null;
          case 2: Console.WriteLine(args.GetString(0), args.Object(1)); return null;
          case 3: Console.WriteLine(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly ConsoleClass_6 ^instance_ = new ConsoleClass_6();
}

class FileClass_6 : Internal_6 {
  public FileClass_6() : base("File") { }

  public override RValue_6 ^InvokeStatic(Method_6 m, ValueList_6 args) {
    switch (m.name_) {
      case "Delete": File.Delete(args.GetString(0)); return null;
      case "Exists": return new GBool_6(File.Exists(args.ToString()));
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly FileClass_6 ^instance_ = new FileClass_6();
}

class PathClass_6 : Internal_6 {
  public PathClass_6() : base("Path") { }

  public override RValue_6 ^InvokeStatic(Method_6 m, ValueList_6 args) {
    switch (m.name_) {
      case "GetTempFileName": return new GString_6(Path.GetTempFileName());
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly PathClass_6 ^instance_ = new PathClass_6();
}

class StreamReaderClass_6 : Internal_6 {
  public StreamReaderClass_6() : base("StreamReader") { }
  public override GValue_6 ^New_6() { return new GStreamReader_6(); }
}

class GStreamReader_6 : GValue_6 {
  StreamReader ^reader_;

  public static readonly StreamReaderClass_6 ^type_ = new StreamReaderClass_6();

  public override GType_6 Type() { return type_; }

  public override RValue_6 ^Invoke(Method_6 m, ValueList_6 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StreamReader": reader_ = new StreamReader(args.GetString(0)); return null;
      case "Read": return new GInt_6(reader_.Read());
      case "Peek": return new GInt_6(reader_.Peek());
      default: Debug.Assert(false); return null;
    }
  }
}

class Program_6 {
  ArrayList /* of string */ ^gel_import_ = new ArrayList();
  ArrayList /* of string */ ^cpp_import_ = new ArrayList();

  static Scanner_6 ^scanner_;

  NonOwningArrayList ^classes_ = new NonOwningArrayList();
  ArrayList ^own_classes_ = new ArrayList();

  public bool crt_alloc_;
  public bool debug_;
  public bool safe_ = true;

  public Control_6 prev_;   // previous node in control flow graph, used during graph construction

  public void Import(string s) {
    ArrayList a = null;
    string extension = Path.GetExtension(s);
    switch (extension) {
      case ".gel": a = gel_import_; break;
      case ".cpp": a = cpp_import_; break;
      default:
        new Syntax_6().Error("can't import file with extension {0}", extension);
        Environment.Exit(0);
        break;
    }
    foreach (string i in a)
      if (i == s)
        return;   // already imported
    a.Add(s);
  }

  public void FindAndImport(string s) {
    // First look relative to the importing file.
    string dir = Path.GetDirectoryName(Gel_6.CurrentFile());
    string s1 = Path.Combine(dir, s);
    if (!File.Exists(s1)) {
      // Now look relative to the GEL2 directory.
      s1 = Path.Combine(Gel_6.gel_directory_, s);
      if (!File.Exists(s1)) {
        new Syntax_6().Error("import not found: ", s);
        Environment.Exit(0);
      }
    }
    Import(s1);
  }
  
  public void Add(Class_6 c) {
    c.SetProgram(this);
    classes_.Add(c);
  }

  public void AddOwn(Class_6 ^c) {
    own_classes_.Add(c);
  }

  public Class_6 FindClass(string name) {
    foreach (Class_6 c in classes_)
      if (c.name_ == name)
        return c;
    return null;
  }

  public string CurrentFile() {
    return scanner_.filename_;
  }

  public int Line() {
    return scanner_.Line();
  }

  string Builtin(string module) {
    string file = String.Format("{0}.gel", module);
    return Path.Combine(Gel_6.gel_directory_, file);
  }

  public bool Parse() {
    Parser ^parser = new Parser();
    for (int i = 0; i < gel_import_.Count; ++i) {
      string file = (string) gel_import_[i];
      scanner_ = new Scanner_6(file);
      parser.yyParse(scanner_);
      if (i == 0) {
        Import(Builtin("internal"));
        Import(Builtin("library"));
      }
    }
    return true;
  }

  public bool Resolve() {
    foreach (Class_6 c in classes_)
      if (!c.ResolveAll(this))
        return false;

    return true;
  }

  public bool Check() {
    Context_6 ^ctx = new Context_6(this);
    bool ok = true;

    // Make a first checking pass where we check only constant fields.
    foreach (Class_6 c in classes_)
      ok &= c.Check1(ctx);

    foreach (Class_6 c in classes_)
      ok &= c.Check(ctx);

    return ok;
  }

  Method_6 FindMain() {
    NonOwningArrayList ^methods = new NonOwningArrayList();
    foreach (Class_6 c in classes_) {
      c.GetMainMethod(methods);
    }
    if (methods.Count == 0) {
      Console.WriteLine("no Main() method found");
      return null;
    }
    if (methods.Count > 1) {
      Console.WriteLine("error: found more than one Main() method");
      return null;
    }
    return (Method_6) methods[0];
  }

  public void Eval(ArrayList /* of string */ args) {
    Method_6 m = FindMain();
    if (m == null)
      return;
    ArrayList ^a = new ArrayList();
    if (m.parameters_.Count > 0) {   // Main() takes a string[] argument
      GArray_6 ^arr = new GArray_6(new ArrayType_6(GString_6.type_), args.Count);
      for (int i = 0 ; i < args.Count ; ++i)
        arr.Set(i, new GString_6((string) args[i]));
      a.Add(arr);
    }
    foreach (Class_6 c in classes_)
      c.StaticInit();
    m.Invoke(null, a);
  }

  void EmitMain(SourceWriter_6 w, Method_6 main) {
    bool args = main.parameters_.Count > 0;
    w.Write("int main({0}) ", args ? "int argc, char *argv[]" : "");
    w.OpenBrace();
    w.IWriteLine("return gel_runmain({0}::Main{1});", main.GetClass().name_, args ? ", argc, argv" : "");
    w.CloseBrace();
  }

  public bool Emit(SourceWriter_6 w) {
    Method_6 main = FindMain();
    if (main == null)
      return false;

    w.WriteLine("#define MEMORY_OWN 1");
    if (safe_)
      w.WriteLine("#define MEMORY_SAFE 1");
    if (crt_alloc_)
      w.WriteLine("#define MEMORY_CRT 1");

    foreach (string f in cpp_import_)
      w.WriteLine("#include {0}", GString_6.EmitString(f));

    // We undefine NULL since Gel_6 code may legitimately define fields or variables with that name.
    // Generated code uses 0, not NULL, to indicate the null pointer.
    w.WriteLine("#undef NULL");

    w.WriteLine("");

    // Forward-declare all classes since C++ requires a class to be declared before its name can
    // be used as a type.
    foreach (Class_6 c in classes_)
      if (!(c.HasAttribute(Attribute_6.Extern)))
        w.WriteLine("class {0};", c.name_);
    w.WriteLine("");

    foreach (Class_6 c in classes_)
      c.EmitDeclaration(w);

    foreach (Class_6 c in classes_)
      c.Emit(w);

    EmitMain(w, main);
    return true;
  }

  // Emit C++ code.
  public bool Generate(string basename) {
    string cpp_file = basename + ".cpp";
    StreamWriter ^w = new StreamWriter(cpp_file);
    bool ok = Emit(new SourceWriter_6(w));
    w.Close();
    return ok;
  }

  static string[] ^vsdirs = { "Microsoft Visual Studio 8",
                            "Microsoft Visual Studio .NET 2003",
                            "Microsoft Visual Studio .NET 2002" };

  string VsVars(int i) {
    return String.Format("C:\\Program_6 Files\\{0}\\Common7\\Tools\\vsvars32.bat", vsdirs[i]);
  }

  string FindVsVars() {
    for (int i = 0; i < vsdirs.Length; ++i) {
      string f = VsVars(i);
      if (File.Exists(f))
        return f;
    }

    Console.WriteLine("Error: unable to find vsvars32.bat at any of the following locations:");
    Console.WriteLine("");
    for (int i = 0; i < vsdirs.Length; ++i)
      Console.WriteLine(VsVars(i));
    Console.WriteLine("");
    Console.WriteLine("Your Visual Studio installation may be invalid.  Aborting compilation.");
    return null;
  }

  // Report compilation error. Print error message from a file
  void ReportCompilationError(string error_msg_file) {
      Console.WriteLine(
        "Error: unable to compile generated C++ code.  You may have found a bug in the GEL2 compiler.");
      Console.WriteLine("C++ compiler output follows:");
      Console.WriteLine("");
      Console.WriteLine((new StreamReader(error_msg_file)).ReadToEnd());
  }

  void UnixCppCompile(string basename) {
    string command_out = Path.GetTempFileName();
    string dbg_options = debug_ ? "-g -DDEBUG" : "-O2 -DNDEBUG";
    StringBuilder ^sb = new StringBuilder();
    // -o basename, use basename as the executable name
    // -Werror, make all warnings into hard errors
    sb.AppendFormat("/usr/bin/g++ -o {0} -Werror {1} {2}.cpp",
                    basename, dbg_options, basename);

    // Append redirection of output
    sb.AppendFormat(" > {0} 2>&1", command_out);
 
    string sh_cmd = sb.ToString();

    if (Gel_6.verbose_) 
      Console.WriteLine(sh_cmd);
  
    if (Process.System(sh_cmd) !=0) {
      ReportCompilationError(command_out);
    }
    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".o");
  }

  // Run vsvars32.bat and the run the given command, redirecting output to a file.
  // We must always redirect output since vsvars32 prints a message "Setting environment..."
  // which we don't want users to see.
  int VsRun(string vsvars, string command, string output) {
    command = String.Format("(\"{0}\" & {1}) > \"{2}\"", 
                            vsvars, command, output);
    return Process.System(command);
  }

  void VsCppCompile(string basename) {
    string vsvars = FindVsVars();
    if (vsvars == null)
      return;
    string command_out = Path.GetTempFileName();

    string options = debug_ ?
      //  /MDd - runtime library: multithreaded debug DLL
      //  /Od - optimization: disabled
      //  /ZI - debug information format: Program_6 Database for Edit & Continue_6
      "/MDd /Od /ZI /D \"_DEBUG\"" :

      //  /MD - runtime library: multithreaded DLL
      //  /O2 - optimization: Maximize Speed
      //  /GL - optimization: Whole Program_6 Optimization
      "/MD /O2 /GL /D \"NDEBUG\"";

    StringBuilder ^sb = new StringBuilder();
    //  /WX - treat warnings as errors
    sb.AppendFormat("cl /nologo /WX {0} {1}.cpp", options, basename);
    string mode = debug_ ? "debug" : "release";
    if (!crt_alloc_)
      sb.AppendFormat(" {0}\\{1}\\dlmalloc.obj", Gel_6.gel_directory_, mode);
    sb.Append(" user32.lib shell32.lib shlwapi.lib");
    string command = sb.ToString();
    if (Gel_6.verbose_)
      Console.WriteLine(command);

    if (VsRun(vsvars, command, command_out) != 0) {
      ReportCompilationError(command_out);
    } else {
      // Run the manifest tool to embed the linker-generated manifest into the executable file;
      // this allows the executable to find the C runtime DLL even when the manifest file is absent.
      string mt_command = String.Format("mt -nologo -manifest {0}.exe.manifest -outputresource:\"{0}.exe;#1\"",
                              basename);
      if (Gel_6.verbose_)
        Console.WriteLine(mt_command);
      if (VsRun(vsvars, mt_command, command_out) != 0)
        Console.WriteLine("warning: could not run manifest tool");
    }

    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".obj");
    File.Delete(basename + ".exe.manifest");
  }

  // Invoke the C++ compiler to generate a native executable.
  void CppCompile(string basename) {
    if (Environment.OSVersion.Platform == PlatformID.Win32NT) 
      VsCppCompile(basename);
    else
      UnixCppCompile(basename);
  }

  public void Compile(string output, bool cpp_only) {
    if (output == null)
      output = Path.GetFileNameWithoutExtension((string) gel_import_[0]);
    if (Generate(output) && !cpp_only)
      CppCompile(output);
  }
}

class Scanner_6 : yyInput {
  public readonly string filename_;

  int line_;
  public int Line() { return line_; }

  StreamReader ^sr_;
  int token_;
  object ^ value_;

  int next_token_ = -1;
  object ^ next_value_;

  public Scanner_6 (string filename) {
    filename_ = filename;
    sr_ = new StreamReader(filename);
    line_ = 1;
  }

  public override int GetToken () {
    return token_;
  }

  public override object ^ GetValue () {
    return take value_;
  }

  int Read() {
    int i = sr_.Read();
    if (i == '\n')
      ++line_;
    return i;
  }

  bool Read(out char c) {
    int i = Read();
    c = (char) i;
    return i != -1;
  }

  char Peek() {
    return (char) sr_.Peek();
  }

  string ReadWord(char first) {
    StringBuilder ^sb = new StringBuilder();
    if (first != '\0')
      sb.Append(first);
    while (true) {
      char c = Peek();
      if (!Char.IsLetter(c) && !Char.IsDigit(c) && c != '_')
        break;
      sb.Append(c);
      Read();
    }
    return sb.ToString();
  }

  // Read to the end of the current line.
  string ReadLine() {
    StringBuilder ^sb = new StringBuilder();
    char c;
    while (Read(out c)) {
      if (c == '\n')
        break;
      sb.Append(c);
    }
    return sb.ToString();
  }

  // Read a comment delimited by /* ... */, assuming we've already read the opening /*.
  // Returns true on success, or false on EOF.
  bool ReadDelimitedComment() {
    char prev = (char) 0;
    while (true) {
      char c;
      if (!Read(out c)) {
        Console.WriteLine("warning: unterminated comment at end of file");
        return false;
      }
      if (c == '/' && prev == '*')
        return true;
      prev = c;
    }
  }

  // Preprocess input, handling whitespace, comments and directives; return the first
  // character not eaten by preprocessing, or -1 on EOF.
  int GetChar() {
    while (true) {
      int i = Read();
      if (i == -1)
        return -1;   // end of input
      if (i == 0)
        continue;   // end of this file; move on
      char c = (char) i;

      if (c == '\n' && Peek() == '#') {
        Read();
        string directive = ReadWord('\0');
        if (directive == "line") {
          ReadLine();
          continue;
        }
        Console.WriteLine("error: unknown preprocessing directive {0}", directive);
        Environment.Exit(0);
      }

      if (Char.IsWhiteSpace(c))
        continue;

      if (c == '/') {
        switch (Peek()) {
          case '/':  // single-line comment
            Read();
            int line = line_;
            string s = ReadLine();
            if (Gel_6.error_test_ && s.StartsWith(" error"))
              Gel_6.expected_error_lines_.Add(line);
            continue;

          case '*':  // comment delimited by /* ... */
            Read();   // move past opening '*'
            if (!ReadDelimitedComment())
              return (char) 0;
            continue;
        }
      }

      return c;
    }
  }

  bool IsDigit(char c, bool hex) {
    if (Char.IsDigit(c))
      return true;
    if (!hex)
      return false;
    return (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');
  }

  // Read a number, possibly including a decimal point and/or exponent.
  string ReadNumber(char first, bool hex, out bool real) {
    bool dot = false, exp = false;
    StringBuilder ^sb = new StringBuilder();
    sb.Append(first);
    if (first == '.')
      dot = true;

    while (true) {
      bool need_digit = false;
      char c = Peek();
      if (c == '.' && !hex && !dot && !exp) {
        sb.Append(c);
        Read();
        dot = true;
        c = Peek();
        need_digit = true;
      }
      else if ((c == 'e' || c == 'E') && !hex && !exp) {
        sb.Append(c);
        Read();
        exp = true;
        c = Peek();
        if (c == '+' || c == '-') {
          sb.Append(c);
          Read();
          c = Peek();
        }
        need_digit = true;
      }
      if (!IsDigit(c, hex)) {
        if (!need_digit)
          break;
        real = false;
        return null;
      }
      sb.Append(c);
      Read();
    }

    real = dot || exp;
    return sb.ToString();
  }

  int ParseNumber(char first, out object ^val) {
    bool hex = false;
    if (first == '0') {
      char p = Peek();
      if (p == 'x' || p == 'X') {
        Read();
        hex = true;
      }
    }
    bool real;
    string s = ReadNumber(first, hex, out real);
    if (s == null) {
      val = null;
      return Parser.SCAN_ERROR;
    }
    if (!hex) {
      switch (Peek()) {
        case 'F':
        case 'f':
          Read();
          val = Single.Parse(s);
          return Parser.FLOAT_LITERAL;
        case 'D':
        case 'd':
          Read();
          real = true;
        break;
    }
    }
    if (real) {
      val = Double.Parse(s);
      return Parser.DOUBLE_LITERAL;
    }
    val = int.Parse(s, hex ? NumberStyles.HexNumber : NumberStyles.Integer);
    return Parser.INT_LITERAL;
  }

  int ParseWord(char first, out object ^val) {
    string s = ReadWord(first);

    val = null;
    switch (s) {
      case "abstract": return Parser.ABSTRACT;
      case "as": return Parser.AS;
      case "base": return Parser.BASE;
      case "bool": return Parser.BOOL;
      case "break": return Parser.BREAK;
      case "case": return Parser.CASE;
      case "char": return Parser.CHAR;
      case "class": return Parser.CLASS;
      case "const": return Parser.CONST_TOKEN;
      case "continue": return Parser.CONTINUE;
      case "default": return Parser.DEFAULT;
      case "do": return Parser.DO;
      case "double": return Parser.DOUBLE;
      case "else": return Parser.ELSE;
      case "extern": return Parser.EXTERN;
      case "false": return Parser.FALSE_TOKEN;
      case "float": return Parser.FLOAT;
      case "for": return Parser.FOR;
      case "foreach": return Parser.FOREACH;
      case "if": return Parser.IF;
      case "import": return Parser.IMPORT;
      case "in": return Parser.IN_TOKEN;
      case "int": return Parser.INT;
      case "is": return Parser.IS;
      case "new": return Parser.NEW;
      case "null": return Parser.NULL;
      case "object": return Parser.OBJECT;
      case "out": return Parser.OUT_TOKEN;
      case "override": return Parser.OVERRIDE;
      case "pool": return Parser.POOL;
      case "private": return Parser.PRIVATE;
      case "protected": return Parser.PROTECTED;
      case "public": return Parser.PUBLIC;
      case "readonly": return Parser.READONLY;
      case "ref": return Parser.REF;
      case "return": return Parser.RETURN;
      case "short": return Parser.SHORT;
      case "static": return Parser.STATIC;
      case "string": return Parser.STRING;
      case "switch": return Parser.SWITCH;
      case "take": return Parser.TAKE;
      case "this": return Parser.THIS_TOKEN;
      case "true": return Parser.TRUE_TOKEN;
      case "virtual": return Parser.VIRTUAL;
      case "void": return Parser.VOID_TOKEN;
      case "while": return Parser.WHILE;
      default:
        val = s;
        return Parser.ID;
    }
  }

  bool ParseEscape(ref char c) {
    if (!Read(out c))
      return false;
    switch (c) {
      case '\'':
      case '\"':
      case '\\':
        break;
      case '0': c = '\0'; break;
      case 'n': c = '\n'; break;
      case 'r': c = '\r'; break;
      case 't': c = '\t'; break;
      default: return false;
    }
    return true;
  }

  int ParseChar(out object ^val) {
    val = null;
    char c;
    if (!Read(out c))
      return Parser.SCAN_ERROR;
    if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
    char d;
    if (!Read(out d) || d != '\'')
      return Parser.SCAN_ERROR;
    val = c;
    return Parser.CHAR_LITERAL;
  }

  int ParseString(out object ^val) {
    val = null;
    StringBuilder ^sb = new StringBuilder();
    while (true) {
      char c;
      if (!Read(out c))
        return Parser.SCAN_ERROR;
      if (c == '"')
        break;
      if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
      sb.Append(c);
    }
    val = sb.ToString();
    return Parser.STRING_LITERAL;
  }

  int ReadToken(out object ^val) {
    val = null;

    int i = GetChar();
    if (i == -1)
      return -1;
    char c = (char) i;

    if (Char.IsDigit(c) || c == '.' && Char.IsDigit(Peek()))
      return ParseNumber(c, out val);

    if (Char.IsLetter(c) || c == '_')
      return ParseWord(c, out val);

    if (c == '\'')
      return ParseChar(out val);

    if (c == '"')
      return ParseString(out val);

    char peek = Peek();
    int token = 0;
    switch (c.ToString() + peek.ToString()) {
      case "++": token = Parser.PLUS_PLUS; break;
      case "--": token = Parser.MINUS_MINUS; break;
      case "&&": token = Parser.OP_AND; break;
      case "||": token = Parser.OP_OR; break;
      case "==": token = Parser.OP_EQUAL; break;
      case "!=": token = Parser.OP_NE; break;
      case "<=": token = Parser.OP_LE; break;
      case "<<": token = Parser.OP_LEFT_SHIFT; break;
      case ">=": token = Parser.OP_GE; break;
      case ">>": token = Parser.OP_RIGHT_SHIFT; break;
      case "*=": token = Parser.STAR_EQUAL; break;
      case "/=": token = Parser.SLASH_EQUAL; break;
      case "%=": token = Parser.PERCENT_EQUAL; break;
      case "+=": token = Parser.PLUS_EQUAL; break;
      case "-=": token = Parser.MINUS_EQUAL; break;
      case "&=": token = Parser.AND_EQUAL; break;
      case "|=": token = Parser.OR_EQUAL; break;

      // Return_6 [] as a single token; this lets the parser distinguish the cases
      // "foo[] a;" and "foo[x] = 4" as soon as it reads the first token after the identifier "foo".
      case "[]": token = Parser.ARRAY_TYPE; break;
    }
    if (token != 0) {
      Read();
    } else token = c;

    val = token;
    return token;
  }

  public override bool Advance () {
    if (next_token_ != -1) {
      token_ = next_token_;
      value_ = take next_value_;
      next_token_ = -1;
    } else {
      token_ = ReadToken(out value_);
      if (token_ == -1) return false;
    }

    if (token_ == ')') {
      // We need to read one token ahead to determine whether this close parenthesis
      // ends a type cast.  See e.g. the discussion in the Cast_6 Expressions section
      // of the C# specification.
      next_token_ = ReadToken(out next_value_);
      switch (next_token_) {
        case -1:  // end of file
          break;
        case '!':
        case '(':
        case Parser.ID:
        case Parser.INT_LITERAL:
        case Parser.CHAR_LITERAL:
        case Parser.STRING_LITERAL:
          token_ = Parser.CAST_CLOSE_PAREN;
          break;
        default:
          if (next_token_ >= Parser.FIRST_KEYWORD && next_token_ <= Parser.LAST_KEYWORD &&
              next_token_ != Parser.AS && next_token_ != Parser.IS)
            token_ = Parser.CAST_CLOSE_PAREN;
          break;
      }
    }
    return true;
  }

  public override void Fatal() {
    new Syntax_6().Error("irrecoverable syntax error");
    Environment.Exit(1);
  }

}

class Gel_6 {
  public static bool verbose_;

  public static bool error_test_;
  public static bool print_type_sets_;

  public static readonly ArrayList /* of int */ ^expected_error_lines_ = new ArrayList();
  public static readonly ArrayList /* of int */ ^error_lines_ = new ArrayList();

  public static Program_6 ^program_;

  public static readonly string gel_directory_ = GetLibraryPath();

  static string GetLibraryPath() {
    return Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName); 
  }

  public static string CurrentFile() {
    return program_ == null ? "" : program_.CurrentFile();
  }

  public static int Line() {
    return program_ == null ? 0 : program_.Line();
  }

  public static void Exit() { Environment.Exit(0); }

  // Given two sorted ArrayLists a, b of ints, return an ArrayList containing all ints which appear
  // in [a] but not in [b].
  ArrayList ^Diff(ArrayList a, ArrayList b) {
    ArrayList ^ret = new ArrayList();
    int bi = 0;
    foreach (int i in a) {
      while (bi < b.Count && (int) b[bi] < i)
        ++bi;
      if (bi >= b.Count || (int) b[bi] > i)
        ret.Add(i);
    }
    return ret;
  }

  void WriteLineNumbers(ArrayList a) {
    for (int i = 0; i < a.Count; ++i) {
      if (i > 0)
        Console.Write(", ");
      Console.Write(a[i]);
    }
    Console.WriteLine("");
  }

  void ErrorTestReport() {
    Console.WriteLine("");
    ArrayList ^e = Diff(error_lines_, expected_error_lines_);
    if (e.Count > 0) {
      Console.Write("unexpected error at line ");
      WriteLineNumbers(e);
    }
    ArrayList ^e2 = Diff(expected_error_lines_, error_lines_);
    if (e2.Count > 0) {
      Console.Write("expected error at line ");
      WriteLineNumbers(e2);
    }
    if (e.Count == 0 && e2.Count == 0)
      Console.WriteLine("all errors expected");
  }

  void Usage_6() {
    Console.WriteLine("usage: gel <source-file> ... [args]");
    Console.WriteLine("       gel -c [-d] [-o <name>] [-u] [-v] [-cpp] <source-file> ...");
    Console.WriteLine("");
    Console.WriteLine("   -c: compile to native executable");
    Console.WriteLine("   -d: debug mode: disable optimizations, link with debug build of C runtime");
    Console.WriteLine("   -o: specify output filename");
    Console.WriteLine("   -u: unsafe: skip reference count checks");
    Console.WriteLine("   -v: verbose: display command used to invoke C++ compiler");
    Console.WriteLine(" -cpp: compile to C++ only");
  }

  public void Run(string[] args) {
    if (args.Length < 1) {
      Usage_6();
      return;
    }

    Internal_6.Init();

    program_ = new Program_6();
    bool compile = false;
    bool cpp_only = false;
    string output = null;
    int i;
    for (i = 0; i < args.Length && args[i].StartsWith("-"); ++i)
      switch (args[i]) {
        case "-c": compile = true; break;
        case "-d": program_.debug_ = true; break;
        case "-e": error_test_ = true; break;
        case "-o":
          if (++i >= args.Length) {
            Usage_6();
            return;
          }
          output = Path.GetFileNameWithoutExtension(args[i]);
          break;
        case "-u": program_.safe_ = false; break;
        case "-v": verbose_ = true; break;
        case "-cpp": cpp_only = true; break;
        case "-crt": program_.crt_alloc_ = true; break;
        case "-typeset": print_type_sets_ = true; break;
        default:
          Console.WriteLine("unrecognized option: {0}", args[i]);
          return;
      }

    for (; i < args.Length ; ++i)
      if (args[i].EndsWith(".gel"))
        program_.Import(args[i]);
      else {
        if (args[i] == "-")   // marker indicating end of source files
          ++i;
        break;
      }

    ArrayList ^program_args = new ArrayList();
    if (compile) {
      if (i < args.Length) {
        Console.WriteLine("file to compile has unrecognized extension: {0}", args[i]);
        return;
      }
    } else {
      for (; i < args.Length; ++i)
        program_args.Add(args[i]);
    }

    if (!program_.Parse())
      return;

    bool ok = program_.Resolve() && program_.Check();
    if (error_test_)
      ErrorTestReport();
    if (!ok)
      return;

    if (compile)
      program_.Compile(output, cpp_only);
    else program_.Eval(program_args);
  }

  public static void Main_6(string[] args) {
    new Gel_6().Run(args);
  }
}
/*
Copyright (c) 2006 Google Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

class Syntax_7 {
  public readonly string file_;
  public readonly int line_;

  public Syntax_7() { file_ = Gel_7.CurrentFile(); line_ = Gel_7.Line(); }

  static void Report(string file, int line, string type) {
    Console.Write("{0}({1}): ", file, line);
    Console.Write("{0}: ", type);
    if (Gel_7.error_test_)
      Gel_7.error_lines_.Add(line);
  }

  public void Error(string message) {
    Report(file_, line_, "error");
    Console.WriteLine(message);
  }

  public void Error(string format, object arg) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg);
  }

  public void Error(string format, object arg1, object arg2) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2);
  }

  public void Error(string format, object arg1, object arg2, object arg3) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2, arg3);
  }

  public void Warning(string message) {
    Report(file_, line_, "warning");
    Console.WriteLine(message);
  }
}

abstract class TypeExpr_7 : Syntax_7 {
  public abstract GType_7 Resolve(Program_7 program);
  public abstract TypeExpr_7 ^Copy();
}

class ConversionContext_7 {
  public const int Other = 0,
                   AssignVar = 1,
                   MethodArg = 2;
}

// GEL2 includes the following kinds of types:
// - simple types (int, bool, char, float, double): SimpleType_7
// - owned types (including array types): ArrayType_7 or Class_7 with Owned() => true
// - owning types: Owning_7
// - string: GString_7
// - null type: NullType_7
// - void: VoidType_7

abstract class GType_7 {
  public virtual bool IsOwned() { return false; }

  // A reference type is an owned, owning, string or null type.
  public virtual bool IsReference() { return true; }

  // A value type is a simple or string type.
  public virtual bool IsValue() { return false; }

  public virtual Class_7 Parent() { return GObject_7.type_; }
  
  // If_7 this is an owning type T ^ then return T; otherwise return this.
  public virtual GType_7 BaseType() { return this; }

  // Return_7 the set of types which may be destroyed when a variable of this type
  // is destroyed.
  public virtual TypeSet_7 VarDestroys() { return TypeSet_7.empty_; }

  // Return_7 the set of types which may be destroyed when a value of this concrete type
  // is destroyed.
  public virtual TypeSet_7 TypeDestroys() { return TypeSet_7.empty_; }

  public virtual void FindVarDestroys(int marker, TypeSet_7 set) { }

  public virtual void FindTypeDestroys(int marker, TypeSet_7 set) { }

  public virtual bool IsSubtype(GType_7 type) {
    for (GType_7 t = this; t != null ; t = t.Parent())
      if (type.Equals(t))
        return true;
    return false;
  }

  public virtual Owning_7 OwningType() { Debug.Assert(false); return null; }

  protected virtual bool CanConvertOwnership(GType_7 t, int context) {
    bool from_owning = this is Owning_7;
    bool to_owning = t is Owning_7;
    if (IsValue() && t.BaseType() == GObject_7.type_) {
      Debug.Assert(!from_owning);
      // boxing conversion yields an owning pointer; string->object conversion may
      // yield an owning or non-owning pointer
      return to_owning || context == ConversionContext_7.MethodArg || this == GString_7.type_;
    }
    if (BaseType() == GObject_7.type_ && t.IsValue()) {
      Debug.Assert(!to_owning);
      return true;  // an unboxing or object->string conversion, OK in any context
    }
    return from_owning == to_owning ||
           from_owning && !to_owning &&
             (context == ConversionContext_7.AssignVar || context == ConversionContext_7.MethodArg);
  }

  // Ensure that this class will inherit from Object in generated C++ code.
  public virtual void SetObjectInherit() { }

  // Return_7 true if there is a non-subtyping implicit conversion from this to t.
  public virtual bool CanConvert1(GType_7 t) { return false; }

  // Return_7 true if there is a non-subtyping explicit conversion from this to t.
  protected virtual bool CanConvertExplicit1(GType_7 t) { return false; }

  // Return_7 true if this type can be converted to type [to].
  public bool CanConvert(GType_7 to, int context, bool is_explicit, bool subtype_only) {
    if (!CanConvertOwnership(to, context))
      return false;

    GType_7 from_base = BaseType();
    GType_7 to_base = to.BaseType();
    if (from_base.Equals(to_base))
      return true;   // identity conversion

    // If_7 we ever perform a conversion to C ^, then C must have a vtable so that we can call
    // a virtual destructor when an owning pointer is destroyed.
    if (to is Owning_7 && this != Null_7.type_)
      to_base.SetVirtual();

    // If_7 we ever perform an explicit conversion from a class, that class must
    // have a vtable so that every instance of the class will have run-time type information.
    if (is_explicit)
      from_base.SetVirtual();

    // If_7 we ever convert between C and Object, then C must derive from Object in generated code.
    if (from_base == GObject_7.type_)
      to_base.SetObjectInherit();
    else if (to_base == GObject_7.type_)
      from_base.SetObjectInherit();

    return from_base.IsSubtype(to_base) ||
           !subtype_only && from_base.CanConvert1(to_base) ||
           is_explicit && (to_base.IsSubtype(from_base) ||
                           !subtype_only && from_base.CanConvertExplicit1(to_base));
  }

  public bool CanConvert(GType_7 t, int context) { return CanConvert(t, context, false, false); }
  public bool CanConvert(GType_7 t) { return CanConvert(t, ConversionContext_7.Other); }

  public bool CanConvertExplicit(GType_7 t, bool subtype_only) {
    return CanConvert(t, ConversionContext_7.Other, true, subtype_only);
  }

  public bool CheckConvert(Syntax_7 caller, GType_7 t, int context) {
    if (!CanConvert(t, context)) {
      caller.Error("can't convert {0} to {1}", this, t);
      return false;
    }
    return true;
  }

  public bool CheckConvert(Syntax_7 caller, GType_7 t) {
    return CheckConvert(caller, t, ConversionContext_7.Other);
  }

  // Return_7 a type to which the types [this] and t can both be implicitly converted.
  public GType_7 CommonType(Syntax_7 caller, GType_7 t) {
    if (CanConvert(t))
      return t;
    if (t.CanConvert(this))
      return this;
    caller.Error("incompatible types: {0} and {1}", this, t);
    return null;
  }

  public abstract SimpleValue_7 DefaultValue_7();

  static ArrayList ^empty_array_ = new ArrayList();
  public virtual ArrayList /* of Member_7 */ Members() { return empty_array_; }

  public Member_7 GetMatchingMember(Member_7 m1) {
    foreach (Member_7 m in Members())
      if (m.MatchSignature(m1))
        return m;
    return null;
  }

  // Find a match for m in this type or its ancestors, ignoring private members and
  // optionally ignoring overrides.
  public Member_7 FindMatchingMember(Member_7 m, bool override_ok) {
    for (GType_7 t = this ; t != null ; t = t.Parent()) {
      Member_7 m1 = t.GetMatchingMember(m);
      if (m1 != null && !m1.IsPrivate() && (override_ok || !m1.IsOverride()))
        return m1;
    }
    return null;
  }

  int Score(bool accessible, int mismatches) {
    return (accessible ? 0 : 100) + mismatches;
  }

  public Member_7 Lookup(Syntax_7 caller, Class_7 from_class, bool through_base,
                       int kind, string name, ArrayList /* of Argument_7 */ arguments, bool report_error) {
    Member_7 m1 = null;   // the best match we've found so far
    bool found_any = false;
    bool accessible = false;
    int score = -1;

    GType_7 this_type = BaseType();
    GType_7 t;
    for (t = this_type; t != null; t = (kind == MemberKind_7.Constructor_7 ? null : t.Parent())) {
      foreach (Member_7 m in t.Members())
        if (Member_7.MatchKind(m.Kind(), kind) && m.name_ == name && !m.IsOverride()) {
          found_any = true;
          int mismatches = 0;
          if (arguments != null && !m.IsApplicable(arguments, out mismatches))
            continue; // wrong argument count
          bool new_accessible = m.IsAccessible(from_class, this_type, through_base);
          int new_score = Score(new_accessible, mismatches);
          if (new_score == 0 && score == 0) {
            if (report_error)
              caller.Error("{0}: ambiguous {1} call", name, Member_7.ToString(kind));
            return null;
          }
          if (score == -1 || new_score < score) {
            m1 = m;
            score = new_score;
            accessible = new_accessible;
          }
        }
      if (score == 0)
        break;
    }

    if (score != 0) {
      if (report_error) {
        string k = Member_7.ToString(kind);
        if (!found_any)
          caller.Error("{0}: {1} not found", name, k);
        else if (score == -1) {
          string a = String.Format("{0} argument{1}", arguments.Count, arguments.Count == 1 ? "" : "s");
          caller.Error("{0}: no {1} overload takes {2}", name, k, a);
        } else if (!accessible)
          caller.Error("{0}: can't access {1} {2}",
                       name, m1.IsProtected() ? "protected" : "private", k);
        else {
          caller.Error("{0}: the best overloaded {1} match has some invalid arguments", name, k);
          m1.ReportMismatches(caller, arguments);
        }
      }
      return null;
    }

    // If_7 we've found a member of the Object class, then we're using this class as an object,
    // so in generated code it must ultimately inherit from Object, not _Object.
    if (t == GObject_7.type_)
      this_type.SetObjectInherit();

    if (through_base) {
      // As_7 a special case, whenever we're accessing through base we find the member which will
      // actually be invoked; this is not necessarily the same as the member we've just found
      // if the member is virtual.
      m1 = FindMatchingMember(m1, true);
      Debug.Assert(m1 != null);
    }

    return m1;
  }

  public virtual void SetVirtual() { }

  // Emit the name of the C++ class we use to hold instances of this type.
  public virtual string EmitTypeName() { Debug.Assert(false); return null; }

  // Return_7 a C++ type of the form "T<U>".  If_7 U ends with a '>', we emit an
  // extra space to avoid emitting the token >>, which will cause GCC to complain.
  public static string ConstructType(string generic, string type) {
    return String.Format("{0}<{1}{2}>", generic, type,
                         type.EndsWith(">") ? " " : "");
  }

  string EmitNonOwningPointer(string name) {
    if (Gel_7.program_.safe_)
      return ConstructType(this == GObject_7.type_ ? "_PtrRef" : "_Ptr", name);
    return String.Format("{0} *", name);
  }

  // Emit a C++ type used for variables holding instances of this type.
  public virtual string EmitType() {
    return EmitNonOwningPointer(EmitTypeName());
  }

  // Emit a C++ type used for expressions holding instances of this type.
  public virtual string EmitExprType() {
    return EmitTypeName() + " *";
  }

  public virtual string EmitReturnType() {
    return EmitExprType();
  }

  public virtual string EmitGenericType() {
    return IsReference() ? EmitNonOwningPointer("Object") : EmitType();
  }
}

class TypeSet_7 {
  NonOwningArrayList /* of GType_7 */ ^types_ = new NonOwningArrayList();

  public static readonly TypeSet_7 ^empty_ = new TypeSet_7();

  public void Add(GType_7 type) {
    for (int i = 0; i < types_.Count; ++i) {
      GType_7 t = (GType_7) types_[i];
      if (type.IsSubtype(t))
        return;
      if (t.IsSubtype(type)) {
        types_[i++] = type;
        while (i < types_.Count) {
          t = (GType_7) types_[i];
          if (t.IsSubtype(type))
            types_.RemoveAt(i);
          else ++i;
        }
        return;
      }
    }
    types_.Add(type);
  }

  public void Add(TypeSet_7 set) {
    foreach (GType_7 t in set.types_)
      Add(t);
  }

  public bool Contains(GType_7 type) {
    foreach (GType_7 t in types_)
      if (type.IsSubtype(t))
        return true;
    return false;
  }

  public bool IsObject() {
    return types_.Count > 0 && types_[0] == GObject_7.type_;
  }

  public override string ToString() {
    StringBuilder ^sb = new StringBuilder();
    sb.Append("{");
    foreach (GType_7 t in types_)
      sb.AppendFormat(" {0}", t.ToString());
    sb.Append(" }");
    return sb.ToString();
  }
}

class VoidType_7 : GType_7 {
  public override bool IsReference() { Debug.Assert(false); return false; }

  public override SimpleValue_7 DefaultValue_7() { Debug.Assert(false); return null; }

  public override string ToString() { return "void"; }

  public override string EmitExprType() { return "void"; }
  public override string EmitType() { return "void"; }
}

class Void_7 {
  public static readonly GType_7 ^type_ = new VoidType_7();
}

// an RValue_7, a Location_7 containing an RValue_7, or a LocationRef_7 pointing to a Location_7 containing an RValue_7
abstract class ValueOrLocation_7 {
  public abstract GValue_7 Get();
}

// a GValue_7 or a reference to a GValue_7
abstract class RValue_7 : ValueOrLocation_7 {
  public abstract RValue_7 ^CopyRef();
}

abstract class GValue_7 : RValue_7 {
  public override GValue_7 Get() { return this; }

  public abstract GType_7 Type();

  public override RValue_7 ^CopyRef() { return new Reference_7(this); }

  public virtual RValue_7 ^Get(Field_7 field) { Debug.Assert(false); return null; }
  public virtual RValue_7 ^Take_7(Field_7 field) { Debug.Assert(false); return null; }

  public virtual RValue_7 ^ConvertExplicit(ref RValue_7 ^this_own, GType_7 t) {
    // try implicit conversion
    RValue_7 ^v = Convert(ref this_own, t);
    if (v != this || Type().IsSubtype(t) )
      return v;

    Console.WriteLine("type cast failed: object of type {0} is not a {1}", Type(), t);
    Gel_7.Exit();
    return null;
  }

  // Implicitly convert this value to type t.
  public virtual RValue_7 ^Convert(ref RValue_7 ^this_own, GType_7 t) {
    return take this_own;
  }

  public virtual bool DefaultEquals(object o) { return Equals(o); }
  public virtual int DefaultHashCode() { return GetHashCode(); }
  public virtual string DefaultToString() { return ToString(); }

  public virtual RValue_7 ^Invoke(Method_7 m, ValueList_7 args) {
    switch (m.name_) {
      case "Equals": return new GBool_7(DefaultEquals(args.Object(0)));
      case "GetHashCode": return new GInt_7(DefaultHashCode());
      case "ToString": return new GString_7(DefaultToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class Reference_7 : RValue_7 {
  public readonly GValue_7 value_;    // a reference value, never a SimpleValue_7

  public Reference_7(GValue_7 v) { value_ = v; }

  public override GValue_7 Get() { return value_; }

  public override RValue_7 ^CopyRef() { return new Reference_7(value_); }
}

abstract class SimpleValue_7 : GValue_7 {
  public abstract SimpleValue_7 ^Copy();
  public override RValue_7 ^CopyRef() { return Copy(); }
  public abstract string Emit();
}

class GBool_7 : SimpleValue_7 {
  public readonly bool b_;

  public GBool_7(bool b) { b_ = b; }

  public override bool Equals(object o) {
    GBool_7 b = o as GBool_7;
    return b != null && b.b_ == b_;
  }

  public override int GetHashCode() { return b_.GetHashCode(); }

  public override SimpleValue_7 ^Copy() { return new GBool_7(b_); }

  public static readonly BoolClass_7 ^type_ = new BoolClass_7();

  public override GType_7 Type() { return type_; }

  public override string ToString() { return b_.ToString(); }

  public override string Emit() { return b_ ? "true" : "false"; }
}

class GInt_7 : SimpleValue_7 {
  public readonly int i_;

  public GInt_7(int i) { i_ = i; }

  public static readonly IntClass_7 ^type_ = new IntClass_7();

  public override GType_7 Type() { return type_; }

  public override bool Equals(object o) {
    GInt_7 i = o as GInt_7;
    return i != null && i.i_ == i_;
  }

  public override int GetHashCode() { return i_.GetHashCode(); }

  public override SimpleValue_7 ^Copy() { return new GInt_7(i_); }

  public override RValue_7 ^Convert(ref RValue_7 ^this_own, GType_7 t) {
    if (t == GFloat_7.type_)
      return new GFloat_7(i_);
    if (t == GDouble_7.type_)
      return new GDouble_7(i_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_7 ^ConvertExplicit(ref RValue_7 ^this_own, GType_7 t) {
    return t == GChar_7.type_ ? new GChar_7((char) i_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return i_.ToString(); }

  public override string Emit() { return i_.ToString(); }
}

class GFloat_7 : SimpleValue_7 {
  public readonly float f_;

  public GFloat_7(float f) { f_ = f; }

  public static readonly FloatClass_7 ^type_ = new FloatClass_7();

  public override GType_7 Type() { return type_; }

  public override bool Equals(object o) {
    GFloat_7 f = o as GFloat_7;
    return f != null && f.f_ == f_;
  }

  public override int GetHashCode() { return f_.GetHashCode(); }

  public override SimpleValue_7 ^Copy() { return new GFloat_7(f_); }

  public override RValue_7 ^Convert(ref RValue_7 ^this_own, GType_7 t) {
    if (t == GDouble_7.type_)
      return new GDouble_7(f_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_7 ^ConvertExplicit(ref RValue_7 ^this_own, GType_7 t) {
    return t == GInt_7.type_ ? new GInt_7((int) f_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return f_.ToString(); }

  public override string Emit() {
    string s = f_.ToString();
    return s + (s.IndexOf('.') == -1 ? ".0f" : "f");
  }
}

class GDouble_7 : SimpleValue_7 {
  public readonly double d_;

  public GDouble_7(double d) { d_ = d; }

  public static readonly DoubleClass_7 ^type_ = new DoubleClass_7();

  public override GType_7 Type() { return type_; }

  public override bool Equals(object o) {
    GDouble_7 d = o as GDouble_7;
    return d != null && d.d_ == d_;
  }

  public override int GetHashCode() { return d_.GetHashCode(); }

  public override SimpleValue_7 ^Copy() { return new GDouble_7(d_); }

  public override RValue_7 ^ConvertExplicit(ref RValue_7 ^this_own, GType_7 t) {
    if (t == GInt_7.type_)
      return new GInt_7((int) d_);
    if (t == GFloat_7.type_)
      return new GFloat_7((float) d_);
    return base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return d_.ToString(); }

  public override string Emit() {
    string s = d_.ToString();
    if (s.IndexOf('.') == -1)
      s = s + ".0";
    return s;
  }
}

class GChar_7 : SimpleValue_7 {
  public readonly char c_;

  public GChar_7(char c) { c_ = c; }

  public static readonly CharClass_7 ^type_ = new CharClass_7();

  public override GType_7 Type() { return type_; }

  public override bool Equals(object o) {
    GChar_7 c = o as GChar_7;
    return c != null && c.c_ == c_;
  }

  public override int GetHashCode() { return c_.GetHashCode(); }

  public override SimpleValue_7 ^Copy() { return new GChar_7(c_); }

  public override RValue_7 ^Convert(ref RValue_7 ^this_own, GType_7 t) {
    return t == GInt_7.type_ ? new GInt_7(c_) : base.Convert(ref this_own, t);
  }

  public override string ToString() { return c_.ToString(); }

  public static string Emit(char c) {
    switch (c) {
      case '\0': return "\\0";
      case '\n': return "\\n";
      case '\r': return "\\r";
      case '\t': return "\\t";
      case '\'': return "\\'";
      case '\"': return "\\\"";
      case '\\': return "\\\\";
    }
    if (c < 32) {
      Debug.Assert(false); return null;
    }
    return c.ToString();
  }

  public override string Emit() {
    return String.Format("'{0}'", Emit(c_));
  }
}

abstract class LocationOrRef_7 : ValueOrLocation_7 {
  public abstract Location_7 GetLoc();
}

class Location_7 : LocationOrRef_7 {
  public RValue_7 ^value_;

  public Location_7(RValue_7 ^val) { value_ = val; }

  public override GValue_7 Get() { return value_.Get(); }

  public override Location_7 GetLoc() { return this; }
}

// We allocate a LocationRef_7 when we need an owning reference to a Location_7 which we don't own.
class LocationRef_7 : LocationOrRef_7 {
  public readonly Location_7 location_;

  public LocationRef_7(Location_7 loc) { location_ = loc; }

  public override GValue_7 Get() { return location_.Get(); }

  public override Location_7 GetLoc() { return location_; }
}

class MapNode_7 {
  public readonly MapNode_7 ^next_;
  public readonly object key_;
  public ValueOrLocation_7 ^value_;   // (must appear after next_ so it will be destroyed first)

  public MapNode_7(object key, ValueOrLocation_7 ^value, MapNode_7 ^next) {
    key_ = key; value_ = value; next_ = next;
  }
}

class Map_7 {
  MapNode_7 ^nodes_;

  protected MapNode_7 Find1(object key) {
    for (MapNode_7 n = nodes_; n != null; n = n.next_)
      if (n.key_ == key)
        return n;
    return null;
  }

  protected virtual MapNode_7 Find(object key) {
    MapNode_7 n = Find1(key);
    Debug.Assert(n != null);
    return n;
  }

  public RValue_7 ^Get(object key) {
    return Find(key).value_.Get().CopyRef();
  }

  public RValue_7 ^Take_7(object key) {
    MapNode_7 n = Find(key);
    LocationOrRef_7 l = n.value_ as LocationOrRef_7;
    if (l != null)
      return take l.GetLoc().value_;
    return (RValue_7) take n.value_;
  }

  public void Set(object key, RValue_7 ^val) {
    MapNode_7 n = Find(key);
    LocationOrRef_7 l = n.value_ as LocationOrRef_7;
    if (l != null)
      l.GetLoc().value_ = val;
    else n.value_ = val;
  }

  public void Add(object key, ValueOrLocation_7 ^val) {
    nodes_ = new MapNode_7(key, val, take nodes_);
  }

  public Location_7 GetLocation(object key) {
    MapNode_7 n = Find(key);
    LocationOrRef_7 l = n.value_ as LocationOrRef_7;
    if (l != null)
      return l.GetLoc();
    Location_7 ^loc1 = new Location_7((RValue_7) take n.value_);
    Location_7 loc = loc1;
    n.value_ = loc1;
    return loc;
  }
}

class GObject_7 : GValue_7 {
  public readonly Class_7 class_;   // the class of this object

  Map_7 ^map_ = new Map_7();

  public GObject_7(Class_7 cl) {
    class_ = cl;
    while (cl != null) {
      foreach (Field_7 f in cl.fields_)
        map_.Add(f, f.Type().DefaultValue_7().Copy() );
      cl = cl.Parent();
    }
  }

  // the type of this object
  public override GType_7 Type() { return class_; }

  public override RValue_7 ^Get(Field_7 field) { return map_.Get(field); }
  public override RValue_7 ^Take_7(Field_7 field) { return map_.Take_7(field); }
  public void Set(Field_7 field, RValue_7 ^val) { map_.Set(field, val); }
  public Location_7 GetLocation(Field_7 field) { return map_.GetLocation(field); }

  public override int DefaultHashCode() { return base.GetHashCode(); }
  public override int GetHashCode() {
    GInt_7 ^i = (GInt_7) Invocation_7.InvokeMethod(this, GObject_7.type_.get_hash_code_, new ArrayList(), true);
    return i.i_;
  }

  public override bool DefaultEquals(object o) { return base.Equals(o); }
  public override bool Equals(object o) {
    GValue_7 v = o as GValue_7;
    if (v == null)
      return false;

    ArrayList ^args = new ArrayList();
    args.Add(v.CopyRef());
    GBool_7 ^b = (GBool_7) Invocation_7.InvokeMethod(this, GObject_7.type_.equals_, args, true);
    return b.b_;
  }

  public override string DefaultToString() { return String.Format("<object {0}>", class_.name_); }
  public override string ToString() {
    GString_7 ^s = (GString_7) Invocation_7.InvokeMethod(this, GObject_7.type_.to_string_, new ArrayList(), true);
    return s.s_;
  }

  // the Object class
  public static readonly ObjectClass_7 ^type_ = new ObjectClass_7();
}

class NullType_7 : GType_7 {
  public override string ToString() { return "null_type"; }

  public override SimpleValue_7 DefaultValue_7() { Debug.Assert(false); return null; }

  public override bool IsSubtype(GType_7 t1) {
    return t1.IsReference();
  }

  protected override bool CanConvertOwnership(GType_7 t, int context) {
    return true;    // conversion from null type to owning type is okay
  }

  public override string EmitType() { Debug.Assert(false); return null; }
}

class Null_7 : SimpleValue_7 {
  public Null_7() { }

  public static readonly NullType_7 ^type_ = new NullType_7();

  public override GType_7 Type() { return type_; }

  public override bool Equals(object o) {
    return o is Null_7;
  }

  public override SimpleValue_7 ^Copy() { return new Null_7(); }

  public override int GetHashCode() { return 0; }

  public static readonly Null_7 ^Instance = new Null_7();

  public override string ToString() { return ""; }

  public override string Emit() { return "0"; }
}

class Owning_7 : GType_7 {
  GType_7 base_type_;

  public Owning_7(GType_7 type) {
    base_type_ = type;
  }

  public override Class_7 Parent() { Debug.Assert(false); return null; }

  public override SimpleValue_7 DefaultValue_7() { return Null_7.Instance; }

  public override GType_7 BaseType() { return base_type_; }

  public override TypeSet_7 VarDestroys() { return base_type_.TypeDestroys(); }

  public override void FindVarDestroys(int marker, TypeSet_7 set) {
    base_type_.FindTypeDestroys(marker, set);
  }

  public override bool Equals(object o) {
    Owning_7 t = o as Owning_7;
    return t != null && t.base_type_.Equals(base_type_);
  }

  public override int GetHashCode() { return base_type_.GetHashCode() * 87; }

  public override string ToString() { return base_type_.ToString() + " ^"; }

  public override string EmitTypeName() {
    return base_type_.EmitTypeName();
  }

  string EmitType(string name) {
    return ConstructType(base_type_ == GObject_7.type_ ? "_OwnRef" : "_Own", name);
  }

  public override string EmitType() {
    // We represent an object ^ using a _OwnRef<Object>.
    // We represent a Foo ^ using an _Own<Foo>.
    return EmitType(EmitTypeName());
  }

  public override string EmitGenericType() {
    // We represent an object ^ [] using an _Array<_OwnRef<Object>>.
    // We represent a Foo ^ [] using an _Array<_Own<Object>>.
    return EmitType("Object");
  }
}

class OwningExpr_7 : TypeExpr_7 {
  readonly TypeExpr_7 ^expr_;

  public OwningExpr_7(TypeExpr_7 ^expr) { expr_ = expr; }

  public override TypeExpr_7 ^Copy() { return new OwningExpr_7(expr_.Copy()); }

  public override GType_7 Resolve(Program_7 program) {
    GType_7 t = expr_.Resolve(program);
    if (t == null)
        return null;
    if (t.IsValue()) {
      Error("^ cannot be applied to primitive types or strings");
      return null;
    }
    return t.OwningType();
  }
}

class GString_7 : SimpleValue_7 {
  public readonly string s_;

  public GString_7(string s) { s_ = s; }

  public static readonly StringClass_7 ^type_ = new StringClass_7();

  public override GType_7 Type() { return type_; }

  public override bool Equals(object o) {
    GString_7 s = o as GString_7;
    return s != null && s.s_ == s_;
  }

  public override SimpleValue_7 ^Copy() { return new GString_7(s_); }

  public override int GetHashCode() { return s_.GetHashCode(); }

  public override string ToString() { return s_; }

  public override RValue_7 ^Invoke(Method_7 m, ValueList_7 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StartsWith": return new GBool_7(s_.StartsWith(args.GetString(0)));
      case "EndsWith": return new GBool_7(s_.EndsWith(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public static string EmitStringConst(string s) {
    return String.Format("L{0}", EmitString(s));
  }

  public static string EmitString(string s) {
    StringBuilder ^sb = new StringBuilder();
    sb.Append('"');
    for (int i = 0; i < s.Length; ++i)
      sb.Append(GChar_7.Emit(s[i]));
    sb.Append('"');
    return sb.ToString();
  }

  public override string Emit() {
    string s = String.Format("new String({0})", EmitStringConst(s_));
    s = String.Format("_Ref<String>({0}).Get()", s);
    return s;
  }
}

abstract class Ownable_7 : GType_7 {
  Owning_7 ^owning_type_;

  public override Owning_7 OwningType() {
    if (owning_type_ == null)
      owning_type_ = new Owning_7(this);
    return owning_type_;
  }
}

class ArrayType_7 : Ownable_7 {
  GType_7 element_type_;

  public ArrayType_7(GType_7 type) {
    element_type_ = type;

    // Any type used generically must inherit from Object in C++ code.
    type.BaseType().SetObjectInherit();
  }

  public override bool IsOwned() { return true; }

  public override Class_7 Parent() { return GArray_7.array_class_; }

  public override SimpleValue_7 DefaultValue_7() { return Null_7.Instance; }

  public GType_7 ElementType() { return element_type_; }

  public override bool Equals(object o) {
    ArrayType_7 t = o as ArrayType_7;
    return (t != null && t.element_type_.Equals(element_type_));
  }

  public override TypeSet_7 TypeDestroys() { return element_type_.VarDestroys(); }

  public override void FindTypeDestroys(int marker, TypeSet_7 set) {
    element_type_.FindVarDestroys(marker, set);
  }

  public override int GetHashCode() { return element_type_.GetHashCode() * 77; }

  public override string EmitTypeName() {
    return ConstructType("_Array", element_type_.EmitGenericType());  
  }

  public override string ToString() {
    return element_type_.ToString() + "[]";
  }
}

class ArrayTypeExpr_7 : TypeExpr_7 {
  readonly TypeExpr_7 ^expr_;
  GType_7 ^type_;

  public ArrayTypeExpr_7(TypeExpr_7 ^expr) { expr_ = expr; }

  public override TypeExpr_7 ^Copy() { return new ArrayTypeExpr_7(expr_.Copy()); }

  public override GType_7 Resolve(Program_7 program) {
    GType_7 t = expr_.Resolve(program);
    return t == null ? null : (type_ = new ArrayType_7(t));
  }
}

class GArray_7 : GValue_7 {
  ArrayType_7 type_;

  ValueOrLocation_7^[] ^elements_;   // each element is a GValue_7 or a Location_7

  public override GType_7 Type() { return type_; }

  public GArray_7(ArrayType_7 type, int count) {
    type_ = type;
    elements_ = new ValueOrLocation_7^[count];
    for (int i = 0 ; i < count ; ++i)
      elements_[i] = type_.ElementType().DefaultValue_7().Copy();
  }

  void CheckIndex(int index) {
    if (index < 0 || index >= elements_.Length) {
      Console.WriteLine("error: array access out of bounds");
      Gel_7.Exit();
    }
  }

  public RValue_7 ^Get(int index) {
    CheckIndex(index);
    return elements_[index].Get().CopyRef();
  }

  public RValue_7 ^Take_7(int index) {
    CheckIndex(index);
    Location_7 loc = elements_[index] as Location_7;
    if (loc != null)
      return take loc.value_;
    return (RValue_7) (take elements_[index]);
  }

  public void Set(int index, RValue_7 ^val) {
    CheckIndex(index);
    Location_7 loc = elements_[index] as Location_7;
    if (loc != null)
      loc.value_ = val;
    else elements_[index] = val;
  }

  public Location_7 GetLocation(int index) {
    CheckIndex(index);
    Location_7 loc = elements_[index] as Location_7;
    if (loc != null)
      return loc;
    Location_7 ^loc1 = new Location_7((RValue_7) take elements_[index]);
    loc = loc1;
    elements_[index] = loc1;
    return loc;
  }

  public static readonly ArrayClass_7 ^array_class_ = new ArrayClass_7();

  public override RValue_7 ^Invoke(Method_7 m, ValueList_7 args) {
    if (m.GetClass() != array_class_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "CopyTo":
        GArray_7 a = (GArray_7) args.Object(0);
        if (!type_.Equals(a.type_)) {
          Console.WriteLine("error: can't copy between arrays of different types");
          Gel_7.Exit();
        }
        if (a.type_.ElementType() is Owning_7) {
          Console.WriteLine("error: can't copy to owning array");
          Gel_7.Exit();
        }
        // should check for index out of bounds here!
        int dest = args.Int(1);
        for (int i = 0 ; i < elements_.Length ; ++i)
          a.Set(dest + i, Get(i));
        return null;
      case "get_Length":
        return new GInt_7(elements_.Length);
      default:
        Debug.Assert(false); return null;
    }
  }
}

// A control graph object representing temporary variables destroyed when a top-level
// expression completes evaluation. 
class Temporaries_7 : Node_7 {
  NonOwningArrayList /* of GType_7 */ ^types_ = new NonOwningArrayList();
  TypeSet_7 ^destroys_;

  public void Add(GType_7 t) {
    Debug.Assert(t is Owning_7);
    types_.Add(t.BaseType());
  }

  public override TypeSet_7 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_7();
    foreach (GType_7 t in types_)
        destroys_.Add(t.TypeDestroys());
    }
    return destroys_;
  }
}

class Context_7 {
  public readonly Program_7 program_;   // containing program
  public readonly Class_7 class_;       // containing class
  public readonly Method_7 method_;     // containing method
  public readonly Escapable_7 escape_;  // containing switch, while, do, for, or foreach
  public readonly Loop_7 loop_;         // containing while, do, for, or foreach
  public Local_7 var_;    // chain of local variable declarations

  // subexpressions of the current top-level expression possibly yielding temporary objects
  NonOwningArrayList /* of Expression_7 */ ^temporaries_ = new NonOwningArrayList();

  public Context_7(Program_7 program) { program_ = program; }

  public Context_7(Class_7 cl) { program_ = cl.GetProgram(); class_ = cl; }

  // Copy a context; new variable declarations in either copy will not be visible in the other.
  public Context_7(Context_7 cx) {
    program_ = cx.program_;
    class_ = cx.class_;
    method_ = cx.method_;
    escape_ = cx.escape_;
    loop_ = cx.loop_;
    var_ = cx.var_;
  }

  public Context_7(Context_7 cx, Class_7 c) : this(cx) { class_ = c; }

  public Context_7(Context_7 cx, Method_7 m) : this(cx) { method_ = m; }

  public Context_7(Context_7 cx, Loop_7 l) : this(cx) {
    escape_ = l;
    loop_ = l;
  }

  public Context_7(Context_7 cx, Switch_7 s) : this(cx) { escape_ = s; }

  public bool IsStatic() { return method_ == null || method_.IsStatic(); }

  public void SetVar(Local_7 var) {
    var_ = var;
  }

  public Local_7 FindVar(string name) {
    for (Local_7 v = var_; v != null; v = v.next_)
      if (v.name_ == name)
        return v;
    return null;
  }

  public Control_7 Prev() { return program_.prev_; }

  public void SetPrev(Control_7 c) {
    Debug.Assert(c != null);
    program_.prev_ = c;
  }

  public void ClearPrev() { program_.prev_ = null; }

  // Called when we begin type-checking a top-level expression.
  public void EnterExpression() {
    Debug.Assert(temporaries_.Count == 0);
  }

  public void AddTemporary(Expression_7 e) {
    temporaries_.Add(e);
  }

  // Called when we've finished type-checking a top-level expression.
  public void FinishExpression() {
    Temporaries_7 t = null;
    foreach (Expression_7 e in temporaries_)
      if (!e.LosesOwnership()) {
        if (t == null)
          t = class_.NewTemporaries();
        t.Add(e.TemporaryType());
      }
    if (t != null)
      t.AddControl(this);
    temporaries_.Clear();
  }
}

class Env_7 : Map_7 {
  public readonly GValue_7 this_;
  readonly Env_7 next_;

  public Env_7(GValue_7 _this) { this_ = _this; next_ = null; }
  public Env_7(Env_7 next) { this_ = next.this_; next_ = next; }

  protected override MapNode_7 Find(object key) {
    for (Env_7 e = this; e != null; e = e.next_) {
      MapNode_7 n = e.Find1(key);
      if (n != null)
        return n;
    }
    Debug.Assert(false);
    return null;
  }

  public static readonly Env_7 ^static_ = new Env_7((GValue_7) null);
}

class TypeLiteral_7 : TypeExpr_7 {
  public readonly GType_7 type_;

  public TypeLiteral_7(GType_7 type) { type_ = type; }

  public override GType_7 Resolve(Program_7 program) {
    return type_;
  }

  public override TypeExpr_7 ^Copy() { return new TypeLiteral_7(type_); }
}

class TypeName_7 : TypeExpr_7 {
  string name_;

  public TypeName_7(string name) { name_ = name; }

  public override GType_7 Resolve(Program_7 program) {
    GType_7 type = program.FindClass(name_);
    if (type == null)
      Error("unknown type: {0}", name_);
    return type;
  }

  public override TypeExpr_7 ^Copy() { return new TypeName_7(name_); }
}

abstract class Traverser_7 {
  // Handle a graph item found in a depth first search; returns one of the exit codes below.
  public abstract int Handle(Control_7 control);

  public const int Continue_7 = 0,  // continue searching, including children of this node
                   Cut = 1,       // continue searching, excluding children of this node
                   Abort = 2;     // abort the search

}

// an item in the control graph: either a Node_7 or Joiner_7
abstract class Control_7 : Syntax_7 {
  public int marker_ = 0;    // marker for depth first search of control flow graph

  static int marker_value_ = 0;
  public static int GetMarkerValue() { return ++marker_value_; }

  // A node representing unreachability.  We could represent this using null, but it's
  // clearer to have this be explicit. 
  public static readonly Node_7 ^unreachable_ = new Node_7();

  // A helper function for Traverse.  If_7 we return true then we should cut the
  // traversal at this point.
  protected bool Visit(Traverser_7 traverser, int marker, out bool ok) {
    ok = true;
    if (marker_ == marker)
      return true;  // we've already seen this node
    marker_ = marker;
    int code = traverser.Handle(this);
    if (code == Traverser_7.Abort)
      ok = false;
    return (code != Traverser_7.Continue_7);
  }

  // Perform a depth-first search of the graph starting with this item, calling the
  // given Traverser_7 for each Node_7 found.  Returns false if the search was aborted.
  public abstract bool Traverse(Traverser_7 traverser, int marker);
}

// A node in the control graph.
class Node_7 : Control_7 {
  public Control_7 prev_;   // previous item in graph

  // add this node to the control graph
  public bool AddControl(Context_7 ctx) {
    Control_7 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      prev_ = prev;
      ctx.SetPrev(this);
      return true;
    }
    else return false;
  }

  // If_7 this node calls a method or constructor then return it; otherwise return null.
  // implementers: LValue_7, Invocation_7, New_7, Assign_7, Constructor_7
  public virtual Method_7 Calls() { return null; }

  // Return_7 the set of types which this node may destroy.
  // implementers: Assign_7, RefOutArgument_7, Scoped_7, Temporaries_7
  public virtual TypeSet_7 NodeDestroys() { return TypeSet_7.empty_; }

  // Return_7 true if this node assigns a value to the given Local_7.
  // implementers: Assign_7, RefOutArgument_7, VariableDeclaration_7, Method_7, ForEach_7
  public virtual bool Sets(Local_7 local) { return false; }

  // Return_7 true if this node takes ownership from the given local.
  // implementers: Name_7
  public virtual bool Takes(Local_7 local) { return false; }

  public bool CanDestroy(GType_7 type) {
    Method_7 m = Calls();
    if (m != null && m.Destroys().Contains(type))
      return true;
    return NodeDestroys().Contains(type);
  }

  public override bool Traverse(Traverser_7 traverser, int marker) {
    Node_7 n = this;
    Control_7 prev = null;

    // Traverse nodes iteratively until we come to a Join; this efficiently avoids
    // making a recursive call on each successive node.
    while (n != null) {
      bool ok;
      if (n.Visit(traverser, marker, out ok))
        return ok;
      prev = n.prev_;
      n = prev as Node_7;
    }
    Debug.Assert(prev != null);  // a Traverser_7 must end traversal before we run off the end
    return prev.Traverse(traverser, marker);
  }
}

class Joiner_7 : Control_7 {
  NonOwningArrayList /* of Control_7 */ ^prev_ = new NonOwningArrayList();

  public void Join(Control_7 c) {
    Debug.Assert(c != null);
    if (c == unreachable_)
      return;
    if (prev_.Count == 0 || c != prev_[0])
      prev_.Add(c);
  }

  // add this joiner to the control graph
  public void AddControl(Context_7 ctx) {
    Control_7 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      Join(prev);
      ctx.SetPrev(this);
    }
  }

  // Once we've finished merging paths into a Joiner_7, if the Joiner_7 points to only a single path
  // then as an optimization we can discard the Joiner_7 and just use that path instead.
  public Control_7 Combine() {
    switch (prev_.Count) {
      case 0:
        prev_ = null;
        return unreachable_;
      case 1:
        Control_7 c = (Control_7) prev_[0];
        prev_ = null;
        return c;
      default: return this;
    }
  }

  public override bool Traverse(Traverser_7 traverser, int marker) {
    bool ok;
    if (Visit(traverser, marker, out ok))
      return ok;

    foreach (Control_7 p in prev_)
      if (!p.Traverse(traverser, marker))
        return false;  // aborted
    return true;
  }
}

class ExprKind_7 {
  public const int Value = 0,

  // either a local variable, or an expression whose value is derived from local variables
                   Local_7 = 1,

                   Field_7 = 2,
                   Property_7 = 3,
                   Indexer_7 = 4,
                   Type = 5;
}

class SourceWriter_7 {
  public readonly StreamWriter writer_;
  int indent_ = 0;

  public SourceWriter_7(StreamWriter writer) { writer_ = writer; }

  public void AddIndent() { ++indent_; }
  public void SubIndent() { --indent_; }

  public void Indent(int adjust) {
    for (int i = 0; i < 2 * indent_ + adjust; ++i)
      writer_.Write(' ');
  }

  public void Indent() { Indent(0); }

  public void Write(string s) { writer_.Write(s); }
  public void Write(string s, object arg) { writer_.Write(s, arg); }
  public void Write(string s, object arg1, object arg2) { writer_.Write(s, arg1, arg2); }
  public void Write(string s, object arg1, object arg2, object arg3) { writer_.Write(s, arg1, arg2, arg3); }

  public void IWrite(string s) { Indent(); Write(s); }
  public void IWrite(string s, object arg) { Indent(); Write(s, arg); }
  public void IWrite(string s, object arg1, object arg2) { Indent(); Write(s, arg1, arg2); }
  public void IWrite(string s, object arg1, object arg2, object arg3) { Indent(); Write(s, arg1, arg2, arg3); }

  public void WriteLine(string s) { writer_.WriteLine(s); }
  public void WriteLine(string s, object arg) { writer_.WriteLine(s, arg); }
  public void WriteLine(string s, object arg1, object arg2) { writer_.WriteLine(s, arg1, arg2); }
  public void WriteLine(string s, object arg1, object arg2, object arg3) { writer_.WriteLine(s, arg1, arg2, arg3); }

  public void IWriteLine(string s) { Indent(); WriteLine(s); }
  public void IWriteLine(string s, object arg) { Indent(); WriteLine(s, arg); }
  public void IWriteLine(string s, object arg1, object arg2) { Indent(); WriteLine(s, arg1, arg2); }
  public void IWriteLine(string s, object arg1, object arg2, object arg3) { Indent(); WriteLine(s, arg1, arg2, arg3); }

  public void OpenBrace() { WriteLine("{"); AddIndent(); }
  public void CloseBrace() { SubIndent(); IWriteLine("}"); }
}

class Usage_7 {
  public const int Used = 0, LosesOwnership = 1, Unused = 2;
}

abstract class Expression_7 : Node_7 {
  protected int usage_ = Usage_7.Used;

  // start_ and end_ mark the points in the control graph where this expression is evaluated and used,
  // respectively.  If_7 this expression's type is owned, we use this information to determine whether
  // we need to emit a reference count for this expression.
  Control_7 start_;
  Control_7 end_;

  public abstract GType_7 Check(Context_7 ctx);

  public GType_7 CheckTop(Context_7 ctx) {
    ctx.EnterExpression();
    GType_7 t = Check(ctx);
    ctx.FinishExpression();
    return t;
  }

  public GType_7 CheckAndHold(Context_7 ctx) {
    GType_7 t = Check(ctx);
    if (t != null)
      HoldRef(ctx);
    return t;
  }

  // A fancier checking protocol implemented by lvalues and used by certain callers.
  public virtual GType_7 Check(Context_7 ctx, bool read, bool write, bool type_ok) {
    return Check(ctx);
  }

  public virtual int Kind() { return ExprKind_7.Value; }
  public virtual bool IsRefOutParameter() { return false; }

  public virtual bool IsTrueLiteral() { return false; }
  public virtual bool IsFalseLiteral() { return false; }

  // If_7 this expression is a local variable (possibly cast to a different type),
  // then return that local; otherwise return null.
  public virtual Local_7 GetLocal() { return null; }

  // Return_7 the type of an expression yielding a temporary object.
  // (It might be convenient to generalize this to be able to return any expression's type.)
  public virtual GType_7 TemporaryType() { Debug.Assert(false); return null; }

  public void HoldRef(Context_7 ctx) {
    start_ = ctx.Prev();
    Debug.Assert(start_ != null);
  }

  public void ReleaseRef(Context_7 ctx) {
    end_ = ctx.Prev();
    Debug.Assert(end_ != null);
  }

  public abstract RValue_7 ^Eval(Env_7 env);

  public bool Check(Context_7 ctx, GType_7 t2) {
    GType_7 t = Check(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public bool CheckTop(Context_7 ctx, GType_7 t2) {
    GType_7 t = CheckTop(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public RValue_7 ^Eval(Env_7 env, GType_7 t) {
    RValue_7 ^r = Eval(env);
    GValue_7 v = r.Get();
    return v.Convert(ref r, t);
  }

  public bool EvalBool(Env_7 env) { return ((GBool_7) Eval(env)).b_; }

  public int EvalInt(Env_7 env) {
    RValue_7 ^r = Eval(env, GInt_7.type_);
    GInt_7 i = (GInt_7) r;
    return i.i_;
  }

  public double EvalDouble(Env_7 env) { return ((GDouble_7) Eval(env, GDouble_7.type_)).d_; }
  public float EvalFloat(Env_7 env) { return ((GFloat_7) Eval(env, GFloat_7.type_)).f_; }
  public string EvalString(Env_7 env) { return ((GString_7) Eval(env)).s_; }

  public virtual bool IsConstant() {
    return false;
  }

  public bool CheckConstant() {
    if (IsConstant())
      return true;
    Error("expression must be a constant");
    return false;
  }

  public bool LosesOwnership() { return usage_ == Usage_7.LosesOwnership; }

  public virtual void LoseOwnership() {
    usage_ = Usage_7.LosesOwnership;
  }

  public void SetUnused() {
    Debug.Assert(usage_ == Usage_7.Used);
    usage_ = Usage_7.Unused;
  }

  protected static string EmitAllocate(string type, string args, bool lose_ownership) {
    // If_7 an allocated object never loses ownership then it can be stack allocated.  We
    // can't emit "&Foo(...)" since standard C++ doesn't allow us to take the address
    // of a temporary (both GCC and Visual C++ will allow this, but will emit a warning).
    // So instead we call a function _Addr() to get the address.
    return String.Format(
      !lose_ownership ? "{0}({1})._Addr<{0} *>()" : "new {0}({1})",
      type, args);
  }

  public void CheckLoseOwnership(GType_7 from, GType_7 to) {
    if (to is Owning_7)
      LoseOwnership();
  }

  public abstract string Emit();    // return a C++ expression representing this GEL2 expression

  public bool NeedsRef(GType_7 type) {
    return Gel_7.program_.safe_ && type.IsOwned() && ExpressionTraverser_7.NeedRef(start_, end_, this, type);
  }

  // Emit this expression, adding a reference-counting _Ptr wrapper if needed.
  public string EmitRef(GType_7 type) {
    string s = Emit();
    if (NeedsRef(type))
      s = String.Format("{0}({1}).Get()", type.EmitType(), s);
    return s;
  }

  // Emit an implicit conversion from type [source] to type [dest].
  public static string EmitImplicit(GType_7 source, GType_7 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (!source.IsReference() && dest == GObject_7.type_) {   // a boxing conversion
      Class_7 c = (Class_7) source;
      return EmitAllocate(c.name_, val, loses_ownership);
    }

    if (source == GInt_7.type_ && dest == GFloat_7.type_)
      // an implicit conversion in GEL2, but C++ compilers may warn if we don't use a cast
      return String.Format("static_cast<float>({0})", val);
    
    return val;
  }

  // Emit this expression, converting implicitly from type [source] to type [dest].
  public string Emit(GType_7 source, GType_7 dest) {
    return EmitImplicit(source, dest, Emit(), LosesOwnership());
  }

  public string EmitRef(GType_7 source, GType_7 dest) {
    return EmitImplicit(source, dest, EmitRef(source), LosesOwnership());
  }

  public static string EmitExplicit(GType_7 source, GType_7 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (source.CanConvert(dest)) {
      string v = EmitImplicit(source, dest, val, loses_ownership);
      if (v != val)
        return v;

      // There's nothing to do, but we emit a static_cast anyway since a GEL2 programmer
      // may use a type cast for method call disambiguation; we want to pass such casts onward.
      return String.Format("static_cast<{0} >({1})", dest.EmitExprType(), val);
    }

    if (source.IsReference() && dest.IsReference()) {
      string s = String.Format("_Cast<{0} *>({1})", dest.EmitTypeName(), val);
      ArrayType_7 at = dest as ArrayType_7;
      if (at != null) {
        GType_7 element_type = at.ElementType();
        if (element_type.IsReference())
          s = String.Format("({0})->CheckType(&typeid({1}))", s, element_type.EmitType());
      }
      return s;
    }

    if (source == GObject_7.type_ && !dest.IsReference())  // unboxing conversion
      return String.Format("_Unbox<{0} *>({1})->Value()", ((Class_7) dest).name_, val);

    if (!source.IsReference() && !dest.IsReference())
      return String.Format("static_cast<{0}>({1})", dest.EmitType(), val);

    Debug.Assert(false);
    return null;
  }

  public string EmitExplicit(GType_7 source, GType_7 dest) {
    return EmitExplicit(source, dest, Emit(), LosesOwnership());
  }

  public virtual string EmitArrow(GType_7 t, Member_7 m) {
    return String.Format("({0})->", EmitRef(t));
  }

  // Emit this expression as a local or field initializer, implicitly casting to [type].
  public void EmitAsInitializer(SourceWriter_7 w, GType_7 initializer_type, GType_7 type) {
    // For_7 owning variables, we must emit an initializer of the form "Foo var(val)" since
    // _Own has no copy constructor and hence GCC won't allow "Foo var = val".  For_7 other
    // variables either form is valid, but we emit the second form since it looks clearer.
    w.Write(type is Owning_7 ? "({0})" : " = {0}", Emit(initializer_type, type));
  }

  // Given a value retrieved from a variable, emit an accessor call if needed.
  protected string OwnSuffix(GType_7 t) {
    if (t is Owning_7)
      return LosesOwnership() ? ".Take_7()" : ".Get()";
    if (t == GString_7.type_ || Gel_7.program_.safe_ && t.IsReference() )
      return ".Get()";
    return "";
  }

  // Given a value returned from a function call, emit a wrapper and/or accessor call if needed.
  protected string Hold(GType_7 t, string s) {
    if (t == GString_7.type_)
      return s + ".Get()";
    if (t is Owning_7)
      switch (usage_) {
        case Usage_7.Used:  // does not lose ownership; we need a freeing wrapper
          return String.Format("{0}({1}).Get()", t.EmitType(), s);
        case Usage_7.LosesOwnership:
          return s;
        case Usage_7.Unused:  // a top-level owning expression
          return "delete " + s;
        default: Debug.Assert(false); break;
      }
    return s;
  }
}

class Literal_7 : Expression_7 {
  public readonly SimpleValue_7 ^value_;

  public Literal_7(SimpleValue_7 ^v) { value_ = v; }

  public override bool IsTrueLiteral() {
    GBool_7 b = value_ as GBool_7;
    return b != null && b.b_;
  }

  public override bool IsFalseLiteral() {
    GBool_7 b = value_ as GBool_7;
    return b != null && !b.b_;
  }

  public override GType_7 Check(Context_7 ctx) { return value_.Type(); }

  public override RValue_7 ^Eval(Env_7 env) { return value_.Copy(); }

  public override bool IsConstant() { return true; }

  public override string Emit() { return value_.Emit(); }
}

// An LValue_7 is an expression which can be assigned to: a Name_7, Dot_7, or Sub_7.
//
// In the control graph, an LValue_7 represents a read; if an LValue_7 is written then
// some other node (e.g. an Assign_7) will appear representing the write.
abstract class LValue_7 : Expression_7 {
  public override GType_7 Check(Context_7 ctx) {
    return Check(ctx, true, false, false);
  }

  public abstract override GType_7 Check(Context_7 ctx, bool read, bool write, bool type_ok);

  public abstract GType_7 StorageType();

  public virtual bool IsLocal() { return false; }
  public virtual bool IsLocal(Local_7 l) { return false; }

  public abstract PropertyOrIndexer_7 GetPropertyOrIndexer();

  public override Method_7 Calls() {
    PropertyOrIndexer_7 pi = GetPropertyOrIndexer();
    return pi == null ? null : pi.Getter();
  }

  public virtual void ReleaseAll(Context_7 ctx) { }

  // For_7 LValues, evaluation proceeds in two stages: the caller first calls Eval1(), then
  // passes the resulting values to EvalGet(), EvalSet() and/or EvalLocation().  This_7 lets
  // us evaluate the left side of an assignment expression before evaluating the right side,
  // and also lets us get and then set an indexer without evaluating its expression twice.

  public abstract void Eval1(Env_7 env, out RValue_7 ^v1, out RValue_7 ^v2);
  public abstract RValue_7 ^EvalGet(Env_7 env, RValue_7 ^v1, RValue_7 ^v2);
  public abstract void EvalSet(Env_7 env, RValue_7 ^v1, RValue_7 ^v2, RValue_7 ^val);
  public abstract Location_7 EvalLocation(Env_7 env, RValue_7 ^v1, RValue_7 ^v2);

  public override RValue_7 ^Eval(Env_7 env) {
    RValue_7 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalGet(env, val1, val2);
  }

  public void EvalSet(Env_7 env, RValue_7 ^v) {
    RValue_7 ^val1, val2;
    Eval1(env, out val1, out val2);
    EvalSet(env, val1, val2, v);
  }

  public Location_7 EvalLocation(Env_7 env) {
    RValue_7 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalLocation(env, val1, val2);
  }

  public abstract string EmitSet(string val);

  public abstract string EmitLocation();
}

class Name_7 : LValue_7 {
  public readonly string name_;

  protected Local_7 local_;
  protected LMember_7 field_;  // a field or property

  public Name_7(string n) { name_ = n; }

  public override bool IsLocal() { return local_ != null; }
  public override bool IsLocal(Local_7 l) { return local_ == l; }
  public override bool IsRefOutParameter() { return local_ is RefOutParameter_7; }

  public override bool IsConstant() {
    Debug.Assert(local_ != null || field_ != null);   // make sure we were already type checked
    return field_ is ConstField_7;
  }

  public override GType_7 Check(Context_7 ctx, bool read, bool write, bool type_ok) {
    local_ = ctx.FindVar(name_);
    if (local_ != null) {
      // For_7 reads, we add this Name_7 node to the flow graph; for writes,
      // the caller must add a node which defines this Name_7.
      if (read)
        if (AddControl(ctx))
          local_.AddUse(this);
      if (write)
        local_.SetMutable();
      return local_.ReadType();
    }

    GType_7 cl = type_ok ? ctx.program_.FindClass(name_) : null;
    field_ = (LMember_7) ctx.class_.Lookup(this, ctx.class_, false, MemberKind_7.Field_7, name_, null, cl == null);
    if (field_ != null) {
      if (!field_.CheckAccess(this, ctx, write, true, !ctx.IsStatic()))
        return null;
      if (read) {
        // Only property reads have side effects we need to register in the control graph.
        if (field_ is Property_7)
          AddControl(ctx);
      }
      return field_.Type().BaseType();
    }

    return cl;
  }

  public override int Kind() {
    if (local_ != null)
      return ExprKind_7.Local_7;
    if (field_ is Field_7)
      return ExprKind_7.Field_7;
    if (field_ is Property_7)
      return ExprKind_7.Property_7;
    Debug.Assert(field_ == null);
    return ExprKind_7.Type;
  }

  public override Local_7 GetLocal() { return local_; }

  public override GType_7 StorageType() { return local_ != null ? local_.Type() : field_.Type(); }

  public override bool Takes(Local_7 local) {
    return local_ == local && LosesOwnership() && local.Type() is Owning_7;
  }

  public override PropertyOrIndexer_7 GetPropertyOrIndexer() { return field_ as Property_7; }

  public override void Eval1(Env_7 env, out RValue_7 ^v1, out RValue_7 ^v2) { v1 = v2 = null; }

  public override RValue_7 ^EvalGet(Env_7 env, RValue_7 ^v1, RValue_7 ^v2) {
    if (LosesOwnership() && StorageType() is Owning_7)
      return local_ != null ? env.Take_7(local_) : field_.Take_7(env.this_);
    else return local_ != null ? env.Get(local_) : field_.Get(env.this_);
  }

  public override void EvalSet(Env_7 env, RValue_7 ^v1, RValue_7 ^v2, RValue_7 ^val) {
    if (local_ != null)
      env.Set(local_, val);
    else field_.Set((GObject_7) env.this_, val);
  }

  public override Location_7 EvalLocation(Env_7 env, RValue_7 ^v1, RValue_7 ^v2) {
    return local_ != null ? env.GetLocation(local_) : field_.GetLocation((GObject_7) env.this_);
  }

  public override string Emit() {
    if (local_ != null) {
      string s = local_.Emit();
      return local_.IsWrapper() ? s + OwnSuffix(local_.Type()) : s;
    }
    if (field_ != null)
      return field_.Emit() + OwnSuffix(field_.Type());
    return name_;
  }

  public override string EmitSet(string val) {
    if (local_ != null)
      return String.Format("{0} = {1}", local_.Emit(), val);
    Debug.Assert(field_ != null);
    return field_.EmitSet(val);
  }

  public override string EmitLocation() {
    if (local_ != null)
      return "&" + local_.Emit();
    if (field_ != null)
      return "&" + field_.Emit();
    return "&" + name_;
  }
}

class Parenthesized_7 : Expression_7 {
  Expression_7 ^expr_;

  public Parenthesized_7(Expression_7 ^e) { expr_ = e; }

  public override GType_7 Check(Context_7 ctx) { return expr_.Check(ctx); }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_7 ^Eval(Env_7 env) { return expr_.Eval(env); }

  public override string Emit() { return String.Format("({0})", expr_.Emit()); }
}

class PredefinedType_7 : Expression_7 {
  Class_7 type_;

  public PredefinedType_7(Class_7 type) { type_ = type; }

  public override GType_7 Check(Context_7 ctx) { Debug.Assert(false); return null; }

  public override GType_7 Check(Context_7 ctx, bool read, bool write, bool type_ok) {
    Debug.Assert(type_ok);
    return type_;
  }

  public override int Kind() {
    return ExprKind_7.Type;
  }

  public override RValue_7 ^Eval(Env_7 env) { Debug.Assert(false); return null; }

  public override string Emit() { return type_.name_; }
}

class Dot_7 : LValue_7 {
  Expression_7 ^expr_;  // set to null for a static invocation
  GType_7 expr_type_;
  string name_;

  LMember_7 field_;

  public Dot_7(Expression_7 ^expr, string name) { expr_ = expr; name_ = name; }

  public override bool IsConstant() {
    Debug.Assert(field_ != null);   // make sure we were already type checked
    return field_ is ConstField_7;
  }

  public override GType_7 Check(Context_7 ctx, bool read, bool write, bool type_ok) {
    expr_type_ = expr_.Check(ctx, true, false, true);
    if (expr_type_ == null)
      return null;
    bool is_static = (expr_.Kind() == ExprKind_7.Type);
    if (is_static)
      expr_ = null;
    else expr_.HoldRef(ctx);

    field_ = (LMember_7) expr_type_.Lookup(this, ctx.class_, expr_ is Base_7,
                                         MemberKind_7.Field_7, name_, null, true);
    if (field_ == null)
      return null;

    if (!field_.CheckAccess(this, ctx, write, is_static, !is_static))
      return null;

    if (read) {
      // Only property reads have side effects we need to register in the control graph.
      // (For_7 writes the caller, such as Assign_7, will add its own node.)
      if (field_ is Property_7)
        AddControl(ctx);
      if (expr_ != null)
        expr_.ReleaseRef(ctx);
    }

    return field_.Type().BaseType();
  }

  public override void ReleaseAll(Context_7 ctx) {
    if (expr_ != null)
      expr_.ReleaseRef(ctx);
  }

  public override int Kind() {
    if (field_ is Field_7)
      return ExprKind_7.Field_7;
    if (field_ is Property_7)
      return ExprKind_7.Property_7;
    Debug.Assert(false);
    return 0;
  }

  public override GType_7 StorageType() { return field_.Type(); }

  public override PropertyOrIndexer_7 GetPropertyOrIndexer() { return field_ as Property_7; }

  public override void Eval1(Env_7 env, out RValue_7 ^v1, out RValue_7 ^v2) {
    v1 = v2 = null;
    if (expr_ != null) {  // instance field
      v1 = expr_.Eval(env);
      if (v1 is Null_7) {
        Error("attempted to access field of null object");
        Gel_7.Exit();
      }
    }
  }

  public override RValue_7 ^EvalGet(Env_7 env, RValue_7 ^v1, RValue_7 ^v2) {
    GValue_7 obj = v1 == null ? null : v1.Get();
    return LosesOwnership() && field_.Type() is Owning_7 ? field_.Take_7(obj) : field_.Get(obj);
  }

  public override void EvalSet(Env_7 env, RValue_7 ^v1, RValue_7 ^v2, RValue_7 ^val) {
    GObject_7 obj = v1 == null ? null : (GObject_7) v1.Get();
    field_.Set(obj, val);
  }

  public override Location_7 EvalLocation(Env_7 env, RValue_7 ^v1, RValue_7 ^v2) {
    return field_.GetLocation((GObject_7) v1);
  }

  string EmitPrefix() {
    return expr_ != null ?
      expr_.EmitArrow(expr_type_, field_) :  // instance access
      field_.GetClass().name_ + "::";   // static access
  }

  public override string Emit() {
    string s = EmitPrefix() + field_.Emit();
    GType_7 t = field_.Type();
    return field_ is Property_7 ? Hold(t, s) : s + OwnSuffix(t);
  }

  public override string EmitSet(string val) {
    return EmitPrefix() + field_.EmitSet(val);
  }

  public override string EmitLocation() {
    return "&" + EmitPrefix() + field_.Emit();
  }
}

class Mode_7 {
  public const int In = 0,
                   Ref = 1,
                   Out = 2;

  public static string ToString(int mode) {
    switch (mode) {
      case In: return "";
      case Ref: return "ref ";
      case Out: return "out ";
      default: Debug.Assert(false); return null;
    }
  }
}

abstract class Argument_7 : Node_7 {
  protected GType_7 type_;

  public GType_7 Type() { return type_; }

  public abstract int GetMode();
  public string TypeString() { return Mode_7.ToString(GetMode()) + type_.ToString(); }

  public abstract bool Check(Context_7 ctx);
  public abstract void FinishCall(Context_7 ctx);

  public abstract void AddEval(ArrayList a, Env_7 env, GType_7 t);

  public abstract string Emit(GType_7 t);
}

class InArgument_7 : Argument_7 {
  public readonly Expression_7 ^expr_;

  public InArgument_7(Expression_7 ^expr) { expr_ = expr; }
  public InArgument_7(GType_7 type) { type_ = type; }

  public override int GetMode() { return 0; }

  public override bool Check(Context_7 ctx) {
    if (type_ == null)
      type_ = expr_.CheckAndHold(ctx);
    return type_ != null;
  }

  public override void FinishCall(Context_7 ctx) {
    expr_.ReleaseRef(ctx);
  }

  public override void AddEval(ArrayList a, Env_7 env, GType_7 t) {
    a.Add(expr_.Eval(env, t));
  }

  public override string Emit(GType_7 t) {
    return expr_.EmitRef(type_, t);
  }
}

class RefOutArgument_7 : Argument_7 {
  public readonly int mode_;
  public readonly LValue_7 ^lvalue_;

  public RefOutArgument_7(int mode, LValue_7 ^lvalue) { mode_ = mode; lvalue_ = lvalue; }

  public override int GetMode() { return mode_; }

  public override bool Check(Context_7 ctx) {
    type_ = lvalue_.Check(ctx, mode_ == Mode_7.Ref, true, false);
    if (type_ == null)
      return false;
    if (lvalue_.Kind() == ExprKind_7.Indexer_7) {
      Error("can't pass indexer as ref or out argument");
      return false;
    }
    return true;
  }

  public override void FinishCall(Context_7 ctx) {
    AddControl(ctx);
  }

  public override bool Sets(Local_7 local) { return lvalue_.IsLocal(local); }

  public override TypeSet_7 NodeDestroys() { return lvalue_.StorageType().VarDestroys(); }

  public GType_7 StorageType() { return lvalue_.StorageType(); }

  public override void AddEval(ArrayList a, Env_7 env, GType_7 t) {
    a.Add(new LocationRef_7(lvalue_.EvalLocation(env)));
  }

  public override string Emit(GType_7 t) { return lvalue_.EmitLocation(); }
}

class Invocation_7 : Expression_7 {
  Expression_7 ^obj_;    // may be null
  GType_7 obj_type_;
  string name_;
  ArrayList /* of Argument_7 */ ^arguments_;

  Method_7 method_;

  public Invocation_7(Expression_7 ^obj, string name, ArrayList ^arguments) {
    obj_ = obj; name_ = name; arguments_ = arguments;
  }

  public static Method_7 CheckInvoke(Node_7 caller, Context_7 ctx, bool through_base, GType_7 type,
                                   string name, ArrayList /* of Argument_7 */ arguments,
                                   int kind) {
    foreach (Argument_7 arg in arguments)
      if (!arg.Check(ctx))
        return null;

    // Add the caller to the graph; this node represents the invocation itself.
    caller.AddControl(ctx);

    // Now we can release temporary expressions and add control graph nodes representing
    // assignments to ref and out parameters.
    foreach (Argument_7 arg in arguments)
      arg.FinishCall(ctx);

    Method_7 m = (Method_7) type.Lookup(caller, ctx.class_, through_base, kind, name, arguments, true);
    if (m != null)
      for (int i = 0; i < m.parameters_.Count; ++i) {
        Parameter_7 p = m.Param(i);
        if (p.GetMode() == Mode_7.In) {
          InArgument_7 a = (InArgument_7) arguments[i];
          a.expr_.CheckLoseOwnership(a.Type(), p.Type());
        }
      }
    return m;
  }

  public override GType_7 Check(Context_7 ctx) {
    GType_7 t;
    bool is_class = false;  // true when calling a static method using a class name

    if (obj_ == null)
      t = ctx.class_;
    else {
      t = obj_type_ = obj_.Check(ctx, true, false, true);
      if (t == null)
        return null;
      if (obj_.Kind() == ExprKind_7.Type)
        is_class = true;
      else obj_.HoldRef(ctx);
    }

    method_ = CheckInvoke(this, ctx, obj_ is Base_7, t, name_, arguments_, MemberKind_7.Method_7);
    if (method_ == null)
      return null;

    if (method_ is Constructor_7) {
      Error("can't call constructor directly");
      return null;
    }

    if (obj_ == null) {
      if (!method_.IsStatic() && ctx.IsStatic()) {
        Error("can't call instance method in static context");
        return null;
      }
    } else {
      obj_.ReleaseRef(ctx);
      if (is_class) {
        if (!method_.IsStatic()) {
          Error("can't invoke non-static method through class name");
          return null;
        }
      } else {
        if (method_.IsStatic()) {
          Error("can't invoke static method through object");
          return null;
        }
      }
    }

    GType_7 ret = method_.ReturnType();
    if (ret is Owning_7)
      ctx.AddTemporary(this);
    return ret;
  }

  public override GType_7 TemporaryType() { return method_.ReturnType(); }

  public override Method_7 Calls() { return method_; }

  public static RValue_7 ^InvokeMethod(GValue_7 obj, Method_7 m, ArrayList /* of RValue_7 */ values,
                                    bool virtual_ok) {
    if (m.IsVirtual() && virtual_ok) {
      GType_7 t = obj.Type();
      m = (Method_7) t.FindMatchingMember(m, true);
      Debug.Assert(m != null);
    }
    return m.Invoke(obj, values);
  }

  public static RValue_7 ^CallMethod(Env_7 env, GValue_7 obj,
                                  Method_7 m, ArrayList /* of Argument_7 */ args,
                                  bool virtual_ok) {
    ArrayList /* of ValueOrLocation_7 */ ^values = new ArrayList();
    int i;
    for (i = 0 ; i < args.Count ; ++i) {
      Argument_7 a = (Argument_7) args[i];
      a.AddEval(values, env, m.Param(i).Type());
    }
    return InvokeMethod(obj, m, values, virtual_ok);
  }

  public RValue_7 ^Eval(Env_7 env, Expression_7 obj, Method_7 m, ArrayList /* of Argument_7 */ args) {
    RValue_7 ^r;
    GValue_7 v;
    if (m.IsStatic())
      v = null;
    else {
      if (obj == null)
        v = env.this_;
      else {
        r = obj.Eval(env);
        v = r.Get();
        if (v is Null_7) {
          Error("attempted to call method on null object");
          Gel_7.Exit();
        }
      }
    }

    return CallMethod(env, v, m, args, !(obj is Base_7));
  }

  public override RValue_7 ^Eval(Env_7 env) {
    return Eval(env, obj_, method_, arguments_);
  }

  public static string EmitArguments(Method_7 m, ArrayList /* of Argument_7 */ arguments) {
    StringBuilder ^sb = new StringBuilder();
    Debug.Assert(m.parameters_.Count == arguments.Count);
    for (int i = 0; i < arguments.Count; ++i) {
      if (i > 0)
        sb.Append(", ");
      Argument_7 a = (Argument_7)arguments[i];
      sb.Append(a.Emit(m.Param(i).Type()));
    }
    return sb.ToString();
  }

  public override string Emit() {
    StringBuilder ^sb = new StringBuilder();
    if (obj_ != null) {
      if (method_.IsStatic())
        sb.AppendFormat("{0}::", obj_.Emit());
      else if (obj_type_.IsReference())
        sb.Append(obj_.EmitArrow(obj_type_, method_));
      else sb.AppendFormat("({0})->", obj_.Emit(obj_type_, GObject_7.type_));   // box values
    }
    sb.AppendFormat("{0} ({1})", method_.name_, EmitArguments(method_, arguments_));
    return Hold(method_.ReturnType(), sb.ToString());
  }
}

// an expression of the form a[b]
class Sub_7 : LValue_7 {
  readonly Expression_7 ^base_;
  GType_7 base_type_;
  readonly Expression_7 ^index_;
  GType_7 index_type_;

  GType_7 element_type_;    // for array accesses; null for indexers
  Indexer_7 indexer_;

  public Sub_7(Expression_7 ^base_exp, Expression_7 ^index) { base_ = base_exp; index_ = index; }

  public override GType_7 Check(Context_7 ctx, bool read, bool write, bool type_ok) {
    base_type_ = base_.CheckAndHold(ctx);
    if (base_type_ == null)
      return null;

    index_type_ = index_.CheckAndHold(ctx);
    if (index_type_ == null)
      return null;

    if (read)
      ReleaseAll(ctx);

    ArrayType_7 at = base_type_.BaseType() as ArrayType_7;
    if (at != null) {
      if (!index_type_.CheckConvert(this, GInt_7.type_))
        return null;
      element_type_ = at.ElementType();
      return element_type_.BaseType();
    }

    ArrayList ^arguments = new ArrayList();
    arguments.Add(new InArgument_7(index_type_));

    indexer_ = (Indexer_7) base_type_.Lookup(this, ctx.class_, base_ is Base_7,
                                           MemberKind_7.Indexer_7, null, arguments, true);
    if (indexer_ == null)
      return null;

    if (read && !indexer_.CheckAssigning(this, ctx, false) ||
        write && !indexer_.CheckAssigning(this, ctx, true))
      return null;

    if (read)
      AddControl(ctx);

    return indexer_.Type();
  }

  public override void ReleaseAll(Context_7 ctx) {
    base_.ReleaseRef(ctx);
    index_.ReleaseRef(ctx);
  }

  public override int Kind() {
    return element_type_ != null ? ExprKind_7.Field_7 : ExprKind_7.Indexer_7;
  }

  public override GType_7 StorageType() {
    return element_type_ != null ? element_type_ : indexer_.Type();
  }

  public override PropertyOrIndexer_7 GetPropertyOrIndexer() { return indexer_; }

  public override void Eval1(Env_7 env, out RValue_7 ^v1, out RValue_7 ^v2) {
    v1 = base_.Eval(env);
    if (v1 is Null_7) {
      Error("attempted array or indexer access through null");
      Gel_7.Exit();
    }
    v2 = index_.Eval(env);
  }

  int Index(RValue_7 ^v) {
    // ++ We get an ownership error if we combine the following two lines into one; why?
    v = v.Get().Convert(ref v, GInt_7.type_);
    return ((GInt_7) v).i_;
  }

  public override RValue_7 ^EvalGet(Env_7 env, RValue_7 ^v1, RValue_7 ^v2) {
    if (indexer_ == null) {
      GArray_7 arr = (GArray_7) v1.Get();
      int i = Index(v2);
      return LosesOwnership() && element_type_ is Owning_7 ? arr.Take_7(i) : arr.Get(i);
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    return Invocation_7.InvokeMethod(v1.Get(), indexer_.Getter(), args, true);
  }

  public override void EvalSet(Env_7 env, RValue_7 ^v1, RValue_7 ^v2, RValue_7 ^val) {
    if (indexer_ == null) {
      ((GArray_7) v1.Get()).Set(Index(v2), val);
      return;
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    args.Add(val);
    Invocation_7.InvokeMethod(v1.Get(), indexer_.Setter(), args, true);
  }

  public override Location_7 EvalLocation(Env_7 env, RValue_7 ^v1, RValue_7 ^v2) {
    int i = ((GInt_7) v2).i_;
    return ((GArray_7) v1).GetLocation(i);
  }

  string EmitBase() {
    return base_.EmitArrow(base_type_, indexer_);
  }

  string EmitIndex() {
    return index_.Emit(index_type_, indexer_ != null ? indexer_.parameter_.Type() : GInt_7.type_);
  }

  public override string Emit() {
    string get = String.Format("{0}get_Item({1})", EmitBase(), EmitIndex());
    if (element_type_ != null) {
      get = get + OwnSuffix(element_type_);
      if (!element_type_.IsValue())
        get = String.Format("static_cast<{0} >({1})", element_type_.EmitExprType(), get);
      return get;
    } else return Hold(indexer_.Type(), get);
  }

  public override string EmitSet(string val) {
    return String.Format(element_type_ != null ? "{0}get_Item({1}) = {2}" : "{0}set_Item({1}, {2})",
       EmitBase(), EmitIndex(), val);
  }

  public override string EmitLocation() {
    return String.Format("{0}get_location({1})", EmitBase(), EmitIndex());
  }
}

class This_7 : Expression_7 {
  public override GType_7 Check(Context_7 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access this in a static context");
      return null;
    }
    return ctx.class_;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    return new Reference_7(env.this_);
  }

  public override string Emit() { return "this"; }
}

class Base_7 : Expression_7 {
  Class_7 parent_;

  public override GType_7 Check(Context_7 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access base in a static context");
      return null;
    }
    parent_ = ctx.class_.Parent();
    if (parent_ == null) {
      Error("can't access base: class has no parent");
      return null;
    }
    return parent_;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    return new Reference_7(env.this_);
  }

  public override string Emit() { return "this"; }

  public override string EmitArrow(GType_7 t, Member_7 m) {
    return m.GetClass().name_ + "::"; 
  }
}

class New_7 : Expression_7 {
  Expression_7 ^creator_;    // either a pool or null
  TypeExpr_7 ^type_expr_;
  ArrayList /* of Expression_7 */ ^arguments_;

  Class_7 class_;
  Constructor_7 constructor_;

  public New_7(Expression_7 ^creator, TypeExpr_7 ^expr, ArrayList ^arguments) {
    creator_ = creator;
    type_expr_ = expr;
    arguments_ = arguments;
  }

  GType_7 Type() {
    return creator_ == null ? (GType_7) class_.OwningType() : class_;
  }

  public override GType_7 TemporaryType() { return Type(); }    

  public override GType_7 Check(Context_7 ctx) {
    if (creator_ != null) {
      GType_7 c = creator_.Check(ctx);
      if (c == null)
        return null;
      if (!c.BaseType().IsSubtype(PoolClass_7.instance_)) {
        Error("object creator must be a pool");
        return null;
      }
    }
    GType_7 t = type_expr_.Resolve(ctx.program_);
    if (t == null)
      return null;
    class_ = (Class_7) t;
    if (class_.HasAttribute(Attribute_7.Abstract)) {
      Error("can't instantiate abstract class");
      return null;
    }
    if (creator_ != null) {
      class_.NeedDestroy(); // every pool-allocated class needs the _Destroy1 and _Destroy2 methods
      class_.SetVirtual();  // every pool-allocated class must be virtual
    }

    constructor_ = (Constructor_7) Invocation_7.CheckInvoke(this, ctx, false, class_,
                                      class_.name_, arguments_, MemberKind_7.Constructor_7);
    if (constructor_ == null)
      return null;

    GType_7 type = Type();
    if (type is Owning_7)
      ctx.AddTemporary(this);
    return type;
  }

  public override Method_7 Calls() { return constructor_; }

  public override RValue_7 ^Eval(Env_7 env) {
    GValue_7 ^obj = class_.New_7();
    Invocation_7.CallMethod(env, obj, constructor_, arguments_, false);
    return obj;
  }

  public override string Emit() {
    string args = Invocation_7.EmitArguments(constructor_, arguments_);

    return creator_ == null ?
      EmitAllocate(class_.name_, args, LosesOwnership()) :
      String.Format("new ({0}->Alloc(sizeof({1}))) {1}({2})", creator_.Emit(), class_.name_, args);
  }
}

class ArrayInitializer_7 : Expression_7 {
  public readonly ArrayList /* of Expression_7 */ ^initializers_;

  public ArrayInitializer_7(ArrayList ^initializers) { initializers_ = initializers; }

  public override GType_7 Check(Context_7 ctx) {
    Error("only static fields may have array initializers");
    return null;
  }

  public bool CheckElements(Context_7 ctx, GType_7 element_type) {
    foreach (Expression_7 e in initializers_)
      if (!e.CheckConstant() || !e.Check(ctx, element_type))
        return false;
    return true;
  }

  public override RValue_7 ^Eval(Env_7 env) { Debug.Assert(false); return null; }

  public GArray_7 ^Eval(ArrayType_7 type) {
    GArray_7 ^a = new GArray_7(type, initializers_.Count);
    for (int i = 0; i < initializers_.Count; ++i) {
      Expression_7 e = (Expression_7) initializers_[i];
      a.Set(i, e.Eval(Env_7.static_, type.ElementType()));
    }
    return a;
  }

  public override string Emit() { Debug.Assert(false); return null; }

  public void Emit(SourceWriter_7 w) {
    int count = initializers_.Count;
    int per_row = 12;

    w.Write("{ ");
    if (count > per_row) {    // format onto multiple rows
      w.WriteLine("");
      w.AddIndent();
      w.Indent();
    }
    for (int i = 0; i < count; ++i) {
      if (i > 0) {
        w.Write(", ");
        if (i % per_row == 0) {
          w.WriteLine("");
          w.Indent();
        }
      }
      Expression_7 e = (Expression_7) initializers_[i];
      SimpleValue_7 ^v = (SimpleValue_7) e.Eval(Env_7.static_);
      w.Write(v.Emit());
    }
    if (count > per_row) {
      w.SubIndent();
      w.WriteLine("");
    }
    w.Write(" }");
  }
}

class NewArray_7 : Expression_7 {
  TypeExpr_7 ^element_type_expr_;
  int dimensions_;
  ArrayType_7 ^array_type_;

  Expression_7 ^count_;

  public NewArray_7(TypeExpr_7 ^element_type_expr, int dimensions, Expression_7 ^count) {
    element_type_expr_ = element_type_expr;
    dimensions_ = dimensions;
    count_ = count;
  }

  GType_7 Type() {
    return (GType_7) array_type_.OwningType();
  }

  public override GType_7 TemporaryType() { return Type(); }

  public override GType_7 Check(Context_7 ctx) {
    if (element_type_expr_ is ArrayTypeExpr_7) {
      Error("syntax error in new expression");
      return null;
    }
    for (int i = 0; i < dimensions_; ++i)
      element_type_expr_ = new ArrayTypeExpr_7(take element_type_expr_);
    GType_7 element_type = element_type_expr_.Resolve(ctx.program_);
    if (element_type == null)
      return null;
    array_type_ = new ArrayType_7(element_type);

    if (!count_.Check(ctx, GInt_7.type_))
      return null;

    GType_7 t = Type();
    if (t is Owning_7)
      ctx.AddTemporary(this);
    return t;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    return new GArray_7(array_type_, count_.EvalInt(env));
  }

  public override string Emit() {
    GType_7 t = array_type_.ElementType();
    string array_type = GType_7.ConstructType(
      t is Owning_7 ? "_Array" : "_CopyableArray",
      t.EmitGenericType());
    string args = String.Format("&typeid({0}), {1}", t.EmitType(), count_.Emit());
    return EmitAllocate(array_type, args, LosesOwnership());
  }
}

abstract class Unary_7 : Expression_7 {
  protected Expression_7 ^exp_;

  protected Unary_7(Expression_7 ^e) { exp_ = e; }

  public override bool IsConstant() { return exp_.IsConstant(); }
}

// unary minus operator
class Minus_7 : Unary_7 {
  GType_7 type_;

  public Minus_7(Expression_7 ^e) : base(e) { }

  public override GType_7 Check(Context_7 ctx) {
    type_ = exp_.Check(ctx);
    if (type_ != GInt_7.type_ && type_ != GFloat_7.type_ && type_ != GDouble_7.type_) {
      Error("- operator cannot be applied to value of type {0}", type_);
      return null;
    }
    return type_;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    if (type_ == GInt_7.type_) {
    int i = exp_.EvalInt(env);
    return new GInt_7(-i);
  }
    if (type_ == GFloat_7.type_) {
      float f = exp_.EvalFloat(env);
      return new GFloat_7(-f);
    }
    if (type_ == GDouble_7.type_) {
      double d = exp_.EvalDouble(env);
      return new GDouble_7(-d);
    }
    Debug.Assert(false);
    return null;
  }

  public override string Emit() { return "-" + exp_.Emit(); }
}

class Not_7 : Unary_7 {
  public Not_7(Expression_7 ^e) : base(e) { }

  public override GType_7 Check(Context_7 ctx) {
    return exp_.Check(ctx, GBool_7.type_) ? GBool_7.type_ : null;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    bool b = exp_.EvalBool(env);
    return new GBool_7(!b);
  }

  public override string Emit() { return "!" + exp_.Emit(); }
}

// the bitwise complement (~) operator
class Complement_7 : Unary_7 {
  public Complement_7(Expression_7 ^e) : base(e) { }

  public override GType_7 Check(Context_7 ctx) {
    return exp_.Check(ctx, GInt_7.type_) ? GInt_7.type_ : null;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    int i = exp_.EvalInt(env);
    return new GInt_7(~i);
  }

  public override string Emit() { return "~" + exp_.Emit(); }
}

class IncDec_7 : Expression_7 {
  bool pre_;    // true for pre-increment/decrement; false for post-increment/decrement
  bool inc_;
  LValue_7 ^lvalue_;

  public IncDec_7(bool pre, bool inc, LValue_7 ^lvalue) { pre_ = pre; inc_ = inc; lvalue_ = lvalue; }

  public override GType_7 Check(Context_7 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    GType_7 t = lvalue_.Check(ctx, true, true, false);
    if (t == null)
      return null;
    if (lvalue_.Kind() == ExprKind_7.Indexer_7) {
      Error("++ and -- can't yet operate on indexers");
      return null;
    }
    if (t != GInt_7.type_) {
      Error("++ and -- can operate only on integers");
      return null;
    }
    return GInt_7.type_;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    Location_7 loc = lvalue_.EvalLocation(env);
    GInt_7 ^i = (GInt_7) take loc.value_;
    loc.value_ = new GInt_7(inc_ ? i.i_ + 1 : i.i_ - 1);
    return pre_ ? ((GInt_7) loc.value_).Copy() : i;
  }

  string EmitOp() { return inc_ ? "++" : "--"; }

  public override string Emit() {
    return pre_ ? EmitOp() + lvalue_.Emit() : lvalue_.Emit() + EmitOp();
  }
}

abstract class Conversion_7 : Expression_7 {
  protected Expression_7 ^expr_;
  protected TypeExpr_7 ^type_expr_;

  protected GType_7 from_base_;
  protected GType_7 to_type_, to_base_;

  protected Conversion_7(Expression_7 ^expr, TypeExpr_7 ^type_expr) {
    expr_ = expr; type_expr_ = type_expr;
  }

  protected bool CheckConversion(Context_7 ctx, bool subtype_only) {
    GType_7 from = expr_.Check(ctx);
    if (from == null)
      return false;
    from_base_ = from.BaseType();

    to_base_ = type_expr_.Resolve(ctx.program_);
    if (to_base_ == null)
      return false;
    if (!to_base_.IsValue() &&
       (from is Owning_7 || from_base_.IsValue()))
      to_type_ = to_base_.OwningType();
    else to_type_ = to_base_;

    if (!from.CanConvertExplicit(to_type_, subtype_only)) {
      Error("can't convert from {0} to {1}", from_base_, to_base_);
      return false;
    }
    return true;
  }
}

class Cast_7 : Conversion_7 {
  public Cast_7(Expression_7 ^expr, TypeExpr_7 ^type_expr) : base(expr, type_expr) { }

  public override Local_7 GetLocal() { return expr_.GetLocal(); }
  
  public override GType_7 Check(Context_7 ctx) {
    return CheckConversion(ctx, false) ? to_type_ : null;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_7.Local_7 ? ExprKind_7.Local_7 : ExprKind_7.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_7 ^Eval(Env_7 env) {
    RValue_7 ^r = expr_.Eval(env);
    return r.Get().ConvertExplicit(ref r, to_base_);
  }

  public override string Emit() {
    return expr_.EmitExplicit(from_base_, to_type_);
  }
}

class Binary_7 : Expression_7 {
  int op_;
  Expression_7 ^left_, right_;
  GType_7 left_type_, right_type_;
  GType_7 type_;

  const int CONCATENATE = 0;

  public Binary_7(Expression_7 ^left, int op, Expression_7 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public static GType_7 Promote(Syntax_7 caller, GType_7 left, int op, GType_7 right) {
    if (left.CanConvert(GInt_7.type_) && right.CanConvert(GInt_7.type_))
      return GInt_7.type_;
    if (left.CanConvert(GFloat_7.type_) && right.CanConvert(GFloat_7.type_))
      return GFloat_7.type_;
    if (left.CanConvert(GDouble_7.type_) && right.CanConvert(GDouble_7.type_))
      return GDouble_7.type_;
    caller.Error("can't apply operator {0} to operands of type {1} and {2}", OpName(op), left, right);
    return null;
  }

  bool CheckIntArgs() {
    if (left_type_.CheckConvert(this, GInt_7.type_) && right_type_.CheckConvert(this, GInt_7.type_)) {
      type_ = GInt_7.type_;
      return true;
    }
    return false;
  }

  public override GType_7 Check(Context_7 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);

    if (op_ == '+' && (left_type_ == GString_7.type_ || right_type_ == GString_7.type_)) {
      op_ = CONCATENATE;

      // If_7 we'll be calling ToString() on a class, ensure that it will inherit from
      // Object in generated code.
      if (left_type_ != GString_7.type_)
        left_type_.CanConvert(GObject_7.type_);
      if (right_type_ != GString_7.type_)
        right_type_.CanConvert(GObject_7.type_);

      return GString_7.type_;
    }

    switch (op_) {
      case '*':
      case '/':
      case '+':
      case '-':
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_;

      case '%':
      case Parser.OP_LEFT_SHIFT:
      case Parser.OP_RIGHT_SHIFT:
        return CheckIntArgs() ? GInt_7.type_ : null;

      case '&':
      case '|':
        if (left_type_ == GBool_7.type_ && right_type_ == GBool_7.type_)
          type_ = GBool_7.type_;
        else {
          if (!CheckIntArgs())
            return null;
          type_ = GInt_7.type_;
        }
        return type_;

      case '<':
      case Parser.OP_LE:
      case '>':
      case Parser.OP_GE:
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_ == null ? null : GBool_7.type_;

      default:
        Debug.Assert(false);
        return null;
    }
  }

  public static GBool_7 ^BoolOp(bool x, int op, bool y) {
    switch (op) {
      case '&': return new GBool_7(x & y);
      case '|': return new GBool_7(x | y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_7 ^IntOp(int x, int op, int y) {
    switch (op) {
      case '*': return new GInt_7(x * y);
      case '/': return new GInt_7(x / y);
      case '%': return new GInt_7(x % y);
      case '+': return new GInt_7(x + y);
      case '-': return new GInt_7(x - y);
      case Parser.OP_LEFT_SHIFT: return new GInt_7(x << y);
      case Parser.OP_RIGHT_SHIFT: return new GInt_7(x >> y);
      case '&': return new GInt_7(x & y);
      case '|': return new GInt_7(x | y);
      case '<': return new GBool_7(x < y);
      case Parser.OP_LE: return new GBool_7(x <= y);
      case '>': return new GBool_7(x > y);
      case Parser.OP_GE: return new GBool_7(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_7 ^FloatOp(float x, int op, float y) {
    switch (op) {
      case '*': return new GFloat_7(x * y);
      case '/': return new GFloat_7(x / y);
      case '+': return new GFloat_7(x + y);
      case '-': return new GFloat_7(x - y);
      case '<': return new GBool_7(x < y);
      case Parser.OP_LE: return new GBool_7(x <= y);
      case '>': return new GBool_7(x > y);
      case Parser.OP_GE: return new GBool_7(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_7 ^DoubleOp(double x, int op, double y) {
    switch (op) {
      case '*': return new GDouble_7(x * y);
      case '/': return new GDouble_7(x / y);
      case '+': return new GDouble_7(x + y);
      case '-': return new GDouble_7(x - y);
      case '<': return new GBool_7(x < y);
      case Parser.OP_LE: return new GBool_7(x <= y);
      case '>': return new GBool_7(x > y);
      case Parser.OP_GE: return new GBool_7(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public override RValue_7 ^Eval(Env_7 env) {
    if (op_ == CONCATENATE)
      return new GString_7(left_.Eval(env).ToString() + right_.Eval(env).ToString());

    if (type_ == GBool_7.type_)
      return BoolOp(left_.EvalBool(env), op_, right_.EvalBool(env));
    if (type_ == GInt_7.type_)
      return IntOp(left_.EvalInt(env), op_, right_.EvalInt(env));
    if (type_ == GFloat_7.type_)
      return FloatOp(left_.EvalFloat(env), op_, right_.EvalFloat(env));
    if (type_ == GDouble_7.type_)
      return DoubleOp(left_.EvalDouble(env), op_, right_.EvalDouble(env));

    Debug.Assert(false);
    return null;
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  static string OpName(int op) {
    switch (op) {
      case Parser.OP_LEFT_SHIFT: return "<<";
      case Parser.OP_RIGHT_SHIFT: return ">>";
      case Parser.OP_LE: return "<=";
      case Parser.OP_GE: return ">=";
      default: return ((char) op).ToString();
    }
  }

  public override string Emit() {
    if (op_ == CONCATENATE)
      return Hold(GString_7.type_,
        String.Format("String::_Concat({0}, {1})",
          left_.EmitRef(left_type_, GObject_7.type_), right_.Emit(right_type_, GObject_7.type_)));

    return String.Format("{0} {1} {2}",
      left_.EmitRef(left_type_), OpName(op_), right_.Emit() );
  }
}

class Equality_7 : Expression_7 {
  bool equal_;    // true for ==, false for !=
  Expression_7 ^left_, right_;
  GType_7 left_type_, right_type_, type_;

  public Equality_7(Expression_7 ^left, int op, Expression_7 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_EQUAL: equal_ = true; break;
      case Parser.OP_NE: equal_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_7 Check(Context_7 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);
    if (left_type_.IsReference() != right_type_.IsReference()) {
      Error("can't compare types {0} and {1}", left_type_, right_type_);
      return null;
    }
    type_ = left_type_.BaseType().CommonType(this, right_type_.BaseType());
    return type_ == null ? null : GBool_7.type_;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    RValue_7 ^left = left_.Eval(env, type_);
    RValue_7 ^right = right_.Eval(env, type_);
    bool eq = left.Get().DefaultEquals(right.Get());
    return new GBool_7(equal_ ? eq : !eq);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    string emit_left = left_.EmitRef(left_type_);
    string emit_right = right_.Emit();
    if (type_ == GString_7.type_)
      return String.Format("{0}String::_Equals({1}, {2})",
                           equal_ ? "" : "!", emit_left, emit_right);
    return String.Format("{0} {1} {2}", emit_left, equal_ ? "==" : "!=", emit_right);
  }
}

class Is_7 : Conversion_7 {
  public Is_7(Expression_7 ^expr, TypeExpr_7 ^type_expr) : base(expr, type_expr) { }

  public override GType_7 Check(Context_7 ctx) {
    return CheckConversion(ctx, true) ? GBool_7.type_ : null;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    RValue_7 ^r = expr_.Eval(env);
    GValue_7 v = r.Get();
    return new GBool_7(!(v is Null_7) && v.Type().IsSubtype(to_base_));
  }

  public override string Emit() {
    if (from_base_.IsReference()) {
      Class_7 c = (Class_7) to_base_;
      return String.Format("dynamic_cast<{0} *>({1}) != 0", c.name_, expr_.Emit());
    }
    return to_base_ == from_base_ || to_base_ == GObject_7.type_ ? "true" : "false";
  }
}

class As_7 : Conversion_7 {
  public As_7(Expression_7 ^expr, TypeExpr_7 ^type_expr) : base(expr, type_expr) { }

  public override Local_7 GetLocal() { return expr_.GetLocal(); }

  public override GType_7 Check(Context_7 ctx) {
    if (!CheckConversion(ctx, true))
      return null;
    if (!to_base_.IsReference()) {
      Error("as operator must convert to reference type");
      return null;
    }
    return to_type_;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_7.Local_7 ? ExprKind_7.Local_7 : ExprKind_7.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_7 ^Eval(Env_7 env) {
    RValue_7 ^r = expr_.Eval(env);
    return r.Get().Type().IsSubtype(to_base_) ? r : Null_7.Instance.Copy();
  }

  public override string Emit() {
    if (from_base_.CanConvert(to_base_))
      return expr_.Emit(from_base_, to_base_);
    Class_7 c = (Class_7) to_base_;
    return String.Format("dynamic_cast<{0} *>({1})", c.name_, expr_.Emit());
  }
}

// a && or || operator
class LogicalOp_7 : Expression_7 {
  bool and_;  // true => &&, false => ||
  Expression_7 ^left_, right_;
  Joiner_7 ^join_ = new Joiner_7();

  public LogicalOp_7(Expression_7 ^left, int op, Expression_7 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_AND: and_ = true; break;
      case Parser.OP_OR: and_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_7 Check(Context_7 ctx) {
    if (!left_.Check(ctx, GBool_7.type_))
      return null;

    join_.Join(ctx.Prev());
    if (!right_.Check(ctx, GBool_7.type_))
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    return GBool_7.type_;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    bool left = left_.EvalBool(env);
    bool b = and_ ? left && right_.EvalBool(env) : left || right_.EvalBool(env);
    return new GBool_7(b);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    return String.Format("{0} {1} {2}", left_.Emit(), and_ ? "&&" : "||", right_.Emit());
  }

}

// the ?: operator
class Conditional_7 : Expression_7 {
  Expression_7 ^condition_;
  Expression_7 ^if_true_, if_false_;

  GType_7 true_type_, false_type_;
  GType_7 type_;
  Joiner_7 ^join_ = new Joiner_7();

  public Conditional_7(Expression_7 ^condition, Expression_7 ^if_true, Expression_7 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override GType_7 Check(Context_7 ctx) {
    if (!condition_.Check(ctx, GBool_7.type_))
      return null;

    Control_7 c = ctx.Prev();

    true_type_ = if_true_.Check(ctx);
    if (true_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    false_type_ = if_false_.Check(ctx);
    if (false_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    type_ = true_type_.CommonType(this, false_type_);
    return type_;
  }

  public override int Kind() {
    return if_true_.Kind() == ExprKind_7.Local_7 && if_false_.Kind() == ExprKind_7.Local_7 ? ExprKind_7.Local_7 : ExprKind_7.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    if_true_.LoseOwnership();
    if_false_.LoseOwnership();
  }

  public override RValue_7 ^Eval(Env_7 env) {
    return condition_.EvalBool(env) ? if_true_.Eval(env, type_) : if_false_.Eval(env, type_);
  }

  public override string Emit() {
    return String.Format("{0} ? {1} : {2}", condition_.Emit(),
                         if_true_.Emit(true_type_, type_), if_false_.Emit(false_type_, type_));
  }
}

class Assign_7 : Expression_7 {
  LValue_7 ^left_;
  Expression_7 ^right_;

  GType_7 left_type_, right_type_;

  public Assign_7(LValue_7 ^left, Expression_7 ^right) {
    left_ = left; right_ = right;
  }

  public static bool CheckAssign(Syntax_7 caller, GType_7 left_type, Expression_7 right, GType_7 right_type) {
    if (!right_type.CheckConvert(caller, left_type,
      right.Kind() == ExprKind_7.Local_7 ? ConversionContext_7.AssignVar : ConversionContext_7.Other))
      return false;
    right.CheckLoseOwnership(right_type, left_type);
    return true;
  }

  public override GType_7 Check(Context_7 ctx) {
    left_type_ = left_.Check(ctx, false, true, false);
    if (left_type_ == null)
      return null;

    right_type_ = right_.Check(ctx, true, false, false);
    if (right_type_ == null || !CheckAssign(this, left_.StorageType(), right_, right_type_))
      return null;
    right_.HoldRef(ctx);

    AddControl(ctx);
    left_.ReleaseAll(ctx);
    right_.ReleaseRef(ctx);
    return left_type_;
  }

  public override Method_7 Calls() {
    PropertyOrIndexer_7 pi = left_.GetPropertyOrIndexer();
    return pi == null ? null : pi.Setter();
  }

  public override bool Sets(Local_7 local) { return left_.IsLocal(local); }

  public override TypeSet_7 NodeDestroys() {
    return left_.GetPropertyOrIndexer() != null ? TypeSet_7.empty_ : left_.StorageType().VarDestroys();
  }

  public override RValue_7 ^Eval(Env_7 env) {
    RValue_7 ^v1, v2;
    left_.Eval1(env, out v1, out v2);
    RValue_7 ^val = right_.Eval(env, left_type_);
    RValue_7 ^ret = val.CopyRef();
    left_.EvalSet(env, v1, v2, val);
    return ret;
  }

  public override string Emit() {
    return left_.EmitSet(right_.EmitRef(right_type_, left_type_));
  }
}

// a compound assignment operator such as += or -=
class CompoundAssign_7 : Expression_7 {
  LValue_7 ^left_;
  int op_;
  Expression_7 ^right_;

  GType_7 type_;

  public CompoundAssign_7(LValue_7 ^left, int op, Expression_7 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public override GType_7 Check(Context_7 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    type_ = left_.Check(ctx, true, true, false);
    if (type_ == null)
      return null;
    if (left_.Kind() == ExprKind_7.Indexer_7) {
      Error("compound assignments don't yet work on indexers");
      return null;
    }
    if (type_ == GBool_7.type_ && (op_ == '&' || op_ == '|')) {
      if (!right_.Check(ctx, GBool_7.type_))
        return null;
      return type_;
    }
    if (type_ != GInt_7.type_ && type_ != GFloat_7.type_ && type_ != GDouble_7.type_) {
      Error("compound assignment operator {0}= can't operate on object of type {1}", (char) op_, type_);
      return null;
    }
    if (!right_.Check(ctx, type_))
      return null;
    return type_;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    Location_7 loc = left_.EvalLocation(env);
    if (type_ == GBool_7.type_) {
      bool x = ((GBool_7) loc.value_).b_;
      bool y = right_.EvalBool(env);
      loc.value_ = Binary_7.BoolOp(x, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GInt_7.type_) {
      GInt_7 x = (GInt_7) loc.value_;
      int y = right_.EvalInt(env);
      loc.value_ = Binary_7.IntOp(x.i_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GFloat_7.type_) {
      GFloat_7 x = (GFloat_7) loc.value_;
      float y = right_.EvalFloat(env);
      loc.value_ = Binary_7.FloatOp(x.f_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GDouble_7.type_) {
      GDouble_7 x = (GDouble_7) loc.value_;
      double y = right_.EvalDouble(env);
      loc.value_ = Binary_7.DoubleOp(x.d_, op_, y);
      return loc.value_.CopyRef();
    } else {
      Debug.Assert(false);
      return null;
    }
  }

  public override string Emit() {
    return String.Format("{0} {1}= {2}", left_.Emit(), (char) op_, right_.Emit());
  }
}

class Take_7 : Expression_7 {
  LValue_7 ^exp_;
  Owning_7 type_;

  public Take_7(LValue_7 ^exp) { exp_ = exp; }

  public override GType_7 Check(Context_7 ctx) {
    GType_7 t = exp_.Check(ctx);
    if (t == null)
      return null;
    type_ = exp_.StorageType() as Owning_7;
    if (type_ == null) {
      Error("take must be applied to owning pointer");
      return null;
    }
    exp_.LoseOwnership();
    ctx.AddTemporary(this);
    return type_;
  }

  public override GType_7 TemporaryType() { return type_; }

  public override RValue_7 ^Eval(Env_7 env) {
    RValue_7 ^v = exp_.Eval(env);
    exp_.EvalSet(env, Null_7.Instance.Copy());
    return v;
  }

  public override string Emit() {
    return Hold(exp_.StorageType(), exp_.Emit());
  }
}

abstract class Statement_7 : Node_7 {
  public abstract bool Check(Context_7 ctx);
  public abstract RValue_7 ^Eval(Env_7 env);

  public abstract void Emit(SourceWriter_7 w);

  public virtual void EmitEmbedded(SourceWriter_7 w) {
    w.WriteLine("");
    w.AddIndent();
    w.Indent();
    Emit(w);
    w.SubIndent();
  }

  public virtual void EmitInExistingBlock(SourceWriter_7 w) {
    w.Indent();
    Emit(w);
  }
}

class StatementList_7 {
  public readonly ArrayList /* of Statement_7 */ ^statements_ = new ArrayList();

  public void Add(Statement_7 ^s) { statements_.Add(s); }

  public bool Check(Context_7 ctx) {
    bool ok = true;
    foreach (Statement_7 s in statements_)
      ok &= s.Check(ctx);
    return ok;
  }

  public RValue_7 ^Eval(Env_7 env) {
    foreach (Statement_7 s in statements_) {
      RValue_7 ^v = s.Eval(env);
      if (v != null)
        return v;
    }
    return null;
  }

  public void Emit(SourceWriter_7 w) {
    foreach (Statement_7 s in statements_) {
      w.Indent();
      s.Emit(w);
    }
  }
}

class EmptyStatement_7 : InlineStatement_7 {
  public EmptyStatement_7() { }

  public override bool Check(Context_7 ctx) { return true; }
  public override RValue_7 ^Eval(Env_7 env) { return null; }
  public override void EmitInline(SourceWriter_7 w) { }

  public static readonly EmptyStatement_7 ^instance_ = new EmptyStatement_7();
}

// A Scoped_7 is a statement defining one or more local variables.  If_7 a Scoped_7 appears in the
// control graph, then it destroys those variables when traversed.
abstract class Scoped_7 : Statement_7 {
  protected Local_7 start_;   // the first local outside this statement
  protected Local_7 top_;     // the top local defined inside this statement

  TypeSet_7 ^destroys_;

  protected void SetStartVar(Context_7 ctx) { start_ = top_ = ctx.var_; }
  protected void SetTopVar(Context_7 ctx) { top_ = ctx.var_; }

  public Local_7 GetStart() { return start_; }
  public Local_7 GetTop() { return top_; }

  public override TypeSet_7 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_7();
    for (Local_7 l = top_; l != start_; l = l.next_)
        destroys_.Add(l.Type().VarDestroys());
    }
    return destroys_;
  }
}

class Block_7 : Scoped_7 {
  public readonly StatementList_7 ^list_;

  public Block_7(StatementList_7 ^list) { list_ = list; }

  public bool Absent() { return list_ == null; }

  public override bool Check(Context_7 ctx) {
    Context_7 ^ctx1 = new Context_7(ctx);   // don't pass declarations outside block
    SetStartVar(ctx1);

    if (!list_.Check(ctx1))
      return false;

    SetTopVar(ctx1);

    // Add this Block_7 to the control graph; this represents the destruction of variables
    // within the block at block exit.
    AddControl(ctx1);

    return true;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    return list_.Eval(new Env_7(env));
  }

  public static Block_7 ^EmptyBlock() { return new Block_7(new StatementList_7()); }

  public override void Emit(SourceWriter_7 w) {
    w.OpenBrace();
    list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitEmbedded(SourceWriter_7 w) {
    w.Write(" ");
    Emit(w);
  }

  public override void EmitInExistingBlock(SourceWriter_7 w) {
    list_.Emit(w);
  }
}

class MemberKind_7 {
  public const int
    Field_7 = 0,
    Method_7 = 1,
    Property_7 = 2,
    Indexer_7 = 3,
    Constructor_7 = 4;
}

class Named_7 : Node_7 {
  public readonly TypeExpr_7 ^type_expr_;   // may be null for certain objects such as constructors
  protected GType_7 type_;

  public readonly string name_;

  public Named_7(TypeExpr_7 ^type_expr, string name) {
    type_expr_ = type_expr;
    name_ = name;
  }

  public GType_7 Type() { return type_; }

  public virtual bool Resolve(Program_7 program) {
    if (type_expr_ == null || type_ != null)
      return true;
    type_ = type_expr_.Resolve(program);
    return type_ != null;
  }
}

abstract class Member_7 : Named_7 {
  protected Class_7 class_;    // containing class

  public readonly int attributes_;

  protected Member_7(int attributes, TypeExpr_7 ^type_expr, string name) : base(type_expr, name) {
    attributes_ = attributes;
  }

  public abstract int Kind();

  public static string ToString(int kind) {
    switch (kind) {
      case MemberKind_7.Field_7: return "field";
      case MemberKind_7.Method_7: return "method";
      case MemberKind_7.Property_7: return "property";
      case MemberKind_7.Indexer_7: return "indexer";
      case MemberKind_7.Constructor_7: return "constructor";
      default: Debug.Assert(false); return null;
    }
  }

  public string KindString() { return ToString(Kind()); }

  protected abstract int ValidAttributes();

  public Class_7 GetClass() { return class_; }
  public void SetClass(Class_7 cl) { class_ = cl; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public bool IsOverride() { return HasAttribute(Attribute_7.Override); }

  public bool IsProtected() { return HasAttribute(Attribute_7.Protected); }

  public bool IsPublic() { return HasAttribute(Attribute_7.Public); }

  public bool IsPrivate() { return !HasAttribute(Attribute_7.Public | Attribute_7.Protected); }

  public bool IsVirtual() {
    return HasAttribute(Attribute_7.Virtual | Attribute_7.Abstract | Attribute_7.Override);
  }

  static ArrayList ^empty_ = new ArrayList();

  public virtual ArrayList /* of Parameter_7 */ Parameters() { return empty_; }

  public Parameter_7 Param(int i) {
    return (Parameter_7) Parameters()[i];
  }

  public bool IsAccessible(Class_7 from_class, GType_7 through_type, bool through_base) {
    if (IsPublic())
      return true;

    // In GEL2 (as in C# and C++), a class [from_class] can access a protected member of
    // a class C only if [from_class] is a subtype of C and the access is
    // through a subtype of [from_class].  See e.g. C# 3.5.3 "Protected Access for Instance Members".
    if (IsProtected())
      return through_base || from_class.IsSubtype(class_) && through_type.IsSubtype(from_class);

    // default private access
    return from_class == class_;
  }

  public static bool MatchKind(int kind1, int kind2) {
    return kind1 == kind2 ||
           kind1 == MemberKind_7.Field_7 && kind2 == MemberKind_7.Property_7 ||
           kind1 == MemberKind_7.Property_7 && kind2 == MemberKind_7.Field_7;
  }

  public bool MatchSignature(Member_7 m) {
    if (!MatchKind(Kind(), m.Kind()))
      return false;

    if (name_ != m.name_ || Parameters().Count != m.Parameters().Count)
      return false;

    int i = 0;
    foreach (Parameter_7 p in m.Parameters()) {
      Parameter_7 q = Param(i);
      if (!p.Match(q))
        return false;
      ++i;
    }
    return true;
  }

  public bool IsApplicable(ArrayList arguments, out int mismatches) {
    mismatches = 0;
    if (Parameters().Count != arguments.Count)
      return false;
    int i = 0;
    foreach (Argument_7 a in arguments) {
      if (!Param(i).CanReceive(a))
        ++mismatches;
      ++i;
    }
    return true;
  }

  public void ReportMismatches(Syntax_7 caller, ArrayList arguments) {
    Debug.Assert(Parameters().Count == arguments.Count);
    int i = 0;
    foreach (Argument_7 a in arguments) {
      Parameter_7 p = Param(i);
      if (!p.CanReceive(a))
        caller.Error("argument {0}: can't convert from {1} to {2}", i + 1, a.TypeString(), p.TypeString());
      ++i;
    }
  }

  protected virtual void AddOverride(Member_7 m) { }

  bool CheckOverride(Context_7 ctx) {
    Class_7 parent = ctx.class_.Parent();
    Member_7 m = parent != null ? parent.FindMatchingMember(this, false) : null;
    if (m != null) {
      if (this is Field_7) {
        Error("can't define field with same name as field/property in superclass");
        return false;
      }
      if (m is Field_7) {
        Error("can't define property with same name as field in superclass");
        return false;
      }
      if (!HasAttribute(Attribute_7.Override)) {
        Error("must use override keyword to override superclass {0}", KindString());
        return false;
      }
      if (HasAttribute(Attribute_7.Virtual)) {
        Error("{0} with override or abstract keyword cannot be marked virtual", KindString());
        return false;
      }
      if (!m.IsVirtual()) {
        Error("attempting to override non-virtual {0}", KindString());
        return false;
      }
      if (!m.Type().Equals(Type())) {
        Error("can't override {0} with different return type", KindString());
        return false;
      }
      if (m.IsPublic() != IsPublic()) {
        Error("override {0} must have same accessibility as {0} it overrides", KindString());
        return false;
      }
      m.AddOverride(this);
    } else if (HasAttribute(Attribute_7.Override)) {
      Error("can't find {0} to override", KindString());
      return false;
    }
    return true;
  }

  bool CheckAccessibility() {
    int n = 0;
    if ((attributes_ & Attribute_7.Private) != 0)
      ++n;
    if ((attributes_ & Attribute_7.Protected) != 0)
      ++n;
    if ((attributes_ & Attribute_7.Public) != 0)
      ++n;
    if (n > 1) {
      Error("only one access level (private, protected, public) may be specified");
      return false;
    }

    if (IsVirtual() && IsPrivate()) {
      Error("a virtual or abstract {0} may not be private", KindString());
      return false;
    }

    return true;
  }

  public virtual bool Check(Context_7 ctx) {
    if (!AttributeUtil_7.CheckOnly(attributes_, ValidAttributes())) {
      Error("illegal {0} attribute", KindString());
      return false;
    }

    if (HasAttribute(Attribute_7.Abstract) && !ctx.class_.HasAttribute(Attribute_7.Abstract)) {
      Error("an abstract {0} can be defined only in an abstract class", KindString());
      return false;
    }

    if (name_ == class_.name_ && !(this is Constructor_7)) {
      Error("{0} cannot have same name as enclosing class", KindString());
      return false;
    }

    if (class_.GetMatchingMember(this) != this) {
      Error("{0} {1} appears twice in same class", KindString(), name_ != null ? name_ : "");
      return false;
    }

    return CheckOverride(ctx) && CheckAccessibility();
  }
}

// a member which represents a storage location: a field, property, or indexer
abstract class LMember_7 : Member_7 {
  protected LMember_7(int attributes, TypeExpr_7 ^type_expr, string name)
    : base(attributes, type_expr, name) { }

  public bool IsConstOrStatic() {
    return HasAttribute(Attribute_7.Const | Attribute_7.Static);
  }

  protected bool CheckStatic(Syntax_7 caller, bool static_ok, bool instance_ok) {
    if (!static_ok && IsConstOrStatic()) {
      caller.Error("{0} {1} is static", KindString(), name_);
      return false;
    }
    if (!instance_ok && !IsConstOrStatic()) {
      caller.Error("{0} {1} is not static", KindString(), name_);
      return false;
    }
    return true;
  }

  public abstract bool CheckAssigning(Syntax_7 caller, Context_7 ctx, bool assigning);

  public bool CheckAccess(Syntax_7 caller, Context_7 ctx, bool assigning, bool static_ok, bool instance_ok) {
    return CheckStatic(caller, static_ok, instance_ok) && CheckAssigning(caller, ctx, assigning);
  }

  public abstract Location_7 GetLocation(GObject_7 obj);

  // These methods are for fields and properties; indexers have their own versions which take
  // an extra index argument.
  public virtual RValue_7 ^Get(GValue_7 obj) { Debug.Assert(false); return null; }
  public virtual RValue_7 ^Take_7(GValue_7 obj) { Debug.Assert(false); return null; }
  public virtual void Set(GObject_7 obj, RValue_7 ^val)  { Debug.Assert(false); }

  public virtual string Emit()  { Debug.Assert(false); return null; }
  public virtual string EmitSet(string val)  { Debug.Assert(false); return null; }
}

class Field_7 : LMember_7 {
  protected Expression_7 ^initializer_;    // or null if none
  protected GType_7 initializer_type_;

  public Field_7(int attributes, TypeExpr_7 ^type_expr, string name, Expression_7 ^initializer)
  : base(attributes, type_expr, name) {
    initializer_ = initializer;
  }

  // Create a field for an internal class.  Such fields will never be type checked.
  public Field_7(GType_7 type, string name) : this(Attribute_7.Public | Attribute_7.ReadOnly, null, name, null) {
    type_ = type;
  }

  public static Field_7 ^New_7(int attributes, TypeExpr_7 ^type_expr, string name, Expression_7 ^initializer) {
    if ((attributes & Attribute_7.Static) != 0)
      return new StaticField_7(attributes, type_expr, name, initializer);
    if ((attributes & Attribute_7.Const) != 0)
      return new ConstField_7(attributes, type_expr, name, initializer);
    return new Field_7(attributes, type_expr, name, initializer);
  }

  public override int Kind() { return MemberKind_7.Field_7; }

  public Expression_7 Initializer() { return initializer_; }

  protected virtual bool CheckInitializer(Context_7 ctx) {
    if (initializer_ == null)
      return true;

    ctx.EnterExpression();
    initializer_type_ = initializer_.Check(ctx);
    bool b = initializer_type_ != null &&
             Assign_7.CheckAssign(this, type_, initializer_, initializer_type_);
    ctx.FinishExpression();
    return b;
  }

  protected override int ValidAttributes() {
    return Attribute_7.Const | Attribute_7.Private | Attribute_7.Protected | Attribute_7.Public |
           Attribute_7.ReadOnly | Attribute_7.Static;
  }

  public override bool Check(Context_7 ctx) {
    if (!base.Check(ctx))
      return false;

    // We build up a small control graph even when checking field initializers; we do this
    // since expression-checking code uses the graph to determine when temporary
    // ref counts are needed.
    prev_ = unreachable_;
    ctx.SetPrev(this);

    bool b = CheckInitializer(ctx);

    ctx.ClearPrev();
    return b;
  }

  public override bool CheckAssigning(Syntax_7 caller, Context_7 ctx, bool assigning) {
    if (assigning) {
      if (HasAttribute(Attribute_7.Const)) {
        caller.Error("can't assign to const field");
        return false;
      }
      if (HasAttribute(Attribute_7.ReadOnly) &&
          (ctx.class_ != class_ || !(ctx.method_ is Constructor_7)) ) {
        caller.Error("readonly field {0} can only be assigned in constructor", name_);
        return false;
      }
    }
    return true;
  }

  public override RValue_7 ^Get(GValue_7 obj) { return obj.Get(this); }
  public override RValue_7 ^Take_7(GValue_7 obj) { return obj.Take_7(this); }
  public override void Set(GObject_7 obj, RValue_7 ^val) { obj.Set(this, val); }
  public override Location_7 GetLocation(GObject_7 obj) { return obj.GetLocation(this); }

  protected void WriteField(SourceWriter_7 w, bool declaration) {
    w.Indent();
    if (declaration && IsConstOrStatic())
      w.Write("static ");
    w.Write("{0} ", type_.EmitType());
    if (this is ConstField_7)
      w.Write("const ");
    if (!declaration)
      w.Write("{0}::", class_.name_);
    w.Write(name_);
  }

  protected void WriteDeclaration(SourceWriter_7 w) { WriteField(w, true); }
  protected void WriteDefinition(SourceWriter_7 w) { WriteField(w, false); }

  public virtual void EmitDeclaration(SourceWriter_7 w) {
    WriteDeclaration(w);
    w.WriteLine(";");
  }

  public void EmitInitializer(SourceWriter_7 w) {
    w.IWrite("{0} = ", name_);
    if (initializer_ != null)
      w.Write(initializer_.Emit(initializer_type_, type_));
    else w.Write(type_.DefaultValue_7().Emit());
    w.WriteLine(";");
  }

  public virtual void Emit(SourceWriter_7 w) { }

  public override string Emit() { return name_; }

  public override string EmitSet(string val) {
    return String.Format("{0} = {1}", name_, val);
  }
}

class StaticField_7 : Field_7 {
  protected Location_7 ^loc_;

  public StaticField_7(int attributes, TypeExpr_7 ^type_expr, string name, Expression_7 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_7 ctx) {
    if (!base.Check(ctx))
      return false;
    loc_ = new Location_7(Type().DefaultValue_7().Copy());
    return true;
  }

  protected override bool CheckInitializer(Context_7 ctx) {
    ArrayInitializer_7 ai = initializer_ as ArrayInitializer_7;
    if (ai != null) {
      GType_7 type = type_;
      Owning_7 o = type as Owning_7;
      type = (o != null) ? o.BaseType() : null;
      ArrayType_7 at = type as ArrayType_7;
      if (at == null) {
        Error("only owning arrays may have initializers");
        return false;
      }
      return ai.CheckElements(ctx, at.ElementType());
    }

    return base.CheckInitializer(ctx);
  }

  public virtual void Init() {
    ArrayInitializer_7 ai = initializer_ as ArrayInitializer_7;
    if (ai != null)
      loc_.value_ = ai.Eval((ArrayType_7) type_.BaseType());
    else if (initializer_ != null)
      loc_.value_ = initializer_.Eval(Env_7.static_, type_);
  }

  public override RValue_7 ^Get(GValue_7 obj) { return loc_.Get().CopyRef(); }
  public override RValue_7 ^Take_7(GValue_7 obj) { return take loc_.value_; }
  public override void Set(GObject_7 obj, RValue_7 ^val) { loc_.value_ = val; }
  public override Location_7 GetLocation(GObject_7 obj) { return loc_; }

  public override void Emit(SourceWriter_7 w) {
    ArrayInitializer_7 ai = initializer_ as ArrayInitializer_7;
    if (ai != null) {
      GType_7 element_type = ((ArrayType_7) type_.BaseType()).ElementType();
      string varname = String.Format("_{0}_{1}", class_.name_, name_);
      w.Write("{0} {1}[] = ", element_type.EmitGenericType(), varname);
      ai.Emit(w);
      w.WriteLine(";");
      WriteDefinition(w);
      w.Write("(new {0}", GType_7.ConstructType("_StaticArray", element_type.EmitGenericType()));
      w.Write("(&typeid({0}), {1}, {2}))", element_type.EmitType(), ai.initializers_.Count, varname);
    } else {
      WriteDefinition(w);
      if (initializer_ != null)
        initializer_.EmitAsInitializer(w, initializer_type_, type_);
    }
    w.WriteLine(";");
    w.WriteLine("");
  }
}

class ConstField_7 : Field_7 {
  protected SimpleValue_7 ^value_;

  public ConstField_7(int attributes, TypeExpr_7 ^type_expr, string name, Expression_7 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_7 ctx) {
    if (!base.Check(ctx))
      return false;
    return initializer_.CheckConstant();
  }

  SimpleValue_7 ^Get() {
    if (value_ == DefaultValue_7.instance_) {
      Error("circular dependency among constant fields");
      Gel_7.Exit();
    }
    if (value_ == null) {
      value_ = new DefaultValue_7();    // marker used to catch circular const references
      value_ = (SimpleValue_7)initializer_.Eval(Env_7.static_, type_);
    }
    return value_.Copy();
  }

  public override RValue_7 ^Get(GValue_7 obj) {
    return Get();
  }

  public override void Set(GObject_7 obj, RValue_7 ^val) { Debug.Assert(false); }
  public override Location_7 GetLocation(GObject_7 obj) { Debug.Assert(false); return null; }

  public override void EmitDeclaration(SourceWriter_7 w) {
    WriteDeclaration(w);
    if (type_ is IntegralType_7)
      w.Write(" = {0}", Get().Emit());
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_7 w) {
    WriteDefinition(w);
    if (!(type_ is IntegralType_7)) {
      w.WriteLine(" = {0};", Get().Emit());
    }
    w.WriteLine(";");
  }
}

class ExpressionTraverser_7 : Traverser_7 {
  readonly Control_7 start_;
  Local_7 local_;
  GType_7 type_;
  bool assign_;
  bool destroy_;

  public ExpressionTraverser_7(Control_7 start, Local_7 local, GType_7 type) {
    start_ = start; local_ = local; type_ = type;
  }

  public override int Handle(Control_7 control) {
    if (control == start_)
      return Cut;
    Node_7 node = control as Node_7;
    if (node != null) {
      if (!destroy_ && node.CanDestroy(type_))
        destroy_ = true;
      else if (local_ != null && node.Sets(local_))
        assign_ = true;
    }
    return Continue_7;
  }

  // Return_7 true if the given expression needs a reference count while we evaluate
  // the control graph nodes between [start] and [end].
  // A local variable needs a ref count if it is assigned to and the object
  // the variable previously pointed to might possibly be destroyed.
  // Any other expression needs a ref count if the object it evaluates to
  // might possibly be destroyed.
  public static bool NeedRef(Control_7 start, Control_7 end, Expression_7 expr, GType_7 type) {
    Debug.Assert(start != null && end != null);
    if (start == end || !type.IsOwned() || expr is This_7 || expr is Base_7)
      return false;
    Local_7 local = expr.GetLocal();
    ExpressionTraverser_7 ^et = new ExpressionTraverser_7(start, local, type);
    end.Traverse(et, Control_7.GetMarkerValue());
    return et.destroy_ && (local == null || et.assign_);
  }
}

abstract class LocalHandler_7 {
  public abstract bool Handle(Local_7 local, Node_7 node, Name_7 use);
}

class LocalChecker_7 : LocalHandler_7 {
  public override bool Handle(Local_7 local, Node_7 node, Name_7 use) {
    if (node == Control_7.unreachable_) {
      if (use != null)
        use.Error("variable {0} may be used before it is assigned a value", use.name_);
      else
        local.Error("out parameter {0} must be assigned before leaving method", local.name_);
      return false;
    }
    if (node.Takes(local)) {
      Name_7 name = (Name_7) node;
      name.Error("can't transfer ownership from {0}: value may be used again", name.name_);
      return false;
    }
    return true;
  }
}

class LocalRefAnalyzer_7 : LocalHandler_7 {
  public override bool Handle(Local_7 local, Node_7 node, Name_7 use) {
    Debug.Assert(node != Control_7.unreachable_);
    if (node.CanDestroy(local.Type())) {
      local.NeedsRef();
      return false;   // abort search
    }
    return true;
  }
}

class LocalTraverser_7 : Traverser_7 {
  readonly Local_7 local_;
  readonly LocalHandler_7 handler_;
  Name_7 use_;

  public LocalTraverser_7(Local_7 local, LocalHandler_7 handler) {
    local_ = local;
    handler_ = handler;
  }

  public void SetUse(Name_7 use) { use_ = use; }

  public override int Handle(Control_7 control) {
    Node_7 node = control as Node_7;
    if (node == null)
      return Continue_7;

    if (node.Sets(local_))
      return Cut;

    return handler_.Handle(local_, node, use_) ? Continue_7 : Abort;
  }
}

class Local_7 : Named_7 {
  protected Expression_7 ^initializer_;    // or null if none
  protected GType_7 initializer_type_;

  public Local_7 next_;    // next variable upward in scope chain

  NonOwningArrayList /* of Name_7 */ ^uses_ = new NonOwningArrayList();    // all uses of this variable

  protected bool mutable_;   // true if this local may ever change after it's first initialized

  protected bool needs_ref_;    // true if this variable needs a reference count in emitted code

  public Expression_7 Initializer() { return initializer_; }

  public void NeedsRef() { needs_ref_ = true; }

  public virtual string Emit() { return name_; }

  // Return_7 true if we represent this local using a smart pointer wrapper (i.e.
  // _Ptr, _Own, _OwnRef or _Ref).
  public virtual bool IsWrapper() {
    return type_ is Owning_7 || type_ == GString_7.type_ || needs_ref_;
  }

  public Local_7(TypeExpr_7 ^type_expr, string name, Expression_7 ^initializer) : base(type_expr, name) {
    initializer_ = initializer;
    next_ = null;
  }

  public bool Check(Context_7 ctx) {
    Local_7 decl = ctx.FindVar(name_);
    if (decl != null) {
      Error("error: variable already defined");
      return false;
    }

    if (initializer_ != null) {
      ctx.EnterExpression();
      initializer_type_ = initializer_.Check(ctx);
      bool ok = initializer_type_ != null &&
                Assign_7.CheckAssign(this, type_, initializer_, initializer_type_);

      // Add this Local_7 to the control graph.  We need to do this before calling
      // FinishExpression since the Local_7 will be initialized before temporaries 
      // are destroyed.
      AddControl(ctx);

      ctx.FinishExpression();
      if (!ok)
        return false;
    }

    next_ = ctx.var_;
    ctx.SetVar(this);

    ctx.method_.AddVar(this);
    return true;
  }

  public override bool Sets(Local_7 local) {
    return this == local && initializer_ != null;
  }

  public virtual GType_7 ReadType() {
    return type_;
  }

  public void AddUse(Name_7 name) {
    uses_.Add(name);
  }

  public void SetMutable() { mutable_ = true; }

  // Traverse the control graph nodes where this local is live, calling the given
  // LocalHandler_7's Handle method on each node.
  public bool Traverse(Method_7 method, LocalHandler_7 h) {
    LocalTraverser_7 ^t = new LocalTraverser_7(this, h);
    int marker = Control_7.GetMarkerValue();
    foreach (Name_7 name in uses_) {
      t.SetUse(name);
      if (!name.prev_.Traverse(t, marker))
        return false;
    }

    Parameter_7 p = this as Parameter_7;
    if (p != null && p.GetMode() == Mode_7.Out) {
      t.SetUse(null);
      if (!method.exit_.Traverse(t, marker))
        return false;
    }
    return true;
  }

  // check variable usage once control flow graph is complete
  public bool CheckUsage(Method_7 method) {
    return Traverse(method, new LocalChecker_7());
  }

  // Determine whether this Local_7 needs a reference count.  This_7 can happen only after
  // we've built up a control graph for all methods.
  public void ComputeRef(Method_7 method) {
    // For_7 now, a variable of type object always needs a reference count since it may
    // contain a string and we don't yet detect string destruction in the graph traversal.
    if (type_ == GObject_7.type_)
      NeedsRef();
    else if (type_.IsOwned())
      Traverse(method, new LocalRefAnalyzer_7());
  }

  public void EvalInit(Env_7 env) {
    env.Add(this, initializer_ != null ? initializer_.Eval(env, type_) : null);
  }

  protected virtual string EmitDeclarationType() {
    return IsWrapper() ? type_.EmitType() : type_.EmitExprType();
  }

  public virtual string EmitDeclarationName() { return name_; }

  public void EmitDeclaration(SourceWriter_7 w) {
    w.Write("{0} {1}", EmitDeclarationType(), EmitDeclarationName());
  }

  public void EmitInitializer(SourceWriter_7 w) {
    if (initializer_ != null)
      initializer_.EmitAsInitializer(w, initializer_type_, type_);
  }
}

class Parameter_7 : Local_7 {
  public Parameter_7(TypeExpr_7 ^type_expr, string name) : base(type_expr, name, null) { }

  // We represent some parameters using both a C++ parameter and a C++ local, which
  // have different types; we call these dual parameters.  For_7 such parameters
  // param_name_ is the C++ parameter name.
  string param_name_;

  public static Parameter_7 ^New_7(int mode, TypeExpr_7 ^type_expr, string name) {
    return mode == 0 ? new Parameter_7(type_expr, name) :
                               new RefOutParameter_7(mode, type_expr, name);
  }

  public virtual int GetMode() { return 0; }
  public string TypeString() { return Mode_7.ToString(GetMode()) + type_.ToString(); }

  public virtual Parameter_7 ^Copy() {
    return new Parameter_7(new TypeLiteral_7(type_), name_);
  }

  public virtual bool CanReceive(Argument_7 a) {
    return a.GetMode() == 0 && a.Type().CanConvert(type_, ConversionContext_7.MethodArg);
  }

  public bool Match(Parameter_7 p) {
    return GetMode() == p.GetMode() && type_.Equals(p.type_);
  }

  public override bool IsWrapper() {
    return type_ is Owning_7 || type_ == GString_7.type_ || mutable_ && needs_ref_;
  }

  public void CheckParameterUsage(Method_7 method) {
    if (type_ is Owning_7 && !(this is RefOutParameter_7)) {
      // We need both a C++ parameter and a C++ local: the parameter type can't be
      // _Own<>, since _Own has no public copy constructor and GCC doesn't allow passing
      // by value when a class's copy constructor is private.
      string n = name_;
      do {
        n = "_" + n;
      } while (method.HasLocal(n));
      param_name_ = n;
    }
  }

  protected override string EmitDeclarationType() {
    // For_7 owning parameters the declaration type is the expression type since we can't
    // pass _Own<> by value.
    return type_ is Owning_7 ? type_.EmitExprType() : base.EmitDeclarationType();
  }

  public override string EmitDeclarationName() {
    return param_name_ != null ? param_name_ : name_;
  }

  public void EmitExtraDeclaration(SourceWriter_7 w) {
    if (param_name_ != null)
      w.IWriteLine("{0} {1}({2});", type_.EmitType(), name_, param_name_);
  }
}

class RefOutParameter_7 : Parameter_7 {
  public readonly int mode_;
  public override int GetMode() { return mode_; }

  public RefOutParameter_7(int mode, TypeExpr_7 ^type_expr, string name) : base(type_expr, name) {
    mode_ = mode;
    mutable_ = true;
  }

  public override Parameter_7 ^Copy() { Debug.Assert(false); return null; }

  public override bool CanReceive(Argument_7 a) {
    if (mode_ != a.GetMode())
      return false;
    RefOutArgument_7 ra = (RefOutArgument_7) a;
    return type_.Equals(ra.StorageType());
  }

  public override GType_7 ReadType() {
    // If_7 a ref parameter has an owning type, we require the user to use the take operator to take
    // ownership of the value, since taking ownership has the visible side effect of clearing the
    // value the ref parameter points to.
    return mode_ == Mode_7.Ref ? type_.BaseType() : type_;
  }

  public override string Emit() {
    return "(*" + name_ + ")";
  }

  protected override string EmitDeclarationType() {
    return type_.EmitType() + " *";
  }
}

abstract class InlineStatement_7 : Statement_7 {
  public abstract void EmitInline(SourceWriter_7 w);

  public override void Emit(SourceWriter_7 w) {
    EmitInline(w);
    w.WriteLine(";");
  }
}

class VariableDeclaration_7 : InlineStatement_7 {
  ArrayList /* of Local_7 */ ^locals_ = new ArrayList();

  public VariableDeclaration_7(TypeExpr_7 ^type_expr, string name, Expression_7 ^initializer) {
    locals_.Add(new Local_7(type_expr, name, initializer));
  }

  public void Add(string name, Expression_7 ^initializer) {
    TypeExpr_7 ^t = ((Local_7) locals_[0]).type_expr_.Copy();
    locals_.Add(new Local_7(t, name, initializer));
  }

  public override bool Check(Context_7 ctx) {
    // local variables are not resolved during the Resolve phase, so we must resolve them here
    foreach (Local_7 l in locals_)
      if (!l.Resolve(ctx.program_) || !l.Check(ctx))
        return false;

    return true;
  }

  // Return_7 the type of all variables in this VariableDeclaration_7.
  public GType_7 Type() { return ((Local_7) locals_[0]).Type(); }

  public override RValue_7 ^Eval(Env_7 env) {
    foreach (Local_7 l in locals_)
      l.EvalInit(env);
    return null;
  }

  void Emit(SourceWriter_7 w, bool in_line) {
    if (in_line)
      Debug.Assert(locals_.Count == 1);

    foreach (Local_7 l in locals_) {
      l.EmitDeclaration(w);
      l.EmitInitializer(w);
      if (!in_line)
        w.WriteLine(";");
    }
  }

  public override void EmitInline(SourceWriter_7 w) { Emit(w, true); }
  public override void Emit(SourceWriter_7 w) { Emit(w, false); }
}

class ExpressionStatement_7 : InlineStatement_7 {
  Expression_7 ^exp_;

  public ExpressionStatement_7(Expression_7 ^e) {
    exp_ = e;
  }

  public override bool Check(Context_7 ctx) {
    if (exp_.CheckTop(ctx) == null)
      return false;
    exp_.SetUnused();
    return true;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    exp_.Eval(env);   // discard expression value
    return null;
  }

  public override void EmitInline(SourceWriter_7 w) {
    w.Write(exp_.Emit());
  }

}

class If_7 : Statement_7 {
  Expression_7 ^condition_;
  Statement_7 ^if_true_;
  Statement_7 ^if_false_;
  Joiner_7 ^join_ = new Joiner_7();

  public If_7(Expression_7 ^condition, Statement_7 ^if_true, Statement_7 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override bool Check(Context_7 ctx) {
    if (!condition_.Check(ctx, GBool_7.type_))
      return false;

    Control_7 c = ctx.Prev();

    if (!if_true_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    if (if_false_ != null && !if_false_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());
    return true;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    if (condition_.EvalBool(env))
      return if_true_.Eval(env);
    else
      return if_false_ != null ? if_false_.Eval(env) : null;
  }

  public override void Emit(SourceWriter_7 w) {
    w.Write("if ({0})", condition_.Emit());
    if_true_.EmitEmbedded(w);
    if (if_false_ != null) {
      w.IWrite("else");
      if_false_.EmitEmbedded(w);
    }
  }

}

class DefaultValue_7 : SimpleValue_7 {
  public DefaultValue_7() { }
  public static readonly DefaultValue_7 ^instance_ = new DefaultValue_7();

  public override SimpleValue_7 ^Copy() { Debug.Assert(false); return null; }
  public override GType_7 Type()  { Debug.Assert(false); return null; }
  public override string Emit() { Debug.Assert(false); return null; }
}

// A section in a switch statement.
//
// In GEL2, unlike C# and C++, local variables declared in a switch section are visible only
// in that section.  There doesn't seem to be much point in allowing sections to share locals
// since GEL2 (like C#) doesn't allow control to fall through from one section to the next.  This_7 also
// makes compiling to C++ slightly easier since C++ doesn't allow local variables in switch sections
// other than the last to have initializers (see e.g. C++ Primer, 4th ed., 6.6.5 "Variable Definitions
// inside a switch").

class SwitchSection_7 : Node_7 {
  ArrayList /* of Expression_7 */ ^cases_;     // null represents default:
  public readonly Block_7 ^block_;

  ArrayList /* of GValue_7 */ ^values_ = new ArrayList();

  public SwitchSection_7(ArrayList ^cases, StatementList_7 ^statements) {
    cases_ = cases;
    block_ = new Block_7(statements);
  }

  public bool Check(Context_7 ctx, GType_7 switch_type, OwningHashtable all_values, out bool is_default) {
    is_default = false;
    foreach (Expression_7 e in cases_) {
      GValue_7 ^v;
      if (e == null) {
        is_default = true;
        v = new DefaultValue_7();
      } else {
        if (!e.Check(ctx, switch_type) || !e.CheckConstant())
          return false;
        v = (GValue_7) e.Eval(Env_7.static_, switch_type);
      }
      if (all_values.ContainsKey(v)) {
        Error("switch statement cannot contain the same value twice");
        return false;
      }
      all_values.Set(v, null);
      values_.Add(v);
    }
    return block_.Check(ctx);
  }

  public bool Match(GValue_7 v) {
    foreach (GValue_7 val in values_)
      if (val.Equals(v))
        return true;
    return false;
  }

  public void Emit(SourceWriter_7 w) {
    foreach (Expression_7 c in cases_)
      if (c == null)
        w.IWriteLine("default:");
      else w.IWriteLine("case {0}:", c.Emit());
    w.Indent();
    block_.Emit(w);
  }

  public void EmitString(SourceWriter_7 w) {
    w.IWrite("if (");
    for (int i = 0 ; i < values_.Count ; ++i) {
      if (i > 0) {
        w.WriteLine(" ||");
        w.IWrite("    ");
      }
      w.Write("_s->_Equals({0})", 
              GString_7.EmitStringConst(((GString_7) values_[i]).s_));
    }
    w.Write(") ");
    block_.Emit(w);
  }
}

abstract class Escapable_7 : Scoped_7 {
  public readonly Joiner_7 ^exit_ = new Joiner_7();
}

class Switch_7 : Escapable_7 {
  Expression_7 ^expr_;
  GType_7 type_;
  ArrayList /* of SwitchSection_7 */ ^sections_;
  SwitchSection_7 default_;    // or null if no default section

  public Switch_7(Expression_7 ^expr, ArrayList ^sections) { expr_ = expr; sections_ = sections; }

  public override bool Check(Context_7 ctx) {
    SetStartVar(ctx);
    type_ = expr_.CheckTop(ctx);
    if (type_ == null)
      return false;
    if (type_ != GInt_7.type_ && type_ != GChar_7.type_ && type_ != GString_7.type_) {
      Error("switch expression must be of type int, char or string");
      return false;
    }
    Context_7 ^ctx1 = new Context_7(ctx, this);
    OwningHashtable ^values = new OwningHashtable();
    Control_7 c = ctx1.Prev();
    foreach (SwitchSection_7 s in sections_) {
      bool is_default;
      ctx1.SetPrev(c);
      if (!s.Check(ctx1, type_, values, out is_default))
        return false;
      if (is_default)
        default_ = s;
      if (ctx1.Prev() != unreachable_) {
        s.Error("switch case may not fall through to following case");
        return false;
      }
    }
    if (default_ == null)
      exit_.Join(c);
    ctx1.SetPrev(exit_.Combine());
    return true;
  }

  SwitchSection_7 FindSection(GValue_7 v) {
    foreach (SwitchSection_7 s in sections_)
      if (s.Match(v))
        return s;
    return default_;
  }

  RValue_7 ^CatchBreak(RValue_7 ^v) {
    return v is BreakValue_7 ? null : v;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    RValue_7 ^v = expr_.Eval(env);
    if (v == null)
      return null;
    SwitchSection_7 s = FindSection(v.Get());
    if (s == null)
      return null;
    return CatchBreak(s.block_.Eval(env));
  }

  public override void Emit(SourceWriter_7 w) {
    if (type_ == GString_7.type_) {
      // For_7 now, we implement a switch on strings using a sequence of if statements.  We wrap
      // the sequence in a dummy switch statement so that break statements will work properly.
      // If_7 the switch statement has just a default: label then the Microsoft C++ compiler issues
      // a warning, and if it has just a case 0: label then the compiler doesn't realize that the
      // case will always be executed, which may lead to warnings about not all code paths returning
      // a value.  So we use both default: and case 0:, which seems to work fine.
      w.Write("switch (0) ");
      w.OpenBrace();
      w.IWriteLine("case 0:");
      w.IWriteLine("default:");
      w.IWriteLine("StringPtr _s = {0};", expr_.Emit());
      foreach (SwitchSection_7 s in sections_)
        if (s != default_)
          s.EmitString(w);
      if (default_ != null)
        default_.block_.Emit(w);
      w.CloseBrace();
    } else {
      w.Write("switch ({0}) ", expr_.Emit());
      w.OpenBrace();

      foreach (SwitchSection_7 s in sections_)
        s.Emit(w);

      w.CloseBrace();
    }
  }
}

abstract class Loop_7 : Escapable_7 {
  public readonly Joiner_7 ^loop_ = new Joiner_7();
}

abstract class ForOrWhile_7 : Loop_7 {
  protected Expression_7 ^condition_;
  protected Statement_7 ^statement_;

  protected ForOrWhile_7(Expression_7 ^condition, Statement_7 ^statement) {
    condition_ = condition; statement_ = statement;
  }

  protected abstract InlineStatement_7 Initializer();
  protected abstract InlineStatement_7 Iterator();

  public override bool Check(Context_7 prev_ctx) {
    Context_7 ^ctx = new Context_7(prev_ctx, this);   // initializer may declare new local variable
    SetStartVar(ctx);
    if (!Initializer().Check(ctx))
      return false;
    SetTopVar(ctx);

    loop_.AddControl(ctx);

    if (!condition_.CheckTop(ctx, GBool_7.type_))
      return false;

    if (!condition_.IsTrueLiteral())  // we may exit the loop at this point
      exit_.Join(ctx.Prev());  

    if (!statement_.Check(ctx))
      return false;

    if (!Iterator().Check(ctx))
      return false;

    loop_.Join(ctx.Prev());  // loop back to top

    ctx.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy any local defined in an initializer above.
    AddControl(ctx);

    return true;
  }

  public override RValue_7 ^Eval(Env_7 outer_env) {
    Env_7 ^env = new Env_7(outer_env);   // initializer may declare new local
    for (Initializer().Eval(env); condition_.EvalBool(env); Iterator().Eval(env)) {
      RValue_7 ^v = statement_.Eval(env);
      if (v is BreakValue_7)
        break;
      if (v is ContinueValue_7)
        continue;
      if (v != null)
        return v;
    }
    return null;
  }
}

class While_7 : ForOrWhile_7 {
  public While_7(Expression_7 ^condition, Statement_7 ^statement) : base(condition, statement) { }

  protected override InlineStatement_7 Initializer()  { return EmptyStatement_7.instance_; }
  protected override InlineStatement_7 Iterator()  { return EmptyStatement_7.instance_; }

  public override void Emit(SourceWriter_7 w) {
    w.Write("while ({0})", condition_.Emit());
    statement_.EmitEmbedded(w);
  }
}

class For_7 : ForOrWhile_7 {
  InlineStatement_7 ^initializer_;
  InlineStatement_7 ^iterator_;

  public For_7(InlineStatement_7 ^initializer, Expression_7 ^condition, InlineStatement_7 ^iterator,
             Statement_7 ^statement)
    : base(condition != null ? condition : new Literal_7(new GBool_7(true)),
           statement) {
    initializer_ = initializer != null ? initializer : new EmptyStatement_7();
    iterator_ = iterator != null ? iterator : new EmptyStatement_7();
  }

  protected override InlineStatement_7 Initializer()  { return initializer_; }
  protected override InlineStatement_7 Iterator()  { return iterator_; }

  public override void Emit(SourceWriter_7 w) {
    w.Write("for (");
    initializer_.EmitInline(w);
    w.Write("; {0}; ", condition_.Emit());
    iterator_.EmitInline(w);
    w.Write(")");
    statement_.EmitEmbedded(w);
  }
}

class Do_7 : Loop_7 {
  Statement_7 ^statement_;
  Expression_7 ^condition_;

  Joiner_7 ^join_ = new Joiner_7();

  public Do_7(Statement_7 ^statement, Expression_7 ^condition) {
    statement_ = statement;
    condition_ = condition;
  }

  public override bool Check(Context_7 ctx) {
    join_.AddControl(ctx);

    Context_7 ^ctx1 = new Context_7(ctx, this);
    SetStartVar(ctx);

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx.Prev());  // continue statements jump here
    ctx.SetPrev(loop_.Combine());

    if (!condition_.CheckTop(ctx, GBool_7.type_))
      return false;

    if (!condition_.IsFalseLiteral())
      join_.Join(ctx.Prev());   // loop back to top
    if (!condition_.IsTrueLiteral())
      exit_.Join(ctx.Prev());   // fall through to exit
    ctx.SetPrev(exit_.Combine());

    return true;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    do {
      RValue_7 ^v = statement_.Eval(env);
      if (v is BreakValue_7)
        break;
      if (v is ContinueValue_7)
        continue;
      if (v != null)
        return v;
    } while (condition_.EvalBool(env));
    return null;
  }

  public override void Emit(SourceWriter_7 w) {
    w.IWrite("do");
    statement_.EmitEmbedded(w);
    w.IWriteLine("while ({0});", condition_.Emit());
  }
}

// A helper class for ForEach_7: a node defining a single variable in the control graph.
class Definer_7 : Node_7 {
  Local_7 local_;

  public Definer_7(Local_7 local) { local_ = local; }

  public override bool Sets(Local_7 local) {
    return local_ == local;
  }
}

class ForEach_7 : Loop_7 {
  Local_7 ^local_;
  Expression_7 ^expr_;
  GType_7 expr_type_;
  Statement_7 ^statement_;

  Property_7 count_;
  Indexer_7 indexer_;

  Definer_7 ^definer_;

  public ForEach_7(TypeExpr_7 ^type_expr, string name, Expression_7 ^expr, Statement_7 ^statement) {
    local_ = new Local_7(type_expr, name, null);
    expr_ = expr;
    statement_ = statement;
  }

  public override bool Check(Context_7 ctx) {
    if (!local_.Resolve(ctx.program_))
      return false;

    expr_type_ = expr_.CheckTop(ctx);
    if (expr_type_ == null)
      return false;

    count_ = expr_type_.Lookup(this, ctx.class_, false, MemberKind_7.Property_7, "Count", null, false) as Property_7;
    if (count_ == null) {
      Error("object enumerable by foreach must have an accessible property Count");
      return false;
    }
    if (count_.Type() != GInt_7.type_) {
      Error("object enumerable by foreach must have a property Count of type int");
      return false;
    }

    ArrayList ^args = new ArrayList();
    args.Add(new InArgument_7(GInt_7.type_));
    indexer_ = (Indexer_7) expr_type_.Lookup(this, ctx.class_, false, MemberKind_7.Indexer_7, null, args, false);
    if (indexer_ == null) {
      Error("object enumerable by foreach must have an accessible indexer on integers");
      return false;
    }
    if (!indexer_.CheckAssigning(this, ctx, false))
      return false;

    GType_7 indexer_type = indexer_.Type();
    GType_7 iterator_type = local_.Type();
    if (!indexer_type.CanConvertExplicit(iterator_type, false)) {
      Error("enumeration type {0} is not explicitly convertible to iteration variable type {1}",
        indexer_type, iterator_type);
      return false;
    }

    Context_7 ^ctx1 = new Context_7(ctx, this);

    SetStartVar(ctx1);
    if (!local_.Check(ctx1))   // will add local to scope chain
      return false;
    SetTopVar(ctx1);

    // Add a control graph node representing the creation of the local above.
    definer_ = new Definer_7(local_);
    definer_.AddControl(ctx1);

    loop_.AddControl(ctx1);   // continue statements jump here

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx1.Prev());   // loop back to top

    exit_.Join(loop_);  // any loop iteration may exit

    ctx1.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy the local variable created above.
    AddControl(ctx1);

    return true;
  }

  public override RValue_7 ^Eval(Env_7 outer_env) {
    RValue_7 ^r = expr_.Eval(outer_env);
    GValue_7 e = r.Get();
    if (e is Null_7) {
      Error("foreach: can't iterate over null object");
      Gel_7.Exit();
    }

    int count = ((GInt_7) count_.Get(e)).i_;

    Env_7 ^env = new Env_7(outer_env);
    env.Add(local_, null);
    for (int i = 0 ; i < count ; ++i) {
      RValue_7 ^v = indexer_.Get(e, new GInt_7(i));
      env.Set(local_, v.Get().ConvertExplicit(ref v, local_.Type()));
      RValue_7 ^s = statement_.Eval(env);
      if (s is BreakValue_7)
        break;
      if (s is ContinueValue_7)
        continue;
      if (s != null)
        return s;
    }
    return null;
  }

  public override void Emit(SourceWriter_7 w) {
    w.OpenBrace();
    w.IWriteLine("{0} _collection = {1};", expr_type_.BaseType().EmitType(), expr_.Emit());
    w.IWriteLine("int _count = _collection->get_Count();");
    w.IWrite("for (int _i = 0 ; _i < _count ; ++_i) ");
    w.OpenBrace();
    w.Indent();
    local_.EmitDeclaration(w);
    w.WriteLine(" = {0}; ",
      Expression_7.EmitExplicit(indexer_.Type(), local_.Type(), "_collection->get_Item(_i)", true));
    statement_.EmitInExistingBlock(w);
    w.CloseBrace();
    w.CloseBrace();
  }
}

class BreakValue_7 : GValue_7 {
  public BreakValue_7() { }

  public static readonly BreakValue_7 ^instance_ = new BreakValue_7();

  public override GType_7 Type()  { Debug.Assert(false); return null; }
}

abstract class BreakOrContinue_7 : Scoped_7 {
  protected void Link(Context_7 ctx, Scoped_7 target, Joiner_7 joiner) {
    // When traversed in the control graph, we destroy all variables in the scopes we are exiting,
    // excluding variables defined in the containing Escapable_7 or Loop_7.
    start_ = target.GetTop();
    SetTopVar(ctx);

    prev_ = ctx.Prev();
    if (prev_ != unreachable_)
      joiner.Join(this);

    ctx.SetPrev(unreachable_);
  }
}

class Break_7 : BreakOrContinue_7 {
  public override bool Check(Context_7 ctx) {
    Escapable_7 e = ctx.escape_;
    if (e == null) {
      Error("break statement must appear inside a while, do, for, foreach or switch statement");
      return false;
    }
    Link(ctx, e, e.exit_);
    return true;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    return new BreakValue_7();
  }

  public override void Emit(SourceWriter_7 w) {
    w.WriteLine("break;");
  }
}

class ContinueValue_7 : GValue_7 {
  public ContinueValue_7() { }

  public static readonly ContinueValue_7 ^instance_ = new ContinueValue_7();

  public override GType_7 Type()  { Debug.Assert(false); return null; }
}

class Continue_7 : BreakOrContinue_7 {
  public override bool Check(Context_7 ctx) {
    Loop_7 l = ctx.loop_;
    if (l == null) {
      Error("continue statement must appear inside a while, do, for or foreach statement");
      return false;
    }
    Link(ctx, l, l.loop_);
    return true;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    return new ContinueValue_7();
  }

  public override void Emit(SourceWriter_7 w) {
    w.WriteLine("continue;");
  }
}

class Return_7 : Statement_7 {
  Expression_7 ^exp_;    // null if no return value
  GType_7 exp_type_;
  GType_7 type_;

  public Return_7(Expression_7 ^exp) {
    exp_ = exp;
  }

  public override bool Check(Context_7 ctx) {
    if (exp_ == null) {
      if (ctx.method_.ReturnType() != Void_7.type_) {
        Error("error: returning value from function returning void");
        return false;
      }
    } else {
      type_ = ctx.method_.ReturnType();
      ctx.EnterExpression();
      exp_type_ = exp_.CheckAndHold(ctx);
      if (exp_type_ == null ||
          !exp_type_.CheckConvert(this, type_,
            exp_.IsRefOutParameter() ? ConversionContext_7.AssignVar : ConversionContext_7.Other))
        return false;
      exp_.CheckLoseOwnership(exp_type_, type_);
      ctx.FinishExpression();
      exp_.ReleaseRef(ctx);
    }

    ctx.method_.JoinReturn(ctx);
    ctx.SetPrev(unreachable_);
    return true;
  }

  public override RValue_7 ^Eval(Env_7 env) {
    return exp_ != null ? exp_.Eval(env, type_)
                        : Null_7.Instance.Copy();    // an arbitrary value
  }

  public override void Emit(SourceWriter_7 w) {
    if (exp_ != null && exp_.NeedsRef(exp_type_)) {
      // If_7 exp_ needs a reference count, that reference count needs to survive the destruction
      // of temporaries, so we can't simply emit a temporary reference count wrapper.  For_7 example,
      // when compiling the expression "return (new Foo()).Fun();", if Fun() returns a Foo then we
      // need a wrapper, and we can't generate "return _Ptr<Fun>(Foo().Fun()).Get()" since the _Ptr<Fun>
      // wrapper will be destroyed before the temporary Foo() object is destroyed.  So we need to
      // use an extra variable here.
      w.OpenBrace();
      w.IWriteLine("{0} __ret = {1};", exp_type_.EmitType(), exp_.Emit());
      w.IWriteLine("return __ret.Get();");
      w.CloseBrace();
    } else {
      w.Write("return ");
      if (exp_ != null)
        w.Write(exp_.Emit(exp_type_, type_));
      w.WriteLine(";");
    }
  }
}

class Attribute_7 {
  public const int Abstract = 1,
  Const = 2,
  Extern = 4,
  Override = 8,
  Private = 16,
  Protected = 32,
  Public = 64,
  ReadOnly = 128,
  Ref = 256,
  Static = 512,
  Virtual = 1024,
  Setter = 2048;
}

class AttributeUtil_7 {
  public static bool CheckOnly(int a, int allowed) {
    return (a & ~allowed) == 0;
  }
}

class MethodTraverser_7 : Traverser_7 {
  Method_7 method_;

  public MethodTraverser_7(Method_7 method) { method_ = method; }

  public override int Handle(Control_7 control) {
    if (control == Control_7.unreachable_)
      return Cut;

    Node_7 node = control as Node_7;
    if (node != null) {
      Method_7 c = node.Calls();
      if (c != null)
        method_.calls_.Add(c);
      method_.internal_destroys_.Add(node.NodeDestroys());
    }

    return Continue_7;
  }
}

class Method_7 : Member_7 {
  public readonly ArrayList /* of Parameter_7 */ ^parameters_;

  protected Block_7 ^body_;

  public Joiner_7 ^exit_ = new Joiner_7();

  // all parameters and locals defined in this method
  readonly NonOwningArrayList /* of Local_7 */ ^locals_ = new NonOwningArrayList();

  NonOwningArrayList /* of Method_7 */ ^overrides_;   // list of all overrides (virtual methods only)

  // methods called from this method
  public readonly NonOwningArrayList /* of Method_7 */ ^calls_ = new NonOwningArrayList();

  // Types destroyed inside this method, not including types destroyed through
  // calls to other methods.
  public readonly TypeSet_7 ^internal_destroys_ = new TypeSet_7();

  // Types destroyed inside this method or in any methods called by this method.
  TypeSet_7 ^destroys_;

  TypeSet_7 ^parameter_destroys_;

  // A marker used when performing a depth-first search of the method graph to compute destroys_.
  int method_marker_;

  public Method_7(int attributes, TypeExpr_7 ^return_type_expr,
                string name, ArrayList /* of Parameter_7 */ ^parameters, Block_7 ^body)
    : base(attributes, return_type_expr, name) {
    parameters_ = parameters;
    body_ = body;
  }

  public override int Kind() { return MemberKind_7.Method_7; }

  public GType_7 ReturnType() { return type_; }

  public override ArrayList Parameters() {
    return parameters_;
  }

  public bool IsExtern() { return class_.IsExtern(); }

  public bool IsStatic() {
    return HasAttribute(Attribute_7.Static);
  }

  public override bool Resolve(Program_7 program) {
    if (!base.Resolve(program))
      return false;
    foreach (Parameter_7 p in parameters_)
      if (!p.Resolve(program))
        return false;
    return true;
  }

  public void AddVar(Local_7 v) {
    locals_.Add(v);
  }

  public override bool Sets(Local_7 local) {
    foreach (Parameter_7 p in parameters_)
      if (p == local && p.GetMode() != Mode_7.Out)
        return true;
    return false;
  }

  public void JoinReturn(Context_7 ctx) {
    exit_.Join(ctx.Prev());
  }

  public const int kValidAttributes =
    Attribute_7.Abstract | Attribute_7.Override |
    Attribute_7.Private | Attribute_7.Protected | Attribute_7.Public |
    Attribute_7.Static | Attribute_7.Virtual | Attribute_7.Setter;

  protected override int ValidAttributes() {
    return kValidAttributes;
  }

  // overridden by Constructor_7 subclass
  protected virtual bool CheckEntry(Context_7 ctx) { return true; }

  // overridden by Constructor_7 subclass
  public override bool Check(Context_7 prev_ctx) {
    if (!base.Check(prev_ctx))
      return false;

    bool abstract_or_extern = HasAttribute(Attribute_7.Abstract) || IsExtern();

    if (body_.Absent()) {
      if (!abstract_or_extern) {
        Error("a method without a body must be abstract or extern");
        return false;
      }
      return true;
    } 

    if (abstract_or_extern) {
      Error("an abstract or extern method cannot have a body");
      return false;
    }

    Context_7 ^ctx = new Context_7(prev_ctx, this);

    prev_ = unreachable_;
    ctx.SetPrev(this);    // begin the control graph with this Method_7

    foreach (Parameter_7 p in parameters_)
      if (!p.Check(ctx))
        return false;

    if (!CheckEntry(ctx))
      return false;

    if (!body_.Check(ctx))
      return false;

    if (!(this is Constructor_7) && type_ != Void_7.type_ && ctx.Prev() != unreachable_) {
      Error("method must return a value");
      return false;
    }
    JoinReturn(ctx);

    ctx.ClearPrev();  // control graph is complete

    // Traverse the control graph to build calls_ and internal_destroys_.
    MethodTraverser_7 ^mt = new MethodTraverser_7(this);
    exit_.Traverse(mt, Control_7.GetMarkerValue());

    bool ok = true;
    foreach (Local_7 v in locals_)    // for all locals and parameters
      ok &= v.CheckUsage(this);

    foreach (Parameter_7 p in parameters_)
      p.CheckParameterUsage(this);

    return ok;
  }

  // Determine whether each local variable needs a reference count.
  protected void ComputeRefs() {
    foreach (Local_7 v in locals_)
      v.ComputeRef(this);
  }

  // Return_7 true if this method has a local or parameter with the given name.
  public bool HasLocal(string name) {
    foreach (Local_7 l in locals_)
      if (l.name_ == name)
        return true;
    return false;
  }

  public override TypeSet_7 NodeDestroys() {
    if (parameter_destroys_ == null) {
      parameter_destroys_ = new TypeSet_7();
    foreach (Parameter_7 p in parameters_)
        parameter_destroys_.Add(p.Type().VarDestroys());
    }
    return parameter_destroys_;
  }

  protected override void AddOverride(Member_7 m) {
    if (overrides_ == null)
      overrides_ = new NonOwningArrayList();
    overrides_.Add((Method_7) m);
  }

  bool Visit(int marker, TypeSet_7 set) {
    if (method_marker_ == marker)
      return true;

    method_marker_ = marker;
    set.Add(internal_destroys_);
    if (set.IsObject())
      return false;   // we already have object; no point in traversing further

    foreach (Method_7 m in calls_)
      if (!m.Visit(marker, set))
        return false;

    if (overrides_ != null)
      foreach (Method_7 m in overrides_)
        if (!m.Visit(marker, set))
          return false;

    return true;
  }

  public TypeSet_7 Destroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_7();
      Visit(Control_7.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  // overridden by Constructor_7 subclass
  public virtual RValue_7 ^Eval(Env_7 env) {
    return body_.Eval(env);
  }

  public RValue_7 ^Invoke(GValue_7 obj, ArrayList /* of ValueOrLocation_7 */ values) {
    if (body_.Absent()) { // an external method
      ValueList_7 ^list = new ValueList_7(values);
      if (IsStatic())
        return class_.InvokeStatic(this, list);   // let the class handle it
      return obj.Invoke(this, list);   // let the object handle it
    }

    Env_7 ^env = new Env_7(obj);
    Debug.Assert(values.Count == parameters_.Count);
    for (int i = 0 ; i < values.Count ; ++i)
      env.Add((Parameter_7) parameters_[i], (ValueOrLocation_7) values.Take(i));

    return Eval(env);
  }

  protected void EmitParameterNames(SourceWriter_7 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      w.Write(Param(i).EmitDeclarationName());
    }
    w.Write(")");
  }

  protected void EmitParameters(SourceWriter_7 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      Param(i).EmitDeclaration(w);
    }
    w.Write(") ");
  }

  void EmitAttributes(SourceWriter_7 w, bool declaration) {
    w.Indent();
    if (!IsStatic() && !IsVirtual())
      return;

    if (!declaration)
      w.Write("/* ");
    if (IsStatic())
      w.Write("static ");
    if (IsVirtual())
      w.Write("virtual ");
    if (!declaration)
      w.Write("*/ ");
  }

  void EmitSignature(SourceWriter_7 w, bool declaration) {
    EmitAttributes(w, declaration);
    w.Write("{0} ", type_.EmitReturnType());
    if (!declaration)
      w.Write("{0}::", class_.name_);
    if (HasAttribute(Attribute_7.Setter))
      w.Write("_");
    w.Write(name_);
    EmitParameters(w);
  }

  public virtual void EmitDeclaration(SourceWriter_7 w) {
    ComputeRefs();
    EmitSignature(w, true);
    if (body_.Absent())
      w.Write("= 0");
    w.WriteLine(";");

    if (HasAttribute(Attribute_7.Setter)) {
      w.WriteLine("");
      EmitAttributes(w, true);
      w.Write("{0} ", Param(parameters_.Count - 1).Type().EmitType());
      w.Write(name_);
      EmitParameters(w);
      w.OpenBrace();
      w.IWrite("_{0}", name_);
      EmitParameterNames(w);
      w.WriteLine(";");
      w.IWriteLine("return value;");
      w.CloseBrace();
    }
  }

  protected void EmitExtraDeclarations(SourceWriter_7 w) {
    foreach (Parameter_7 p in parameters_)
      p.EmitExtraDeclaration(w);
  }

  public virtual void Emit(SourceWriter_7 w) {
    if (!body_.Absent()) {
      EmitSignature(w, false);
      w.OpenBrace();
      EmitExtraDeclarations(w);
      body_.list_.Emit(w);
      w.CloseBrace();
      w.WriteLine("");
    }
    if (Gel_7.print_type_sets_)
      Console.WriteLine("{0}.{1}: {2}", class_.name_, name_, Destroys());
  }
}

class Constructor_7 : Method_7 {
  bool call_base_;
  ArrayList /* of Argument_7 */ ^initializer_params_;

  Constructor_7 initializer_;

  bool invoked_;  // true if another constructor invokes this one using : base() or : this()

  public Constructor_7(int attributes, string name, ArrayList ^parameters,
                     bool call_base, ArrayList ^initializer_params, Block_7 ^body)
    : base(attributes, null, name, parameters, body) {
    call_base_ = call_base;
    initializer_params_ = initializer_params;
  }

  public Constructor_7(int attributes, string name, ArrayList ^parameters, Block_7 ^body)
    : this(attributes, name, parameters, true, new ArrayList(), body) { }

  public override int Kind() { return MemberKind_7.Constructor_7; }

  protected override int ValidAttributes() {
    return Attribute_7.Private | Attribute_7.Protected | Attribute_7.Public;
  }

  public override bool Check(Context_7 ctx) {
    if (name_ != class_.name_) {
      Error("constructor name must match class name");
      return false;
    }
    return base.Check(ctx);
  }

  protected override bool CheckEntry(Context_7 ctx) {
    Class_7 c = call_base_ ? class_.Parent() : class_;
    if (c != null || initializer_params_.Count > 0) {
      initializer_ = (Constructor_7) Invocation_7.CheckInvoke(this, ctx, call_base_, c,
                                      c.name_, initializer_params_, MemberKind_7.Constructor_7);
      if (initializer_ == null)
        return false;
      if (initializer_ == this) {
        Error("constructor initializer invokes itself");
        return false;
      }
      initializer_.invoked_ = true;
    }
    return true;
  }

  // A Constructor_7 node in the control graph represents the call to the base constructor;
  // this node gets added when we call Invocation_7.CheckInvoke() above.
  public override Method_7 Calls() { return initializer_; }

  public override RValue_7 ^Eval(Env_7 env) {
    if (initializer_ == null || initializer_.class_ != class_) {
      // run instance variable initializers
      foreach (Field_7 f in class_.fields_)
        if (!f.IsConstOrStatic() && f.Initializer() != null)
          ((GObject_7) env.this_).Set(f, f.Initializer().Eval(Env_7.static_, f.Type()));
    }
    if (initializer_ != null)
      Invocation_7.CallMethod(env, env.this_, initializer_, initializer_params_, false);
    return body_.Eval(env);
  }

  void EmitInitializerArgs(SourceWriter_7 w) {
    w.WriteLine("({0});", Invocation_7.EmitArguments(initializer_, initializer_params_));
  }

  void EmitConstructorBody(SourceWriter_7 w) {
    w.OpenBrace();
    EmitExtraDeclarations(w);
    if (call_base_) {
      if (class_.constructors_.Count > 1)
        w.IWriteLine("_Init();");
      else class_.EmitInitializers(w);

      Class_7 parent = class_.Parent();
      if (parent != GObject_7.type_) {
        w.IWrite("{0}::_Construct", parent.name_);
        EmitInitializerArgs(w);
      }
    } else {
      w.IWrite("_Construct");
      EmitInitializerArgs(w);
    }

    body_.list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitDeclaration(SourceWriter_7 w) {
    ComputeRefs();

    // If_7 we're invoked by some other constructor then we need to declare a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void _Construct");
      EmitParameters(w);
      w.WriteLine(";");
    }

    // Now declare the actual C++ constructor.
    w.IWrite(name_);
    EmitParameters(w);
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_7 w) {
    // If_7 we're invoked by some other constructor then we need to emit a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void {0}::_Construct", name_);
      EmitParameters(w);
      EmitConstructorBody(w);
      w.WriteLine("");
    }

    // Now emit the actual C++ constructor.
    w.IWrite("{0}::{1}", name_, name_);
    EmitParameters(w);
    Class_7 parent = class_.Parent();
    if (parent != GObject_7.type_)
      w.Write(": {0}((Dummy *) 0) ", parent.name_);

    if (invoked_) {   // call the _Construct method we just generated
      w.Write("{ _Construct");
      EmitParameterNames(w);
      w.WriteLine("; }");
    } else EmitConstructorBody(w);
    w.WriteLine("");
  }
}

abstract class PropertyOrIndexer_7 : LMember_7 {
  // If_7 a get accessor is not declared at all, then get_block_ will be null; if it is
  // declared, but has an empty body ("get;") then get_block_ will be a Block_7 whose list_ is
  // null.  We need to distinguish these cases since for abstract or extern properties the
  // presence of a get accessor with an empty body indicates that a property is readable.
  // (set_block_ works similarly.)
  Block_7 ^get_block_, set_block_;

  protected Method_7 getter_, setter_;

  protected PropertyOrIndexer_7(int attributes, TypeExpr_7 ^type_expr, string name,
                              string id1, Block_7 ^block1, string id2, Block_7 ^block2)
    : base(attributes, type_expr, name) {
    StoreAccessor(id1, block1);
    if (id2 != null)
      StoreAccessor(id2, block2);
    if (id1 == id2)
      Error("can't have two {0} accessors", id1);
  }

  void StoreAccessor(string id, Block_7 ^block) {
    // Note that we don't have scanner tokens GET and SET since these are not keywords in GEL2.
    switch (id) {
      case "get": get_block_ = block; return;
      case "set": set_block_ = block; return;
    }
    Error("expected get or set");
  }

  public Method_7 Getter() { return getter_; }
  public Method_7 Setter() { return setter_; }

  protected abstract string BaseName();

  ArrayList ^CopyParameters() {
    ArrayList ^a = new ArrayList();
    foreach (Parameter_7 p in Parameters())
      a.Add(p.Copy());
    return a;
  }

  public override bool Check(Context_7 ctx) {
    if (!base.Check(ctx))
      return false;

    if (get_block_ != null) {
      Method_7 ^m = new Method_7(attributes_, new TypeLiteral_7(type_), "get_" + BaseName(), CopyParameters(), take get_block_);
      getter_ = m;
      class_.Add(m);
      if (!getter_.Resolve(ctx.program_) || !getter_.Check(ctx))
        return false;
    }

    if (set_block_ != null) {
      ArrayList ^set_params = CopyParameters();
      set_params.Add(new Parameter_7(new TypeLiteral_7(type_), "value"));
      Method_7 ^m = new Method_7(attributes_ | Attribute_7.Setter,
                           new TypeLiteral_7(Void_7.type_), "set_" + BaseName(), set_params, take set_block_);
      setter_ = m;
      class_.Add(m);
      if (!setter_.Resolve(ctx.program_) || !setter_.Check(ctx))
        return false;
    }

    return true;
  }

  public override bool CheckAssigning(Syntax_7 caller, Context_7 ctx, bool assigning) {
    if (assigning && set_block_ == null && setter_ == null) {
      caller.Error("can't assign to read-only {0}", KindString());
      return false;
    }
    if (!assigning && get_block_ == null && getter_ == null) {
      caller.Error("can't read from write-only {0}", KindString());
      return false;
    }
    return true;
  }

  public override Location_7 GetLocation(GObject_7 obj) { Debug.Assert(false); return null; }
}

class Property_7 : PropertyOrIndexer_7 {
  public Property_7(int attributes, TypeExpr_7 ^type_expr, string name,
                  string id1, Block_7 ^block1, string id2, Block_7 ^block2)
    : base(attributes, type_expr, name, id1, block1, id2, block2) { }

  public override int Kind() { return MemberKind_7.Property_7; }

  protected override int ValidAttributes() {
    return Method_7.kValidAttributes;
  }

  protected override string BaseName() { return name_; }

  public override RValue_7 ^Get(GValue_7 obj) {
    return Invocation_7.InvokeMethod(obj, getter_, new ArrayList(), true);
  }

  public override void Set(GObject_7 obj, RValue_7 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(val);
    Invocation_7.InvokeMethod(obj, setter_, a, true);
  }

  public override string Emit() {
    return String.Format("get_{0}()", name_);
  }

  public override string EmitSet(string val) {
    return String.Format("set_{0}({1})", name_, val);
  }
}

class Indexer_7 : PropertyOrIndexer_7 {
  public readonly Parameter_7 parameter_;

  ArrayList /* of Parameter_7 */ ^parameters_;

  public Indexer_7(int attributes, TypeExpr_7 ^type_expr, Parameter_7 ^parameter,
                 string id1, Block_7 ^block1, string id2, Block_7 ^block2)
    : base(attributes, type_expr, null, id1, block1, id2, block2) {
    parameter_ = parameter;

    parameters_ = new ArrayList();
    parameters_.Add(parameter);
  }

  public override int Kind() { return MemberKind_7.Indexer_7; }

  public override bool Resolve(Program_7 program) {
    return base.Resolve(program) && parameter_.Resolve(program);
  }

  protected override int ValidAttributes() {
    return Attribute_7.Abstract | Attribute_7.Override |
    Attribute_7.Private | Attribute_7.Protected | Attribute_7.Public | Attribute_7.Virtual;
  }

  protected override string BaseName() { return "Item"; }

  public override bool Check(Context_7 ctx) {
    if (parameter_ is RefOutParameter_7) {
      Error("indexer parameter may not be ref or out");
      return false;
    }

    return base.Check(ctx);
  }

  public override ArrayList /* of Parameter_7 */ Parameters() {
    return parameters_; 
  }

  public RValue_7 ^Get(GValue_7 obj, RValue_7 ^index) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    return Invocation_7.InvokeMethod(obj, getter_, a, true);
  }

  public void Set(GObject_7 obj, RValue_7 ^index, RValue_7 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    a.Add(val);
    Invocation_7.InvokeMethod(obj, setter_, a, true);
  }
}

class Class_7 : Ownable_7 {
  Syntax_7 ^syntax_ = new Syntax_7();
  Program_7 program_;   // containing program
  int attributes_;
  public readonly string name_;
  string parent_name_;    // or null if not specified

  Class_7 parent_;

  public readonly NonOwningArrayList /* of Field_7 */ ^fields_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Method_7 */ ^methods_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Property_7 */ ^properties_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Indexer_7 */ ^indexers_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Constructor_7 */ ^constructors_ = new NonOwningArrayList();

  public readonly ArrayList /* of Member_7 */ ^members_ = new ArrayList();

  public readonly ArrayList /* of Temporaries_7 */ ^temporaries_ = new ArrayList();

  public readonly NonOwningArrayList /* of Class_7 */ ^subclasses_ = new NonOwningArrayList();
  bool emitted_;

  // If_7 virtual_ is true, then this class needs a vtable; we set this for a class C
  // in any of the following cases:
  // - the program converts some type T to C ^ (for then a C ^ may hold a T, and when
  // the owning pointer is destroyed we need to know which destructor to call)
  // - the program explicitly converts from C to some other type (so we need RTTI for C)
  bool virtual_;
  
  // If_7 object_inherit_ is true, then this class must derive from Object in generated C++
  // code; we set this for a class C in any of the following cases:
  // - a member lookup in C yields a member in Object
  // - the program converts from C to Object or from Object to C
  // - the class is used in a generic context, i.e. in the type C [] or C ^ [].  All such types
  //   use the generic compiled classes Array<Object> / Array<_Own<Object>>, and so in this case we need
  //   to be able to cast between C and Object.
  //
  // If_7 object_inherit_ is true then this class and all its superclasses will have vtables since
  // the C++ Object class has a vtable.
  bool object_inherit_;

  bool need_destroy_;  // true if we need to emit _Destroy methods for this class

  // The set of types which may be destroyed when an instance of this class is destroyed.
  TypeSet_7 ^destroys_;

  // A marker used in performing a depth-first search to construct the destroys_ type set.
  int marker_;

  protected Class_7(string name) { name_ = name; }

  public static Class_7 New_7(int attributes, string name, string parent_name) {
    Class_7 c = Internal_7.Find(name);
    if (c == null) {
      Class_7 ^c1 = new Class_7(name);
      c = c1;
      Gel_7.program_.AddOwn(c1);
    }

    c.attributes_ = attributes;
    c.parent_name_ = parent_name;

    return c;
  }

  public override bool IsOwned() { return true; }

  public Program_7 GetProgram() { return program_; }
  public void SetProgram(Program_7 p) { program_ = p; }

  public bool IsExtern() { return HasAttribute(Attribute_7.Extern); }

  public override Class_7 Parent() { return parent_; }

  public override string ToString() { return name_; }

  public override ArrayList Members() { return members_; }

  public override SimpleValue_7 DefaultValue_7() { return Null_7.Instance; }

  public override void SetVirtual() { virtual_ = true; }
  public override void SetObjectInherit() { object_inherit_ = true;  }
  public void NeedDestroy() { need_destroy_ = true; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public virtual GValue_7 ^New_7() { return new GObject_7(this); }
  public virtual RValue_7 ^InvokeStatic(Method_7 m, ValueList_7 args) { Debug.Assert(false); return null; }

  public void Add(Field_7 ^f) { f.SetClass(this); fields_.Add(f); members_.Add(f);  }

  public virtual void Add(Method_7 ^m) { m.SetClass(this); methods_.Add(m); members_.Add(m);  }

  public void Add(Property_7 ^p) { p.SetClass(this); properties_.Add(p); members_.Add(p);  }

  public void Add(Indexer_7 ^i) { i.SetClass(this); indexers_.Add(i); members_.Add(i); }

  public void AddConstructor(Constructor_7 ^c) { c.SetClass(this); constructors_.Add(c); members_.Add(c);  }

  public NonOwningArrayList /* of Member_7 */ ^FindAbstractMembers() {
    NonOwningArrayList /* of Member_7 */ ^a;
    if (parent_ != null)  {
      a = parent_.FindAbstractMembers();

      // remove members overridden in this class
      int i = 0;
      while (i < a.Count) {
        Member_7 m = (Member_7) a[i];
        Member_7 n = GetMatchingMember(m);
        if (n != null) {
          Debug.Assert(n.HasAttribute(Attribute_7.Abstract | Attribute_7.Override));
          a.RemoveAt(i);
        } else ++i;
      }
    } else a = new NonOwningArrayList();

    // add abstract members from this class
    foreach (Member_7 m in members_) {
      if (m.HasAttribute(Attribute_7.Abstract))
        a.Add(m);
    }

    return a;
  }

  public bool ResolveAll(Program_7 program) {
    if (parent_name_ != null) {
      parent_ = program.FindClass(parent_name_);
      if (parent_ == null) {
        syntax_.Error("can't find parent class {0}", parent_name_);
        return false;
      }
    } else if (this == GObject_7.type_)
      parent_ = null;
    else parent_ = GObject_7.type_;
    if (parent_ != null)
      parent_.subclasses_.Add(this);

    foreach (Member_7 m in members_)
      if (!m.Resolve(program))
        return false;

    if (!IsExtern() && constructors_.Count == 0)
      // add a default constructor
      AddConstructor(new Constructor_7(Attribute_7.Public, name_, new ArrayList(), Block_7.EmptyBlock()));

    return true;
  }

  // In our first checking pass we check all constant fields since we may need to evaluate them
  // in the course of checking other code.
  public bool Check1(Context_7 prev_ctx) {
    if (!AttributeUtil_7.CheckOnly(attributes_,
         Attribute_7.Abstract | Attribute_7.Extern | Attribute_7.Public)) {
      syntax_.Error("illegal class attribute");
      return false;
    }

    if (prev_ctx.program_.FindClass(name_) != this) {
      syntax_.Error("can't have two classes named {0}", name_);
      return false;
    }

    Context_7 ^ctx = new Context_7(prev_ctx, this);
    bool ok = true;
    foreach (Field_7 f in fields_) {
      ConstField_7 cf = f as ConstField_7;
      if (cf != null)
        ok &= cf.Check(ctx);
    }
    return ok;
  }

  public bool Check(Context_7 prev_ctx) {
    Context_7 ^ctx = new Context_7(prev_ctx, this);

    bool ok = true;

    foreach (Member_7 m in members_)
      if (m is Field_7 && !(m is ConstField_7) || m is Method_7)
        ok &= m.Check(ctx);

    // We need to check properties and indexers separately since they add methods to the members_
    // array as they are checked.
    foreach (Property_7 p in properties_)
      ok &= p.Check(ctx);
    foreach (Indexer_7 i in indexers_)
      ok &= i.Check(ctx);

    if (!HasAttribute(Attribute_7.Abstract)) {
      NonOwningArrayList ^a = FindAbstractMembers();
      if (a.Count > 0) {
        foreach (Member_7 m in a)
          syntax_.Error("class does not define inherited abstract {0} {1}", m.KindString(), m.name_);
        ok = false;
      }
    }

    return ok;
  }

  public void GetMainMethod(NonOwningArrayList /* of Method_7 */ result) {
    foreach (Method_7 m in methods_)
      if (m.name_ == "Main" && m.IsPublic() && m.IsStatic() && m.ReturnType() == Void_7.type_) {
        int c = m.parameters_.Count;
        if (c > 1)
          continue;
        if (c == 1) {
          Parameter_7 p = m.Param(0);
          if (p.GetMode() != 0 || !p.Type().Equals(new ArrayType_7(GString_7.type_)) )
            continue;
        }
        result.Add(m);
      }
  }

  public override void FindTypeDestroys(int marker, TypeSet_7 set) {
    if (marker_ == marker)
      return;
    marker_ = marker;
    set.Add(this);
    for (Class_7 c = this; c != null; c = c.parent_) {
      if (c != this && c.marker_ == marker)
        break;
      foreach (Field_7 f in c.fields_)
        if (!f.IsConstOrStatic())
          f.Type().FindVarDestroys(marker, set);
    }
    foreach (Class_7 c in subclasses_)
      c.FindTypeDestroys(marker, set);
  }

  public override TypeSet_7 TypeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_7();
      FindTypeDestroys(Control_7.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  public Temporaries_7 NewTemporaries() {
    Temporaries_7 ^t = new Temporaries_7();
    Temporaries_7 ret = t;
    temporaries_.Add(t);
    return ret;
  }

  public void StaticInit() {
    foreach (Field_7 f in fields_) {
      StaticField_7 sf = f as StaticField_7;
      if (sf != null)
        sf.Init();
    }
  }

  public override string EmitTypeName() { return name_; }

  int EmitAccess(SourceWriter_7 w, int old_access, int new_access) {
    new_access = (new_access & Attribute_7.Public) != 0 ? Attribute_7.Public : Attribute_7.Protected;

    if (new_access != old_access) {
      switch (new_access) {
        case Attribute_7.Protected:
          w.Indent(-1);
          w.WriteLine("protected:");
          break;
        case Attribute_7.Public:
          w.Indent(-1);
          w.WriteLine("public:");
          break;
        default:
          Debug.Assert(false);
          break;
      }
    }

    return new_access;
  }

  public void EmitInitializers(SourceWriter_7 w) {
    foreach (Field_7 f in fields_)
      if (!f.IsConstOrStatic())
        f.EmitInitializer(w);
  }

  // Return_7 true if this top-level class must inherit from Object.
  bool ObjectInherit() {
    if (object_inherit_)
      return true;
    foreach (Class_7 c in subclasses_)
      if (c.ObjectInherit())
        return true;
    return false;
  }

  public void EmitDeclaration(SourceWriter_7 w) {
    if (emitted_ || IsExtern())
      return;

    // C++ requires a parent class to appear before its subclasses in a source file.
    parent_.EmitDeclaration(w);

    emitted_ = true;

    w.Write("class {0} ", name_);
    if (parent_ != null)
      w.Write(": public {0} ",
              parent_ == GObject_7.type_ && !ObjectInherit() ? "_Object" : parent_.name_);
    w.OpenBrace();

    int access = 0;

    if (fields_.Count > 0) {
      foreach (Field_7 f in fields_) {
        access = EmitAccess(w, access, f.attributes_);
        f.EmitDeclaration(w);
      }
      w.WriteLine("");
    }

    if (subclasses_.Count > 0) {
      access = EmitAccess(w, access, Attribute_7.Protected);
      w.IWrite("{0}(Dummy *dummy) ", name_);
      if (parent_ != GObject_7.type_)
        w.Write(": {0}(dummy) ", parent_.name_);
      w.WriteLine("{ }");
      w.WriteLine("");
    }

    // If_7 we have more than one constructor, emit an _Init() method which constructors can
    // call to initialize instance variables.
    if (constructors_.Count > 1) {
      access = EmitAccess(w, access, Attribute_7.Protected);
      w.IWriteLine("void _Init();");
      w.WriteLine("");
    }

    foreach (Constructor_7 c in constructors_) {
      access = EmitAccess(w, access, c.attributes_);
      c.EmitDeclaration(w);
    }

    if (virtual_) {
      access = EmitAccess(w, access, Attribute_7.Public);
      w.IWrite("virtual ~{0}()", name_);
      w.WriteLine(" { }");
      w.WriteLine("");
    }

    if (need_destroy_) {
      access = EmitAccess(w, access, Attribute_7.Public);
      w.IWriteLine("GEL_OBJECT({0})", name_);
      w.WriteLine("");
    }

    foreach (Method_7 m in methods_) {
      access = EmitAccess(w, access, m.attributes_);
      m.EmitDeclaration(w);
    }

    w.SubIndent();
    w.WriteLine("};");
    w.WriteLine("");
  }

  public void Emit(SourceWriter_7 w) {
    if (IsExtern())
      return;

    if (fields_.Count > 0) {
      foreach (Field_7 f in fields_)
        f.Emit(w);
      w.WriteLine("");
    }

    if (constructors_.Count > 1) {
      w.IWrite("void {0}::_Init() ", name_);
      w.OpenBrace();
      EmitInitializers(w);
      w.CloseBrace();
      w.WriteLine("");
    }

    foreach (Constructor_7 c in constructors_)
      c.Emit(w);

    foreach (Method_7 m in methods_)
      m.Emit(w);

    if (Gel_7.print_type_sets_)
      Console.WriteLine("~{0}: {1}", name_, TypeDestroys());
  }
}

class ClassPtr_7 {
  public readonly Class_7 class_;

  public ClassPtr_7(Class_7 c) { class_ = c; }
}

class ValueList_7 {
  public ArrayList list_;
  public ValueList_7(ArrayList list) { list_ = list; }

  public GValue_7 Object(int i) { return ((RValue_7) list_[i]).Get(); }
  public bool Bool(int i) { return ((GBool_7) list_[i]).b_; }
  public int Int(int i) { return ((GInt_7) list_[i]).i_; }
  public char Char(int i) { return ((GChar_7) list_[i]).c_; }
  public string GetString(int i) { return ((GString_7) list_[i]).s_; }
}

class Internal_7 : Class_7 {
  static NonOwningArrayList /* of Internal_7 */ ^all_ = new NonOwningArrayList();

  protected Internal_7(string name) : base(name) { }

  public static Internal_7 Find(string name) {
    foreach (Internal_7 p in all_)
      if (p.name_ == name)
        return p;
    return null;
  }

  static void Add(Internal_7 p) { all_.Add(p); }

  public static void Init() {
    Add(GObject_7.type_);
    Add(GArray_7.array_class_);
    Add(GBool_7.type_);
    Add(GChar_7.type_);
    Add(GDouble_7.type_);
    Add(GFloat_7.type_);
    Add(GInt_7.type_);
    Add(GString_7.type_);
    Add(GStringBuilder_7.type_);
    Add(PoolClass_7.instance_);
    Add(DebugClass_7.instance_);
    Add(EnvironmentClass_7.instance_);

    Add(ConsoleClass_7.instance_);
    Add(FileClass_7.instance_);
    Add(PathClass_7.instance_);
    Add(GStreamReader_7.type_);
  }
}

class ObjectClass_7 : Internal_7 {
  public Method_7 equals_;
  public Method_7 get_hash_code_;
  public Method_7 to_string_;

  public ObjectClass_7() : base("Object") { }

  public override void Add(Method_7 ^m) {
    switch (m.name_) {
      case "Equals": equals_ = m; break;
      case "GetHashCode": get_hash_code_ = m; break;
      case "ToString": to_string_ = m; break;
    }
    base.Add(m);
  }
}

class ArrayClass_7 : Internal_7 {
  public ArrayClass_7() : base("Array") { }
}

abstract class SimpleType_7 : Internal_7 {
  protected SimpleType_7(string name) : base(name) { }

  public override bool IsOwned() { return false; }
  public override bool IsReference() { return false; }
  public override bool IsValue() { return true; }

  public override string EmitExprType() { return EmitType(); }
  public override string EmitType() { Debug.Assert(false); return null; }
}

abstract class IntegralType_7 : SimpleType_7 {
  protected IntegralType_7(string name) : base(name) { }
}

class BoolClass_7 : IntegralType_7 {
  public BoolClass_7() : base("Bool") { }

  static GBool_7 ^default_ = new GBool_7(false);
  public override SimpleValue_7 DefaultValue_7() { return default_; }

  public override string ToString() { return "bool"; }

  public override string EmitType() { return "bool"; }
}

class CharClass_7 : IntegralType_7 {
  public CharClass_7() : base("Char") { }

  static GChar_7 ^default_ = new GChar_7('\0');

  public override SimpleValue_7 DefaultValue_7() { return default_; }

  public override bool CanConvert1(GType_7 t) { return t == GInt_7.type_; }

  public override string ToString() { return "char"; }

  public override RValue_7 ^InvokeStatic(Method_7 m, ValueList_7 args) {
    switch (m.name_) {
      case "IsDigit": return new GBool_7(Char.IsDigit(args.Char(0)));
      case "IsLetter": return new GBool_7(Char.IsLetter(args.Char(0)));
      case "IsWhiteSpace": return new GBool_7(Char.IsWhiteSpace(args.Char(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "wchar_t"; }
}

class IntClass_7 : IntegralType_7 {
  public IntClass_7() : base("Int") { }

  static GInt_7 ^default_ = new GInt_7(0);

  public override SimpleValue_7 DefaultValue_7() { return default_; }

  public override bool CanConvert1(GType_7 t) {
    return t == GFloat_7.type_ || t == GDouble_7.type_;
  }

  protected override bool CanConvertExplicit1(GType_7 t) {
    return t == GChar_7.type_;
  }

  public override string ToString() { return "int"; }

  public override RValue_7 ^InvokeStatic(Method_7 m, ValueList_7 args) {
    switch (m.name_) {
      case "Parse": return new GInt_7(int.Parse(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "int"; }
}

class FloatClass_7 : SimpleType_7 {
  public FloatClass_7() : base("Single") { }

  static GFloat_7 ^default_ = new GFloat_7(0.0f);

  public override SimpleValue_7 DefaultValue_7() { return default_; }

  public override bool CanConvert1(GType_7 t) {
    return t == GDouble_7.type_;
  }

  protected override bool CanConvertExplicit1(GType_7 t) {
    return t == GInt_7.type_;
  }

  public override string ToString() { return "float"; }

  public override string EmitType() { return "float"; }
}

class DoubleClass_7 : SimpleType_7 {
  public DoubleClass_7() : base("Double") { }

  static GDouble_7 ^default_ = new GDouble_7(0.0d);

  public override SimpleValue_7 DefaultValue_7() { return default_; }

  protected override bool CanConvertExplicit1(GType_7 t) {
    return t == GInt_7.type_ || t == GFloat_7.type_;
  }

  public override string ToString() { return "double"; }

  public override string EmitType() { return "double"; }
}

class StringClass_7 : Internal_7 {
  public StringClass_7() : base("String") { }

  public override bool IsOwned() { return false; }
  public override bool IsValue() { return true; }

  public override string ToString() { return "string"; }

  public override string EmitType() {
    return "_Ref<String>";
  }

  public override string EmitReturnType() {
    return EmitType();
  }

  public override string EmitGenericType() {
    return EmitType();
  }

  public override RValue_7 ^InvokeStatic(Method_7 m, ValueList_7 args) {
    switch (m.name_) {
      case "Format": return new GString_7(String.Format(args.GetString(0), args.Object(1)));
      default: Debug.Assert(false); return null;
    }
  }
}

class StringBuilderClass_7 : Internal_7 {
  public StringBuilderClass_7() : base("StringBuilder") { }
  public override GValue_7 ^New_7() { return new GStringBuilder_7(); }
}

class GStringBuilder_7 : GValue_7 {
  readonly StringBuilder ^b_ = new StringBuilder();

  public static readonly StringBuilderClass_7 ^type_ = new StringBuilderClass_7();

  public override GType_7 Type() { return type_; }

  public override RValue_7 ^Invoke(Method_7 m, ValueList_7 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "Append": b_.Append(args.Char(0)); return null;
      case "ToString": return new GString_7(b_.ToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class PoolClass_7 : Internal_7 {
  public PoolClass_7() : base("Pool") { }

  public static PoolClass_7 ^instance_ = new PoolClass_7();
}

class DebugClass_7 : Internal_7 {
  public DebugClass_7() : base("Debug") { }
  public static readonly DebugClass_7 ^instance_ = new DebugClass_7();
  
  public override RValue_7 ^InvokeStatic(Method_7 m, ValueList_7 args) {
    switch (m.name_) {
      case "Assert": Debug.Assert(args.Bool(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

class EnvironmentClass_7 : Internal_7 {
  public EnvironmentClass_7() : base("Environment") { }
  public static readonly EnvironmentClass_7 ^instance_ = new EnvironmentClass_7();

  public override RValue_7 ^InvokeStatic(Method_7 m, ValueList_7 args) {
    switch (m.name_) {
      case "Exit": Environment.Exit(args.Int(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

// built-in I/O classes

class ConsoleClass_7 : Internal_7 {
  public ConsoleClass_7() : base("Console") { }

  public override RValue_7 ^InvokeStatic(Method_7 m, ValueList_7 args) {
    switch (m.name_) {
      case "Write":
        switch (m.parameters_.Count) {
          case 1: Console.Write(args.Object(0)); return null;
          case 2: Console.Write(args.GetString(0), args.Object(1)); return null;
          case 3: Console.Write(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      case "WriteLine":
        switch (m.parameters_.Count) {
          case 1: Console.WriteLine(args.Object(0)); return null;
          case 2: Console.WriteLine(args.GetString(0), args.Object(1)); return null;
          case 3: Console.WriteLine(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly ConsoleClass_7 ^instance_ = new ConsoleClass_7();
}

class FileClass_7 : Internal_7 {
  public FileClass_7() : base("File") { }

  public override RValue_7 ^InvokeStatic(Method_7 m, ValueList_7 args) {
    switch (m.name_) {
      case "Delete": File.Delete(args.GetString(0)); return null;
      case "Exists": return new GBool_7(File.Exists(args.ToString()));
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly FileClass_7 ^instance_ = new FileClass_7();
}

class PathClass_7 : Internal_7 {
  public PathClass_7() : base("Path") { }

  public override RValue_7 ^InvokeStatic(Method_7 m, ValueList_7 args) {
    switch (m.name_) {
      case "GetTempFileName": return new GString_7(Path.GetTempFileName());
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly PathClass_7 ^instance_ = new PathClass_7();
}

class StreamReaderClass_7 : Internal_7 {
  public StreamReaderClass_7() : base("StreamReader") { }
  public override GValue_7 ^New_7() { return new GStreamReader_7(); }
}

class GStreamReader_7 : GValue_7 {
  StreamReader ^reader_;

  public static readonly StreamReaderClass_7 ^type_ = new StreamReaderClass_7();

  public override GType_7 Type() { return type_; }

  public override RValue_7 ^Invoke(Method_7 m, ValueList_7 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StreamReader": reader_ = new StreamReader(args.GetString(0)); return null;
      case "Read": return new GInt_7(reader_.Read());
      case "Peek": return new GInt_7(reader_.Peek());
      default: Debug.Assert(false); return null;
    }
  }
}

class Program_7 {
  ArrayList /* of string */ ^gel_import_ = new ArrayList();
  ArrayList /* of string */ ^cpp_import_ = new ArrayList();

  static Scanner_7 ^scanner_;

  NonOwningArrayList ^classes_ = new NonOwningArrayList();
  ArrayList ^own_classes_ = new ArrayList();

  public bool crt_alloc_;
  public bool debug_;
  public bool safe_ = true;

  public Control_7 prev_;   // previous node in control flow graph, used during graph construction

  public void Import(string s) {
    ArrayList a = null;
    string extension = Path.GetExtension(s);
    switch (extension) {
      case ".gel": a = gel_import_; break;
      case ".cpp": a = cpp_import_; break;
      default:
        new Syntax_7().Error("can't import file with extension {0}", extension);
        Environment.Exit(0);
        break;
    }
    foreach (string i in a)
      if (i == s)
        return;   // already imported
    a.Add(s);
  }

  public void FindAndImport(string s) {
    // First look relative to the importing file.
    string dir = Path.GetDirectoryName(Gel_7.CurrentFile());
    string s1 = Path.Combine(dir, s);
    if (!File.Exists(s1)) {
      // Now look relative to the GEL2 directory.
      s1 = Path.Combine(Gel_7.gel_directory_, s);
      if (!File.Exists(s1)) {
        new Syntax_7().Error("import not found: ", s);
        Environment.Exit(0);
      }
    }
    Import(s1);
  }
  
  public void Add(Class_7 c) {
    c.SetProgram(this);
    classes_.Add(c);
  }

  public void AddOwn(Class_7 ^c) {
    own_classes_.Add(c);
  }

  public Class_7 FindClass(string name) {
    foreach (Class_7 c in classes_)
      if (c.name_ == name)
        return c;
    return null;
  }

  public string CurrentFile() {
    return scanner_.filename_;
  }

  public int Line() {
    return scanner_.Line();
  }

  string Builtin(string module) {
    string file = String.Format("{0}.gel", module);
    return Path.Combine(Gel_7.gel_directory_, file);
  }

  public bool Parse() {
    Parser ^parser = new Parser();
    for (int i = 0; i < gel_import_.Count; ++i) {
      string file = (string) gel_import_[i];
      scanner_ = new Scanner_7(file);
      parser.yyParse(scanner_);
      if (i == 0) {
        Import(Builtin("internal"));
        Import(Builtin("library"));
      }
    }
    return true;
  }

  public bool Resolve() {
    foreach (Class_7 c in classes_)
      if (!c.ResolveAll(this))
        return false;

    return true;
  }

  public bool Check() {
    Context_7 ^ctx = new Context_7(this);
    bool ok = true;

    // Make a first checking pass where we check only constant fields.
    foreach (Class_7 c in classes_)
      ok &= c.Check1(ctx);

    foreach (Class_7 c in classes_)
      ok &= c.Check(ctx);

    return ok;
  }

  Method_7 FindMain() {
    NonOwningArrayList ^methods = new NonOwningArrayList();
    foreach (Class_7 c in classes_) {
      c.GetMainMethod(methods);
    }
    if (methods.Count == 0) {
      Console.WriteLine("no Main() method found");
      return null;
    }
    if (methods.Count > 1) {
      Console.WriteLine("error: found more than one Main() method");
      return null;
    }
    return (Method_7) methods[0];
  }

  public void Eval(ArrayList /* of string */ args) {
    Method_7 m = FindMain();
    if (m == null)
      return;
    ArrayList ^a = new ArrayList();
    if (m.parameters_.Count > 0) {   // Main() takes a string[] argument
      GArray_7 ^arr = new GArray_7(new ArrayType_7(GString_7.type_), args.Count);
      for (int i = 0 ; i < args.Count ; ++i)
        arr.Set(i, new GString_7((string) args[i]));
      a.Add(arr);
    }
    foreach (Class_7 c in classes_)
      c.StaticInit();
    m.Invoke(null, a);
  }

  void EmitMain(SourceWriter_7 w, Method_7 main) {
    bool args = main.parameters_.Count > 0;
    w.Write("int main({0}) ", args ? "int argc, char *argv[]" : "");
    w.OpenBrace();
    w.IWriteLine("return gel_runmain({0}::Main{1});", main.GetClass().name_, args ? ", argc, argv" : "");
    w.CloseBrace();
  }

  public bool Emit(SourceWriter_7 w) {
    Method_7 main = FindMain();
    if (main == null)
      return false;

    w.WriteLine("#define MEMORY_OWN 1");
    if (safe_)
      w.WriteLine("#define MEMORY_SAFE 1");
    if (crt_alloc_)
      w.WriteLine("#define MEMORY_CRT 1");

    foreach (string f in cpp_import_)
      w.WriteLine("#include {0}", GString_7.EmitString(f));

    // We undefine NULL since Gel_7 code may legitimately define fields or variables with that name.
    // Generated code uses 0, not NULL, to indicate the null pointer.
    w.WriteLine("#undef NULL");

    w.WriteLine("");

    // Forward-declare all classes since C++ requires a class to be declared before its name can
    // be used as a type.
    foreach (Class_7 c in classes_)
      if (!(c.HasAttribute(Attribute_7.Extern)))
        w.WriteLine("class {0};", c.name_);
    w.WriteLine("");

    foreach (Class_7 c in classes_)
      c.EmitDeclaration(w);

    foreach (Class_7 c in classes_)
      c.Emit(w);

    EmitMain(w, main);
    return true;
  }

  // Emit C++ code.
  public bool Generate(string basename) {
    string cpp_file = basename + ".cpp";
    StreamWriter ^w = new StreamWriter(cpp_file);
    bool ok = Emit(new SourceWriter_7(w));
    w.Close();
    return ok;
  }

  static string[] ^vsdirs = { "Microsoft Visual Studio 8",
                            "Microsoft Visual Studio .NET 2003",
                            "Microsoft Visual Studio .NET 2002" };

  string VsVars(int i) {
    return String.Format("C:\\Program_7 Files\\{0}\\Common7\\Tools\\vsvars32.bat", vsdirs[i]);
  }

  string FindVsVars() {
    for (int i = 0; i < vsdirs.Length; ++i) {
      string f = VsVars(i);
      if (File.Exists(f))
        return f;
    }

    Console.WriteLine("Error: unable to find vsvars32.bat at any of the following locations:");
    Console.WriteLine("");
    for (int i = 0; i < vsdirs.Length; ++i)
      Console.WriteLine(VsVars(i));
    Console.WriteLine("");
    Console.WriteLine("Your Visual Studio installation may be invalid.  Aborting compilation.");
    return null;
  }

  // Report compilation error. Print error message from a file
  void ReportCompilationError(string error_msg_file) {
      Console.WriteLine(
        "Error: unable to compile generated C++ code.  You may have found a bug in the GEL2 compiler.");
      Console.WriteLine("C++ compiler output follows:");
      Console.WriteLine("");
      Console.WriteLine((new StreamReader(error_msg_file)).ReadToEnd());
  }

  void UnixCppCompile(string basename) {
    string command_out = Path.GetTempFileName();
    string dbg_options = debug_ ? "-g -DDEBUG" : "-O2 -DNDEBUG";
    StringBuilder ^sb = new StringBuilder();
    // -o basename, use basename as the executable name
    // -Werror, make all warnings into hard errors
    sb.AppendFormat("/usr/bin/g++ -o {0} -Werror {1} {2}.cpp",
                    basename, dbg_options, basename);

    // Append redirection of output
    sb.AppendFormat(" > {0} 2>&1", command_out);
 
    string sh_cmd = sb.ToString();

    if (Gel_7.verbose_) 
      Console.WriteLine(sh_cmd);
  
    if (Process.System(sh_cmd) !=0) {
      ReportCompilationError(command_out);
    }
    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".o");
  }

  // Run vsvars32.bat and the run the given command, redirecting output to a file.
  // We must always redirect output since vsvars32 prints a message "Setting environment..."
  // which we don't want users to see.
  int VsRun(string vsvars, string command, string output) {
    command = String.Format("(\"{0}\" & {1}) > \"{2}\"", 
                            vsvars, command, output);
    return Process.System(command);
  }

  void VsCppCompile(string basename) {
    string vsvars = FindVsVars();
    if (vsvars == null)
      return;
    string command_out = Path.GetTempFileName();

    string options = debug_ ?
      //  /MDd - runtime library: multithreaded debug DLL
      //  /Od - optimization: disabled
      //  /ZI - debug information format: Program_7 Database for Edit & Continue_7
      "/MDd /Od /ZI /D \"_DEBUG\"" :

      //  /MD - runtime library: multithreaded DLL
      //  /O2 - optimization: Maximize Speed
      //  /GL - optimization: Whole Program_7 Optimization
      "/MD /O2 /GL /D \"NDEBUG\"";

    StringBuilder ^sb = new StringBuilder();
    //  /WX - treat warnings as errors
    sb.AppendFormat("cl /nologo /WX {0} {1}.cpp", options, basename);
    string mode = debug_ ? "debug" : "release";
    if (!crt_alloc_)
      sb.AppendFormat(" {0}\\{1}\\dlmalloc.obj", Gel_7.gel_directory_, mode);
    sb.Append(" user32.lib shell32.lib shlwapi.lib");
    string command = sb.ToString();
    if (Gel_7.verbose_)
      Console.WriteLine(command);

    if (VsRun(vsvars, command, command_out) != 0) {
      ReportCompilationError(command_out);
    } else {
      // Run the manifest tool to embed the linker-generated manifest into the executable file;
      // this allows the executable to find the C runtime DLL even when the manifest file is absent.
      string mt_command = String.Format("mt -nologo -manifest {0}.exe.manifest -outputresource:\"{0}.exe;#1\"",
                              basename);
      if (Gel_7.verbose_)
        Console.WriteLine(mt_command);
      if (VsRun(vsvars, mt_command, command_out) != 0)
        Console.WriteLine("warning: could not run manifest tool");
    }

    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".obj");
    File.Delete(basename + ".exe.manifest");
  }

  // Invoke the C++ compiler to generate a native executable.
  void CppCompile(string basename) {
    if (Environment.OSVersion.Platform == PlatformID.Win32NT) 
      VsCppCompile(basename);
    else
      UnixCppCompile(basename);
  }

  public void Compile(string output, bool cpp_only) {
    if (output == null)
      output = Path.GetFileNameWithoutExtension((string) gel_import_[0]);
    if (Generate(output) && !cpp_only)
      CppCompile(output);
  }
}

class Scanner_7 : yyInput {
  public readonly string filename_;

  int line_;
  public int Line() { return line_; }

  StreamReader ^sr_;
  int token_;
  object ^ value_;

  int next_token_ = -1;
  object ^ next_value_;

  public Scanner_7 (string filename) {
    filename_ = filename;
    sr_ = new StreamReader(filename);
    line_ = 1;
  }

  public override int GetToken () {
    return token_;
  }

  public override object ^ GetValue () {
    return take value_;
  }

  int Read() {
    int i = sr_.Read();
    if (i == '\n')
      ++line_;
    return i;
  }

  bool Read(out char c) {
    int i = Read();
    c = (char) i;
    return i != -1;
  }

  char Peek() {
    return (char) sr_.Peek();
  }

  string ReadWord(char first) {
    StringBuilder ^sb = new StringBuilder();
    if (first != '\0')
      sb.Append(first);
    while (true) {
      char c = Peek();
      if (!Char.IsLetter(c) && !Char.IsDigit(c) && c != '_')
        break;
      sb.Append(c);
      Read();
    }
    return sb.ToString();
  }

  // Read to the end of the current line.
  string ReadLine() {
    StringBuilder ^sb = new StringBuilder();
    char c;
    while (Read(out c)) {
      if (c == '\n')
        break;
      sb.Append(c);
    }
    return sb.ToString();
  }

  // Read a comment delimited by /* ... */, assuming we've already read the opening /*.
  // Returns true on success, or false on EOF.
  bool ReadDelimitedComment() {
    char prev = (char) 0;
    while (true) {
      char c;
      if (!Read(out c)) {
        Console.WriteLine("warning: unterminated comment at end of file");
        return false;
      }
      if (c == '/' && prev == '*')
        return true;
      prev = c;
    }
  }

  // Preprocess input, handling whitespace, comments and directives; return the first
  // character not eaten by preprocessing, or -1 on EOF.
  int GetChar() {
    while (true) {
      int i = Read();
      if (i == -1)
        return -1;   // end of input
      if (i == 0)
        continue;   // end of this file; move on
      char c = (char) i;

      if (c == '\n' && Peek() == '#') {
        Read();
        string directive = ReadWord('\0');
        if (directive == "line") {
          ReadLine();
          continue;
        }
        Console.WriteLine("error: unknown preprocessing directive {0}", directive);
        Environment.Exit(0);
      }

      if (Char.IsWhiteSpace(c))
        continue;

      if (c == '/') {
        switch (Peek()) {
          case '/':  // single-line comment
            Read();
            int line = line_;
            string s = ReadLine();
            if (Gel_7.error_test_ && s.StartsWith(" error"))
              Gel_7.expected_error_lines_.Add(line);
            continue;

          case '*':  // comment delimited by /* ... */
            Read();   // move past opening '*'
            if (!ReadDelimitedComment())
              return (char) 0;
            continue;
        }
      }

      return c;
    }
  }

  bool IsDigit(char c, bool hex) {
    if (Char.IsDigit(c))
      return true;
    if (!hex)
      return false;
    return (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');
  }

  // Read a number, possibly including a decimal point and/or exponent.
  string ReadNumber(char first, bool hex, out bool real) {
    bool dot = false, exp = false;
    StringBuilder ^sb = new StringBuilder();
    sb.Append(first);
    if (first == '.')
      dot = true;

    while (true) {
      bool need_digit = false;
      char c = Peek();
      if (c == '.' && !hex && !dot && !exp) {
        sb.Append(c);
        Read();
        dot = true;
        c = Peek();
        need_digit = true;
      }
      else if ((c == 'e' || c == 'E') && !hex && !exp) {
        sb.Append(c);
        Read();
        exp = true;
        c = Peek();
        if (c == '+' || c == '-') {
          sb.Append(c);
          Read();
          c = Peek();
        }
        need_digit = true;
      }
      if (!IsDigit(c, hex)) {
        if (!need_digit)
          break;
        real = false;
        return null;
      }
      sb.Append(c);
      Read();
    }

    real = dot || exp;
    return sb.ToString();
  }

  int ParseNumber(char first, out object ^val) {
    bool hex = false;
    if (first == '0') {
      char p = Peek();
      if (p == 'x' || p == 'X') {
        Read();
        hex = true;
      }
    }
    bool real;
    string s = ReadNumber(first, hex, out real);
    if (s == null) {
      val = null;
      return Parser.SCAN_ERROR;
    }
    if (!hex) {
      switch (Peek()) {
        case 'F':
        case 'f':
          Read();
          val = Single.Parse(s);
          return Parser.FLOAT_LITERAL;
        case 'D':
        case 'd':
          Read();
          real = true;
        break;
    }
    }
    if (real) {
      val = Double.Parse(s);
      return Parser.DOUBLE_LITERAL;
    }
    val = int.Parse(s, hex ? NumberStyles.HexNumber : NumberStyles.Integer);
    return Parser.INT_LITERAL;
  }

  int ParseWord(char first, out object ^val) {
    string s = ReadWord(first);

    val = null;
    switch (s) {
      case "abstract": return Parser.ABSTRACT;
      case "as": return Parser.AS;
      case "base": return Parser.BASE;
      case "bool": return Parser.BOOL;
      case "break": return Parser.BREAK;
      case "case": return Parser.CASE;
      case "char": return Parser.CHAR;
      case "class": return Parser.CLASS;
      case "const": return Parser.CONST_TOKEN;
      case "continue": return Parser.CONTINUE;
      case "default": return Parser.DEFAULT;
      case "do": return Parser.DO;
      case "double": return Parser.DOUBLE;
      case "else": return Parser.ELSE;
      case "extern": return Parser.EXTERN;
      case "false": return Parser.FALSE_TOKEN;
      case "float": return Parser.FLOAT;
      case "for": return Parser.FOR;
      case "foreach": return Parser.FOREACH;
      case "if": return Parser.IF;
      case "import": return Parser.IMPORT;
      case "in": return Parser.IN_TOKEN;
      case "int": return Parser.INT;
      case "is": return Parser.IS;
      case "new": return Parser.NEW;
      case "null": return Parser.NULL;
      case "object": return Parser.OBJECT;
      case "out": return Parser.OUT_TOKEN;
      case "override": return Parser.OVERRIDE;
      case "pool": return Parser.POOL;
      case "private": return Parser.PRIVATE;
      case "protected": return Parser.PROTECTED;
      case "public": return Parser.PUBLIC;
      case "readonly": return Parser.READONLY;
      case "ref": return Parser.REF;
      case "return": return Parser.RETURN;
      case "short": return Parser.SHORT;
      case "static": return Parser.STATIC;
      case "string": return Parser.STRING;
      case "switch": return Parser.SWITCH;
      case "take": return Parser.TAKE;
      case "this": return Parser.THIS_TOKEN;
      case "true": return Parser.TRUE_TOKEN;
      case "virtual": return Parser.VIRTUAL;
      case "void": return Parser.VOID_TOKEN;
      case "while": return Parser.WHILE;
      default:
        val = s;
        return Parser.ID;
    }
  }

  bool ParseEscape(ref char c) {
    if (!Read(out c))
      return false;
    switch (c) {
      case '\'':
      case '\"':
      case '\\':
        break;
      case '0': c = '\0'; break;
      case 'n': c = '\n'; break;
      case 'r': c = '\r'; break;
      case 't': c = '\t'; break;
      default: return false;
    }
    return true;
  }

  int ParseChar(out object ^val) {
    val = null;
    char c;
    if (!Read(out c))
      return Parser.SCAN_ERROR;
    if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
    char d;
    if (!Read(out d) || d != '\'')
      return Parser.SCAN_ERROR;
    val = c;
    return Parser.CHAR_LITERAL;
  }

  int ParseString(out object ^val) {
    val = null;
    StringBuilder ^sb = new StringBuilder();
    while (true) {
      char c;
      if (!Read(out c))
        return Parser.SCAN_ERROR;
      if (c == '"')
        break;
      if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
      sb.Append(c);
    }
    val = sb.ToString();
    return Parser.STRING_LITERAL;
  }

  int ReadToken(out object ^val) {
    val = null;

    int i = GetChar();
    if (i == -1)
      return -1;
    char c = (char) i;

    if (Char.IsDigit(c) || c == '.' && Char.IsDigit(Peek()))
      return ParseNumber(c, out val);

    if (Char.IsLetter(c) || c == '_')
      return ParseWord(c, out val);

    if (c == '\'')
      return ParseChar(out val);

    if (c == '"')
      return ParseString(out val);

    char peek = Peek();
    int token = 0;
    switch (c.ToString() + peek.ToString()) {
      case "++": token = Parser.PLUS_PLUS; break;
      case "--": token = Parser.MINUS_MINUS; break;
      case "&&": token = Parser.OP_AND; break;
      case "||": token = Parser.OP_OR; break;
      case "==": token = Parser.OP_EQUAL; break;
      case "!=": token = Parser.OP_NE; break;
      case "<=": token = Parser.OP_LE; break;
      case "<<": token = Parser.OP_LEFT_SHIFT; break;
      case ">=": token = Parser.OP_GE; break;
      case ">>": token = Parser.OP_RIGHT_SHIFT; break;
      case "*=": token = Parser.STAR_EQUAL; break;
      case "/=": token = Parser.SLASH_EQUAL; break;
      case "%=": token = Parser.PERCENT_EQUAL; break;
      case "+=": token = Parser.PLUS_EQUAL; break;
      case "-=": token = Parser.MINUS_EQUAL; break;
      case "&=": token = Parser.AND_EQUAL; break;
      case "|=": token = Parser.OR_EQUAL; break;

      // Return_7 [] as a single token; this lets the parser distinguish the cases
      // "foo[] a;" and "foo[x] = 4" as soon as it reads the first token after the identifier "foo".
      case "[]": token = Parser.ARRAY_TYPE; break;
    }
    if (token != 0) {
      Read();
    } else token = c;

    val = token;
    return token;
  }

  public override bool Advance () {
    if (next_token_ != -1) {
      token_ = next_token_;
      value_ = take next_value_;
      next_token_ = -1;
    } else {
      token_ = ReadToken(out value_);
      if (token_ == -1) return false;
    }

    if (token_ == ')') {
      // We need to read one token ahead to determine whether this close parenthesis
      // ends a type cast.  See e.g. the discussion in the Cast_7 Expressions section
      // of the C# specification.
      next_token_ = ReadToken(out next_value_);
      switch (next_token_) {
        case -1:  // end of file
          break;
        case '!':
        case '(':
        case Parser.ID:
        case Parser.INT_LITERAL:
        case Parser.CHAR_LITERAL:
        case Parser.STRING_LITERAL:
          token_ = Parser.CAST_CLOSE_PAREN;
          break;
        default:
          if (next_token_ >= Parser.FIRST_KEYWORD && next_token_ <= Parser.LAST_KEYWORD &&
              next_token_ != Parser.AS && next_token_ != Parser.IS)
            token_ = Parser.CAST_CLOSE_PAREN;
          break;
      }
    }
    return true;
  }

  public override void Fatal() {
    new Syntax_7().Error("irrecoverable syntax error");
    Environment.Exit(1);
  }

}

class Gel_7 {
  public static bool verbose_;

  public static bool error_test_;
  public static bool print_type_sets_;

  public static readonly ArrayList /* of int */ ^expected_error_lines_ = new ArrayList();
  public static readonly ArrayList /* of int */ ^error_lines_ = new ArrayList();

  public static Program_7 ^program_;

  public static readonly string gel_directory_ = GetLibraryPath();

  static string GetLibraryPath() {
    return Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName); 
  }

  public static string CurrentFile() {
    return program_ == null ? "" : program_.CurrentFile();
  }

  public static int Line() {
    return program_ == null ? 0 : program_.Line();
  }

  public static void Exit() { Environment.Exit(0); }

  // Given two sorted ArrayLists a, b of ints, return an ArrayList containing all ints which appear
  // in [a] but not in [b].
  ArrayList ^Diff(ArrayList a, ArrayList b) {
    ArrayList ^ret = new ArrayList();
    int bi = 0;
    foreach (int i in a) {
      while (bi < b.Count && (int) b[bi] < i)
        ++bi;
      if (bi >= b.Count || (int) b[bi] > i)
        ret.Add(i);
    }
    return ret;
  }

  void WriteLineNumbers(ArrayList a) {
    for (int i = 0; i < a.Count; ++i) {
      if (i > 0)
        Console.Write(", ");
      Console.Write(a[i]);
    }
    Console.WriteLine("");
  }

  void ErrorTestReport() {
    Console.WriteLine("");
    ArrayList ^e = Diff(error_lines_, expected_error_lines_);
    if (e.Count > 0) {
      Console.Write("unexpected error at line ");
      WriteLineNumbers(e);
    }
    ArrayList ^e2 = Diff(expected_error_lines_, error_lines_);
    if (e2.Count > 0) {
      Console.Write("expected error at line ");
      WriteLineNumbers(e2);
    }
    if (e.Count == 0 && e2.Count == 0)
      Console.WriteLine("all errors expected");
  }

  void Usage_7() {
    Console.WriteLine("usage: gel <source-file> ... [args]");
    Console.WriteLine("       gel -c [-d] [-o <name>] [-u] [-v] [-cpp] <source-file> ...");
    Console.WriteLine("");
    Console.WriteLine("   -c: compile to native executable");
    Console.WriteLine("   -d: debug mode: disable optimizations, link with debug build of C runtime");
    Console.WriteLine("   -o: specify output filename");
    Console.WriteLine("   -u: unsafe: skip reference count checks");
    Console.WriteLine("   -v: verbose: display command used to invoke C++ compiler");
    Console.WriteLine(" -cpp: compile to C++ only");
  }

  public void Run(string[] args) {
    if (args.Length < 1) {
      Usage_7();
      return;
    }

    Internal_7.Init();

    program_ = new Program_7();
    bool compile = false;
    bool cpp_only = false;
    string output = null;
    int i;
    for (i = 0; i < args.Length && args[i].StartsWith("-"); ++i)
      switch (args[i]) {
        case "-c": compile = true; break;
        case "-d": program_.debug_ = true; break;
        case "-e": error_test_ = true; break;
        case "-o":
          if (++i >= args.Length) {
            Usage_7();
            return;
          }
          output = Path.GetFileNameWithoutExtension(args[i]);
          break;
        case "-u": program_.safe_ = false; break;
        case "-v": verbose_ = true; break;
        case "-cpp": cpp_only = true; break;
        case "-crt": program_.crt_alloc_ = true; break;
        case "-typeset": print_type_sets_ = true; break;
        default:
          Console.WriteLine("unrecognized option: {0}", args[i]);
          return;
      }

    for (; i < args.Length ; ++i)
      if (args[i].EndsWith(".gel"))
        program_.Import(args[i]);
      else {
        if (args[i] == "-")   // marker indicating end of source files
          ++i;
        break;
      }

    ArrayList ^program_args = new ArrayList();
    if (compile) {
      if (i < args.Length) {
        Console.WriteLine("file to compile has unrecognized extension: {0}", args[i]);
        return;
      }
    } else {
      for (; i < args.Length; ++i)
        program_args.Add(args[i]);
    }

    if (!program_.Parse())
      return;

    bool ok = program_.Resolve() && program_.Check();
    if (error_test_)
      ErrorTestReport();
    if (!ok)
      return;

    if (compile)
      program_.Compile(output, cpp_only);
    else program_.Eval(program_args);
  }

  public static void Main_7(string[] args) {
    new Gel_7().Run(args);
  }
}
/*
Copyright (c) 2006 Google Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

class Syntax_8 {
  public readonly string file_;
  public readonly int line_;

  public Syntax_8() { file_ = Gel_8.CurrentFile(); line_ = Gel_8.Line(); }

  static void Report(string file, int line, string type) {
    Console.Write("{0}({1}): ", file, line);
    Console.Write("{0}: ", type);
    if (Gel_8.error_test_)
      Gel_8.error_lines_.Add(line);
  }

  public void Error(string message) {
    Report(file_, line_, "error");
    Console.WriteLine(message);
  }

  public void Error(string format, object arg) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg);
  }

  public void Error(string format, object arg1, object arg2) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2);
  }

  public void Error(string format, object arg1, object arg2, object arg3) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2, arg3);
  }

  public void Warning(string message) {
    Report(file_, line_, "warning");
    Console.WriteLine(message);
  }
}

abstract class TypeExpr_8 : Syntax_8 {
  public abstract GType_8 Resolve(Program_8 program);
  public abstract TypeExpr_8 ^Copy();
}

class ConversionContext_8 {
  public const int Other = 0,
                   AssignVar = 1,
                   MethodArg = 2;
}

// GEL2 includes the following kinds of types:
// - simple types (int, bool, char, float, double): SimpleType_8
// - owned types (including array types): ArrayType_8 or Class_8 with Owned() => true
// - owning types: Owning_8
// - string: GString_8
// - null type: NullType_8
// - void: VoidType_8

abstract class GType_8 {
  public virtual bool IsOwned() { return false; }

  // A reference type is an owned, owning, string or null type.
  public virtual bool IsReference() { return true; }

  // A value type is a simple or string type.
  public virtual bool IsValue() { return false; }

  public virtual Class_8 Parent() { return GObject_8.type_; }
  
  // If_8 this is an owning type T ^ then return T; otherwise return this.
  public virtual GType_8 BaseType() { return this; }

  // Return_8 the set of types which may be destroyed when a variable of this type
  // is destroyed.
  public virtual TypeSet_8 VarDestroys() { return TypeSet_8.empty_; }

  // Return_8 the set of types which may be destroyed when a value of this concrete type
  // is destroyed.
  public virtual TypeSet_8 TypeDestroys() { return TypeSet_8.empty_; }

  public virtual void FindVarDestroys(int marker, TypeSet_8 set) { }

  public virtual void FindTypeDestroys(int marker, TypeSet_8 set) { }

  public virtual bool IsSubtype(GType_8 type) {
    for (GType_8 t = this; t != null ; t = t.Parent())
      if (type.Equals(t))
        return true;
    return false;
  }

  public virtual Owning_8 OwningType() { Debug.Assert(false); return null; }

  protected virtual bool CanConvertOwnership(GType_8 t, int context) {
    bool from_owning = this is Owning_8;
    bool to_owning = t is Owning_8;
    if (IsValue() && t.BaseType() == GObject_8.type_) {
      Debug.Assert(!from_owning);
      // boxing conversion yields an owning pointer; string->object conversion may
      // yield an owning or non-owning pointer
      return to_owning || context == ConversionContext_8.MethodArg || this == GString_8.type_;
    }
    if (BaseType() == GObject_8.type_ && t.IsValue()) {
      Debug.Assert(!to_owning);
      return true;  // an unboxing or object->string conversion, OK in any context
    }
    return from_owning == to_owning ||
           from_owning && !to_owning &&
             (context == ConversionContext_8.AssignVar || context == ConversionContext_8.MethodArg);
  }

  // Ensure that this class will inherit from Object in generated C++ code.
  public virtual void SetObjectInherit() { }

  // Return_8 true if there is a non-subtyping implicit conversion from this to t.
  public virtual bool CanConvert1(GType_8 t) { return false; }

  // Return_8 true if there is a non-subtyping explicit conversion from this to t.
  protected virtual bool CanConvertExplicit1(GType_8 t) { return false; }

  // Return_8 true if this type can be converted to type [to].
  public bool CanConvert(GType_8 to, int context, bool is_explicit, bool subtype_only) {
    if (!CanConvertOwnership(to, context))
      return false;

    GType_8 from_base = BaseType();
    GType_8 to_base = to.BaseType();
    if (from_base.Equals(to_base))
      return true;   // identity conversion

    // If_8 we ever perform a conversion to C ^, then C must have a vtable so that we can call
    // a virtual destructor when an owning pointer is destroyed.
    if (to is Owning_8 && this != Null_8.type_)
      to_base.SetVirtual();

    // If_8 we ever perform an explicit conversion from a class, that class must
    // have a vtable so that every instance of the class will have run-time type information.
    if (is_explicit)
      from_base.SetVirtual();

    // If_8 we ever convert between C and Object, then C must derive from Object in generated code.
    if (from_base == GObject_8.type_)
      to_base.SetObjectInherit();
    else if (to_base == GObject_8.type_)
      from_base.SetObjectInherit();

    return from_base.IsSubtype(to_base) ||
           !subtype_only && from_base.CanConvert1(to_base) ||
           is_explicit && (to_base.IsSubtype(from_base) ||
                           !subtype_only && from_base.CanConvertExplicit1(to_base));
  }

  public bool CanConvert(GType_8 t, int context) { return CanConvert(t, context, false, false); }
  public bool CanConvert(GType_8 t) { return CanConvert(t, ConversionContext_8.Other); }

  public bool CanConvertExplicit(GType_8 t, bool subtype_only) {
    return CanConvert(t, ConversionContext_8.Other, true, subtype_only);
  }

  public bool CheckConvert(Syntax_8 caller, GType_8 t, int context) {
    if (!CanConvert(t, context)) {
      caller.Error("can't convert {0} to {1}", this, t);
      return false;
    }
    return true;
  }

  public bool CheckConvert(Syntax_8 caller, GType_8 t) {
    return CheckConvert(caller, t, ConversionContext_8.Other);
  }

  // Return_8 a type to which the types [this] and t can both be implicitly converted.
  public GType_8 CommonType(Syntax_8 caller, GType_8 t) {
    if (CanConvert(t))
      return t;
    if (t.CanConvert(this))
      return this;
    caller.Error("incompatible types: {0} and {1}", this, t);
    return null;
  }

  public abstract SimpleValue_8 DefaultValue_8();

  static ArrayList ^empty_array_ = new ArrayList();
  public virtual ArrayList /* of Member_8 */ Members() { return empty_array_; }

  public Member_8 GetMatchingMember(Member_8 m1) {
    foreach (Member_8 m in Members())
      if (m.MatchSignature(m1))
        return m;
    return null;
  }

  // Find a match for m in this type or its ancestors, ignoring private members and
  // optionally ignoring overrides.
  public Member_8 FindMatchingMember(Member_8 m, bool override_ok) {
    for (GType_8 t = this ; t != null ; t = t.Parent()) {
      Member_8 m1 = t.GetMatchingMember(m);
      if (m1 != null && !m1.IsPrivate() && (override_ok || !m1.IsOverride()))
        return m1;
    }
    return null;
  }

  int Score(bool accessible, int mismatches) {
    return (accessible ? 0 : 100) + mismatches;
  }

  public Member_8 Lookup(Syntax_8 caller, Class_8 from_class, bool through_base,
                       int kind, string name, ArrayList /* of Argument_8 */ arguments, bool report_error) {
    Member_8 m1 = null;   // the best match we've found so far
    bool found_any = false;
    bool accessible = false;
    int score = -1;

    GType_8 this_type = BaseType();
    GType_8 t;
    for (t = this_type; t != null; t = (kind == MemberKind_8.Constructor_8 ? null : t.Parent())) {
      foreach (Member_8 m in t.Members())
        if (Member_8.MatchKind(m.Kind(), kind) && m.name_ == name && !m.IsOverride()) {
          found_any = true;
          int mismatches = 0;
          if (arguments != null && !m.IsApplicable(arguments, out mismatches))
            continue; // wrong argument count
          bool new_accessible = m.IsAccessible(from_class, this_type, through_base);
          int new_score = Score(new_accessible, mismatches);
          if (new_score == 0 && score == 0) {
            if (report_error)
              caller.Error("{0}: ambiguous {1} call", name, Member_8.ToString(kind));
            return null;
          }
          if (score == -1 || new_score < score) {
            m1 = m;
            score = new_score;
            accessible = new_accessible;
          }
        }
      if (score == 0)
        break;
    }

    if (score != 0) {
      if (report_error) {
        string k = Member_8.ToString(kind);
        if (!found_any)
          caller.Error("{0}: {1} not found", name, k);
        else if (score == -1) {
          string a = String.Format("{0} argument{1}", arguments.Count, arguments.Count == 1 ? "" : "s");
          caller.Error("{0}: no {1} overload takes {2}", name, k, a);
        } else if (!accessible)
          caller.Error("{0}: can't access {1} {2}",
                       name, m1.IsProtected() ? "protected" : "private", k);
        else {
          caller.Error("{0}: the best overloaded {1} match has some invalid arguments", name, k);
          m1.ReportMismatches(caller, arguments);
        }
      }
      return null;
    }

    // If_8 we've found a member of the Object class, then we're using this class as an object,
    // so in generated code it must ultimately inherit from Object, not _Object.
    if (t == GObject_8.type_)
      this_type.SetObjectInherit();

    if (through_base) {
      // As_8 a special case, whenever we're accessing through base we find the member which will
      // actually be invoked; this is not necessarily the same as the member we've just found
      // if the member is virtual.
      m1 = FindMatchingMember(m1, true);
      Debug.Assert(m1 != null);
    }

    return m1;
  }

  public virtual void SetVirtual() { }

  // Emit the name of the C++ class we use to hold instances of this type.
  public virtual string EmitTypeName() { Debug.Assert(false); return null; }

  // Return_8 a C++ type of the form "T<U>".  If_8 U ends with a '>', we emit an
  // extra space to avoid emitting the token >>, which will cause GCC to complain.
  public static string ConstructType(string generic, string type) {
    return String.Format("{0}<{1}{2}>", generic, type,
                         type.EndsWith(">") ? " " : "");
  }

  string EmitNonOwningPointer(string name) {
    if (Gel_8.program_.safe_)
      return ConstructType(this == GObject_8.type_ ? "_PtrRef" : "_Ptr", name);
    return String.Format("{0} *", name);
  }

  // Emit a C++ type used for variables holding instances of this type.
  public virtual string EmitType() {
    return EmitNonOwningPointer(EmitTypeName());
  }

  // Emit a C++ type used for expressions holding instances of this type.
  public virtual string EmitExprType() {
    return EmitTypeName() + " *";
  }

  public virtual string EmitReturnType() {
    return EmitExprType();
  }

  public virtual string EmitGenericType() {
    return IsReference() ? EmitNonOwningPointer("Object") : EmitType();
  }
}

class TypeSet_8 {
  NonOwningArrayList /* of GType_8 */ ^types_ = new NonOwningArrayList();

  public static readonly TypeSet_8 ^empty_ = new TypeSet_8();

  public void Add(GType_8 type) {
    for (int i = 0; i < types_.Count; ++i) {
      GType_8 t = (GType_8) types_[i];
      if (type.IsSubtype(t))
        return;
      if (t.IsSubtype(type)) {
        types_[i++] = type;
        while (i < types_.Count) {
          t = (GType_8) types_[i];
          if (t.IsSubtype(type))
            types_.RemoveAt(i);
          else ++i;
        }
        return;
      }
    }
    types_.Add(type);
  }

  public void Add(TypeSet_8 set) {
    foreach (GType_8 t in set.types_)
      Add(t);
  }

  public bool Contains(GType_8 type) {
    foreach (GType_8 t in types_)
      if (type.IsSubtype(t))
        return true;
    return false;
  }

  public bool IsObject() {
    return types_.Count > 0 && types_[0] == GObject_8.type_;
  }

  public override string ToString() {
    StringBuilder ^sb = new StringBuilder();
    sb.Append("{");
    foreach (GType_8 t in types_)
      sb.AppendFormat(" {0}", t.ToString());
    sb.Append(" }");
    return sb.ToString();
  }
}

class VoidType_8 : GType_8 {
  public override bool IsReference() { Debug.Assert(false); return false; }

  public override SimpleValue_8 DefaultValue_8() { Debug.Assert(false); return null; }

  public override string ToString() { return "void"; }

  public override string EmitExprType() { return "void"; }
  public override string EmitType() { return "void"; }
}

class Void_8 {
  public static readonly GType_8 ^type_ = new VoidType_8();
}

// an RValue_8, a Location_8 containing an RValue_8, or a LocationRef_8 pointing to a Location_8 containing an RValue_8
abstract class ValueOrLocation_8 {
  public abstract GValue_8 Get();
}

// a GValue_8 or a reference to a GValue_8
abstract class RValue_8 : ValueOrLocation_8 {
  public abstract RValue_8 ^CopyRef();
}

abstract class GValue_8 : RValue_8 {
  public override GValue_8 Get() { return this; }

  public abstract GType_8 Type();

  public override RValue_8 ^CopyRef() { return new Reference_8(this); }

  public virtual RValue_8 ^Get(Field_8 field) { Debug.Assert(false); return null; }
  public virtual RValue_8 ^Take_8(Field_8 field) { Debug.Assert(false); return null; }

  public virtual RValue_8 ^ConvertExplicit(ref RValue_8 ^this_own, GType_8 t) {
    // try implicit conversion
    RValue_8 ^v = Convert(ref this_own, t);
    if (v != this || Type().IsSubtype(t) )
      return v;

    Console.WriteLine("type cast failed: object of type {0} is not a {1}", Type(), t);
    Gel_8.Exit();
    return null;
  }

  // Implicitly convert this value to type t.
  public virtual RValue_8 ^Convert(ref RValue_8 ^this_own, GType_8 t) {
    return take this_own;
  }

  public virtual bool DefaultEquals(object o) { return Equals(o); }
  public virtual int DefaultHashCode() { return GetHashCode(); }
  public virtual string DefaultToString() { return ToString(); }

  public virtual RValue_8 ^Invoke(Method_8 m, ValueList_8 args) {
    switch (m.name_) {
      case "Equals": return new GBool_8(DefaultEquals(args.Object(0)));
      case "GetHashCode": return new GInt_8(DefaultHashCode());
      case "ToString": return new GString_8(DefaultToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class Reference_8 : RValue_8 {
  public readonly GValue_8 value_;    // a reference value, never a SimpleValue_8

  public Reference_8(GValue_8 v) { value_ = v; }

  public override GValue_8 Get() { return value_; }

  public override RValue_8 ^CopyRef() { return new Reference_8(value_); }
}

abstract class SimpleValue_8 : GValue_8 {
  public abstract SimpleValue_8 ^Copy();
  public override RValue_8 ^CopyRef() { return Copy(); }
  public abstract string Emit();
}

class GBool_8 : SimpleValue_8 {
  public readonly bool b_;

  public GBool_8(bool b) { b_ = b; }

  public override bool Equals(object o) {
    GBool_8 b = o as GBool_8;
    return b != null && b.b_ == b_;
  }

  public override int GetHashCode() { return b_.GetHashCode(); }

  public override SimpleValue_8 ^Copy() { return new GBool_8(b_); }

  public static readonly BoolClass_8 ^type_ = new BoolClass_8();

  public override GType_8 Type() { return type_; }

  public override string ToString() { return b_.ToString(); }

  public override string Emit() { return b_ ? "true" : "false"; }
}

class GInt_8 : SimpleValue_8 {
  public readonly int i_;

  public GInt_8(int i) { i_ = i; }

  public static readonly IntClass_8 ^type_ = new IntClass_8();

  public override GType_8 Type() { return type_; }

  public override bool Equals(object o) {
    GInt_8 i = o as GInt_8;
    return i != null && i.i_ == i_;
  }

  public override int GetHashCode() { return i_.GetHashCode(); }

  public override SimpleValue_8 ^Copy() { return new GInt_8(i_); }

  public override RValue_8 ^Convert(ref RValue_8 ^this_own, GType_8 t) {
    if (t == GFloat_8.type_)
      return new GFloat_8(i_);
    if (t == GDouble_8.type_)
      return new GDouble_8(i_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_8 ^ConvertExplicit(ref RValue_8 ^this_own, GType_8 t) {
    return t == GChar_8.type_ ? new GChar_8((char) i_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return i_.ToString(); }

  public override string Emit() { return i_.ToString(); }
}

class GFloat_8 : SimpleValue_8 {
  public readonly float f_;

  public GFloat_8(float f) { f_ = f; }

  public static readonly FloatClass_8 ^type_ = new FloatClass_8();

  public override GType_8 Type() { return type_; }

  public override bool Equals(object o) {
    GFloat_8 f = o as GFloat_8;
    return f != null && f.f_ == f_;
  }

  public override int GetHashCode() { return f_.GetHashCode(); }

  public override SimpleValue_8 ^Copy() { return new GFloat_8(f_); }

  public override RValue_8 ^Convert(ref RValue_8 ^this_own, GType_8 t) {
    if (t == GDouble_8.type_)
      return new GDouble_8(f_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_8 ^ConvertExplicit(ref RValue_8 ^this_own, GType_8 t) {
    return t == GInt_8.type_ ? new GInt_8((int) f_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return f_.ToString(); }

  public override string Emit() {
    string s = f_.ToString();
    return s + (s.IndexOf('.') == -1 ? ".0f" : "f");
  }
}

class GDouble_8 : SimpleValue_8 {
  public readonly double d_;

  public GDouble_8(double d) { d_ = d; }

  public static readonly DoubleClass_8 ^type_ = new DoubleClass_8();

  public override GType_8 Type() { return type_; }

  public override bool Equals(object o) {
    GDouble_8 d = o as GDouble_8;
    return d != null && d.d_ == d_;
  }

  public override int GetHashCode() { return d_.GetHashCode(); }

  public override SimpleValue_8 ^Copy() { return new GDouble_8(d_); }

  public override RValue_8 ^ConvertExplicit(ref RValue_8 ^this_own, GType_8 t) {
    if (t == GInt_8.type_)
      return new GInt_8((int) d_);
    if (t == GFloat_8.type_)
      return new GFloat_8((float) d_);
    return base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return d_.ToString(); }

  public override string Emit() {
    string s = d_.ToString();
    if (s.IndexOf('.') == -1)
      s = s + ".0";
    return s;
  }
}

class GChar_8 : SimpleValue_8 {
  public readonly char c_;

  public GChar_8(char c) { c_ = c; }

  public static readonly CharClass_8 ^type_ = new CharClass_8();

  public override GType_8 Type() { return type_; }

  public override bool Equals(object o) {
    GChar_8 c = o as GChar_8;
    return c != null && c.c_ == c_;
  }

  public override int GetHashCode() { return c_.GetHashCode(); }

  public override SimpleValue_8 ^Copy() { return new GChar_8(c_); }

  public override RValue_8 ^Convert(ref RValue_8 ^this_own, GType_8 t) {
    return t == GInt_8.type_ ? new GInt_8(c_) : base.Convert(ref this_own, t);
  }

  public override string ToString() { return c_.ToString(); }

  public static string Emit(char c) {
    switch (c) {
      case '\0': return "\\0";
      case '\n': return "\\n";
      case '\r': return "\\r";
      case '\t': return "\\t";
      case '\'': return "\\'";
      case '\"': return "\\\"";
      case '\\': return "\\\\";
    }
    if (c < 32) {
      Debug.Assert(false); return null;
    }
    return c.ToString();
  }

  public override string Emit() {
    return String.Format("'{0}'", Emit(c_));
  }
}

abstract class LocationOrRef_8 : ValueOrLocation_8 {
  public abstract Location_8 GetLoc();
}

class Location_8 : LocationOrRef_8 {
  public RValue_8 ^value_;

  public Location_8(RValue_8 ^val) { value_ = val; }

  public override GValue_8 Get() { return value_.Get(); }

  public override Location_8 GetLoc() { return this; }
}

// We allocate a LocationRef_8 when we need an owning reference to a Location_8 which we don't own.
class LocationRef_8 : LocationOrRef_8 {
  public readonly Location_8 location_;

  public LocationRef_8(Location_8 loc) { location_ = loc; }

  public override GValue_8 Get() { return location_.Get(); }

  public override Location_8 GetLoc() { return location_; }
}

class MapNode_8 {
  public readonly MapNode_8 ^next_;
  public readonly object key_;
  public ValueOrLocation_8 ^value_;   // (must appear after next_ so it will be destroyed first)

  public MapNode_8(object key, ValueOrLocation_8 ^value, MapNode_8 ^next) {
    key_ = key; value_ = value; next_ = next;
  }
}

class Map_8 {
  MapNode_8 ^nodes_;

  protected MapNode_8 Find1(object key) {
    for (MapNode_8 n = nodes_; n != null; n = n.next_)
      if (n.key_ == key)
        return n;
    return null;
  }

  protected virtual MapNode_8 Find(object key) {
    MapNode_8 n = Find1(key);
    Debug.Assert(n != null);
    return n;
  }

  public RValue_8 ^Get(object key) {
    return Find(key).value_.Get().CopyRef();
  }

  public RValue_8 ^Take_8(object key) {
    MapNode_8 n = Find(key);
    LocationOrRef_8 l = n.value_ as LocationOrRef_8;
    if (l != null)
      return take l.GetLoc().value_;
    return (RValue_8) take n.value_;
  }

  public void Set(object key, RValue_8 ^val) {
    MapNode_8 n = Find(key);
    LocationOrRef_8 l = n.value_ as LocationOrRef_8;
    if (l != null)
      l.GetLoc().value_ = val;
    else n.value_ = val;
  }

  public void Add(object key, ValueOrLocation_8 ^val) {
    nodes_ = new MapNode_8(key, val, take nodes_);
  }

  public Location_8 GetLocation(object key) {
    MapNode_8 n = Find(key);
    LocationOrRef_8 l = n.value_ as LocationOrRef_8;
    if (l != null)
      return l.GetLoc();
    Location_8 ^loc1 = new Location_8((RValue_8) take n.value_);
    Location_8 loc = loc1;
    n.value_ = loc1;
    return loc;
  }
}

class GObject_8 : GValue_8 {
  public readonly Class_8 class_;   // the class of this object

  Map_8 ^map_ = new Map_8();

  public GObject_8(Class_8 cl) {
    class_ = cl;
    while (cl != null) {
      foreach (Field_8 f in cl.fields_)
        map_.Add(f, f.Type().DefaultValue_8().Copy() );
      cl = cl.Parent();
    }
  }

  // the type of this object
  public override GType_8 Type() { return class_; }

  public override RValue_8 ^Get(Field_8 field) { return map_.Get(field); }
  public override RValue_8 ^Take_8(Field_8 field) { return map_.Take_8(field); }
  public void Set(Field_8 field, RValue_8 ^val) { map_.Set(field, val); }
  public Location_8 GetLocation(Field_8 field) { return map_.GetLocation(field); }

  public override int DefaultHashCode() { return base.GetHashCode(); }
  public override int GetHashCode() {
    GInt_8 ^i = (GInt_8) Invocation_8.InvokeMethod(this, GObject_8.type_.get_hash_code_, new ArrayList(), true);
    return i.i_;
  }

  public override bool DefaultEquals(object o) { return base.Equals(o); }
  public override bool Equals(object o) {
    GValue_8 v = o as GValue_8;
    if (v == null)
      return false;

    ArrayList ^args = new ArrayList();
    args.Add(v.CopyRef());
    GBool_8 ^b = (GBool_8) Invocation_8.InvokeMethod(this, GObject_8.type_.equals_, args, true);
    return b.b_;
  }

  public override string DefaultToString() { return String.Format("<object {0}>", class_.name_); }
  public override string ToString() {
    GString_8 ^s = (GString_8) Invocation_8.InvokeMethod(this, GObject_8.type_.to_string_, new ArrayList(), true);
    return s.s_;
  }

  // the Object class
  public static readonly ObjectClass_8 ^type_ = new ObjectClass_8();
}

class NullType_8 : GType_8 {
  public override string ToString() { return "null_type"; }

  public override SimpleValue_8 DefaultValue_8() { Debug.Assert(false); return null; }

  public override bool IsSubtype(GType_8 t1) {
    return t1.IsReference();
  }

  protected override bool CanConvertOwnership(GType_8 t, int context) {
    return true;    // conversion from null type to owning type is okay
  }

  public override string EmitType() { Debug.Assert(false); return null; }
}

class Null_8 : SimpleValue_8 {
  public Null_8() { }

  public static readonly NullType_8 ^type_ = new NullType_8();

  public override GType_8 Type() { return type_; }

  public override bool Equals(object o) {
    return o is Null_8;
  }

  public override SimpleValue_8 ^Copy() { return new Null_8(); }

  public override int GetHashCode() { return 0; }

  public static readonly Null_8 ^Instance = new Null_8();

  public override string ToString() { return ""; }

  public override string Emit() { return "0"; }
}

class Owning_8 : GType_8 {
  GType_8 base_type_;

  public Owning_8(GType_8 type) {
    base_type_ = type;
  }

  public override Class_8 Parent() { Debug.Assert(false); return null; }

  public override SimpleValue_8 DefaultValue_8() { return Null_8.Instance; }

  public override GType_8 BaseType() { return base_type_; }

  public override TypeSet_8 VarDestroys() { return base_type_.TypeDestroys(); }

  public override void FindVarDestroys(int marker, TypeSet_8 set) {
    base_type_.FindTypeDestroys(marker, set);
  }

  public override bool Equals(object o) {
    Owning_8 t = o as Owning_8;
    return t != null && t.base_type_.Equals(base_type_);
  }

  public override int GetHashCode() { return base_type_.GetHashCode() * 87; }

  public override string ToString() { return base_type_.ToString() + " ^"; }

  public override string EmitTypeName() {
    return base_type_.EmitTypeName();
  }

  string EmitType(string name) {
    return ConstructType(base_type_ == GObject_8.type_ ? "_OwnRef" : "_Own", name);
  }

  public override string EmitType() {
    // We represent an object ^ using a _OwnRef<Object>.
    // We represent a Foo ^ using an _Own<Foo>.
    return EmitType(EmitTypeName());
  }

  public override string EmitGenericType() {
    // We represent an object ^ [] using an _Array<_OwnRef<Object>>.
    // We represent a Foo ^ [] using an _Array<_Own<Object>>.
    return EmitType("Object");
  }
}

class OwningExpr_8 : TypeExpr_8 {
  readonly TypeExpr_8 ^expr_;

  public OwningExpr_8(TypeExpr_8 ^expr) { expr_ = expr; }

  public override TypeExpr_8 ^Copy() { return new OwningExpr_8(expr_.Copy()); }

  public override GType_8 Resolve(Program_8 program) {
    GType_8 t = expr_.Resolve(program);
    if (t == null)
        return null;
    if (t.IsValue()) {
      Error("^ cannot be applied to primitive types or strings");
      return null;
    }
    return t.OwningType();
  }
}

class GString_8 : SimpleValue_8 {
  public readonly string s_;

  public GString_8(string s) { s_ = s; }

  public static readonly StringClass_8 ^type_ = new StringClass_8();

  public override GType_8 Type() { return type_; }

  public override bool Equals(object o) {
    GString_8 s = o as GString_8;
    return s != null && s.s_ == s_;
  }

  public override SimpleValue_8 ^Copy() { return new GString_8(s_); }

  public override int GetHashCode() { return s_.GetHashCode(); }

  public override string ToString() { return s_; }

  public override RValue_8 ^Invoke(Method_8 m, ValueList_8 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StartsWith": return new GBool_8(s_.StartsWith(args.GetString(0)));
      case "EndsWith": return new GBool_8(s_.EndsWith(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public static string EmitStringConst(string s) {
    return String.Format("L{0}", EmitString(s));
  }

  public static string EmitString(string s) {
    StringBuilder ^sb = new StringBuilder();
    sb.Append('"');
    for (int i = 0; i < s.Length; ++i)
      sb.Append(GChar_8.Emit(s[i]));
    sb.Append('"');
    return sb.ToString();
  }

  public override string Emit() {
    string s = String.Format("new String({0})", EmitStringConst(s_));
    s = String.Format("_Ref<String>({0}).Get()", s);
    return s;
  }
}

abstract class Ownable_8 : GType_8 {
  Owning_8 ^owning_type_;

  public override Owning_8 OwningType() {
    if (owning_type_ == null)
      owning_type_ = new Owning_8(this);
    return owning_type_;
  }
}

class ArrayType_8 : Ownable_8 {
  GType_8 element_type_;

  public ArrayType_8(GType_8 type) {
    element_type_ = type;

    // Any type used generically must inherit from Object in C++ code.
    type.BaseType().SetObjectInherit();
  }

  public override bool IsOwned() { return true; }

  public override Class_8 Parent() { return GArray_8.array_class_; }

  public override SimpleValue_8 DefaultValue_8() { return Null_8.Instance; }

  public GType_8 ElementType() { return element_type_; }

  public override bool Equals(object o) {
    ArrayType_8 t = o as ArrayType_8;
    return (t != null && t.element_type_.Equals(element_type_));
  }

  public override TypeSet_8 TypeDestroys() { return element_type_.VarDestroys(); }

  public override void FindTypeDestroys(int marker, TypeSet_8 set) {
    element_type_.FindVarDestroys(marker, set);
  }

  public override int GetHashCode() { return element_type_.GetHashCode() * 77; }

  public override string EmitTypeName() {
    return ConstructType("_Array", element_type_.EmitGenericType());  
  }

  public override string ToString() {
    return element_type_.ToString() + "[]";
  }
}

class ArrayTypeExpr_8 : TypeExpr_8 {
  readonly TypeExpr_8 ^expr_;
  GType_8 ^type_;

  public ArrayTypeExpr_8(TypeExpr_8 ^expr) { expr_ = expr; }

  public override TypeExpr_8 ^Copy() { return new ArrayTypeExpr_8(expr_.Copy()); }

  public override GType_8 Resolve(Program_8 program) {
    GType_8 t = expr_.Resolve(program);
    return t == null ? null : (type_ = new ArrayType_8(t));
  }
}

class GArray_8 : GValue_8 {
  ArrayType_8 type_;

  ValueOrLocation_8^[] ^elements_;   // each element is a GValue_8 or a Location_8

  public override GType_8 Type() { return type_; }

  public GArray_8(ArrayType_8 type, int count) {
    type_ = type;
    elements_ = new ValueOrLocation_8^[count];
    for (int i = 0 ; i < count ; ++i)
      elements_[i] = type_.ElementType().DefaultValue_8().Copy();
  }

  void CheckIndex(int index) {
    if (index < 0 || index >= elements_.Length) {
      Console.WriteLine("error: array access out of bounds");
      Gel_8.Exit();
    }
  }

  public RValue_8 ^Get(int index) {
    CheckIndex(index);
    return elements_[index].Get().CopyRef();
  }

  public RValue_8 ^Take_8(int index) {
    CheckIndex(index);
    Location_8 loc = elements_[index] as Location_8;
    if (loc != null)
      return take loc.value_;
    return (RValue_8) (take elements_[index]);
  }

  public void Set(int index, RValue_8 ^val) {
    CheckIndex(index);
    Location_8 loc = elements_[index] as Location_8;
    if (loc != null)
      loc.value_ = val;
    else elements_[index] = val;
  }

  public Location_8 GetLocation(int index) {
    CheckIndex(index);
    Location_8 loc = elements_[index] as Location_8;
    if (loc != null)
      return loc;
    Location_8 ^loc1 = new Location_8((RValue_8) take elements_[index]);
    loc = loc1;
    elements_[index] = loc1;
    return loc;
  }

  public static readonly ArrayClass_8 ^array_class_ = new ArrayClass_8();

  public override RValue_8 ^Invoke(Method_8 m, ValueList_8 args) {
    if (m.GetClass() != array_class_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "CopyTo":
        GArray_8 a = (GArray_8) args.Object(0);
        if (!type_.Equals(a.type_)) {
          Console.WriteLine("error: can't copy between arrays of different types");
          Gel_8.Exit();
        }
        if (a.type_.ElementType() is Owning_8) {
          Console.WriteLine("error: can't copy to owning array");
          Gel_8.Exit();
        }
        // should check for index out of bounds here!
        int dest = args.Int(1);
        for (int i = 0 ; i < elements_.Length ; ++i)
          a.Set(dest + i, Get(i));
        return null;
      case "get_Length":
        return new GInt_8(elements_.Length);
      default:
        Debug.Assert(false); return null;
    }
  }
}

// A control graph object representing temporary variables destroyed when a top-level
// expression completes evaluation. 
class Temporaries_8 : Node_8 {
  NonOwningArrayList /* of GType_8 */ ^types_ = new NonOwningArrayList();
  TypeSet_8 ^destroys_;

  public void Add(GType_8 t) {
    Debug.Assert(t is Owning_8);
    types_.Add(t.BaseType());
  }

  public override TypeSet_8 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_8();
    foreach (GType_8 t in types_)
        destroys_.Add(t.TypeDestroys());
    }
    return destroys_;
  }
}

class Context_8 {
  public readonly Program_8 program_;   // containing program
  public readonly Class_8 class_;       // containing class
  public readonly Method_8 method_;     // containing method
  public readonly Escapable_8 escape_;  // containing switch, while, do, for, or foreach
  public readonly Loop_8 loop_;         // containing while, do, for, or foreach
  public Local_8 var_;    // chain of local variable declarations

  // subexpressions of the current top-level expression possibly yielding temporary objects
  NonOwningArrayList /* of Expression_8 */ ^temporaries_ = new NonOwningArrayList();

  public Context_8(Program_8 program) { program_ = program; }

  public Context_8(Class_8 cl) { program_ = cl.GetProgram(); class_ = cl; }

  // Copy a context; new variable declarations in either copy will not be visible in the other.
  public Context_8(Context_8 cx) {
    program_ = cx.program_;
    class_ = cx.class_;
    method_ = cx.method_;
    escape_ = cx.escape_;
    loop_ = cx.loop_;
    var_ = cx.var_;
  }

  public Context_8(Context_8 cx, Class_8 c) : this(cx) { class_ = c; }

  public Context_8(Context_8 cx, Method_8 m) : this(cx) { method_ = m; }

  public Context_8(Context_8 cx, Loop_8 l) : this(cx) {
    escape_ = l;
    loop_ = l;
  }

  public Context_8(Context_8 cx, Switch_8 s) : this(cx) { escape_ = s; }

  public bool IsStatic() { return method_ == null || method_.IsStatic(); }

  public void SetVar(Local_8 var) {
    var_ = var;
  }

  public Local_8 FindVar(string name) {
    for (Local_8 v = var_; v != null; v = v.next_)
      if (v.name_ == name)
        return v;
    return null;
  }

  public Control_8 Prev() { return program_.prev_; }

  public void SetPrev(Control_8 c) {
    Debug.Assert(c != null);
    program_.prev_ = c;
  }

  public void ClearPrev() { program_.prev_ = null; }

  // Called when we begin type-checking a top-level expression.
  public void EnterExpression() {
    Debug.Assert(temporaries_.Count == 0);
  }

  public void AddTemporary(Expression_8 e) {
    temporaries_.Add(e);
  }

  // Called when we've finished type-checking a top-level expression.
  public void FinishExpression() {
    Temporaries_8 t = null;
    foreach (Expression_8 e in temporaries_)
      if (!e.LosesOwnership()) {
        if (t == null)
          t = class_.NewTemporaries();
        t.Add(e.TemporaryType());
      }
    if (t != null)
      t.AddControl(this);
    temporaries_.Clear();
  }
}

class Env_8 : Map_8 {
  public readonly GValue_8 this_;
  readonly Env_8 next_;

  public Env_8(GValue_8 _this) { this_ = _this; next_ = null; }
  public Env_8(Env_8 next) { this_ = next.this_; next_ = next; }

  protected override MapNode_8 Find(object key) {
    for (Env_8 e = this; e != null; e = e.next_) {
      MapNode_8 n = e.Find1(key);
      if (n != null)
        return n;
    }
    Debug.Assert(false);
    return null;
  }

  public static readonly Env_8 ^static_ = new Env_8((GValue_8) null);
}

class TypeLiteral_8 : TypeExpr_8 {
  public readonly GType_8 type_;

  public TypeLiteral_8(GType_8 type) { type_ = type; }

  public override GType_8 Resolve(Program_8 program) {
    return type_;
  }

  public override TypeExpr_8 ^Copy() { return new TypeLiteral_8(type_); }
}

class TypeName_8 : TypeExpr_8 {
  string name_;

  public TypeName_8(string name) { name_ = name; }

  public override GType_8 Resolve(Program_8 program) {
    GType_8 type = program.FindClass(name_);
    if (type == null)
      Error("unknown type: {0}", name_);
    return type;
  }

  public override TypeExpr_8 ^Copy() { return new TypeName_8(name_); }
}

abstract class Traverser_8 {
  // Handle a graph item found in a depth first search; returns one of the exit codes below.
  public abstract int Handle(Control_8 control);

  public const int Continue_8 = 0,  // continue searching, including children of this node
                   Cut = 1,       // continue searching, excluding children of this node
                   Abort = 2;     // abort the search

}

// an item in the control graph: either a Node_8 or Joiner_8
abstract class Control_8 : Syntax_8 {
  public int marker_ = 0;    // marker for depth first search of control flow graph

  static int marker_value_ = 0;
  public static int GetMarkerValue() { return ++marker_value_; }

  // A node representing unreachability.  We could represent this using null, but it's
  // clearer to have this be explicit. 
  public static readonly Node_8 ^unreachable_ = new Node_8();

  // A helper function for Traverse.  If_8 we return true then we should cut the
  // traversal at this point.
  protected bool Visit(Traverser_8 traverser, int marker, out bool ok) {
    ok = true;
    if (marker_ == marker)
      return true;  // we've already seen this node
    marker_ = marker;
    int code = traverser.Handle(this);
    if (code == Traverser_8.Abort)
      ok = false;
    return (code != Traverser_8.Continue_8);
  }

  // Perform a depth-first search of the graph starting with this item, calling the
  // given Traverser_8 for each Node_8 found.  Returns false if the search was aborted.
  public abstract bool Traverse(Traverser_8 traverser, int marker);
}

// A node in the control graph.
class Node_8 : Control_8 {
  public Control_8 prev_;   // previous item in graph

  // add this node to the control graph
  public bool AddControl(Context_8 ctx) {
    Control_8 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      prev_ = prev;
      ctx.SetPrev(this);
      return true;
    }
    else return false;
  }

  // If_8 this node calls a method or constructor then return it; otherwise return null.
  // implementers: LValue_8, Invocation_8, New_8, Assign_8, Constructor_8
  public virtual Method_8 Calls() { return null; }

  // Return_8 the set of types which this node may destroy.
  // implementers: Assign_8, RefOutArgument_8, Scoped_8, Temporaries_8
  public virtual TypeSet_8 NodeDestroys() { return TypeSet_8.empty_; }

  // Return_8 true if this node assigns a value to the given Local_8.
  // implementers: Assign_8, RefOutArgument_8, VariableDeclaration_8, Method_8, ForEach_8
  public virtual bool Sets(Local_8 local) { return false; }

  // Return_8 true if this node takes ownership from the given local.
  // implementers: Name_8
  public virtual bool Takes(Local_8 local) { return false; }

  public bool CanDestroy(GType_8 type) {
    Method_8 m = Calls();
    if (m != null && m.Destroys().Contains(type))
      return true;
    return NodeDestroys().Contains(type);
  }

  public override bool Traverse(Traverser_8 traverser, int marker) {
    Node_8 n = this;
    Control_8 prev = null;

    // Traverse nodes iteratively until we come to a Join; this efficiently avoids
    // making a recursive call on each successive node.
    while (n != null) {
      bool ok;
      if (n.Visit(traverser, marker, out ok))
        return ok;
      prev = n.prev_;
      n = prev as Node_8;
    }
    Debug.Assert(prev != null);  // a Traverser_8 must end traversal before we run off the end
    return prev.Traverse(traverser, marker);
  }
}

class Joiner_8 : Control_8 {
  NonOwningArrayList /* of Control_8 */ ^prev_ = new NonOwningArrayList();

  public void Join(Control_8 c) {
    Debug.Assert(c != null);
    if (c == unreachable_)
      return;
    if (prev_.Count == 0 || c != prev_[0])
      prev_.Add(c);
  }

  // add this joiner to the control graph
  public void AddControl(Context_8 ctx) {
    Control_8 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      Join(prev);
      ctx.SetPrev(this);
    }
  }

  // Once we've finished merging paths into a Joiner_8, if the Joiner_8 points to only a single path
  // then as an optimization we can discard the Joiner_8 and just use that path instead.
  public Control_8 Combine() {
    switch (prev_.Count) {
      case 0:
        prev_ = null;
        return unreachable_;
      case 1:
        Control_8 c = (Control_8) prev_[0];
        prev_ = null;
        return c;
      default: return this;
    }
  }

  public override bool Traverse(Traverser_8 traverser, int marker) {
    bool ok;
    if (Visit(traverser, marker, out ok))
      return ok;

    foreach (Control_8 p in prev_)
      if (!p.Traverse(traverser, marker))
        return false;  // aborted
    return true;
  }
}

class ExprKind_8 {
  public const int Value = 0,

  // either a local variable, or an expression whose value is derived from local variables
                   Local_8 = 1,

                   Field_8 = 2,
                   Property_8 = 3,
                   Indexer_8 = 4,
                   Type = 5;
}

class SourceWriter_8 {
  public readonly StreamWriter writer_;
  int indent_ = 0;

  public SourceWriter_8(StreamWriter writer) { writer_ = writer; }

  public void AddIndent() { ++indent_; }
  public void SubIndent() { --indent_; }

  public void Indent(int adjust) {
    for (int i = 0; i < 2 * indent_ + adjust; ++i)
      writer_.Write(' ');
  }

  public void Indent() { Indent(0); }

  public void Write(string s) { writer_.Write(s); }
  public void Write(string s, object arg) { writer_.Write(s, arg); }
  public void Write(string s, object arg1, object arg2) { writer_.Write(s, arg1, arg2); }
  public void Write(string s, object arg1, object arg2, object arg3) { writer_.Write(s, arg1, arg2, arg3); }

  public void IWrite(string s) { Indent(); Write(s); }
  public void IWrite(string s, object arg) { Indent(); Write(s, arg); }
  public void IWrite(string s, object arg1, object arg2) { Indent(); Write(s, arg1, arg2); }
  public void IWrite(string s, object arg1, object arg2, object arg3) { Indent(); Write(s, arg1, arg2, arg3); }

  public void WriteLine(string s) { writer_.WriteLine(s); }
  public void WriteLine(string s, object arg) { writer_.WriteLine(s, arg); }
  public void WriteLine(string s, object arg1, object arg2) { writer_.WriteLine(s, arg1, arg2); }
  public void WriteLine(string s, object arg1, object arg2, object arg3) { writer_.WriteLine(s, arg1, arg2, arg3); }

  public void IWriteLine(string s) { Indent(); WriteLine(s); }
  public void IWriteLine(string s, object arg) { Indent(); WriteLine(s, arg); }
  public void IWriteLine(string s, object arg1, object arg2) { Indent(); WriteLine(s, arg1, arg2); }
  public void IWriteLine(string s, object arg1, object arg2, object arg3) { Indent(); WriteLine(s, arg1, arg2, arg3); }

  public void OpenBrace() { WriteLine("{"); AddIndent(); }
  public void CloseBrace() { SubIndent(); IWriteLine("}"); }
}

class Usage_8 {
  public const int Used = 0, LosesOwnership = 1, Unused = 2;
}

abstract class Expression_8 : Node_8 {
  protected int usage_ = Usage_8.Used;

  // start_ and end_ mark the points in the control graph where this expression is evaluated and used,
  // respectively.  If_8 this expression's type is owned, we use this information to determine whether
  // we need to emit a reference count for this expression.
  Control_8 start_;
  Control_8 end_;

  public abstract GType_8 Check(Context_8 ctx);

  public GType_8 CheckTop(Context_8 ctx) {
    ctx.EnterExpression();
    GType_8 t = Check(ctx);
    ctx.FinishExpression();
    return t;
  }

  public GType_8 CheckAndHold(Context_8 ctx) {
    GType_8 t = Check(ctx);
    if (t != null)
      HoldRef(ctx);
    return t;
  }

  // A fancier checking protocol implemented by lvalues and used by certain callers.
  public virtual GType_8 Check(Context_8 ctx, bool read, bool write, bool type_ok) {
    return Check(ctx);
  }

  public virtual int Kind() { return ExprKind_8.Value; }
  public virtual bool IsRefOutParameter() { return false; }

  public virtual bool IsTrueLiteral() { return false; }
  public virtual bool IsFalseLiteral() { return false; }

  // If_8 this expression is a local variable (possibly cast to a different type),
  // then return that local; otherwise return null.
  public virtual Local_8 GetLocal() { return null; }

  // Return_8 the type of an expression yielding a temporary object.
  // (It might be convenient to generalize this to be able to return any expression's type.)
  public virtual GType_8 TemporaryType() { Debug.Assert(false); return null; }

  public void HoldRef(Context_8 ctx) {
    start_ = ctx.Prev();
    Debug.Assert(start_ != null);
  }

  public void ReleaseRef(Context_8 ctx) {
    end_ = ctx.Prev();
    Debug.Assert(end_ != null);
  }

  public abstract RValue_8 ^Eval(Env_8 env);

  public bool Check(Context_8 ctx, GType_8 t2) {
    GType_8 t = Check(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public bool CheckTop(Context_8 ctx, GType_8 t2) {
    GType_8 t = CheckTop(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public RValue_8 ^Eval(Env_8 env, GType_8 t) {
    RValue_8 ^r = Eval(env);
    GValue_8 v = r.Get();
    return v.Convert(ref r, t);
  }

  public bool EvalBool(Env_8 env) { return ((GBool_8) Eval(env)).b_; }

  public int EvalInt(Env_8 env) {
    RValue_8 ^r = Eval(env, GInt_8.type_);
    GInt_8 i = (GInt_8) r;
    return i.i_;
  }

  public double EvalDouble(Env_8 env) { return ((GDouble_8) Eval(env, GDouble_8.type_)).d_; }
  public float EvalFloat(Env_8 env) { return ((GFloat_8) Eval(env, GFloat_8.type_)).f_; }
  public string EvalString(Env_8 env) { return ((GString_8) Eval(env)).s_; }

  public virtual bool IsConstant() {
    return false;
  }

  public bool CheckConstant() {
    if (IsConstant())
      return true;
    Error("expression must be a constant");
    return false;
  }

  public bool LosesOwnership() { return usage_ == Usage_8.LosesOwnership; }

  public virtual void LoseOwnership() {
    usage_ = Usage_8.LosesOwnership;
  }

  public void SetUnused() {
    Debug.Assert(usage_ == Usage_8.Used);
    usage_ = Usage_8.Unused;
  }

  protected static string EmitAllocate(string type, string args, bool lose_ownership) {
    // If_8 an allocated object never loses ownership then it can be stack allocated.  We
    // can't emit "&Foo(...)" since standard C++ doesn't allow us to take the address
    // of a temporary (both GCC and Visual C++ will allow this, but will emit a warning).
    // So instead we call a function _Addr() to get the address.
    return String.Format(
      !lose_ownership ? "{0}({1})._Addr<{0} *>()" : "new {0}({1})",
      type, args);
  }

  public void CheckLoseOwnership(GType_8 from, GType_8 to) {
    if (to is Owning_8)
      LoseOwnership();
  }

  public abstract string Emit();    // return a C++ expression representing this GEL2 expression

  public bool NeedsRef(GType_8 type) {
    return Gel_8.program_.safe_ && type.IsOwned() && ExpressionTraverser_8.NeedRef(start_, end_, this, type);
  }

  // Emit this expression, adding a reference-counting _Ptr wrapper if needed.
  public string EmitRef(GType_8 type) {
    string s = Emit();
    if (NeedsRef(type))
      s = String.Format("{0}({1}).Get()", type.EmitType(), s);
    return s;
  }

  // Emit an implicit conversion from type [source] to type [dest].
  public static string EmitImplicit(GType_8 source, GType_8 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (!source.IsReference() && dest == GObject_8.type_) {   // a boxing conversion
      Class_8 c = (Class_8) source;
      return EmitAllocate(c.name_, val, loses_ownership);
    }

    if (source == GInt_8.type_ && dest == GFloat_8.type_)
      // an implicit conversion in GEL2, but C++ compilers may warn if we don't use a cast
      return String.Format("static_cast<float>({0})", val);
    
    return val;
  }

  // Emit this expression, converting implicitly from type [source] to type [dest].
  public string Emit(GType_8 source, GType_8 dest) {
    return EmitImplicit(source, dest, Emit(), LosesOwnership());
  }

  public string EmitRef(GType_8 source, GType_8 dest) {
    return EmitImplicit(source, dest, EmitRef(source), LosesOwnership());
  }

  public static string EmitExplicit(GType_8 source, GType_8 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (source.CanConvert(dest)) {
      string v = EmitImplicit(source, dest, val, loses_ownership);
      if (v != val)
        return v;

      // There's nothing to do, but we emit a static_cast anyway since a GEL2 programmer
      // may use a type cast for method call disambiguation; we want to pass such casts onward.
      return String.Format("static_cast<{0} >({1})", dest.EmitExprType(), val);
    }

    if (source.IsReference() && dest.IsReference()) {
      string s = String.Format("_Cast<{0} *>({1})", dest.EmitTypeName(), val);
      ArrayType_8 at = dest as ArrayType_8;
      if (at != null) {
        GType_8 element_type = at.ElementType();
        if (element_type.IsReference())
          s = String.Format("({0})->CheckType(&typeid({1}))", s, element_type.EmitType());
      }
      return s;
    }

    if (source == GObject_8.type_ && !dest.IsReference())  // unboxing conversion
      return String.Format("_Unbox<{0} *>({1})->Value()", ((Class_8) dest).name_, val);

    if (!source.IsReference() && !dest.IsReference())
      return String.Format("static_cast<{0}>({1})", dest.EmitType(), val);

    Debug.Assert(false);
    return null;
  }

  public string EmitExplicit(GType_8 source, GType_8 dest) {
    return EmitExplicit(source, dest, Emit(), LosesOwnership());
  }

  public virtual string EmitArrow(GType_8 t, Member_8 m) {
    return String.Format("({0})->", EmitRef(t));
  }

  // Emit this expression as a local or field initializer, implicitly casting to [type].
  public void EmitAsInitializer(SourceWriter_8 w, GType_8 initializer_type, GType_8 type) {
    // For_8 owning variables, we must emit an initializer of the form "Foo var(val)" since
    // _Own has no copy constructor and hence GCC won't allow "Foo var = val".  For_8 other
    // variables either form is valid, but we emit the second form since it looks clearer.
    w.Write(type is Owning_8 ? "({0})" : " = {0}", Emit(initializer_type, type));
  }

  // Given a value retrieved from a variable, emit an accessor call if needed.
  protected string OwnSuffix(GType_8 t) {
    if (t is Owning_8)
      return LosesOwnership() ? ".Take_8()" : ".Get()";
    if (t == GString_8.type_ || Gel_8.program_.safe_ && t.IsReference() )
      return ".Get()";
    return "";
  }

  // Given a value returned from a function call, emit a wrapper and/or accessor call if needed.
  protected string Hold(GType_8 t, string s) {
    if (t == GString_8.type_)
      return s + ".Get()";
    if (t is Owning_8)
      switch (usage_) {
        case Usage_8.Used:  // does not lose ownership; we need a freeing wrapper
          return String.Format("{0}({1}).Get()", t.EmitType(), s);
        case Usage_8.LosesOwnership:
          return s;
        case Usage_8.Unused:  // a top-level owning expression
          return "delete " + s;
        default: Debug.Assert(false); break;
      }
    return s;
  }
}

class Literal_8 : Expression_8 {
  public readonly SimpleValue_8 ^value_;

  public Literal_8(SimpleValue_8 ^v) { value_ = v; }

  public override bool IsTrueLiteral() {
    GBool_8 b = value_ as GBool_8;
    return b != null && b.b_;
  }

  public override bool IsFalseLiteral() {
    GBool_8 b = value_ as GBool_8;
    return b != null && !b.b_;
  }

  public override GType_8 Check(Context_8 ctx) { return value_.Type(); }

  public override RValue_8 ^Eval(Env_8 env) { return value_.Copy(); }

  public override bool IsConstant() { return true; }

  public override string Emit() { return value_.Emit(); }
}

// An LValue_8 is an expression which can be assigned to: a Name_8, Dot_8, or Sub_8.
//
// In the control graph, an LValue_8 represents a read; if an LValue_8 is written then
// some other node (e.g. an Assign_8) will appear representing the write.
abstract class LValue_8 : Expression_8 {
  public override GType_8 Check(Context_8 ctx) {
    return Check(ctx, true, false, false);
  }

  public abstract override GType_8 Check(Context_8 ctx, bool read, bool write, bool type_ok);

  public abstract GType_8 StorageType();

  public virtual bool IsLocal() { return false; }
  public virtual bool IsLocal(Local_8 l) { return false; }

  public abstract PropertyOrIndexer_8 GetPropertyOrIndexer();

  public override Method_8 Calls() {
    PropertyOrIndexer_8 pi = GetPropertyOrIndexer();
    return pi == null ? null : pi.Getter();
  }

  public virtual void ReleaseAll(Context_8 ctx) { }

  // For_8 LValues, evaluation proceeds in two stages: the caller first calls Eval1(), then
  // passes the resulting values to EvalGet(), EvalSet() and/or EvalLocation().  This_8 lets
  // us evaluate the left side of an assignment expression before evaluating the right side,
  // and also lets us get and then set an indexer without evaluating its expression twice.

  public abstract void Eval1(Env_8 env, out RValue_8 ^v1, out RValue_8 ^v2);
  public abstract RValue_8 ^EvalGet(Env_8 env, RValue_8 ^v1, RValue_8 ^v2);
  public abstract void EvalSet(Env_8 env, RValue_8 ^v1, RValue_8 ^v2, RValue_8 ^val);
  public abstract Location_8 EvalLocation(Env_8 env, RValue_8 ^v1, RValue_8 ^v2);

  public override RValue_8 ^Eval(Env_8 env) {
    RValue_8 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalGet(env, val1, val2);
  }

  public void EvalSet(Env_8 env, RValue_8 ^v) {
    RValue_8 ^val1, val2;
    Eval1(env, out val1, out val2);
    EvalSet(env, val1, val2, v);
  }

  public Location_8 EvalLocation(Env_8 env) {
    RValue_8 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalLocation(env, val1, val2);
  }

  public abstract string EmitSet(string val);

  public abstract string EmitLocation();
}

class Name_8 : LValue_8 {
  public readonly string name_;

  protected Local_8 local_;
  protected LMember_8 field_;  // a field or property

  public Name_8(string n) { name_ = n; }

  public override bool IsLocal() { return local_ != null; }
  public override bool IsLocal(Local_8 l) { return local_ == l; }
  public override bool IsRefOutParameter() { return local_ is RefOutParameter_8; }

  public override bool IsConstant() {
    Debug.Assert(local_ != null || field_ != null);   // make sure we were already type checked
    return field_ is ConstField_8;
  }

  public override GType_8 Check(Context_8 ctx, bool read, bool write, bool type_ok) {
    local_ = ctx.FindVar(name_);
    if (local_ != null) {
      // For_8 reads, we add this Name_8 node to the flow graph; for writes,
      // the caller must add a node which defines this Name_8.
      if (read)
        if (AddControl(ctx))
          local_.AddUse(this);
      if (write)
        local_.SetMutable();
      return local_.ReadType();
    }

    GType_8 cl = type_ok ? ctx.program_.FindClass(name_) : null;
    field_ = (LMember_8) ctx.class_.Lookup(this, ctx.class_, false, MemberKind_8.Field_8, name_, null, cl == null);
    if (field_ != null) {
      if (!field_.CheckAccess(this, ctx, write, true, !ctx.IsStatic()))
        return null;
      if (read) {
        // Only property reads have side effects we need to register in the control graph.
        if (field_ is Property_8)
          AddControl(ctx);
      }
      return field_.Type().BaseType();
    }

    return cl;
  }

  public override int Kind() {
    if (local_ != null)
      return ExprKind_8.Local_8;
    if (field_ is Field_8)
      return ExprKind_8.Field_8;
    if (field_ is Property_8)
      return ExprKind_8.Property_8;
    Debug.Assert(field_ == null);
    return ExprKind_8.Type;
  }

  public override Local_8 GetLocal() { return local_; }

  public override GType_8 StorageType() { return local_ != null ? local_.Type() : field_.Type(); }

  public override bool Takes(Local_8 local) {
    return local_ == local && LosesOwnership() && local.Type() is Owning_8;
  }

  public override PropertyOrIndexer_8 GetPropertyOrIndexer() { return field_ as Property_8; }

  public override void Eval1(Env_8 env, out RValue_8 ^v1, out RValue_8 ^v2) { v1 = v2 = null; }

  public override RValue_8 ^EvalGet(Env_8 env, RValue_8 ^v1, RValue_8 ^v2) {
    if (LosesOwnership() && StorageType() is Owning_8)
      return local_ != null ? env.Take_8(local_) : field_.Take_8(env.this_);
    else return local_ != null ? env.Get(local_) : field_.Get(env.this_);
  }

  public override void EvalSet(Env_8 env, RValue_8 ^v1, RValue_8 ^v2, RValue_8 ^val) {
    if (local_ != null)
      env.Set(local_, val);
    else field_.Set((GObject_8) env.this_, val);
  }

  public override Location_8 EvalLocation(Env_8 env, RValue_8 ^v1, RValue_8 ^v2) {
    return local_ != null ? env.GetLocation(local_) : field_.GetLocation((GObject_8) env.this_);
  }

  public override string Emit() {
    if (local_ != null) {
      string s = local_.Emit();
      return local_.IsWrapper() ? s + OwnSuffix(local_.Type()) : s;
    }
    if (field_ != null)
      return field_.Emit() + OwnSuffix(field_.Type());
    return name_;
  }

  public override string EmitSet(string val) {
    if (local_ != null)
      return String.Format("{0} = {1}", local_.Emit(), val);
    Debug.Assert(field_ != null);
    return field_.EmitSet(val);
  }

  public override string EmitLocation() {
    if (local_ != null)
      return "&" + local_.Emit();
    if (field_ != null)
      return "&" + field_.Emit();
    return "&" + name_;
  }
}

class Parenthesized_8 : Expression_8 {
  Expression_8 ^expr_;

  public Parenthesized_8(Expression_8 ^e) { expr_ = e; }

  public override GType_8 Check(Context_8 ctx) { return expr_.Check(ctx); }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_8 ^Eval(Env_8 env) { return expr_.Eval(env); }

  public override string Emit() { return String.Format("({0})", expr_.Emit()); }
}

class PredefinedType_8 : Expression_8 {
  Class_8 type_;

  public PredefinedType_8(Class_8 type) { type_ = type; }

  public override GType_8 Check(Context_8 ctx) { Debug.Assert(false); return null; }

  public override GType_8 Check(Context_8 ctx, bool read, bool write, bool type_ok) {
    Debug.Assert(type_ok);
    return type_;
  }

  public override int Kind() {
    return ExprKind_8.Type;
  }

  public override RValue_8 ^Eval(Env_8 env) { Debug.Assert(false); return null; }

  public override string Emit() { return type_.name_; }
}

class Dot_8 : LValue_8 {
  Expression_8 ^expr_;  // set to null for a static invocation
  GType_8 expr_type_;
  string name_;

  LMember_8 field_;

  public Dot_8(Expression_8 ^expr, string name) { expr_ = expr; name_ = name; }

  public override bool IsConstant() {
    Debug.Assert(field_ != null);   // make sure we were already type checked
    return field_ is ConstField_8;
  }

  public override GType_8 Check(Context_8 ctx, bool read, bool write, bool type_ok) {
    expr_type_ = expr_.Check(ctx, true, false, true);
    if (expr_type_ == null)
      return null;
    bool is_static = (expr_.Kind() == ExprKind_8.Type);
    if (is_static)
      expr_ = null;
    else expr_.HoldRef(ctx);

    field_ = (LMember_8) expr_type_.Lookup(this, ctx.class_, expr_ is Base_8,
                                         MemberKind_8.Field_8, name_, null, true);
    if (field_ == null)
      return null;

    if (!field_.CheckAccess(this, ctx, write, is_static, !is_static))
      return null;

    if (read) {
      // Only property reads have side effects we need to register in the control graph.
      // (For_8 writes the caller, such as Assign_8, will add its own node.)
      if (field_ is Property_8)
        AddControl(ctx);
      if (expr_ != null)
        expr_.ReleaseRef(ctx);
    }

    return field_.Type().BaseType();
  }

  public override void ReleaseAll(Context_8 ctx) {
    if (expr_ != null)
      expr_.ReleaseRef(ctx);
  }

  public override int Kind() {
    if (field_ is Field_8)
      return ExprKind_8.Field_8;
    if (field_ is Property_8)
      return ExprKind_8.Property_8;
    Debug.Assert(false);
    return 0;
  }

  public override GType_8 StorageType() { return field_.Type(); }

  public override PropertyOrIndexer_8 GetPropertyOrIndexer() { return field_ as Property_8; }

  public override void Eval1(Env_8 env, out RValue_8 ^v1, out RValue_8 ^v2) {
    v1 = v2 = null;
    if (expr_ != null) {  // instance field
      v1 = expr_.Eval(env);
      if (v1 is Null_8) {
        Error("attempted to access field of null object");
        Gel_8.Exit();
      }
    }
  }

  public override RValue_8 ^EvalGet(Env_8 env, RValue_8 ^v1, RValue_8 ^v2) {
    GValue_8 obj = v1 == null ? null : v1.Get();
    return LosesOwnership() && field_.Type() is Owning_8 ? field_.Take_8(obj) : field_.Get(obj);
  }

  public override void EvalSet(Env_8 env, RValue_8 ^v1, RValue_8 ^v2, RValue_8 ^val) {
    GObject_8 obj = v1 == null ? null : (GObject_8) v1.Get();
    field_.Set(obj, val);
  }

  public override Location_8 EvalLocation(Env_8 env, RValue_8 ^v1, RValue_8 ^v2) {
    return field_.GetLocation((GObject_8) v1);
  }

  string EmitPrefix() {
    return expr_ != null ?
      expr_.EmitArrow(expr_type_, field_) :  // instance access
      field_.GetClass().name_ + "::";   // static access
  }

  public override string Emit() {
    string s = EmitPrefix() + field_.Emit();
    GType_8 t = field_.Type();
    return field_ is Property_8 ? Hold(t, s) : s + OwnSuffix(t);
  }

  public override string EmitSet(string val) {
    return EmitPrefix() + field_.EmitSet(val);
  }

  public override string EmitLocation() {
    return "&" + EmitPrefix() + field_.Emit();
  }
}

class Mode_8 {
  public const int In = 0,
                   Ref = 1,
                   Out = 2;

  public static string ToString(int mode) {
    switch (mode) {
      case In: return "";
      case Ref: return "ref ";
      case Out: return "out ";
      default: Debug.Assert(false); return null;
    }
  }
}

abstract class Argument_8 : Node_8 {
  protected GType_8 type_;

  public GType_8 Type() { return type_; }

  public abstract int GetMode();
  public string TypeString() { return Mode_8.ToString(GetMode()) + type_.ToString(); }

  public abstract bool Check(Context_8 ctx);
  public abstract void FinishCall(Context_8 ctx);

  public abstract void AddEval(ArrayList a, Env_8 env, GType_8 t);

  public abstract string Emit(GType_8 t);
}

class InArgument_8 : Argument_8 {
  public readonly Expression_8 ^expr_;

  public InArgument_8(Expression_8 ^expr) { expr_ = expr; }
  public InArgument_8(GType_8 type) { type_ = type; }

  public override int GetMode() { return 0; }

  public override bool Check(Context_8 ctx) {
    if (type_ == null)
      type_ = expr_.CheckAndHold(ctx);
    return type_ != null;
  }

  public override void FinishCall(Context_8 ctx) {
    expr_.ReleaseRef(ctx);
  }

  public override void AddEval(ArrayList a, Env_8 env, GType_8 t) {
    a.Add(expr_.Eval(env, t));
  }

  public override string Emit(GType_8 t) {
    return expr_.EmitRef(type_, t);
  }
}

class RefOutArgument_8 : Argument_8 {
  public readonly int mode_;
  public readonly LValue_8 ^lvalue_;

  public RefOutArgument_8(int mode, LValue_8 ^lvalue) { mode_ = mode; lvalue_ = lvalue; }

  public override int GetMode() { return mode_; }

  public override bool Check(Context_8 ctx) {
    type_ = lvalue_.Check(ctx, mode_ == Mode_8.Ref, true, false);
    if (type_ == null)
      return false;
    if (lvalue_.Kind() == ExprKind_8.Indexer_8) {
      Error("can't pass indexer as ref or out argument");
      return false;
    }
    return true;
  }

  public override void FinishCall(Context_8 ctx) {
    AddControl(ctx);
  }

  public override bool Sets(Local_8 local) { return lvalue_.IsLocal(local); }

  public override TypeSet_8 NodeDestroys() { return lvalue_.StorageType().VarDestroys(); }

  public GType_8 StorageType() { return lvalue_.StorageType(); }

  public override void AddEval(ArrayList a, Env_8 env, GType_8 t) {
    a.Add(new LocationRef_8(lvalue_.EvalLocation(env)));
  }

  public override string Emit(GType_8 t) { return lvalue_.EmitLocation(); }
}

class Invocation_8 : Expression_8 {
  Expression_8 ^obj_;    // may be null
  GType_8 obj_type_;
  string name_;
  ArrayList /* of Argument_8 */ ^arguments_;

  Method_8 method_;

  public Invocation_8(Expression_8 ^obj, string name, ArrayList ^arguments) {
    obj_ = obj; name_ = name; arguments_ = arguments;
  }

  public static Method_8 CheckInvoke(Node_8 caller, Context_8 ctx, bool through_base, GType_8 type,
                                   string name, ArrayList /* of Argument_8 */ arguments,
                                   int kind) {
    foreach (Argument_8 arg in arguments)
      if (!arg.Check(ctx))
        return null;

    // Add the caller to the graph; this node represents the invocation itself.
    caller.AddControl(ctx);

    // Now we can release temporary expressions and add control graph nodes representing
    // assignments to ref and out parameters.
    foreach (Argument_8 arg in arguments)
      arg.FinishCall(ctx);

    Method_8 m = (Method_8) type.Lookup(caller, ctx.class_, through_base, kind, name, arguments, true);
    if (m != null)
      for (int i = 0; i < m.parameters_.Count; ++i) {
        Parameter_8 p = m.Param(i);
        if (p.GetMode() == Mode_8.In) {
          InArgument_8 a = (InArgument_8) arguments[i];
          a.expr_.CheckLoseOwnership(a.Type(), p.Type());
        }
      }
    return m;
  }

  public override GType_8 Check(Context_8 ctx) {
    GType_8 t;
    bool is_class = false;  // true when calling a static method using a class name

    if (obj_ == null)
      t = ctx.class_;
    else {
      t = obj_type_ = obj_.Check(ctx, true, false, true);
      if (t == null)
        return null;
      if (obj_.Kind() == ExprKind_8.Type)
        is_class = true;
      else obj_.HoldRef(ctx);
    }

    method_ = CheckInvoke(this, ctx, obj_ is Base_8, t, name_, arguments_, MemberKind_8.Method_8);
    if (method_ == null)
      return null;

    if (method_ is Constructor_8) {
      Error("can't call constructor directly");
      return null;
    }

    if (obj_ == null) {
      if (!method_.IsStatic() && ctx.IsStatic()) {
        Error("can't call instance method in static context");
        return null;
      }
    } else {
      obj_.ReleaseRef(ctx);
      if (is_class) {
        if (!method_.IsStatic()) {
          Error("can't invoke non-static method through class name");
          return null;
        }
      } else {
        if (method_.IsStatic()) {
          Error("can't invoke static method through object");
          return null;
        }
      }
    }

    GType_8 ret = method_.ReturnType();
    if (ret is Owning_8)
      ctx.AddTemporary(this);
    return ret;
  }

  public override GType_8 TemporaryType() { return method_.ReturnType(); }

  public override Method_8 Calls() { return method_; }

  public static RValue_8 ^InvokeMethod(GValue_8 obj, Method_8 m, ArrayList /* of RValue_8 */ values,
                                    bool virtual_ok) {
    if (m.IsVirtual() && virtual_ok) {
      GType_8 t = obj.Type();
      m = (Method_8) t.FindMatchingMember(m, true);
      Debug.Assert(m != null);
    }
    return m.Invoke(obj, values);
  }

  public static RValue_8 ^CallMethod(Env_8 env, GValue_8 obj,
                                  Method_8 m, ArrayList /* of Argument_8 */ args,
                                  bool virtual_ok) {
    ArrayList /* of ValueOrLocation_8 */ ^values = new ArrayList();
    int i;
    for (i = 0 ; i < args.Count ; ++i) {
      Argument_8 a = (Argument_8) args[i];
      a.AddEval(values, env, m.Param(i).Type());
    }
    return InvokeMethod(obj, m, values, virtual_ok);
  }

  public RValue_8 ^Eval(Env_8 env, Expression_8 obj, Method_8 m, ArrayList /* of Argument_8 */ args) {
    RValue_8 ^r;
    GValue_8 v;
    if (m.IsStatic())
      v = null;
    else {
      if (obj == null)
        v = env.this_;
      else {
        r = obj.Eval(env);
        v = r.Get();
        if (v is Null_8) {
          Error("attempted to call method on null object");
          Gel_8.Exit();
        }
      }
    }

    return CallMethod(env, v, m, args, !(obj is Base_8));
  }

  public override RValue_8 ^Eval(Env_8 env) {
    return Eval(env, obj_, method_, arguments_);
  }

  public static string EmitArguments(Method_8 m, ArrayList /* of Argument_8 */ arguments) {
    StringBuilder ^sb = new StringBuilder();
    Debug.Assert(m.parameters_.Count == arguments.Count);
    for (int i = 0; i < arguments.Count; ++i) {
      if (i > 0)
        sb.Append(", ");
      Argument_8 a = (Argument_8)arguments[i];
      sb.Append(a.Emit(m.Param(i).Type()));
    }
    return sb.ToString();
  }

  public override string Emit() {
    StringBuilder ^sb = new StringBuilder();
    if (obj_ != null) {
      if (method_.IsStatic())
        sb.AppendFormat("{0}::", obj_.Emit());
      else if (obj_type_.IsReference())
        sb.Append(obj_.EmitArrow(obj_type_, method_));
      else sb.AppendFormat("({0})->", obj_.Emit(obj_type_, GObject_8.type_));   // box values
    }
    sb.AppendFormat("{0} ({1})", method_.name_, EmitArguments(method_, arguments_));
    return Hold(method_.ReturnType(), sb.ToString());
  }
}

// an expression of the form a[b]
class Sub_8 : LValue_8 {
  readonly Expression_8 ^base_;
  GType_8 base_type_;
  readonly Expression_8 ^index_;
  GType_8 index_type_;

  GType_8 element_type_;    // for array accesses; null for indexers
  Indexer_8 indexer_;

  public Sub_8(Expression_8 ^base_exp, Expression_8 ^index) { base_ = base_exp; index_ = index; }

  public override GType_8 Check(Context_8 ctx, bool read, bool write, bool type_ok) {
    base_type_ = base_.CheckAndHold(ctx);
    if (base_type_ == null)
      return null;

    index_type_ = index_.CheckAndHold(ctx);
    if (index_type_ == null)
      return null;

    if (read)
      ReleaseAll(ctx);

    ArrayType_8 at = base_type_.BaseType() as ArrayType_8;
    if (at != null) {
      if (!index_type_.CheckConvert(this, GInt_8.type_))
        return null;
      element_type_ = at.ElementType();
      return element_type_.BaseType();
    }

    ArrayList ^arguments = new ArrayList();
    arguments.Add(new InArgument_8(index_type_));

    indexer_ = (Indexer_8) base_type_.Lookup(this, ctx.class_, base_ is Base_8,
                                           MemberKind_8.Indexer_8, null, arguments, true);
    if (indexer_ == null)
      return null;

    if (read && !indexer_.CheckAssigning(this, ctx, false) ||
        write && !indexer_.CheckAssigning(this, ctx, true))
      return null;

    if (read)
      AddControl(ctx);

    return indexer_.Type();
  }

  public override void ReleaseAll(Context_8 ctx) {
    base_.ReleaseRef(ctx);
    index_.ReleaseRef(ctx);
  }

  public override int Kind() {
    return element_type_ != null ? ExprKind_8.Field_8 : ExprKind_8.Indexer_8;
  }

  public override GType_8 StorageType() {
    return element_type_ != null ? element_type_ : indexer_.Type();
  }

  public override PropertyOrIndexer_8 GetPropertyOrIndexer() { return indexer_; }

  public override void Eval1(Env_8 env, out RValue_8 ^v1, out RValue_8 ^v2) {
    v1 = base_.Eval(env);
    if (v1 is Null_8) {
      Error("attempted array or indexer access through null");
      Gel_8.Exit();
    }
    v2 = index_.Eval(env);
  }

  int Index(RValue_8 ^v) {
    // ++ We get an ownership error if we combine the following two lines into one; why?
    v = v.Get().Convert(ref v, GInt_8.type_);
    return ((GInt_8) v).i_;
  }

  public override RValue_8 ^EvalGet(Env_8 env, RValue_8 ^v1, RValue_8 ^v2) {
    if (indexer_ == null) {
      GArray_8 arr = (GArray_8) v1.Get();
      int i = Index(v2);
      return LosesOwnership() && element_type_ is Owning_8 ? arr.Take_8(i) : arr.Get(i);
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    return Invocation_8.InvokeMethod(v1.Get(), indexer_.Getter(), args, true);
  }

  public override void EvalSet(Env_8 env, RValue_8 ^v1, RValue_8 ^v2, RValue_8 ^val) {
    if (indexer_ == null) {
      ((GArray_8) v1.Get()).Set(Index(v2), val);
      return;
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    args.Add(val);
    Invocation_8.InvokeMethod(v1.Get(), indexer_.Setter(), args, true);
  }

  public override Location_8 EvalLocation(Env_8 env, RValue_8 ^v1, RValue_8 ^v2) {
    int i = ((GInt_8) v2).i_;
    return ((GArray_8) v1).GetLocation(i);
  }

  string EmitBase() {
    return base_.EmitArrow(base_type_, indexer_);
  }

  string EmitIndex() {
    return index_.Emit(index_type_, indexer_ != null ? indexer_.parameter_.Type() : GInt_8.type_);
  }

  public override string Emit() {
    string get = String.Format("{0}get_Item({1})", EmitBase(), EmitIndex());
    if (element_type_ != null) {
      get = get + OwnSuffix(element_type_);
      if (!element_type_.IsValue())
        get = String.Format("static_cast<{0} >({1})", element_type_.EmitExprType(), get);
      return get;
    } else return Hold(indexer_.Type(), get);
  }

  public override string EmitSet(string val) {
    return String.Format(element_type_ != null ? "{0}get_Item({1}) = {2}" : "{0}set_Item({1}, {2})",
       EmitBase(), EmitIndex(), val);
  }

  public override string EmitLocation() {
    return String.Format("{0}get_location({1})", EmitBase(), EmitIndex());
  }
}

class This_8 : Expression_8 {
  public override GType_8 Check(Context_8 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access this in a static context");
      return null;
    }
    return ctx.class_;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    return new Reference_8(env.this_);
  }

  public override string Emit() { return "this"; }
}

class Base_8 : Expression_8 {
  Class_8 parent_;

  public override GType_8 Check(Context_8 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access base in a static context");
      return null;
    }
    parent_ = ctx.class_.Parent();
    if (parent_ == null) {
      Error("can't access base: class has no parent");
      return null;
    }
    return parent_;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    return new Reference_8(env.this_);
  }

  public override string Emit() { return "this"; }

  public override string EmitArrow(GType_8 t, Member_8 m) {
    return m.GetClass().name_ + "::"; 
  }
}

class New_8 : Expression_8 {
  Expression_8 ^creator_;    // either a pool or null
  TypeExpr_8 ^type_expr_;
  ArrayList /* of Expression_8 */ ^arguments_;

  Class_8 class_;
  Constructor_8 constructor_;

  public New_8(Expression_8 ^creator, TypeExpr_8 ^expr, ArrayList ^arguments) {
    creator_ = creator;
    type_expr_ = expr;
    arguments_ = arguments;
  }

  GType_8 Type() {
    return creator_ == null ? (GType_8) class_.OwningType() : class_;
  }

  public override GType_8 TemporaryType() { return Type(); }    

  public override GType_8 Check(Context_8 ctx) {
    if (creator_ != null) {
      GType_8 c = creator_.Check(ctx);
      if (c == null)
        return null;
      if (!c.BaseType().IsSubtype(PoolClass_8.instance_)) {
        Error("object creator must be a pool");
        return null;
      }
    }
    GType_8 t = type_expr_.Resolve(ctx.program_);
    if (t == null)
      return null;
    class_ = (Class_8) t;
    if (class_.HasAttribute(Attribute_8.Abstract)) {
      Error("can't instantiate abstract class");
      return null;
    }
    if (creator_ != null) {
      class_.NeedDestroy(); // every pool-allocated class needs the _Destroy1 and _Destroy2 methods
      class_.SetVirtual();  // every pool-allocated class must be virtual
    }

    constructor_ = (Constructor_8) Invocation_8.CheckInvoke(this, ctx, false, class_,
                                      class_.name_, arguments_, MemberKind_8.Constructor_8);
    if (constructor_ == null)
      return null;

    GType_8 type = Type();
    if (type is Owning_8)
      ctx.AddTemporary(this);
    return type;
  }

  public override Method_8 Calls() { return constructor_; }

  public override RValue_8 ^Eval(Env_8 env) {
    GValue_8 ^obj = class_.New_8();
    Invocation_8.CallMethod(env, obj, constructor_, arguments_, false);
    return obj;
  }

  public override string Emit() {
    string args = Invocation_8.EmitArguments(constructor_, arguments_);

    return creator_ == null ?
      EmitAllocate(class_.name_, args, LosesOwnership()) :
      String.Format("new ({0}->Alloc(sizeof({1}))) {1}({2})", creator_.Emit(), class_.name_, args);
  }
}

class ArrayInitializer_8 : Expression_8 {
  public readonly ArrayList /* of Expression_8 */ ^initializers_;

  public ArrayInitializer_8(ArrayList ^initializers) { initializers_ = initializers; }

  public override GType_8 Check(Context_8 ctx) {
    Error("only static fields may have array initializers");
    return null;
  }

  public bool CheckElements(Context_8 ctx, GType_8 element_type) {
    foreach (Expression_8 e in initializers_)
      if (!e.CheckConstant() || !e.Check(ctx, element_type))
        return false;
    return true;
  }

  public override RValue_8 ^Eval(Env_8 env) { Debug.Assert(false); return null; }

  public GArray_8 ^Eval(ArrayType_8 type) {
    GArray_8 ^a = new GArray_8(type, initializers_.Count);
    for (int i = 0; i < initializers_.Count; ++i) {
      Expression_8 e = (Expression_8) initializers_[i];
      a.Set(i, e.Eval(Env_8.static_, type.ElementType()));
    }
    return a;
  }

  public override string Emit() { Debug.Assert(false); return null; }

  public void Emit(SourceWriter_8 w) {
    int count = initializers_.Count;
    int per_row = 12;

    w.Write("{ ");
    if (count > per_row) {    // format onto multiple rows
      w.WriteLine("");
      w.AddIndent();
      w.Indent();
    }
    for (int i = 0; i < count; ++i) {
      if (i > 0) {
        w.Write(", ");
        if (i % per_row == 0) {
          w.WriteLine("");
          w.Indent();
        }
      }
      Expression_8 e = (Expression_8) initializers_[i];
      SimpleValue_8 ^v = (SimpleValue_8) e.Eval(Env_8.static_);
      w.Write(v.Emit());
    }
    if (count > per_row) {
      w.SubIndent();
      w.WriteLine("");
    }
    w.Write(" }");
  }
}

class NewArray_8 : Expression_8 {
  TypeExpr_8 ^element_type_expr_;
  int dimensions_;
  ArrayType_8 ^array_type_;

  Expression_8 ^count_;

  public NewArray_8(TypeExpr_8 ^element_type_expr, int dimensions, Expression_8 ^count) {
    element_type_expr_ = element_type_expr;
    dimensions_ = dimensions;
    count_ = count;
  }

  GType_8 Type() {
    return (GType_8) array_type_.OwningType();
  }

  public override GType_8 TemporaryType() { return Type(); }

  public override GType_8 Check(Context_8 ctx) {
    if (element_type_expr_ is ArrayTypeExpr_8) {
      Error("syntax error in new expression");
      return null;
    }
    for (int i = 0; i < dimensions_; ++i)
      element_type_expr_ = new ArrayTypeExpr_8(take element_type_expr_);
    GType_8 element_type = element_type_expr_.Resolve(ctx.program_);
    if (element_type == null)
      return null;
    array_type_ = new ArrayType_8(element_type);

    if (!count_.Check(ctx, GInt_8.type_))
      return null;

    GType_8 t = Type();
    if (t is Owning_8)
      ctx.AddTemporary(this);
    return t;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    return new GArray_8(array_type_, count_.EvalInt(env));
  }

  public override string Emit() {
    GType_8 t = array_type_.ElementType();
    string array_type = GType_8.ConstructType(
      t is Owning_8 ? "_Array" : "_CopyableArray",
      t.EmitGenericType());
    string args = String.Format("&typeid({0}), {1}", t.EmitType(), count_.Emit());
    return EmitAllocate(array_type, args, LosesOwnership());
  }
}

abstract class Unary_8 : Expression_8 {
  protected Expression_8 ^exp_;

  protected Unary_8(Expression_8 ^e) { exp_ = e; }

  public override bool IsConstant() { return exp_.IsConstant(); }
}

// unary minus operator
class Minus_8 : Unary_8 {
  GType_8 type_;

  public Minus_8(Expression_8 ^e) : base(e) { }

  public override GType_8 Check(Context_8 ctx) {
    type_ = exp_.Check(ctx);
    if (type_ != GInt_8.type_ && type_ != GFloat_8.type_ && type_ != GDouble_8.type_) {
      Error("- operator cannot be applied to value of type {0}", type_);
      return null;
    }
    return type_;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    if (type_ == GInt_8.type_) {
    int i = exp_.EvalInt(env);
    return new GInt_8(-i);
  }
    if (type_ == GFloat_8.type_) {
      float f = exp_.EvalFloat(env);
      return new GFloat_8(-f);
    }
    if (type_ == GDouble_8.type_) {
      double d = exp_.EvalDouble(env);
      return new GDouble_8(-d);
    }
    Debug.Assert(false);
    return null;
  }

  public override string Emit() { return "-" + exp_.Emit(); }
}

class Not_8 : Unary_8 {
  public Not_8(Expression_8 ^e) : base(e) { }

  public override GType_8 Check(Context_8 ctx) {
    return exp_.Check(ctx, GBool_8.type_) ? GBool_8.type_ : null;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    bool b = exp_.EvalBool(env);
    return new GBool_8(!b);
  }

  public override string Emit() { return "!" + exp_.Emit(); }
}

// the bitwise complement (~) operator
class Complement_8 : Unary_8 {
  public Complement_8(Expression_8 ^e) : base(e) { }

  public override GType_8 Check(Context_8 ctx) {
    return exp_.Check(ctx, GInt_8.type_) ? GInt_8.type_ : null;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    int i = exp_.EvalInt(env);
    return new GInt_8(~i);
  }

  public override string Emit() { return "~" + exp_.Emit(); }
}

class IncDec_8 : Expression_8 {
  bool pre_;    // true for pre-increment/decrement; false for post-increment/decrement
  bool inc_;
  LValue_8 ^lvalue_;

  public IncDec_8(bool pre, bool inc, LValue_8 ^lvalue) { pre_ = pre; inc_ = inc; lvalue_ = lvalue; }

  public override GType_8 Check(Context_8 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    GType_8 t = lvalue_.Check(ctx, true, true, false);
    if (t == null)
      return null;
    if (lvalue_.Kind() == ExprKind_8.Indexer_8) {
      Error("++ and -- can't yet operate on indexers");
      return null;
    }
    if (t != GInt_8.type_) {
      Error("++ and -- can operate only on integers");
      return null;
    }
    return GInt_8.type_;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    Location_8 loc = lvalue_.EvalLocation(env);
    GInt_8 ^i = (GInt_8) take loc.value_;
    loc.value_ = new GInt_8(inc_ ? i.i_ + 1 : i.i_ - 1);
    return pre_ ? ((GInt_8) loc.value_).Copy() : i;
  }

  string EmitOp() { return inc_ ? "++" : "--"; }

  public override string Emit() {
    return pre_ ? EmitOp() + lvalue_.Emit() : lvalue_.Emit() + EmitOp();
  }
}

abstract class Conversion_8 : Expression_8 {
  protected Expression_8 ^expr_;
  protected TypeExpr_8 ^type_expr_;

  protected GType_8 from_base_;
  protected GType_8 to_type_, to_base_;

  protected Conversion_8(Expression_8 ^expr, TypeExpr_8 ^type_expr) {
    expr_ = expr; type_expr_ = type_expr;
  }

  protected bool CheckConversion(Context_8 ctx, bool subtype_only) {
    GType_8 from = expr_.Check(ctx);
    if (from == null)
      return false;
    from_base_ = from.BaseType();

    to_base_ = type_expr_.Resolve(ctx.program_);
    if (to_base_ == null)
      return false;
    if (!to_base_.IsValue() &&
       (from is Owning_8 || from_base_.IsValue()))
      to_type_ = to_base_.OwningType();
    else to_type_ = to_base_;

    if (!from.CanConvertExplicit(to_type_, subtype_only)) {
      Error("can't convert from {0} to {1}", from_base_, to_base_);
      return false;
    }
    return true;
  }
}

class Cast_8 : Conversion_8 {
  public Cast_8(Expression_8 ^expr, TypeExpr_8 ^type_expr) : base(expr, type_expr) { }

  public override Local_8 GetLocal() { return expr_.GetLocal(); }
  
  public override GType_8 Check(Context_8 ctx) {
    return CheckConversion(ctx, false) ? to_type_ : null;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_8.Local_8 ? ExprKind_8.Local_8 : ExprKind_8.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_8 ^Eval(Env_8 env) {
    RValue_8 ^r = expr_.Eval(env);
    return r.Get().ConvertExplicit(ref r, to_base_);
  }

  public override string Emit() {
    return expr_.EmitExplicit(from_base_, to_type_);
  }
}

class Binary_8 : Expression_8 {
  int op_;
  Expression_8 ^left_, right_;
  GType_8 left_type_, right_type_;
  GType_8 type_;

  const int CONCATENATE = 0;

  public Binary_8(Expression_8 ^left, int op, Expression_8 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public static GType_8 Promote(Syntax_8 caller, GType_8 left, int op, GType_8 right) {
    if (left.CanConvert(GInt_8.type_) && right.CanConvert(GInt_8.type_))
      return GInt_8.type_;
    if (left.CanConvert(GFloat_8.type_) && right.CanConvert(GFloat_8.type_))
      return GFloat_8.type_;
    if (left.CanConvert(GDouble_8.type_) && right.CanConvert(GDouble_8.type_))
      return GDouble_8.type_;
    caller.Error("can't apply operator {0} to operands of type {1} and {2}", OpName(op), left, right);
    return null;
  }

  bool CheckIntArgs() {
    if (left_type_.CheckConvert(this, GInt_8.type_) && right_type_.CheckConvert(this, GInt_8.type_)) {
      type_ = GInt_8.type_;
      return true;
    }
    return false;
  }

  public override GType_8 Check(Context_8 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);

    if (op_ == '+' && (left_type_ == GString_8.type_ || right_type_ == GString_8.type_)) {
      op_ = CONCATENATE;

      // If_8 we'll be calling ToString() on a class, ensure that it will inherit from
      // Object in generated code.
      if (left_type_ != GString_8.type_)
        left_type_.CanConvert(GObject_8.type_);
      if (right_type_ != GString_8.type_)
        right_type_.CanConvert(GObject_8.type_);

      return GString_8.type_;
    }

    switch (op_) {
      case '*':
      case '/':
      case '+':
      case '-':
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_;

      case '%':
      case Parser.OP_LEFT_SHIFT:
      case Parser.OP_RIGHT_SHIFT:
        return CheckIntArgs() ? GInt_8.type_ : null;

      case '&':
      case '|':
        if (left_type_ == GBool_8.type_ && right_type_ == GBool_8.type_)
          type_ = GBool_8.type_;
        else {
          if (!CheckIntArgs())
            return null;
          type_ = GInt_8.type_;
        }
        return type_;

      case '<':
      case Parser.OP_LE:
      case '>':
      case Parser.OP_GE:
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_ == null ? null : GBool_8.type_;

      default:
        Debug.Assert(false);
        return null;
    }
  }

  public static GBool_8 ^BoolOp(bool x, int op, bool y) {
    switch (op) {
      case '&': return new GBool_8(x & y);
      case '|': return new GBool_8(x | y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_8 ^IntOp(int x, int op, int y) {
    switch (op) {
      case '*': return new GInt_8(x * y);
      case '/': return new GInt_8(x / y);
      case '%': return new GInt_8(x % y);
      case '+': return new GInt_8(x + y);
      case '-': return new GInt_8(x - y);
      case Parser.OP_LEFT_SHIFT: return new GInt_8(x << y);
      case Parser.OP_RIGHT_SHIFT: return new GInt_8(x >> y);
      case '&': return new GInt_8(x & y);
      case '|': return new GInt_8(x | y);
      case '<': return new GBool_8(x < y);
      case Parser.OP_LE: return new GBool_8(x <= y);
      case '>': return new GBool_8(x > y);
      case Parser.OP_GE: return new GBool_8(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_8 ^FloatOp(float x, int op, float y) {
    switch (op) {
      case '*': return new GFloat_8(x * y);
      case '/': return new GFloat_8(x / y);
      case '+': return new GFloat_8(x + y);
      case '-': return new GFloat_8(x - y);
      case '<': return new GBool_8(x < y);
      case Parser.OP_LE: return new GBool_8(x <= y);
      case '>': return new GBool_8(x > y);
      case Parser.OP_GE: return new GBool_8(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_8 ^DoubleOp(double x, int op, double y) {
    switch (op) {
      case '*': return new GDouble_8(x * y);
      case '/': return new GDouble_8(x / y);
      case '+': return new GDouble_8(x + y);
      case '-': return new GDouble_8(x - y);
      case '<': return new GBool_8(x < y);
      case Parser.OP_LE: return new GBool_8(x <= y);
      case '>': return new GBool_8(x > y);
      case Parser.OP_GE: return new GBool_8(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public override RValue_8 ^Eval(Env_8 env) {
    if (op_ == CONCATENATE)
      return new GString_8(left_.Eval(env).ToString() + right_.Eval(env).ToString());

    if (type_ == GBool_8.type_)
      return BoolOp(left_.EvalBool(env), op_, right_.EvalBool(env));
    if (type_ == GInt_8.type_)
      return IntOp(left_.EvalInt(env), op_, right_.EvalInt(env));
    if (type_ == GFloat_8.type_)
      return FloatOp(left_.EvalFloat(env), op_, right_.EvalFloat(env));
    if (type_ == GDouble_8.type_)
      return DoubleOp(left_.EvalDouble(env), op_, right_.EvalDouble(env));

    Debug.Assert(false);
    return null;
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  static string OpName(int op) {
    switch (op) {
      case Parser.OP_LEFT_SHIFT: return "<<";
      case Parser.OP_RIGHT_SHIFT: return ">>";
      case Parser.OP_LE: return "<=";
      case Parser.OP_GE: return ">=";
      default: return ((char) op).ToString();
    }
  }

  public override string Emit() {
    if (op_ == CONCATENATE)
      return Hold(GString_8.type_,
        String.Format("String::_Concat({0}, {1})",
          left_.EmitRef(left_type_, GObject_8.type_), right_.Emit(right_type_, GObject_8.type_)));

    return String.Format("{0} {1} {2}",
      left_.EmitRef(left_type_), OpName(op_), right_.Emit() );
  }
}

class Equality_8 : Expression_8 {
  bool equal_;    // true for ==, false for !=
  Expression_8 ^left_, right_;
  GType_8 left_type_, right_type_, type_;

  public Equality_8(Expression_8 ^left, int op, Expression_8 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_EQUAL: equal_ = true; break;
      case Parser.OP_NE: equal_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_8 Check(Context_8 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);
    if (left_type_.IsReference() != right_type_.IsReference()) {
      Error("can't compare types {0} and {1}", left_type_, right_type_);
      return null;
    }
    type_ = left_type_.BaseType().CommonType(this, right_type_.BaseType());
    return type_ == null ? null : GBool_8.type_;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    RValue_8 ^left = left_.Eval(env, type_);
    RValue_8 ^right = right_.Eval(env, type_);
    bool eq = left.Get().DefaultEquals(right.Get());
    return new GBool_8(equal_ ? eq : !eq);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    string emit_left = left_.EmitRef(left_type_);
    string emit_right = right_.Emit();
    if (type_ == GString_8.type_)
      return String.Format("{0}String::_Equals({1}, {2})",
                           equal_ ? "" : "!", emit_left, emit_right);
    return String.Format("{0} {1} {2}", emit_left, equal_ ? "==" : "!=", emit_right);
  }
}

class Is_8 : Conversion_8 {
  public Is_8(Expression_8 ^expr, TypeExpr_8 ^type_expr) : base(expr, type_expr) { }

  public override GType_8 Check(Context_8 ctx) {
    return CheckConversion(ctx, true) ? GBool_8.type_ : null;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    RValue_8 ^r = expr_.Eval(env);
    GValue_8 v = r.Get();
    return new GBool_8(!(v is Null_8) && v.Type().IsSubtype(to_base_));
  }

  public override string Emit() {
    if (from_base_.IsReference()) {
      Class_8 c = (Class_8) to_base_;
      return String.Format("dynamic_cast<{0} *>({1}) != 0", c.name_, expr_.Emit());
    }
    return to_base_ == from_base_ || to_base_ == GObject_8.type_ ? "true" : "false";
  }
}

class As_8 : Conversion_8 {
  public As_8(Expression_8 ^expr, TypeExpr_8 ^type_expr) : base(expr, type_expr) { }

  public override Local_8 GetLocal() { return expr_.GetLocal(); }

  public override GType_8 Check(Context_8 ctx) {
    if (!CheckConversion(ctx, true))
      return null;
    if (!to_base_.IsReference()) {
      Error("as operator must convert to reference type");
      return null;
    }
    return to_type_;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_8.Local_8 ? ExprKind_8.Local_8 : ExprKind_8.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_8 ^Eval(Env_8 env) {
    RValue_8 ^r = expr_.Eval(env);
    return r.Get().Type().IsSubtype(to_base_) ? r : Null_8.Instance.Copy();
  }

  public override string Emit() {
    if (from_base_.CanConvert(to_base_))
      return expr_.Emit(from_base_, to_base_);
    Class_8 c = (Class_8) to_base_;
    return String.Format("dynamic_cast<{0} *>({1})", c.name_, expr_.Emit());
  }
}

// a && or || operator
class LogicalOp_8 : Expression_8 {
  bool and_;  // true => &&, false => ||
  Expression_8 ^left_, right_;
  Joiner_8 ^join_ = new Joiner_8();

  public LogicalOp_8(Expression_8 ^left, int op, Expression_8 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_AND: and_ = true; break;
      case Parser.OP_OR: and_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_8 Check(Context_8 ctx) {
    if (!left_.Check(ctx, GBool_8.type_))
      return null;

    join_.Join(ctx.Prev());
    if (!right_.Check(ctx, GBool_8.type_))
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    return GBool_8.type_;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    bool left = left_.EvalBool(env);
    bool b = and_ ? left && right_.EvalBool(env) : left || right_.EvalBool(env);
    return new GBool_8(b);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    return String.Format("{0} {1} {2}", left_.Emit(), and_ ? "&&" : "||", right_.Emit());
  }

}

// the ?: operator
class Conditional_8 : Expression_8 {
  Expression_8 ^condition_;
  Expression_8 ^if_true_, if_false_;

  GType_8 true_type_, false_type_;
  GType_8 type_;
  Joiner_8 ^join_ = new Joiner_8();

  public Conditional_8(Expression_8 ^condition, Expression_8 ^if_true, Expression_8 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override GType_8 Check(Context_8 ctx) {
    if (!condition_.Check(ctx, GBool_8.type_))
      return null;

    Control_8 c = ctx.Prev();

    true_type_ = if_true_.Check(ctx);
    if (true_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    false_type_ = if_false_.Check(ctx);
    if (false_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    type_ = true_type_.CommonType(this, false_type_);
    return type_;
  }

  public override int Kind() {
    return if_true_.Kind() == ExprKind_8.Local_8 && if_false_.Kind() == ExprKind_8.Local_8 ? ExprKind_8.Local_8 : ExprKind_8.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    if_true_.LoseOwnership();
    if_false_.LoseOwnership();
  }

  public override RValue_8 ^Eval(Env_8 env) {
    return condition_.EvalBool(env) ? if_true_.Eval(env, type_) : if_false_.Eval(env, type_);
  }

  public override string Emit() {
    return String.Format("{0} ? {1} : {2}", condition_.Emit(),
                         if_true_.Emit(true_type_, type_), if_false_.Emit(false_type_, type_));
  }
}

class Assign_8 : Expression_8 {
  LValue_8 ^left_;
  Expression_8 ^right_;

  GType_8 left_type_, right_type_;

  public Assign_8(LValue_8 ^left, Expression_8 ^right) {
    left_ = left; right_ = right;
  }

  public static bool CheckAssign(Syntax_8 caller, GType_8 left_type, Expression_8 right, GType_8 right_type) {
    if (!right_type.CheckConvert(caller, left_type,
      right.Kind() == ExprKind_8.Local_8 ? ConversionContext_8.AssignVar : ConversionContext_8.Other))
      return false;
    right.CheckLoseOwnership(right_type, left_type);
    return true;
  }

  public override GType_8 Check(Context_8 ctx) {
    left_type_ = left_.Check(ctx, false, true, false);
    if (left_type_ == null)
      return null;

    right_type_ = right_.Check(ctx, true, false, false);
    if (right_type_ == null || !CheckAssign(this, left_.StorageType(), right_, right_type_))
      return null;
    right_.HoldRef(ctx);

    AddControl(ctx);
    left_.ReleaseAll(ctx);
    right_.ReleaseRef(ctx);
    return left_type_;
  }

  public override Method_8 Calls() {
    PropertyOrIndexer_8 pi = left_.GetPropertyOrIndexer();
    return pi == null ? null : pi.Setter();
  }

  public override bool Sets(Local_8 local) { return left_.IsLocal(local); }

  public override TypeSet_8 NodeDestroys() {
    return left_.GetPropertyOrIndexer() != null ? TypeSet_8.empty_ : left_.StorageType().VarDestroys();
  }

  public override RValue_8 ^Eval(Env_8 env) {
    RValue_8 ^v1, v2;
    left_.Eval1(env, out v1, out v2);
    RValue_8 ^val = right_.Eval(env, left_type_);
    RValue_8 ^ret = val.CopyRef();
    left_.EvalSet(env, v1, v2, val);
    return ret;
  }

  public override string Emit() {
    return left_.EmitSet(right_.EmitRef(right_type_, left_type_));
  }
}

// a compound assignment operator such as += or -=
class CompoundAssign_8 : Expression_8 {
  LValue_8 ^left_;
  int op_;
  Expression_8 ^right_;

  GType_8 type_;

  public CompoundAssign_8(LValue_8 ^left, int op, Expression_8 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public override GType_8 Check(Context_8 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    type_ = left_.Check(ctx, true, true, false);
    if (type_ == null)
      return null;
    if (left_.Kind() == ExprKind_8.Indexer_8) {
      Error("compound assignments don't yet work on indexers");
      return null;
    }
    if (type_ == GBool_8.type_ && (op_ == '&' || op_ == '|')) {
      if (!right_.Check(ctx, GBool_8.type_))
        return null;
      return type_;
    }
    if (type_ != GInt_8.type_ && type_ != GFloat_8.type_ && type_ != GDouble_8.type_) {
      Error("compound assignment operator {0}= can't operate on object of type {1}", (char) op_, type_);
      return null;
    }
    if (!right_.Check(ctx, type_))
      return null;
    return type_;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    Location_8 loc = left_.EvalLocation(env);
    if (type_ == GBool_8.type_) {
      bool x = ((GBool_8) loc.value_).b_;
      bool y = right_.EvalBool(env);
      loc.value_ = Binary_8.BoolOp(x, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GInt_8.type_) {
      GInt_8 x = (GInt_8) loc.value_;
      int y = right_.EvalInt(env);
      loc.value_ = Binary_8.IntOp(x.i_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GFloat_8.type_) {
      GFloat_8 x = (GFloat_8) loc.value_;
      float y = right_.EvalFloat(env);
      loc.value_ = Binary_8.FloatOp(x.f_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GDouble_8.type_) {
      GDouble_8 x = (GDouble_8) loc.value_;
      double y = right_.EvalDouble(env);
      loc.value_ = Binary_8.DoubleOp(x.d_, op_, y);
      return loc.value_.CopyRef();
    } else {
      Debug.Assert(false);
      return null;
    }
  }

  public override string Emit() {
    return String.Format("{0} {1}= {2}", left_.Emit(), (char) op_, right_.Emit());
  }
}

class Take_8 : Expression_8 {
  LValue_8 ^exp_;
  Owning_8 type_;

  public Take_8(LValue_8 ^exp) { exp_ = exp; }

  public override GType_8 Check(Context_8 ctx) {
    GType_8 t = exp_.Check(ctx);
    if (t == null)
      return null;
    type_ = exp_.StorageType() as Owning_8;
    if (type_ == null) {
      Error("take must be applied to owning pointer");
      return null;
    }
    exp_.LoseOwnership();
    ctx.AddTemporary(this);
    return type_;
  }

  public override GType_8 TemporaryType() { return type_; }

  public override RValue_8 ^Eval(Env_8 env) {
    RValue_8 ^v = exp_.Eval(env);
    exp_.EvalSet(env, Null_8.Instance.Copy());
    return v;
  }

  public override string Emit() {
    return Hold(exp_.StorageType(), exp_.Emit());
  }
}

abstract class Statement_8 : Node_8 {
  public abstract bool Check(Context_8 ctx);
  public abstract RValue_8 ^Eval(Env_8 env);

  public abstract void Emit(SourceWriter_8 w);

  public virtual void EmitEmbedded(SourceWriter_8 w) {
    w.WriteLine("");
    w.AddIndent();
    w.Indent();
    Emit(w);
    w.SubIndent();
  }

  public virtual void EmitInExistingBlock(SourceWriter_8 w) {
    w.Indent();
    Emit(w);
  }
}

class StatementList_8 {
  public readonly ArrayList /* of Statement_8 */ ^statements_ = new ArrayList();

  public void Add(Statement_8 ^s) { statements_.Add(s); }

  public bool Check(Context_8 ctx) {
    bool ok = true;
    foreach (Statement_8 s in statements_)
      ok &= s.Check(ctx);
    return ok;
  }

  public RValue_8 ^Eval(Env_8 env) {
    foreach (Statement_8 s in statements_) {
      RValue_8 ^v = s.Eval(env);
      if (v != null)
        return v;
    }
    return null;
  }

  public void Emit(SourceWriter_8 w) {
    foreach (Statement_8 s in statements_) {
      w.Indent();
      s.Emit(w);
    }
  }
}

class EmptyStatement_8 : InlineStatement_8 {
  public EmptyStatement_8() { }

  public override bool Check(Context_8 ctx) { return true; }
  public override RValue_8 ^Eval(Env_8 env) { return null; }
  public override void EmitInline(SourceWriter_8 w) { }

  public static readonly EmptyStatement_8 ^instance_ = new EmptyStatement_8();
}

// A Scoped_8 is a statement defining one or more local variables.  If_8 a Scoped_8 appears in the
// control graph, then it destroys those variables when traversed.
abstract class Scoped_8 : Statement_8 {
  protected Local_8 start_;   // the first local outside this statement
  protected Local_8 top_;     // the top local defined inside this statement

  TypeSet_8 ^destroys_;

  protected void SetStartVar(Context_8 ctx) { start_ = top_ = ctx.var_; }
  protected void SetTopVar(Context_8 ctx) { top_ = ctx.var_; }

  public Local_8 GetStart() { return start_; }
  public Local_8 GetTop() { return top_; }

  public override TypeSet_8 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_8();
    for (Local_8 l = top_; l != start_; l = l.next_)
        destroys_.Add(l.Type().VarDestroys());
    }
    return destroys_;
  }
}

class Block_8 : Scoped_8 {
  public readonly StatementList_8 ^list_;

  public Block_8(StatementList_8 ^list) { list_ = list; }

  public bool Absent() { return list_ == null; }

  public override bool Check(Context_8 ctx) {
    Context_8 ^ctx1 = new Context_8(ctx);   // don't pass declarations outside block
    SetStartVar(ctx1);

    if (!list_.Check(ctx1))
      return false;

    SetTopVar(ctx1);

    // Add this Block_8 to the control graph; this represents the destruction of variables
    // within the block at block exit.
    AddControl(ctx1);

    return true;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    return list_.Eval(new Env_8(env));
  }

  public static Block_8 ^EmptyBlock() { return new Block_8(new StatementList_8()); }

  public override void Emit(SourceWriter_8 w) {
    w.OpenBrace();
    list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitEmbedded(SourceWriter_8 w) {
    w.Write(" ");
    Emit(w);
  }

  public override void EmitInExistingBlock(SourceWriter_8 w) {
    list_.Emit(w);
  }
}

class MemberKind_8 {
  public const int
    Field_8 = 0,
    Method_8 = 1,
    Property_8 = 2,
    Indexer_8 = 3,
    Constructor_8 = 4;
}

class Named_8 : Node_8 {
  public readonly TypeExpr_8 ^type_expr_;   // may be null for certain objects such as constructors
  protected GType_8 type_;

  public readonly string name_;

  public Named_8(TypeExpr_8 ^type_expr, string name) {
    type_expr_ = type_expr;
    name_ = name;
  }

  public GType_8 Type() { return type_; }

  public virtual bool Resolve(Program_8 program) {
    if (type_expr_ == null || type_ != null)
      return true;
    type_ = type_expr_.Resolve(program);
    return type_ != null;
  }
}

abstract class Member_8 : Named_8 {
  protected Class_8 class_;    // containing class

  public readonly int attributes_;

  protected Member_8(int attributes, TypeExpr_8 ^type_expr, string name) : base(type_expr, name) {
    attributes_ = attributes;
  }

  public abstract int Kind();

  public static string ToString(int kind) {
    switch (kind) {
      case MemberKind_8.Field_8: return "field";
      case MemberKind_8.Method_8: return "method";
      case MemberKind_8.Property_8: return "property";
      case MemberKind_8.Indexer_8: return "indexer";
      case MemberKind_8.Constructor_8: return "constructor";
      default: Debug.Assert(false); return null;
    }
  }

  public string KindString() { return ToString(Kind()); }

  protected abstract int ValidAttributes();

  public Class_8 GetClass() { return class_; }
  public void SetClass(Class_8 cl) { class_ = cl; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public bool IsOverride() { return HasAttribute(Attribute_8.Override); }

  public bool IsProtected() { return HasAttribute(Attribute_8.Protected); }

  public bool IsPublic() { return HasAttribute(Attribute_8.Public); }

  public bool IsPrivate() { return !HasAttribute(Attribute_8.Public | Attribute_8.Protected); }

  public bool IsVirtual() {
    return HasAttribute(Attribute_8.Virtual | Attribute_8.Abstract | Attribute_8.Override);
  }

  static ArrayList ^empty_ = new ArrayList();

  public virtual ArrayList /* of Parameter_8 */ Parameters() { return empty_; }

  public Parameter_8 Param(int i) {
    return (Parameter_8) Parameters()[i];
  }

  public bool IsAccessible(Class_8 from_class, GType_8 through_type, bool through_base) {
    if (IsPublic())
      return true;

    // In GEL2 (as in C# and C++), a class [from_class] can access a protected member of
    // a class C only if [from_class] is a subtype of C and the access is
    // through a subtype of [from_class].  See e.g. C# 3.5.3 "Protected Access for Instance Members".
    if (IsProtected())
      return through_base || from_class.IsSubtype(class_) && through_type.IsSubtype(from_class);

    // default private access
    return from_class == class_;
  }

  public static bool MatchKind(int kind1, int kind2) {
    return kind1 == kind2 ||
           kind1 == MemberKind_8.Field_8 && kind2 == MemberKind_8.Property_8 ||
           kind1 == MemberKind_8.Property_8 && kind2 == MemberKind_8.Field_8;
  }

  public bool MatchSignature(Member_8 m) {
    if (!MatchKind(Kind(), m.Kind()))
      return false;

    if (name_ != m.name_ || Parameters().Count != m.Parameters().Count)
      return false;

    int i = 0;
    foreach (Parameter_8 p in m.Parameters()) {
      Parameter_8 q = Param(i);
      if (!p.Match(q))
        return false;
      ++i;
    }
    return true;
  }

  public bool IsApplicable(ArrayList arguments, out int mismatches) {
    mismatches = 0;
    if (Parameters().Count != arguments.Count)
      return false;
    int i = 0;
    foreach (Argument_8 a in arguments) {
      if (!Param(i).CanReceive(a))
        ++mismatches;
      ++i;
    }
    return true;
  }

  public void ReportMismatches(Syntax_8 caller, ArrayList arguments) {
    Debug.Assert(Parameters().Count == arguments.Count);
    int i = 0;
    foreach (Argument_8 a in arguments) {
      Parameter_8 p = Param(i);
      if (!p.CanReceive(a))
        caller.Error("argument {0}: can't convert from {1} to {2}", i + 1, a.TypeString(), p.TypeString());
      ++i;
    }
  }

  protected virtual void AddOverride(Member_8 m) { }

  bool CheckOverride(Context_8 ctx) {
    Class_8 parent = ctx.class_.Parent();
    Member_8 m = parent != null ? parent.FindMatchingMember(this, false) : null;
    if (m != null) {
      if (this is Field_8) {
        Error("can't define field with same name as field/property in superclass");
        return false;
      }
      if (m is Field_8) {
        Error("can't define property with same name as field in superclass");
        return false;
      }
      if (!HasAttribute(Attribute_8.Override)) {
        Error("must use override keyword to override superclass {0}", KindString());
        return false;
      }
      if (HasAttribute(Attribute_8.Virtual)) {
        Error("{0} with override or abstract keyword cannot be marked virtual", KindString());
        return false;
      }
      if (!m.IsVirtual()) {
        Error("attempting to override non-virtual {0}", KindString());
        return false;
      }
      if (!m.Type().Equals(Type())) {
        Error("can't override {0} with different return type", KindString());
        return false;
      }
      if (m.IsPublic() != IsPublic()) {
        Error("override {0} must have same accessibility as {0} it overrides", KindString());
        return false;
      }
      m.AddOverride(this);
    } else if (HasAttribute(Attribute_8.Override)) {
      Error("can't find {0} to override", KindString());
      return false;
    }
    return true;
  }

  bool CheckAccessibility() {
    int n = 0;
    if ((attributes_ & Attribute_8.Private) != 0)
      ++n;
    if ((attributes_ & Attribute_8.Protected) != 0)
      ++n;
    if ((attributes_ & Attribute_8.Public) != 0)
      ++n;
    if (n > 1) {
      Error("only one access level (private, protected, public) may be specified");
      return false;
    }

    if (IsVirtual() && IsPrivate()) {
      Error("a virtual or abstract {0} may not be private", KindString());
      return false;
    }

    return true;
  }

  public virtual bool Check(Context_8 ctx) {
    if (!AttributeUtil_8.CheckOnly(attributes_, ValidAttributes())) {
      Error("illegal {0} attribute", KindString());
      return false;
    }

    if (HasAttribute(Attribute_8.Abstract) && !ctx.class_.HasAttribute(Attribute_8.Abstract)) {
      Error("an abstract {0} can be defined only in an abstract class", KindString());
      return false;
    }

    if (name_ == class_.name_ && !(this is Constructor_8)) {
      Error("{0} cannot have same name as enclosing class", KindString());
      return false;
    }

    if (class_.GetMatchingMember(this) != this) {
      Error("{0} {1} appears twice in same class", KindString(), name_ != null ? name_ : "");
      return false;
    }

    return CheckOverride(ctx) && CheckAccessibility();
  }
}

// a member which represents a storage location: a field, property, or indexer
abstract class LMember_8 : Member_8 {
  protected LMember_8(int attributes, TypeExpr_8 ^type_expr, string name)
    : base(attributes, type_expr, name) { }

  public bool IsConstOrStatic() {
    return HasAttribute(Attribute_8.Const | Attribute_8.Static);
  }

  protected bool CheckStatic(Syntax_8 caller, bool static_ok, bool instance_ok) {
    if (!static_ok && IsConstOrStatic()) {
      caller.Error("{0} {1} is static", KindString(), name_);
      return false;
    }
    if (!instance_ok && !IsConstOrStatic()) {
      caller.Error("{0} {1} is not static", KindString(), name_);
      return false;
    }
    return true;
  }

  public abstract bool CheckAssigning(Syntax_8 caller, Context_8 ctx, bool assigning);

  public bool CheckAccess(Syntax_8 caller, Context_8 ctx, bool assigning, bool static_ok, bool instance_ok) {
    return CheckStatic(caller, static_ok, instance_ok) && CheckAssigning(caller, ctx, assigning);
  }

  public abstract Location_8 GetLocation(GObject_8 obj);

  // These methods are for fields and properties; indexers have their own versions which take
  // an extra index argument.
  public virtual RValue_8 ^Get(GValue_8 obj) { Debug.Assert(false); return null; }
  public virtual RValue_8 ^Take_8(GValue_8 obj) { Debug.Assert(false); return null; }
  public virtual void Set(GObject_8 obj, RValue_8 ^val)  { Debug.Assert(false); }

  public virtual string Emit()  { Debug.Assert(false); return null; }
  public virtual string EmitSet(string val)  { Debug.Assert(false); return null; }
}

class Field_8 : LMember_8 {
  protected Expression_8 ^initializer_;    // or null if none
  protected GType_8 initializer_type_;

  public Field_8(int attributes, TypeExpr_8 ^type_expr, string name, Expression_8 ^initializer)
  : base(attributes, type_expr, name) {
    initializer_ = initializer;
  }

  // Create a field for an internal class.  Such fields will never be type checked.
  public Field_8(GType_8 type, string name) : this(Attribute_8.Public | Attribute_8.ReadOnly, null, name, null) {
    type_ = type;
  }

  public static Field_8 ^New_8(int attributes, TypeExpr_8 ^type_expr, string name, Expression_8 ^initializer) {
    if ((attributes & Attribute_8.Static) != 0)
      return new StaticField_8(attributes, type_expr, name, initializer);
    if ((attributes & Attribute_8.Const) != 0)
      return new ConstField_8(attributes, type_expr, name, initializer);
    return new Field_8(attributes, type_expr, name, initializer);
  }

  public override int Kind() { return MemberKind_8.Field_8; }

  public Expression_8 Initializer() { return initializer_; }

  protected virtual bool CheckInitializer(Context_8 ctx) {
    if (initializer_ == null)
      return true;

    ctx.EnterExpression();
    initializer_type_ = initializer_.Check(ctx);
    bool b = initializer_type_ != null &&
             Assign_8.CheckAssign(this, type_, initializer_, initializer_type_);
    ctx.FinishExpression();
    return b;
  }

  protected override int ValidAttributes() {
    return Attribute_8.Const | Attribute_8.Private | Attribute_8.Protected | Attribute_8.Public |
           Attribute_8.ReadOnly | Attribute_8.Static;
  }

  public override bool Check(Context_8 ctx) {
    if (!base.Check(ctx))
      return false;

    // We build up a small control graph even when checking field initializers; we do this
    // since expression-checking code uses the graph to determine when temporary
    // ref counts are needed.
    prev_ = unreachable_;
    ctx.SetPrev(this);

    bool b = CheckInitializer(ctx);

    ctx.ClearPrev();
    return b;
  }

  public override bool CheckAssigning(Syntax_8 caller, Context_8 ctx, bool assigning) {
    if (assigning) {
      if (HasAttribute(Attribute_8.Const)) {
        caller.Error("can't assign to const field");
        return false;
      }
      if (HasAttribute(Attribute_8.ReadOnly) &&
          (ctx.class_ != class_ || !(ctx.method_ is Constructor_8)) ) {
        caller.Error("readonly field {0} can only be assigned in constructor", name_);
        return false;
      }
    }
    return true;
  }

  public override RValue_8 ^Get(GValue_8 obj) { return obj.Get(this); }
  public override RValue_8 ^Take_8(GValue_8 obj) { return obj.Take_8(this); }
  public override void Set(GObject_8 obj, RValue_8 ^val) { obj.Set(this, val); }
  public override Location_8 GetLocation(GObject_8 obj) { return obj.GetLocation(this); }

  protected void WriteField(SourceWriter_8 w, bool declaration) {
    w.Indent();
    if (declaration && IsConstOrStatic())
      w.Write("static ");
    w.Write("{0} ", type_.EmitType());
    if (this is ConstField_8)
      w.Write("const ");
    if (!declaration)
      w.Write("{0}::", class_.name_);
    w.Write(name_);
  }

  protected void WriteDeclaration(SourceWriter_8 w) { WriteField(w, true); }
  protected void WriteDefinition(SourceWriter_8 w) { WriteField(w, false); }

  public virtual void EmitDeclaration(SourceWriter_8 w) {
    WriteDeclaration(w);
    w.WriteLine(";");
  }

  public void EmitInitializer(SourceWriter_8 w) {
    w.IWrite("{0} = ", name_);
    if (initializer_ != null)
      w.Write(initializer_.Emit(initializer_type_, type_));
    else w.Write(type_.DefaultValue_8().Emit());
    w.WriteLine(";");
  }

  public virtual void Emit(SourceWriter_8 w) { }

  public override string Emit() { return name_; }

  public override string EmitSet(string val) {
    return String.Format("{0} = {1}", name_, val);
  }
}

class StaticField_8 : Field_8 {
  protected Location_8 ^loc_;

  public StaticField_8(int attributes, TypeExpr_8 ^type_expr, string name, Expression_8 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_8 ctx) {
    if (!base.Check(ctx))
      return false;
    loc_ = new Location_8(Type().DefaultValue_8().Copy());
    return true;
  }

  protected override bool CheckInitializer(Context_8 ctx) {
    ArrayInitializer_8 ai = initializer_ as ArrayInitializer_8;
    if (ai != null) {
      GType_8 type = type_;
      Owning_8 o = type as Owning_8;
      type = (o != null) ? o.BaseType() : null;
      ArrayType_8 at = type as ArrayType_8;
      if (at == null) {
        Error("only owning arrays may have initializers");
        return false;
      }
      return ai.CheckElements(ctx, at.ElementType());
    }

    return base.CheckInitializer(ctx);
  }

  public virtual void Init() {
    ArrayInitializer_8 ai = initializer_ as ArrayInitializer_8;
    if (ai != null)
      loc_.value_ = ai.Eval((ArrayType_8) type_.BaseType());
    else if (initializer_ != null)
      loc_.value_ = initializer_.Eval(Env_8.static_, type_);
  }

  public override RValue_8 ^Get(GValue_8 obj) { return loc_.Get().CopyRef(); }
  public override RValue_8 ^Take_8(GValue_8 obj) { return take loc_.value_; }
  public override void Set(GObject_8 obj, RValue_8 ^val) { loc_.value_ = val; }
  public override Location_8 GetLocation(GObject_8 obj) { return loc_; }

  public override void Emit(SourceWriter_8 w) {
    ArrayInitializer_8 ai = initializer_ as ArrayInitializer_8;
    if (ai != null) {
      GType_8 element_type = ((ArrayType_8) type_.BaseType()).ElementType();
      string varname = String.Format("_{0}_{1}", class_.name_, name_);
      w.Write("{0} {1}[] = ", element_type.EmitGenericType(), varname);
      ai.Emit(w);
      w.WriteLine(";");
      WriteDefinition(w);
      w.Write("(new {0}", GType_8.ConstructType("_StaticArray", element_type.EmitGenericType()));
      w.Write("(&typeid({0}), {1}, {2}))", element_type.EmitType(), ai.initializers_.Count, varname);
    } else {
      WriteDefinition(w);
      if (initializer_ != null)
        initializer_.EmitAsInitializer(w, initializer_type_, type_);
    }
    w.WriteLine(";");
    w.WriteLine("");
  }
}

class ConstField_8 : Field_8 {
  protected SimpleValue_8 ^value_;

  public ConstField_8(int attributes, TypeExpr_8 ^type_expr, string name, Expression_8 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_8 ctx) {
    if (!base.Check(ctx))
      return false;
    return initializer_.CheckConstant();
  }

  SimpleValue_8 ^Get() {
    if (value_ == DefaultValue_8.instance_) {
      Error("circular dependency among constant fields");
      Gel_8.Exit();
    }
    if (value_ == null) {
      value_ = new DefaultValue_8();    // marker used to catch circular const references
      value_ = (SimpleValue_8)initializer_.Eval(Env_8.static_, type_);
    }
    return value_.Copy();
  }

  public override RValue_8 ^Get(GValue_8 obj) {
    return Get();
  }

  public override void Set(GObject_8 obj, RValue_8 ^val) { Debug.Assert(false); }
  public override Location_8 GetLocation(GObject_8 obj) { Debug.Assert(false); return null; }

  public override void EmitDeclaration(SourceWriter_8 w) {
    WriteDeclaration(w);
    if (type_ is IntegralType_8)
      w.Write(" = {0}", Get().Emit());
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_8 w) {
    WriteDefinition(w);
    if (!(type_ is IntegralType_8)) {
      w.WriteLine(" = {0};", Get().Emit());
    }
    w.WriteLine(";");
  }
}

class ExpressionTraverser_8 : Traverser_8 {
  readonly Control_8 start_;
  Local_8 local_;
  GType_8 type_;
  bool assign_;
  bool destroy_;

  public ExpressionTraverser_8(Control_8 start, Local_8 local, GType_8 type) {
    start_ = start; local_ = local; type_ = type;
  }

  public override int Handle(Control_8 control) {
    if (control == start_)
      return Cut;
    Node_8 node = control as Node_8;
    if (node != null) {
      if (!destroy_ && node.CanDestroy(type_))
        destroy_ = true;
      else if (local_ != null && node.Sets(local_))
        assign_ = true;
    }
    return Continue_8;
  }

  // Return_8 true if the given expression needs a reference count while we evaluate
  // the control graph nodes between [start] and [end].
  // A local variable needs a ref count if it is assigned to and the object
  // the variable previously pointed to might possibly be destroyed.
  // Any other expression needs a ref count if the object it evaluates to
  // might possibly be destroyed.
  public static bool NeedRef(Control_8 start, Control_8 end, Expression_8 expr, GType_8 type) {
    Debug.Assert(start != null && end != null);
    if (start == end || !type.IsOwned() || expr is This_8 || expr is Base_8)
      return false;
    Local_8 local = expr.GetLocal();
    ExpressionTraverser_8 ^et = new ExpressionTraverser_8(start, local, type);
    end.Traverse(et, Control_8.GetMarkerValue());
    return et.destroy_ && (local == null || et.assign_);
  }
}

abstract class LocalHandler_8 {
  public abstract bool Handle(Local_8 local, Node_8 node, Name_8 use);
}

class LocalChecker_8 : LocalHandler_8 {
  public override bool Handle(Local_8 local, Node_8 node, Name_8 use) {
    if (node == Control_8.unreachable_) {
      if (use != null)
        use.Error("variable {0} may be used before it is assigned a value", use.name_);
      else
        local.Error("out parameter {0} must be assigned before leaving method", local.name_);
      return false;
    }
    if (node.Takes(local)) {
      Name_8 name = (Name_8) node;
      name.Error("can't transfer ownership from {0}: value may be used again", name.name_);
      return false;
    }
    return true;
  }
}

class LocalRefAnalyzer_8 : LocalHandler_8 {
  public override bool Handle(Local_8 local, Node_8 node, Name_8 use) {
    Debug.Assert(node != Control_8.unreachable_);
    if (node.CanDestroy(local.Type())) {
      local.NeedsRef();
      return false;   // abort search
    }
    return true;
  }
}

class LocalTraverser_8 : Traverser_8 {
  readonly Local_8 local_;
  readonly LocalHandler_8 handler_;
  Name_8 use_;

  public LocalTraverser_8(Local_8 local, LocalHandler_8 handler) {
    local_ = local;
    handler_ = handler;
  }

  public void SetUse(Name_8 use) { use_ = use; }

  public override int Handle(Control_8 control) {
    Node_8 node = control as Node_8;
    if (node == null)
      return Continue_8;

    if (node.Sets(local_))
      return Cut;

    return handler_.Handle(local_, node, use_) ? Continue_8 : Abort;
  }
}

class Local_8 : Named_8 {
  protected Expression_8 ^initializer_;    // or null if none
  protected GType_8 initializer_type_;

  public Local_8 next_;    // next variable upward in scope chain

  NonOwningArrayList /* of Name_8 */ ^uses_ = new NonOwningArrayList();    // all uses of this variable

  protected bool mutable_;   // true if this local may ever change after it's first initialized

  protected bool needs_ref_;    // true if this variable needs a reference count in emitted code

  public Expression_8 Initializer() { return initializer_; }

  public void NeedsRef() { needs_ref_ = true; }

  public virtual string Emit() { return name_; }

  // Return_8 true if we represent this local using a smart pointer wrapper (i.e.
  // _Ptr, _Own, _OwnRef or _Ref).
  public virtual bool IsWrapper() {
    return type_ is Owning_8 || type_ == GString_8.type_ || needs_ref_;
  }

  public Local_8(TypeExpr_8 ^type_expr, string name, Expression_8 ^initializer) : base(type_expr, name) {
    initializer_ = initializer;
    next_ = null;
  }

  public bool Check(Context_8 ctx) {
    Local_8 decl = ctx.FindVar(name_);
    if (decl != null) {
      Error("error: variable already defined");
      return false;
    }

    if (initializer_ != null) {
      ctx.EnterExpression();
      initializer_type_ = initializer_.Check(ctx);
      bool ok = initializer_type_ != null &&
                Assign_8.CheckAssign(this, type_, initializer_, initializer_type_);

      // Add this Local_8 to the control graph.  We need to do this before calling
      // FinishExpression since the Local_8 will be initialized before temporaries 
      // are destroyed.
      AddControl(ctx);

      ctx.FinishExpression();
      if (!ok)
        return false;
    }

    next_ = ctx.var_;
    ctx.SetVar(this);

    ctx.method_.AddVar(this);
    return true;
  }

  public override bool Sets(Local_8 local) {
    return this == local && initializer_ != null;
  }

  public virtual GType_8 ReadType() {
    return type_;
  }

  public void AddUse(Name_8 name) {
    uses_.Add(name);
  }

  public void SetMutable() { mutable_ = true; }

  // Traverse the control graph nodes where this local is live, calling the given
  // LocalHandler_8's Handle method on each node.
  public bool Traverse(Method_8 method, LocalHandler_8 h) {
    LocalTraverser_8 ^t = new LocalTraverser_8(this, h);
    int marker = Control_8.GetMarkerValue();
    foreach (Name_8 name in uses_) {
      t.SetUse(name);
      if (!name.prev_.Traverse(t, marker))
        return false;
    }

    Parameter_8 p = this as Parameter_8;
    if (p != null && p.GetMode() == Mode_8.Out) {
      t.SetUse(null);
      if (!method.exit_.Traverse(t, marker))
        return false;
    }
    return true;
  }

  // check variable usage once control flow graph is complete
  public bool CheckUsage(Method_8 method) {
    return Traverse(method, new LocalChecker_8());
  }

  // Determine whether this Local_8 needs a reference count.  This_8 can happen only after
  // we've built up a control graph for all methods.
  public void ComputeRef(Method_8 method) {
    // For_8 now, a variable of type object always needs a reference count since it may
    // contain a string and we don't yet detect string destruction in the graph traversal.
    if (type_ == GObject_8.type_)
      NeedsRef();
    else if (type_.IsOwned())
      Traverse(method, new LocalRefAnalyzer_8());
  }

  public void EvalInit(Env_8 env) {
    env.Add(this, initializer_ != null ? initializer_.Eval(env, type_) : null);
  }

  protected virtual string EmitDeclarationType() {
    return IsWrapper() ? type_.EmitType() : type_.EmitExprType();
  }

  public virtual string EmitDeclarationName() { return name_; }

  public void EmitDeclaration(SourceWriter_8 w) {
    w.Write("{0} {1}", EmitDeclarationType(), EmitDeclarationName());
  }

  public void EmitInitializer(SourceWriter_8 w) {
    if (initializer_ != null)
      initializer_.EmitAsInitializer(w, initializer_type_, type_);
  }
}

class Parameter_8 : Local_8 {
  public Parameter_8(TypeExpr_8 ^type_expr, string name) : base(type_expr, name, null) { }

  // We represent some parameters using both a C++ parameter and a C++ local, which
  // have different types; we call these dual parameters.  For_8 such parameters
  // param_name_ is the C++ parameter name.
  string param_name_;

  public static Parameter_8 ^New_8(int mode, TypeExpr_8 ^type_expr, string name) {
    return mode == 0 ? new Parameter_8(type_expr, name) :
                               new RefOutParameter_8(mode, type_expr, name);
  }

  public virtual int GetMode() { return 0; }
  public string TypeString() { return Mode_8.ToString(GetMode()) + type_.ToString(); }

  public virtual Parameter_8 ^Copy() {
    return new Parameter_8(new TypeLiteral_8(type_), name_);
  }

  public virtual bool CanReceive(Argument_8 a) {
    return a.GetMode() == 0 && a.Type().CanConvert(type_, ConversionContext_8.MethodArg);
  }

  public bool Match(Parameter_8 p) {
    return GetMode() == p.GetMode() && type_.Equals(p.type_);
  }

  public override bool IsWrapper() {
    return type_ is Owning_8 || type_ == GString_8.type_ || mutable_ && needs_ref_;
  }

  public void CheckParameterUsage(Method_8 method) {
    if (type_ is Owning_8 && !(this is RefOutParameter_8)) {
      // We need both a C++ parameter and a C++ local: the parameter type can't be
      // _Own<>, since _Own has no public copy constructor and GCC doesn't allow passing
      // by value when a class's copy constructor is private.
      string n = name_;
      do {
        n = "_" + n;
      } while (method.HasLocal(n));
      param_name_ = n;
    }
  }

  protected override string EmitDeclarationType() {
    // For_8 owning parameters the declaration type is the expression type since we can't
    // pass _Own<> by value.
    return type_ is Owning_8 ? type_.EmitExprType() : base.EmitDeclarationType();
  }

  public override string EmitDeclarationName() {
    return param_name_ != null ? param_name_ : name_;
  }

  public void EmitExtraDeclaration(SourceWriter_8 w) {
    if (param_name_ != null)
      w.IWriteLine("{0} {1}({2});", type_.EmitType(), name_, param_name_);
  }
}

class RefOutParameter_8 : Parameter_8 {
  public readonly int mode_;
  public override int GetMode() { return mode_; }

  public RefOutParameter_8(int mode, TypeExpr_8 ^type_expr, string name) : base(type_expr, name) {
    mode_ = mode;
    mutable_ = true;
  }

  public override Parameter_8 ^Copy() { Debug.Assert(false); return null; }

  public override bool CanReceive(Argument_8 a) {
    if (mode_ != a.GetMode())
      return false;
    RefOutArgument_8 ra = (RefOutArgument_8) a;
    return type_.Equals(ra.StorageType());
  }

  public override GType_8 ReadType() {
    // If_8 a ref parameter has an owning type, we require the user to use the take operator to take
    // ownership of the value, since taking ownership has the visible side effect of clearing the
    // value the ref parameter points to.
    return mode_ == Mode_8.Ref ? type_.BaseType() : type_;
  }

  public override string Emit() {
    return "(*" + name_ + ")";
  }

  protected override string EmitDeclarationType() {
    return type_.EmitType() + " *";
  }
}

abstract class InlineStatement_8 : Statement_8 {
  public abstract void EmitInline(SourceWriter_8 w);

  public override void Emit(SourceWriter_8 w) {
    EmitInline(w);
    w.WriteLine(";");
  }
}

class VariableDeclaration_8 : InlineStatement_8 {
  ArrayList /* of Local_8 */ ^locals_ = new ArrayList();

  public VariableDeclaration_8(TypeExpr_8 ^type_expr, string name, Expression_8 ^initializer) {
    locals_.Add(new Local_8(type_expr, name, initializer));
  }

  public void Add(string name, Expression_8 ^initializer) {
    TypeExpr_8 ^t = ((Local_8) locals_[0]).type_expr_.Copy();
    locals_.Add(new Local_8(t, name, initializer));
  }

  public override bool Check(Context_8 ctx) {
    // local variables are not resolved during the Resolve phase, so we must resolve them here
    foreach (Local_8 l in locals_)
      if (!l.Resolve(ctx.program_) || !l.Check(ctx))
        return false;

    return true;
  }

  // Return_8 the type of all variables in this VariableDeclaration_8.
  public GType_8 Type() { return ((Local_8) locals_[0]).Type(); }

  public override RValue_8 ^Eval(Env_8 env) {
    foreach (Local_8 l in locals_)
      l.EvalInit(env);
    return null;
  }

  void Emit(SourceWriter_8 w, bool in_line) {
    if (in_line)
      Debug.Assert(locals_.Count == 1);

    foreach (Local_8 l in locals_) {
      l.EmitDeclaration(w);
      l.EmitInitializer(w);
      if (!in_line)
        w.WriteLine(";");
    }
  }

  public override void EmitInline(SourceWriter_8 w) { Emit(w, true); }
  public override void Emit(SourceWriter_8 w) { Emit(w, false); }
}

class ExpressionStatement_8 : InlineStatement_8 {
  Expression_8 ^exp_;

  public ExpressionStatement_8(Expression_8 ^e) {
    exp_ = e;
  }

  public override bool Check(Context_8 ctx) {
    if (exp_.CheckTop(ctx) == null)
      return false;
    exp_.SetUnused();
    return true;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    exp_.Eval(env);   // discard expression value
    return null;
  }

  public override void EmitInline(SourceWriter_8 w) {
    w.Write(exp_.Emit());
  }

}

class If_8 : Statement_8 {
  Expression_8 ^condition_;
  Statement_8 ^if_true_;
  Statement_8 ^if_false_;
  Joiner_8 ^join_ = new Joiner_8();

  public If_8(Expression_8 ^condition, Statement_8 ^if_true, Statement_8 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override bool Check(Context_8 ctx) {
    if (!condition_.Check(ctx, GBool_8.type_))
      return false;

    Control_8 c = ctx.Prev();

    if (!if_true_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    if (if_false_ != null && !if_false_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());
    return true;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    if (condition_.EvalBool(env))
      return if_true_.Eval(env);
    else
      return if_false_ != null ? if_false_.Eval(env) : null;
  }

  public override void Emit(SourceWriter_8 w) {
    w.Write("if ({0})", condition_.Emit());
    if_true_.EmitEmbedded(w);
    if (if_false_ != null) {
      w.IWrite("else");
      if_false_.EmitEmbedded(w);
    }
  }

}

class DefaultValue_8 : SimpleValue_8 {
  public DefaultValue_8() { }
  public static readonly DefaultValue_8 ^instance_ = new DefaultValue_8();

  public override SimpleValue_8 ^Copy() { Debug.Assert(false); return null; }
  public override GType_8 Type()  { Debug.Assert(false); return null; }
  public override string Emit() { Debug.Assert(false); return null; }
}

// A section in a switch statement.
//
// In GEL2, unlike C# and C++, local variables declared in a switch section are visible only
// in that section.  There doesn't seem to be much point in allowing sections to share locals
// since GEL2 (like C#) doesn't allow control to fall through from one section to the next.  This_8 also
// makes compiling to C++ slightly easier since C++ doesn't allow local variables in switch sections
// other than the last to have initializers (see e.g. C++ Primer, 4th ed., 6.6.5 "Variable Definitions
// inside a switch").

class SwitchSection_8 : Node_8 {
  ArrayList /* of Expression_8 */ ^cases_;     // null represents default:
  public readonly Block_8 ^block_;

  ArrayList /* of GValue_8 */ ^values_ = new ArrayList();

  public SwitchSection_8(ArrayList ^cases, StatementList_8 ^statements) {
    cases_ = cases;
    block_ = new Block_8(statements);
  }

  public bool Check(Context_8 ctx, GType_8 switch_type, OwningHashtable all_values, out bool is_default) {
    is_default = false;
    foreach (Expression_8 e in cases_) {
      GValue_8 ^v;
      if (e == null) {
        is_default = true;
        v = new DefaultValue_8();
      } else {
        if (!e.Check(ctx, switch_type) || !e.CheckConstant())
          return false;
        v = (GValue_8) e.Eval(Env_8.static_, switch_type);
      }
      if (all_values.ContainsKey(v)) {
        Error("switch statement cannot contain the same value twice");
        return false;
      }
      all_values.Set(v, null);
      values_.Add(v);
    }
    return block_.Check(ctx);
  }

  public bool Match(GValue_8 v) {
    foreach (GValue_8 val in values_)
      if (val.Equals(v))
        return true;
    return false;
  }

  public void Emit(SourceWriter_8 w) {
    foreach (Expression_8 c in cases_)
      if (c == null)
        w.IWriteLine("default:");
      else w.IWriteLine("case {0}:", c.Emit());
    w.Indent();
    block_.Emit(w);
  }

  public void EmitString(SourceWriter_8 w) {
    w.IWrite("if (");
    for (int i = 0 ; i < values_.Count ; ++i) {
      if (i > 0) {
        w.WriteLine(" ||");
        w.IWrite("    ");
      }
      w.Write("_s->_Equals({0})", 
              GString_8.EmitStringConst(((GString_8) values_[i]).s_));
    }
    w.Write(") ");
    block_.Emit(w);
  }
}

abstract class Escapable_8 : Scoped_8 {
  public readonly Joiner_8 ^exit_ = new Joiner_8();
}

class Switch_8 : Escapable_8 {
  Expression_8 ^expr_;
  GType_8 type_;
  ArrayList /* of SwitchSection_8 */ ^sections_;
  SwitchSection_8 default_;    // or null if no default section

  public Switch_8(Expression_8 ^expr, ArrayList ^sections) { expr_ = expr; sections_ = sections; }

  public override bool Check(Context_8 ctx) {
    SetStartVar(ctx);
    type_ = expr_.CheckTop(ctx);
    if (type_ == null)
      return false;
    if (type_ != GInt_8.type_ && type_ != GChar_8.type_ && type_ != GString_8.type_) {
      Error("switch expression must be of type int, char or string");
      return false;
    }
    Context_8 ^ctx1 = new Context_8(ctx, this);
    OwningHashtable ^values = new OwningHashtable();
    Control_8 c = ctx1.Prev();
    foreach (SwitchSection_8 s in sections_) {
      bool is_default;
      ctx1.SetPrev(c);
      if (!s.Check(ctx1, type_, values, out is_default))
        return false;
      if (is_default)
        default_ = s;
      if (ctx1.Prev() != unreachable_) {
        s.Error("switch case may not fall through to following case");
        return false;
      }
    }
    if (default_ == null)
      exit_.Join(c);
    ctx1.SetPrev(exit_.Combine());
    return true;
  }

  SwitchSection_8 FindSection(GValue_8 v) {
    foreach (SwitchSection_8 s in sections_)
      if (s.Match(v))
        return s;
    return default_;
  }

  RValue_8 ^CatchBreak(RValue_8 ^v) {
    return v is BreakValue_8 ? null : v;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    RValue_8 ^v = expr_.Eval(env);
    if (v == null)
      return null;
    SwitchSection_8 s = FindSection(v.Get());
    if (s == null)
      return null;
    return CatchBreak(s.block_.Eval(env));
  }

  public override void Emit(SourceWriter_8 w) {
    if (type_ == GString_8.type_) {
      // For_8 now, we implement a switch on strings using a sequence of if statements.  We wrap
      // the sequence in a dummy switch statement so that break statements will work properly.
      // If_8 the switch statement has just a default: label then the Microsoft C++ compiler issues
      // a warning, and if it has just a case 0: label then the compiler doesn't realize that the
      // case will always be executed, which may lead to warnings about not all code paths returning
      // a value.  So we use both default: and case 0:, which seems to work fine.
      w.Write("switch (0) ");
      w.OpenBrace();
      w.IWriteLine("case 0:");
      w.IWriteLine("default:");
      w.IWriteLine("StringPtr _s = {0};", expr_.Emit());
      foreach (SwitchSection_8 s in sections_)
        if (s != default_)
          s.EmitString(w);
      if (default_ != null)
        default_.block_.Emit(w);
      w.CloseBrace();
    } else {
      w.Write("switch ({0}) ", expr_.Emit());
      w.OpenBrace();

      foreach (SwitchSection_8 s in sections_)
        s.Emit(w);

      w.CloseBrace();
    }
  }
}

abstract class Loop_8 : Escapable_8 {
  public readonly Joiner_8 ^loop_ = new Joiner_8();
}

abstract class ForOrWhile_8 : Loop_8 {
  protected Expression_8 ^condition_;
  protected Statement_8 ^statement_;

  protected ForOrWhile_8(Expression_8 ^condition, Statement_8 ^statement) {
    condition_ = condition; statement_ = statement;
  }

  protected abstract InlineStatement_8 Initializer();
  protected abstract InlineStatement_8 Iterator();

  public override bool Check(Context_8 prev_ctx) {
    Context_8 ^ctx = new Context_8(prev_ctx, this);   // initializer may declare new local variable
    SetStartVar(ctx);
    if (!Initializer().Check(ctx))
      return false;
    SetTopVar(ctx);

    loop_.AddControl(ctx);

    if (!condition_.CheckTop(ctx, GBool_8.type_))
      return false;

    if (!condition_.IsTrueLiteral())  // we may exit the loop at this point
      exit_.Join(ctx.Prev());  

    if (!statement_.Check(ctx))
      return false;

    if (!Iterator().Check(ctx))
      return false;

    loop_.Join(ctx.Prev());  // loop back to top

    ctx.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy any local defined in an initializer above.
    AddControl(ctx);

    return true;
  }

  public override RValue_8 ^Eval(Env_8 outer_env) {
    Env_8 ^env = new Env_8(outer_env);   // initializer may declare new local
    for (Initializer().Eval(env); condition_.EvalBool(env); Iterator().Eval(env)) {
      RValue_8 ^v = statement_.Eval(env);
      if (v is BreakValue_8)
        break;
      if (v is ContinueValue_8)
        continue;
      if (v != null)
        return v;
    }
    return null;
  }
}

class While_8 : ForOrWhile_8 {
  public While_8(Expression_8 ^condition, Statement_8 ^statement) : base(condition, statement) { }

  protected override InlineStatement_8 Initializer()  { return EmptyStatement_8.instance_; }
  protected override InlineStatement_8 Iterator()  { return EmptyStatement_8.instance_; }

  public override void Emit(SourceWriter_8 w) {
    w.Write("while ({0})", condition_.Emit());
    statement_.EmitEmbedded(w);
  }
}

class For_8 : ForOrWhile_8 {
  InlineStatement_8 ^initializer_;
  InlineStatement_8 ^iterator_;

  public For_8(InlineStatement_8 ^initializer, Expression_8 ^condition, InlineStatement_8 ^iterator,
             Statement_8 ^statement)
    : base(condition != null ? condition : new Literal_8(new GBool_8(true)),
           statement) {
    initializer_ = initializer != null ? initializer : new EmptyStatement_8();
    iterator_ = iterator != null ? iterator : new EmptyStatement_8();
  }

  protected override InlineStatement_8 Initializer()  { return initializer_; }
  protected override InlineStatement_8 Iterator()  { return iterator_; }

  public override void Emit(SourceWriter_8 w) {
    w.Write("for (");
    initializer_.EmitInline(w);
    w.Write("; {0}; ", condition_.Emit());
    iterator_.EmitInline(w);
    w.Write(")");
    statement_.EmitEmbedded(w);
  }
}

class Do_8 : Loop_8 {
  Statement_8 ^statement_;
  Expression_8 ^condition_;

  Joiner_8 ^join_ = new Joiner_8();

  public Do_8(Statement_8 ^statement, Expression_8 ^condition) {
    statement_ = statement;
    condition_ = condition;
  }

  public override bool Check(Context_8 ctx) {
    join_.AddControl(ctx);

    Context_8 ^ctx1 = new Context_8(ctx, this);
    SetStartVar(ctx);

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx.Prev());  // continue statements jump here
    ctx.SetPrev(loop_.Combine());

    if (!condition_.CheckTop(ctx, GBool_8.type_))
      return false;

    if (!condition_.IsFalseLiteral())
      join_.Join(ctx.Prev());   // loop back to top
    if (!condition_.IsTrueLiteral())
      exit_.Join(ctx.Prev());   // fall through to exit
    ctx.SetPrev(exit_.Combine());

    return true;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    do {
      RValue_8 ^v = statement_.Eval(env);
      if (v is BreakValue_8)
        break;
      if (v is ContinueValue_8)
        continue;
      if (v != null)
        return v;
    } while (condition_.EvalBool(env));
    return null;
  }

  public override void Emit(SourceWriter_8 w) {
    w.IWrite("do");
    statement_.EmitEmbedded(w);
    w.IWriteLine("while ({0});", condition_.Emit());
  }
}

// A helper class for ForEach_8: a node defining a single variable in the control graph.
class Definer_8 : Node_8 {
  Local_8 local_;

  public Definer_8(Local_8 local) { local_ = local; }

  public override bool Sets(Local_8 local) {
    return local_ == local;
  }
}

class ForEach_8 : Loop_8 {
  Local_8 ^local_;
  Expression_8 ^expr_;
  GType_8 expr_type_;
  Statement_8 ^statement_;

  Property_8 count_;
  Indexer_8 indexer_;

  Definer_8 ^definer_;

  public ForEach_8(TypeExpr_8 ^type_expr, string name, Expression_8 ^expr, Statement_8 ^statement) {
    local_ = new Local_8(type_expr, name, null);
    expr_ = expr;
    statement_ = statement;
  }

  public override bool Check(Context_8 ctx) {
    if (!local_.Resolve(ctx.program_))
      return false;

    expr_type_ = expr_.CheckTop(ctx);
    if (expr_type_ == null)
      return false;

    count_ = expr_type_.Lookup(this, ctx.class_, false, MemberKind_8.Property_8, "Count", null, false) as Property_8;
    if (count_ == null) {
      Error("object enumerable by foreach must have an accessible property Count");
      return false;
    }
    if (count_.Type() != GInt_8.type_) {
      Error("object enumerable by foreach must have a property Count of type int");
      return false;
    }

    ArrayList ^args = new ArrayList();
    args.Add(new InArgument_8(GInt_8.type_));
    indexer_ = (Indexer_8) expr_type_.Lookup(this, ctx.class_, false, MemberKind_8.Indexer_8, null, args, false);
    if (indexer_ == null) {
      Error("object enumerable by foreach must have an accessible indexer on integers");
      return false;
    }
    if (!indexer_.CheckAssigning(this, ctx, false))
      return false;

    GType_8 indexer_type = indexer_.Type();
    GType_8 iterator_type = local_.Type();
    if (!indexer_type.CanConvertExplicit(iterator_type, false)) {
      Error("enumeration type {0} is not explicitly convertible to iteration variable type {1}",
        indexer_type, iterator_type);
      return false;
    }

    Context_8 ^ctx1 = new Context_8(ctx, this);

    SetStartVar(ctx1);
    if (!local_.Check(ctx1))   // will add local to scope chain
      return false;
    SetTopVar(ctx1);

    // Add a control graph node representing the creation of the local above.
    definer_ = new Definer_8(local_);
    definer_.AddControl(ctx1);

    loop_.AddControl(ctx1);   // continue statements jump here

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx1.Prev());   // loop back to top

    exit_.Join(loop_);  // any loop iteration may exit

    ctx1.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy the local variable created above.
    AddControl(ctx1);

    return true;
  }

  public override RValue_8 ^Eval(Env_8 outer_env) {
    RValue_8 ^r = expr_.Eval(outer_env);
    GValue_8 e = r.Get();
    if (e is Null_8) {
      Error("foreach: can't iterate over null object");
      Gel_8.Exit();
    }

    int count = ((GInt_8) count_.Get(e)).i_;

    Env_8 ^env = new Env_8(outer_env);
    env.Add(local_, null);
    for (int i = 0 ; i < count ; ++i) {
      RValue_8 ^v = indexer_.Get(e, new GInt_8(i));
      env.Set(local_, v.Get().ConvertExplicit(ref v, local_.Type()));
      RValue_8 ^s = statement_.Eval(env);
      if (s is BreakValue_8)
        break;
      if (s is ContinueValue_8)
        continue;
      if (s != null)
        return s;
    }
    return null;
  }

  public override void Emit(SourceWriter_8 w) {
    w.OpenBrace();
    w.IWriteLine("{0} _collection = {1};", expr_type_.BaseType().EmitType(), expr_.Emit());
    w.IWriteLine("int _count = _collection->get_Count();");
    w.IWrite("for (int _i = 0 ; _i < _count ; ++_i) ");
    w.OpenBrace();
    w.Indent();
    local_.EmitDeclaration(w);
    w.WriteLine(" = {0}; ",
      Expression_8.EmitExplicit(indexer_.Type(), local_.Type(), "_collection->get_Item(_i)", true));
    statement_.EmitInExistingBlock(w);
    w.CloseBrace();
    w.CloseBrace();
  }
}

class BreakValue_8 : GValue_8 {
  public BreakValue_8() { }

  public static readonly BreakValue_8 ^instance_ = new BreakValue_8();

  public override GType_8 Type()  { Debug.Assert(false); return null; }
}

abstract class BreakOrContinue_8 : Scoped_8 {
  protected void Link(Context_8 ctx, Scoped_8 target, Joiner_8 joiner) {
    // When traversed in the control graph, we destroy all variables in the scopes we are exiting,
    // excluding variables defined in the containing Escapable_8 or Loop_8.
    start_ = target.GetTop();
    SetTopVar(ctx);

    prev_ = ctx.Prev();
    if (prev_ != unreachable_)
      joiner.Join(this);

    ctx.SetPrev(unreachable_);
  }
}

class Break_8 : BreakOrContinue_8 {
  public override bool Check(Context_8 ctx) {
    Escapable_8 e = ctx.escape_;
    if (e == null) {
      Error("break statement must appear inside a while, do, for, foreach or switch statement");
      return false;
    }
    Link(ctx, e, e.exit_);
    return true;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    return new BreakValue_8();
  }

  public override void Emit(SourceWriter_8 w) {
    w.WriteLine("break;");
  }
}

class ContinueValue_8 : GValue_8 {
  public ContinueValue_8() { }

  public static readonly ContinueValue_8 ^instance_ = new ContinueValue_8();

  public override GType_8 Type()  { Debug.Assert(false); return null; }
}

class Continue_8 : BreakOrContinue_8 {
  public override bool Check(Context_8 ctx) {
    Loop_8 l = ctx.loop_;
    if (l == null) {
      Error("continue statement must appear inside a while, do, for or foreach statement");
      return false;
    }
    Link(ctx, l, l.loop_);
    return true;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    return new ContinueValue_8();
  }

  public override void Emit(SourceWriter_8 w) {
    w.WriteLine("continue;");
  }
}

class Return_8 : Statement_8 {
  Expression_8 ^exp_;    // null if no return value
  GType_8 exp_type_;
  GType_8 type_;

  public Return_8(Expression_8 ^exp) {
    exp_ = exp;
  }

  public override bool Check(Context_8 ctx) {
    if (exp_ == null) {
      if (ctx.method_.ReturnType() != Void_8.type_) {
        Error("error: returning value from function returning void");
        return false;
      }
    } else {
      type_ = ctx.method_.ReturnType();
      ctx.EnterExpression();
      exp_type_ = exp_.CheckAndHold(ctx);
      if (exp_type_ == null ||
          !exp_type_.CheckConvert(this, type_,
            exp_.IsRefOutParameter() ? ConversionContext_8.AssignVar : ConversionContext_8.Other))
        return false;
      exp_.CheckLoseOwnership(exp_type_, type_);
      ctx.FinishExpression();
      exp_.ReleaseRef(ctx);
    }

    ctx.method_.JoinReturn(ctx);
    ctx.SetPrev(unreachable_);
    return true;
  }

  public override RValue_8 ^Eval(Env_8 env) {
    return exp_ != null ? exp_.Eval(env, type_)
                        : Null_8.Instance.Copy();    // an arbitrary value
  }

  public override void Emit(SourceWriter_8 w) {
    if (exp_ != null && exp_.NeedsRef(exp_type_)) {
      // If_8 exp_ needs a reference count, that reference count needs to survive the destruction
      // of temporaries, so we can't simply emit a temporary reference count wrapper.  For_8 example,
      // when compiling the expression "return (new Foo()).Fun();", if Fun() returns a Foo then we
      // need a wrapper, and we can't generate "return _Ptr<Fun>(Foo().Fun()).Get()" since the _Ptr<Fun>
      // wrapper will be destroyed before the temporary Foo() object is destroyed.  So we need to
      // use an extra variable here.
      w.OpenBrace();
      w.IWriteLine("{0} __ret = {1};", exp_type_.EmitType(), exp_.Emit());
      w.IWriteLine("return __ret.Get();");
      w.CloseBrace();
    } else {
      w.Write("return ");
      if (exp_ != null)
        w.Write(exp_.Emit(exp_type_, type_));
      w.WriteLine(";");
    }
  }
}

class Attribute_8 {
  public const int Abstract = 1,
  Const = 2,
  Extern = 4,
  Override = 8,
  Private = 16,
  Protected = 32,
  Public = 64,
  ReadOnly = 128,
  Ref = 256,
  Static = 512,
  Virtual = 1024,
  Setter = 2048;
}

class AttributeUtil_8 {
  public static bool CheckOnly(int a, int allowed) {
    return (a & ~allowed) == 0;
  }
}

class MethodTraverser_8 : Traverser_8 {
  Method_8 method_;

  public MethodTraverser_8(Method_8 method) { method_ = method; }

  public override int Handle(Control_8 control) {
    if (control == Control_8.unreachable_)
      return Cut;

    Node_8 node = control as Node_8;
    if (node != null) {
      Method_8 c = node.Calls();
      if (c != null)
        method_.calls_.Add(c);
      method_.internal_destroys_.Add(node.NodeDestroys());
    }

    return Continue_8;
  }
}

class Method_8 : Member_8 {
  public readonly ArrayList /* of Parameter_8 */ ^parameters_;

  protected Block_8 ^body_;

  public Joiner_8 ^exit_ = new Joiner_8();

  // all parameters and locals defined in this method
  readonly NonOwningArrayList /* of Local_8 */ ^locals_ = new NonOwningArrayList();

  NonOwningArrayList /* of Method_8 */ ^overrides_;   // list of all overrides (virtual methods only)

  // methods called from this method
  public readonly NonOwningArrayList /* of Method_8 */ ^calls_ = new NonOwningArrayList();

  // Types destroyed inside this method, not including types destroyed through
  // calls to other methods.
  public readonly TypeSet_8 ^internal_destroys_ = new TypeSet_8();

  // Types destroyed inside this method or in any methods called by this method.
  TypeSet_8 ^destroys_;

  TypeSet_8 ^parameter_destroys_;

  // A marker used when performing a depth-first search of the method graph to compute destroys_.
  int method_marker_;

  public Method_8(int attributes, TypeExpr_8 ^return_type_expr,
                string name, ArrayList /* of Parameter_8 */ ^parameters, Block_8 ^body)
    : base(attributes, return_type_expr, name) {
    parameters_ = parameters;
    body_ = body;
  }

  public override int Kind() { return MemberKind_8.Method_8; }

  public GType_8 ReturnType() { return type_; }

  public override ArrayList Parameters() {
    return parameters_;
  }

  public bool IsExtern() { return class_.IsExtern(); }

  public bool IsStatic() {
    return HasAttribute(Attribute_8.Static);
  }

  public override bool Resolve(Program_8 program) {
    if (!base.Resolve(program))
      return false;
    foreach (Parameter_8 p in parameters_)
      if (!p.Resolve(program))
        return false;
    return true;
  }

  public void AddVar(Local_8 v) {
    locals_.Add(v);
  }

  public override bool Sets(Local_8 local) {
    foreach (Parameter_8 p in parameters_)
      if (p == local && p.GetMode() != Mode_8.Out)
        return true;
    return false;
  }

  public void JoinReturn(Context_8 ctx) {
    exit_.Join(ctx.Prev());
  }

  public const int kValidAttributes =
    Attribute_8.Abstract | Attribute_8.Override |
    Attribute_8.Private | Attribute_8.Protected | Attribute_8.Public |
    Attribute_8.Static | Attribute_8.Virtual | Attribute_8.Setter;

  protected override int ValidAttributes() {
    return kValidAttributes;
  }

  // overridden by Constructor_8 subclass
  protected virtual bool CheckEntry(Context_8 ctx) { return true; }

  // overridden by Constructor_8 subclass
  public override bool Check(Context_8 prev_ctx) {
    if (!base.Check(prev_ctx))
      return false;

    bool abstract_or_extern = HasAttribute(Attribute_8.Abstract) || IsExtern();

    if (body_.Absent()) {
      if (!abstract_or_extern) {
        Error("a method without a body must be abstract or extern");
        return false;
      }
      return true;
    } 

    if (abstract_or_extern) {
      Error("an abstract or extern method cannot have a body");
      return false;
    }

    Context_8 ^ctx = new Context_8(prev_ctx, this);

    prev_ = unreachable_;
    ctx.SetPrev(this);    // begin the control graph with this Method_8

    foreach (Parameter_8 p in parameters_)
      if (!p.Check(ctx))
        return false;

    if (!CheckEntry(ctx))
      return false;

    if (!body_.Check(ctx))
      return false;

    if (!(this is Constructor_8) && type_ != Void_8.type_ && ctx.Prev() != unreachable_) {
      Error("method must return a value");
      return false;
    }
    JoinReturn(ctx);

    ctx.ClearPrev();  // control graph is complete

    // Traverse the control graph to build calls_ and internal_destroys_.
    MethodTraverser_8 ^mt = new MethodTraverser_8(this);
    exit_.Traverse(mt, Control_8.GetMarkerValue());

    bool ok = true;
    foreach (Local_8 v in locals_)    // for all locals and parameters
      ok &= v.CheckUsage(this);

    foreach (Parameter_8 p in parameters_)
      p.CheckParameterUsage(this);

    return ok;
  }

  // Determine whether each local variable needs a reference count.
  protected void ComputeRefs() {
    foreach (Local_8 v in locals_)
      v.ComputeRef(this);
  }

  // Return_8 true if this method has a local or parameter with the given name.
  public bool HasLocal(string name) {
    foreach (Local_8 l in locals_)
      if (l.name_ == name)
        return true;
    return false;
  }

  public override TypeSet_8 NodeDestroys() {
    if (parameter_destroys_ == null) {
      parameter_destroys_ = new TypeSet_8();
    foreach (Parameter_8 p in parameters_)
        parameter_destroys_.Add(p.Type().VarDestroys());
    }
    return parameter_destroys_;
  }

  protected override void AddOverride(Member_8 m) {
    if (overrides_ == null)
      overrides_ = new NonOwningArrayList();
    overrides_.Add((Method_8) m);
  }

  bool Visit(int marker, TypeSet_8 set) {
    if (method_marker_ == marker)
      return true;

    method_marker_ = marker;
    set.Add(internal_destroys_);
    if (set.IsObject())
      return false;   // we already have object; no point in traversing further

    foreach (Method_8 m in calls_)
      if (!m.Visit(marker, set))
        return false;

    if (overrides_ != null)
      foreach (Method_8 m in overrides_)
        if (!m.Visit(marker, set))
          return false;

    return true;
  }

  public TypeSet_8 Destroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_8();
      Visit(Control_8.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  // overridden by Constructor_8 subclass
  public virtual RValue_8 ^Eval(Env_8 env) {
    return body_.Eval(env);
  }

  public RValue_8 ^Invoke(GValue_8 obj, ArrayList /* of ValueOrLocation_8 */ values) {
    if (body_.Absent()) { // an external method
      ValueList_8 ^list = new ValueList_8(values);
      if (IsStatic())
        return class_.InvokeStatic(this, list);   // let the class handle it
      return obj.Invoke(this, list);   // let the object handle it
    }

    Env_8 ^env = new Env_8(obj);
    Debug.Assert(values.Count == parameters_.Count);
    for (int i = 0 ; i < values.Count ; ++i)
      env.Add((Parameter_8) parameters_[i], (ValueOrLocation_8) values.Take(i));

    return Eval(env);
  }

  protected void EmitParameterNames(SourceWriter_8 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      w.Write(Param(i).EmitDeclarationName());
    }
    w.Write(")");
  }

  protected void EmitParameters(SourceWriter_8 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      Param(i).EmitDeclaration(w);
    }
    w.Write(") ");
  }

  void EmitAttributes(SourceWriter_8 w, bool declaration) {
    w.Indent();
    if (!IsStatic() && !IsVirtual())
      return;

    if (!declaration)
      w.Write("/* ");
    if (IsStatic())
      w.Write("static ");
    if (IsVirtual())
      w.Write("virtual ");
    if (!declaration)
      w.Write("*/ ");
  }

  void EmitSignature(SourceWriter_8 w, bool declaration) {
    EmitAttributes(w, declaration);
    w.Write("{0} ", type_.EmitReturnType());
    if (!declaration)
      w.Write("{0}::", class_.name_);
    if (HasAttribute(Attribute_8.Setter))
      w.Write("_");
    w.Write(name_);
    EmitParameters(w);
  }

  public virtual void EmitDeclaration(SourceWriter_8 w) {
    ComputeRefs();
    EmitSignature(w, true);
    if (body_.Absent())
      w.Write("= 0");
    w.WriteLine(";");

    if (HasAttribute(Attribute_8.Setter)) {
      w.WriteLine("");
      EmitAttributes(w, true);
      w.Write("{0} ", Param(parameters_.Count - 1).Type().EmitType());
      w.Write(name_);
      EmitParameters(w);
      w.OpenBrace();
      w.IWrite("_{0}", name_);
      EmitParameterNames(w);
      w.WriteLine(";");
      w.IWriteLine("return value;");
      w.CloseBrace();
    }
  }

  protected void EmitExtraDeclarations(SourceWriter_8 w) {
    foreach (Parameter_8 p in parameters_)
      p.EmitExtraDeclaration(w);
  }

  public virtual void Emit(SourceWriter_8 w) {
    if (!body_.Absent()) {
      EmitSignature(w, false);
      w.OpenBrace();
      EmitExtraDeclarations(w);
      body_.list_.Emit(w);
      w.CloseBrace();
      w.WriteLine("");
    }
    if (Gel_8.print_type_sets_)
      Console.WriteLine("{0}.{1}: {2}", class_.name_, name_, Destroys());
  }
}

class Constructor_8 : Method_8 {
  bool call_base_;
  ArrayList /* of Argument_8 */ ^initializer_params_;

  Constructor_8 initializer_;

  bool invoked_;  // true if another constructor invokes this one using : base() or : this()

  public Constructor_8(int attributes, string name, ArrayList ^parameters,
                     bool call_base, ArrayList ^initializer_params, Block_8 ^body)
    : base(attributes, null, name, parameters, body) {
    call_base_ = call_base;
    initializer_params_ = initializer_params;
  }

  public Constructor_8(int attributes, string name, ArrayList ^parameters, Block_8 ^body)
    : this(attributes, name, parameters, true, new ArrayList(), body) { }

  public override int Kind() { return MemberKind_8.Constructor_8; }

  protected override int ValidAttributes() {
    return Attribute_8.Private | Attribute_8.Protected | Attribute_8.Public;
  }

  public override bool Check(Context_8 ctx) {
    if (name_ != class_.name_) {
      Error("constructor name must match class name");
      return false;
    }
    return base.Check(ctx);
  }

  protected override bool CheckEntry(Context_8 ctx) {
    Class_8 c = call_base_ ? class_.Parent() : class_;
    if (c != null || initializer_params_.Count > 0) {
      initializer_ = (Constructor_8) Invocation_8.CheckInvoke(this, ctx, call_base_, c,
                                      c.name_, initializer_params_, MemberKind_8.Constructor_8);
      if (initializer_ == null)
        return false;
      if (initializer_ == this) {
        Error("constructor initializer invokes itself");
        return false;
      }
      initializer_.invoked_ = true;
    }
    return true;
  }

  // A Constructor_8 node in the control graph represents the call to the base constructor;
  // this node gets added when we call Invocation_8.CheckInvoke() above.
  public override Method_8 Calls() { return initializer_; }

  public override RValue_8 ^Eval(Env_8 env) {
    if (initializer_ == null || initializer_.class_ != class_) {
      // run instance variable initializers
      foreach (Field_8 f in class_.fields_)
        if (!f.IsConstOrStatic() && f.Initializer() != null)
          ((GObject_8) env.this_).Set(f, f.Initializer().Eval(Env_8.static_, f.Type()));
    }
    if (initializer_ != null)
      Invocation_8.CallMethod(env, env.this_, initializer_, initializer_params_, false);
    return body_.Eval(env);
  }

  void EmitInitializerArgs(SourceWriter_8 w) {
    w.WriteLine("({0});", Invocation_8.EmitArguments(initializer_, initializer_params_));
  }

  void EmitConstructorBody(SourceWriter_8 w) {
    w.OpenBrace();
    EmitExtraDeclarations(w);
    if (call_base_) {
      if (class_.constructors_.Count > 1)
        w.IWriteLine("_Init();");
      else class_.EmitInitializers(w);

      Class_8 parent = class_.Parent();
      if (parent != GObject_8.type_) {
        w.IWrite("{0}::_Construct", parent.name_);
        EmitInitializerArgs(w);
      }
    } else {
      w.IWrite("_Construct");
      EmitInitializerArgs(w);
    }

    body_.list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitDeclaration(SourceWriter_8 w) {
    ComputeRefs();

    // If_8 we're invoked by some other constructor then we need to declare a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void _Construct");
      EmitParameters(w);
      w.WriteLine(";");
    }

    // Now declare the actual C++ constructor.
    w.IWrite(name_);
    EmitParameters(w);
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_8 w) {
    // If_8 we're invoked by some other constructor then we need to emit a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void {0}::_Construct", name_);
      EmitParameters(w);
      EmitConstructorBody(w);
      w.WriteLine("");
    }

    // Now emit the actual C++ constructor.
    w.IWrite("{0}::{1}", name_, name_);
    EmitParameters(w);
    Class_8 parent = class_.Parent();
    if (parent != GObject_8.type_)
      w.Write(": {0}((Dummy *) 0) ", parent.name_);

    if (invoked_) {   // call the _Construct method we just generated
      w.Write("{ _Construct");
      EmitParameterNames(w);
      w.WriteLine("; }");
    } else EmitConstructorBody(w);
    w.WriteLine("");
  }
}

abstract class PropertyOrIndexer_8 : LMember_8 {
  // If_8 a get accessor is not declared at all, then get_block_ will be null; if it is
  // declared, but has an empty body ("get;") then get_block_ will be a Block_8 whose list_ is
  // null.  We need to distinguish these cases since for abstract or extern properties the
  // presence of a get accessor with an empty body indicates that a property is readable.
  // (set_block_ works similarly.)
  Block_8 ^get_block_, set_block_;

  protected Method_8 getter_, setter_;

  protected PropertyOrIndexer_8(int attributes, TypeExpr_8 ^type_expr, string name,
                              string id1, Block_8 ^block1, string id2, Block_8 ^block2)
    : base(attributes, type_expr, name) {
    StoreAccessor(id1, block1);
    if (id2 != null)
      StoreAccessor(id2, block2);
    if (id1 == id2)
      Error("can't have two {0} accessors", id1);
  }

  void StoreAccessor(string id, Block_8 ^block) {
    // Note that we don't have scanner tokens GET and SET since these are not keywords in GEL2.
    switch (id) {
      case "get": get_block_ = block; return;
      case "set": set_block_ = block; return;
    }
    Error("expected get or set");
  }

  public Method_8 Getter() { return getter_; }
  public Method_8 Setter() { return setter_; }

  protected abstract string BaseName();

  ArrayList ^CopyParameters() {
    ArrayList ^a = new ArrayList();
    foreach (Parameter_8 p in Parameters())
      a.Add(p.Copy());
    return a;
  }

  public override bool Check(Context_8 ctx) {
    if (!base.Check(ctx))
      return false;

    if (get_block_ != null) {
      Method_8 ^m = new Method_8(attributes_, new TypeLiteral_8(type_), "get_" + BaseName(), CopyParameters(), take get_block_);
      getter_ = m;
      class_.Add(m);
      if (!getter_.Resolve(ctx.program_) || !getter_.Check(ctx))
        return false;
    }

    if (set_block_ != null) {
      ArrayList ^set_params = CopyParameters();
      set_params.Add(new Parameter_8(new TypeLiteral_8(type_), "value"));
      Method_8 ^m = new Method_8(attributes_ | Attribute_8.Setter,
                           new TypeLiteral_8(Void_8.type_), "set_" + BaseName(), set_params, take set_block_);
      setter_ = m;
      class_.Add(m);
      if (!setter_.Resolve(ctx.program_) || !setter_.Check(ctx))
        return false;
    }

    return true;
  }

  public override bool CheckAssigning(Syntax_8 caller, Context_8 ctx, bool assigning) {
    if (assigning && set_block_ == null && setter_ == null) {
      caller.Error("can't assign to read-only {0}", KindString());
      return false;
    }
    if (!assigning && get_block_ == null && getter_ == null) {
      caller.Error("can't read from write-only {0}", KindString());
      return false;
    }
    return true;
  }

  public override Location_8 GetLocation(GObject_8 obj) { Debug.Assert(false); return null; }
}

class Property_8 : PropertyOrIndexer_8 {
  public Property_8(int attributes, TypeExpr_8 ^type_expr, string name,
                  string id1, Block_8 ^block1, string id2, Block_8 ^block2)
    : base(attributes, type_expr, name, id1, block1, id2, block2) { }

  public override int Kind() { return MemberKind_8.Property_8; }

  protected override int ValidAttributes() {
    return Method_8.kValidAttributes;
  }

  protected override string BaseName() { return name_; }

  public override RValue_8 ^Get(GValue_8 obj) {
    return Invocation_8.InvokeMethod(obj, getter_, new ArrayList(), true);
  }

  public override void Set(GObject_8 obj, RValue_8 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(val);
    Invocation_8.InvokeMethod(obj, setter_, a, true);
  }

  public override string Emit() {
    return String.Format("get_{0}()", name_);
  }

  public override string EmitSet(string val) {
    return String.Format("set_{0}({1})", name_, val);
  }
}

class Indexer_8 : PropertyOrIndexer_8 {
  public readonly Parameter_8 parameter_;

  ArrayList /* of Parameter_8 */ ^parameters_;

  public Indexer_8(int attributes, TypeExpr_8 ^type_expr, Parameter_8 ^parameter,
                 string id1, Block_8 ^block1, string id2, Block_8 ^block2)
    : base(attributes, type_expr, null, id1, block1, id2, block2) {
    parameter_ = parameter;

    parameters_ = new ArrayList();
    parameters_.Add(parameter);
  }

  public override int Kind() { return MemberKind_8.Indexer_8; }

  public override bool Resolve(Program_8 program) {
    return base.Resolve(program) && parameter_.Resolve(program);
  }

  protected override int ValidAttributes() {
    return Attribute_8.Abstract | Attribute_8.Override |
    Attribute_8.Private | Attribute_8.Protected | Attribute_8.Public | Attribute_8.Virtual;
  }

  protected override string BaseName() { return "Item"; }

  public override bool Check(Context_8 ctx) {
    if (parameter_ is RefOutParameter_8) {
      Error("indexer parameter may not be ref or out");
      return false;
    }

    return base.Check(ctx);
  }

  public override ArrayList /* of Parameter_8 */ Parameters() {
    return parameters_; 
  }

  public RValue_8 ^Get(GValue_8 obj, RValue_8 ^index) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    return Invocation_8.InvokeMethod(obj, getter_, a, true);
  }

  public void Set(GObject_8 obj, RValue_8 ^index, RValue_8 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    a.Add(val);
    Invocation_8.InvokeMethod(obj, setter_, a, true);
  }
}

class Class_8 : Ownable_8 {
  Syntax_8 ^syntax_ = new Syntax_8();
  Program_8 program_;   // containing program
  int attributes_;
  public readonly string name_;
  string parent_name_;    // or null if not specified

  Class_8 parent_;

  public readonly NonOwningArrayList /* of Field_8 */ ^fields_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Method_8 */ ^methods_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Property_8 */ ^properties_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Indexer_8 */ ^indexers_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Constructor_8 */ ^constructors_ = new NonOwningArrayList();

  public readonly ArrayList /* of Member_8 */ ^members_ = new ArrayList();

  public readonly ArrayList /* of Temporaries_8 */ ^temporaries_ = new ArrayList();

  public readonly NonOwningArrayList /* of Class_8 */ ^subclasses_ = new NonOwningArrayList();
  bool emitted_;

  // If_8 virtual_ is true, then this class needs a vtable; we set this for a class C
  // in any of the following cases:
  // - the program converts some type T to C ^ (for then a C ^ may hold a T, and when
  // the owning pointer is destroyed we need to know which destructor to call)
  // - the program explicitly converts from C to some other type (so we need RTTI for C)
  bool virtual_;
  
  // If_8 object_inherit_ is true, then this class must derive from Object in generated C++
  // code; we set this for a class C in any of the following cases:
  // - a member lookup in C yields a member in Object
  // - the program converts from C to Object or from Object to C
  // - the class is used in a generic context, i.e. in the type C [] or C ^ [].  All such types
  //   use the generic compiled classes Array<Object> / Array<_Own<Object>>, and so in this case we need
  //   to be able to cast between C and Object.
  //
  // If_8 object_inherit_ is true then this class and all its superclasses will have vtables since
  // the C++ Object class has a vtable.
  bool object_inherit_;

  bool need_destroy_;  // true if we need to emit _Destroy methods for this class

  // The set of types which may be destroyed when an instance of this class is destroyed.
  TypeSet_8 ^destroys_;

  // A marker used in performing a depth-first search to construct the destroys_ type set.
  int marker_;

  protected Class_8(string name) { name_ = name; }

  public static Class_8 New_8(int attributes, string name, string parent_name) {
    Class_8 c = Internal_8.Find(name);
    if (c == null) {
      Class_8 ^c1 = new Class_8(name);
      c = c1;
      Gel_8.program_.AddOwn(c1);
    }

    c.attributes_ = attributes;
    c.parent_name_ = parent_name;

    return c;
  }

  public override bool IsOwned() { return true; }

  public Program_8 GetProgram() { return program_; }
  public void SetProgram(Program_8 p) { program_ = p; }

  public bool IsExtern() { return HasAttribute(Attribute_8.Extern); }

  public override Class_8 Parent() { return parent_; }

  public override string ToString() { return name_; }

  public override ArrayList Members() { return members_; }

  public override SimpleValue_8 DefaultValue_8() { return Null_8.Instance; }

  public override void SetVirtual() { virtual_ = true; }
  public override void SetObjectInherit() { object_inherit_ = true;  }
  public void NeedDestroy() { need_destroy_ = true; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public virtual GValue_8 ^New_8() { return new GObject_8(this); }
  public virtual RValue_8 ^InvokeStatic(Method_8 m, ValueList_8 args) { Debug.Assert(false); return null; }

  public void Add(Field_8 ^f) { f.SetClass(this); fields_.Add(f); members_.Add(f);  }

  public virtual void Add(Method_8 ^m) { m.SetClass(this); methods_.Add(m); members_.Add(m);  }

  public void Add(Property_8 ^p) { p.SetClass(this); properties_.Add(p); members_.Add(p);  }

  public void Add(Indexer_8 ^i) { i.SetClass(this); indexers_.Add(i); members_.Add(i); }

  public void AddConstructor(Constructor_8 ^c) { c.SetClass(this); constructors_.Add(c); members_.Add(c);  }

  public NonOwningArrayList /* of Member_8 */ ^FindAbstractMembers() {
    NonOwningArrayList /* of Member_8 */ ^a;
    if (parent_ != null)  {
      a = parent_.FindAbstractMembers();

      // remove members overridden in this class
      int i = 0;
      while (i < a.Count) {
        Member_8 m = (Member_8) a[i];
        Member_8 n = GetMatchingMember(m);
        if (n != null) {
          Debug.Assert(n.HasAttribute(Attribute_8.Abstract | Attribute_8.Override));
          a.RemoveAt(i);
        } else ++i;
      }
    } else a = new NonOwningArrayList();

    // add abstract members from this class
    foreach (Member_8 m in members_) {
      if (m.HasAttribute(Attribute_8.Abstract))
        a.Add(m);
    }

    return a;
  }

  public bool ResolveAll(Program_8 program) {
    if (parent_name_ != null) {
      parent_ = program.FindClass(parent_name_);
      if (parent_ == null) {
        syntax_.Error("can't find parent class {0}", parent_name_);
        return false;
      }
    } else if (this == GObject_8.type_)
      parent_ = null;
    else parent_ = GObject_8.type_;
    if (parent_ != null)
      parent_.subclasses_.Add(this);

    foreach (Member_8 m in members_)
      if (!m.Resolve(program))
        return false;

    if (!IsExtern() && constructors_.Count == 0)
      // add a default constructor
      AddConstructor(new Constructor_8(Attribute_8.Public, name_, new ArrayList(), Block_8.EmptyBlock()));

    return true;
  }

  // In our first checking pass we check all constant fields since we may need to evaluate them
  // in the course of checking other code.
  public bool Check1(Context_8 prev_ctx) {
    if (!AttributeUtil_8.CheckOnly(attributes_,
         Attribute_8.Abstract | Attribute_8.Extern | Attribute_8.Public)) {
      syntax_.Error("illegal class attribute");
      return false;
    }

    if (prev_ctx.program_.FindClass(name_) != this) {
      syntax_.Error("can't have two classes named {0}", name_);
      return false;
    }

    Context_8 ^ctx = new Context_8(prev_ctx, this);
    bool ok = true;
    foreach (Field_8 f in fields_) {
      ConstField_8 cf = f as ConstField_8;
      if (cf != null)
        ok &= cf.Check(ctx);
    }
    return ok;
  }

  public bool Check(Context_8 prev_ctx) {
    Context_8 ^ctx = new Context_8(prev_ctx, this);

    bool ok = true;

    foreach (Member_8 m in members_)
      if (m is Field_8 && !(m is ConstField_8) || m is Method_8)
        ok &= m.Check(ctx);

    // We need to check properties and indexers separately since they add methods to the members_
    // array as they are checked.
    foreach (Property_8 p in properties_)
      ok &= p.Check(ctx);
    foreach (Indexer_8 i in indexers_)
      ok &= i.Check(ctx);

    if (!HasAttribute(Attribute_8.Abstract)) {
      NonOwningArrayList ^a = FindAbstractMembers();
      if (a.Count > 0) {
        foreach (Member_8 m in a)
          syntax_.Error("class does not define inherited abstract {0} {1}", m.KindString(), m.name_);
        ok = false;
      }
    }

    return ok;
  }

  public void GetMainMethod(NonOwningArrayList /* of Method_8 */ result) {
    foreach (Method_8 m in methods_)
      if (m.name_ == "Main" && m.IsPublic() && m.IsStatic() && m.ReturnType() == Void_8.type_) {
        int c = m.parameters_.Count;
        if (c > 1)
          continue;
        if (c == 1) {
          Parameter_8 p = m.Param(0);
          if (p.GetMode() != 0 || !p.Type().Equals(new ArrayType_8(GString_8.type_)) )
            continue;
        }
        result.Add(m);
      }
  }

  public override void FindTypeDestroys(int marker, TypeSet_8 set) {
    if (marker_ == marker)
      return;
    marker_ = marker;
    set.Add(this);
    for (Class_8 c = this; c != null; c = c.parent_) {
      if (c != this && c.marker_ == marker)
        break;
      foreach (Field_8 f in c.fields_)
        if (!f.IsConstOrStatic())
          f.Type().FindVarDestroys(marker, set);
    }
    foreach (Class_8 c in subclasses_)
      c.FindTypeDestroys(marker, set);
  }

  public override TypeSet_8 TypeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_8();
      FindTypeDestroys(Control_8.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  public Temporaries_8 NewTemporaries() {
    Temporaries_8 ^t = new Temporaries_8();
    Temporaries_8 ret = t;
    temporaries_.Add(t);
    return ret;
  }

  public void StaticInit() {
    foreach (Field_8 f in fields_) {
      StaticField_8 sf = f as StaticField_8;
      if (sf != null)
        sf.Init();
    }
  }

  public override string EmitTypeName() { return name_; }

  int EmitAccess(SourceWriter_8 w, int old_access, int new_access) {
    new_access = (new_access & Attribute_8.Public) != 0 ? Attribute_8.Public : Attribute_8.Protected;

    if (new_access != old_access) {
      switch (new_access) {
        case Attribute_8.Protected:
          w.Indent(-1);
          w.WriteLine("protected:");
          break;
        case Attribute_8.Public:
          w.Indent(-1);
          w.WriteLine("public:");
          break;
        default:
          Debug.Assert(false);
          break;
      }
    }

    return new_access;
  }

  public void EmitInitializers(SourceWriter_8 w) {
    foreach (Field_8 f in fields_)
      if (!f.IsConstOrStatic())
        f.EmitInitializer(w);
  }

  // Return_8 true if this top-level class must inherit from Object.
  bool ObjectInherit() {
    if (object_inherit_)
      return true;
    foreach (Class_8 c in subclasses_)
      if (c.ObjectInherit())
        return true;
    return false;
  }

  public void EmitDeclaration(SourceWriter_8 w) {
    if (emitted_ || IsExtern())
      return;

    // C++ requires a parent class to appear before its subclasses in a source file.
    parent_.EmitDeclaration(w);

    emitted_ = true;

    w.Write("class {0} ", name_);
    if (parent_ != null)
      w.Write(": public {0} ",
              parent_ == GObject_8.type_ && !ObjectInherit() ? "_Object" : parent_.name_);
    w.OpenBrace();

    int access = 0;

    if (fields_.Count > 0) {
      foreach (Field_8 f in fields_) {
        access = EmitAccess(w, access, f.attributes_);
        f.EmitDeclaration(w);
      }
      w.WriteLine("");
    }

    if (subclasses_.Count > 0) {
      access = EmitAccess(w, access, Attribute_8.Protected);
      w.IWrite("{0}(Dummy *dummy) ", name_);
      if (parent_ != GObject_8.type_)
        w.Write(": {0}(dummy) ", parent_.name_);
      w.WriteLine("{ }");
      w.WriteLine("");
    }

    // If_8 we have more than one constructor, emit an _Init() method which constructors can
    // call to initialize instance variables.
    if (constructors_.Count > 1) {
      access = EmitAccess(w, access, Attribute_8.Protected);
      w.IWriteLine("void _Init();");
      w.WriteLine("");
    }

    foreach (Constructor_8 c in constructors_) {
      access = EmitAccess(w, access, c.attributes_);
      c.EmitDeclaration(w);
    }

    if (virtual_) {
      access = EmitAccess(w, access, Attribute_8.Public);
      w.IWrite("virtual ~{0}()", name_);
      w.WriteLine(" { }");
      w.WriteLine("");
    }

    if (need_destroy_) {
      access = EmitAccess(w, access, Attribute_8.Public);
      w.IWriteLine("GEL_OBJECT({0})", name_);
      w.WriteLine("");
    }

    foreach (Method_8 m in methods_) {
      access = EmitAccess(w, access, m.attributes_);
      m.EmitDeclaration(w);
    }

    w.SubIndent();
    w.WriteLine("};");
    w.WriteLine("");
  }

  public void Emit(SourceWriter_8 w) {
    if (IsExtern())
      return;

    if (fields_.Count > 0) {
      foreach (Field_8 f in fields_)
        f.Emit(w);
      w.WriteLine("");
    }

    if (constructors_.Count > 1) {
      w.IWrite("void {0}::_Init() ", name_);
      w.OpenBrace();
      EmitInitializers(w);
      w.CloseBrace();
      w.WriteLine("");
    }

    foreach (Constructor_8 c in constructors_)
      c.Emit(w);

    foreach (Method_8 m in methods_)
      m.Emit(w);

    if (Gel_8.print_type_sets_)
      Console.WriteLine("~{0}: {1}", name_, TypeDestroys());
  }
}

class ClassPtr_8 {
  public readonly Class_8 class_;

  public ClassPtr_8(Class_8 c) { class_ = c; }
}

class ValueList_8 {
  public ArrayList list_;
  public ValueList_8(ArrayList list) { list_ = list; }

  public GValue_8 Object(int i) { return ((RValue_8) list_[i]).Get(); }
  public bool Bool(int i) { return ((GBool_8) list_[i]).b_; }
  public int Int(int i) { return ((GInt_8) list_[i]).i_; }
  public char Char(int i) { return ((GChar_8) list_[i]).c_; }
  public string GetString(int i) { return ((GString_8) list_[i]).s_; }
}

class Internal_8 : Class_8 {
  static NonOwningArrayList /* of Internal_8 */ ^all_ = new NonOwningArrayList();

  protected Internal_8(string name) : base(name) { }

  public static Internal_8 Find(string name) {
    foreach (Internal_8 p in all_)
      if (p.name_ == name)
        return p;
    return null;
  }

  static void Add(Internal_8 p) { all_.Add(p); }

  public static void Init() {
    Add(GObject_8.type_);
    Add(GArray_8.array_class_);
    Add(GBool_8.type_);
    Add(GChar_8.type_);
    Add(GDouble_8.type_);
    Add(GFloat_8.type_);
    Add(GInt_8.type_);
    Add(GString_8.type_);
    Add(GStringBuilder_8.type_);
    Add(PoolClass_8.instance_);
    Add(DebugClass_8.instance_);
    Add(EnvironmentClass_8.instance_);

    Add(ConsoleClass_8.instance_);
    Add(FileClass_8.instance_);
    Add(PathClass_8.instance_);
    Add(GStreamReader_8.type_);
  }
}

class ObjectClass_8 : Internal_8 {
  public Method_8 equals_;
  public Method_8 get_hash_code_;
  public Method_8 to_string_;

  public ObjectClass_8() : base("Object") { }

  public override void Add(Method_8 ^m) {
    switch (m.name_) {
      case "Equals": equals_ = m; break;
      case "GetHashCode": get_hash_code_ = m; break;
      case "ToString": to_string_ = m; break;
    }
    base.Add(m);
  }
}

class ArrayClass_8 : Internal_8 {
  public ArrayClass_8() : base("Array") { }
}

abstract class SimpleType_8 : Internal_8 {
  protected SimpleType_8(string name) : base(name) { }

  public override bool IsOwned() { return false; }
  public override bool IsReference() { return false; }
  public override bool IsValue() { return true; }

  public override string EmitExprType() { return EmitType(); }
  public override string EmitType() { Debug.Assert(false); return null; }
}

abstract class IntegralType_8 : SimpleType_8 {
  protected IntegralType_8(string name) : base(name) { }
}

class BoolClass_8 : IntegralType_8 {
  public BoolClass_8() : base("Bool") { }

  static GBool_8 ^default_ = new GBool_8(false);
  public override SimpleValue_8 DefaultValue_8() { return default_; }

  public override string ToString() { return "bool"; }

  public override string EmitType() { return "bool"; }
}

class CharClass_8 : IntegralType_8 {
  public CharClass_8() : base("Char") { }

  static GChar_8 ^default_ = new GChar_8('\0');

  public override SimpleValue_8 DefaultValue_8() { return default_; }

  public override bool CanConvert1(GType_8 t) { return t == GInt_8.type_; }

  public override string ToString() { return "char"; }

  public override RValue_8 ^InvokeStatic(Method_8 m, ValueList_8 args) {
    switch (m.name_) {
      case "IsDigit": return new GBool_8(Char.IsDigit(args.Char(0)));
      case "IsLetter": return new GBool_8(Char.IsLetter(args.Char(0)));
      case "IsWhiteSpace": return new GBool_8(Char.IsWhiteSpace(args.Char(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "wchar_t"; }
}

class IntClass_8 : IntegralType_8 {
  public IntClass_8() : base("Int") { }

  static GInt_8 ^default_ = new GInt_8(0);

  public override SimpleValue_8 DefaultValue_8() { return default_; }

  public override bool CanConvert1(GType_8 t) {
    return t == GFloat_8.type_ || t == GDouble_8.type_;
  }

  protected override bool CanConvertExplicit1(GType_8 t) {
    return t == GChar_8.type_;
  }

  public override string ToString() { return "int"; }

  public override RValue_8 ^InvokeStatic(Method_8 m, ValueList_8 args) {
    switch (m.name_) {
      case "Parse": return new GInt_8(int.Parse(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "int"; }
}

class FloatClass_8 : SimpleType_8 {
  public FloatClass_8() : base("Single") { }

  static GFloat_8 ^default_ = new GFloat_8(0.0f);

  public override SimpleValue_8 DefaultValue_8() { return default_; }

  public override bool CanConvert1(GType_8 t) {
    return t == GDouble_8.type_;
  }

  protected override bool CanConvertExplicit1(GType_8 t) {
    return t == GInt_8.type_;
  }

  public override string ToString() { return "float"; }

  public override string EmitType() { return "float"; }
}

class DoubleClass_8 : SimpleType_8 {
  public DoubleClass_8() : base("Double") { }

  static GDouble_8 ^default_ = new GDouble_8(0.0d);

  public override SimpleValue_8 DefaultValue_8() { return default_; }

  protected override bool CanConvertExplicit1(GType_8 t) {
    return t == GInt_8.type_ || t == GFloat_8.type_;
  }

  public override string ToString() { return "double"; }

  public override string EmitType() { return "double"; }
}

class StringClass_8 : Internal_8 {
  public StringClass_8() : base("String") { }

  public override bool IsOwned() { return false; }
  public override bool IsValue() { return true; }

  public override string ToString() { return "string"; }

  public override string EmitType() {
    return "_Ref<String>";
  }

  public override string EmitReturnType() {
    return EmitType();
  }

  public override string EmitGenericType() {
    return EmitType();
  }

  public override RValue_8 ^InvokeStatic(Method_8 m, ValueList_8 args) {
    switch (m.name_) {
      case "Format": return new GString_8(String.Format(args.GetString(0), args.Object(1)));
      default: Debug.Assert(false); return null;
    }
  }
}

class StringBuilderClass_8 : Internal_8 {
  public StringBuilderClass_8() : base("StringBuilder") { }
  public override GValue_8 ^New_8() { return new GStringBuilder_8(); }
}

class GStringBuilder_8 : GValue_8 {
  readonly StringBuilder ^b_ = new StringBuilder();

  public static readonly StringBuilderClass_8 ^type_ = new StringBuilderClass_8();

  public override GType_8 Type() { return type_; }

  public override RValue_8 ^Invoke(Method_8 m, ValueList_8 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "Append": b_.Append(args.Char(0)); return null;
      case "ToString": return new GString_8(b_.ToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class PoolClass_8 : Internal_8 {
  public PoolClass_8() : base("Pool") { }

  public static PoolClass_8 ^instance_ = new PoolClass_8();
}

class DebugClass_8 : Internal_8 {
  public DebugClass_8() : base("Debug") { }
  public static readonly DebugClass_8 ^instance_ = new DebugClass_8();
  
  public override RValue_8 ^InvokeStatic(Method_8 m, ValueList_8 args) {
    switch (m.name_) {
      case "Assert": Debug.Assert(args.Bool(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

class EnvironmentClass_8 : Internal_8 {
  public EnvironmentClass_8() : base("Environment") { }
  public static readonly EnvironmentClass_8 ^instance_ = new EnvironmentClass_8();

  public override RValue_8 ^InvokeStatic(Method_8 m, ValueList_8 args) {
    switch (m.name_) {
      case "Exit": Environment.Exit(args.Int(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

// built-in I/O classes

class ConsoleClass_8 : Internal_8 {
  public ConsoleClass_8() : base("Console") { }

  public override RValue_8 ^InvokeStatic(Method_8 m, ValueList_8 args) {
    switch (m.name_) {
      case "Write":
        switch (m.parameters_.Count) {
          case 1: Console.Write(args.Object(0)); return null;
          case 2: Console.Write(args.GetString(0), args.Object(1)); return null;
          case 3: Console.Write(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      case "WriteLine":
        switch (m.parameters_.Count) {
          case 1: Console.WriteLine(args.Object(0)); return null;
          case 2: Console.WriteLine(args.GetString(0), args.Object(1)); return null;
          case 3: Console.WriteLine(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly ConsoleClass_8 ^instance_ = new ConsoleClass_8();
}

class FileClass_8 : Internal_8 {
  public FileClass_8() : base("File") { }

  public override RValue_8 ^InvokeStatic(Method_8 m, ValueList_8 args) {
    switch (m.name_) {
      case "Delete": File.Delete(args.GetString(0)); return null;
      case "Exists": return new GBool_8(File.Exists(args.ToString()));
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly FileClass_8 ^instance_ = new FileClass_8();
}

class PathClass_8 : Internal_8 {
  public PathClass_8() : base("Path") { }

  public override RValue_8 ^InvokeStatic(Method_8 m, ValueList_8 args) {
    switch (m.name_) {
      case "GetTempFileName": return new GString_8(Path.GetTempFileName());
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly PathClass_8 ^instance_ = new PathClass_8();
}

class StreamReaderClass_8 : Internal_8 {
  public StreamReaderClass_8() : base("StreamReader") { }
  public override GValue_8 ^New_8() { return new GStreamReader_8(); }
}

class GStreamReader_8 : GValue_8 {
  StreamReader ^reader_;

  public static readonly StreamReaderClass_8 ^type_ = new StreamReaderClass_8();

  public override GType_8 Type() { return type_; }

  public override RValue_8 ^Invoke(Method_8 m, ValueList_8 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StreamReader": reader_ = new StreamReader(args.GetString(0)); return null;
      case "Read": return new GInt_8(reader_.Read());
      case "Peek": return new GInt_8(reader_.Peek());
      default: Debug.Assert(false); return null;
    }
  }
}

class Program_8 {
  ArrayList /* of string */ ^gel_import_ = new ArrayList();
  ArrayList /* of string */ ^cpp_import_ = new ArrayList();

  static Scanner_8 ^scanner_;

  NonOwningArrayList ^classes_ = new NonOwningArrayList();
  ArrayList ^own_classes_ = new ArrayList();

  public bool crt_alloc_;
  public bool debug_;
  public bool safe_ = true;

  public Control_8 prev_;   // previous node in control flow graph, used during graph construction

  public void Import(string s) {
    ArrayList a = null;
    string extension = Path.GetExtension(s);
    switch (extension) {
      case ".gel": a = gel_import_; break;
      case ".cpp": a = cpp_import_; break;
      default:
        new Syntax_8().Error("can't import file with extension {0}", extension);
        Environment.Exit(0);
        break;
    }
    foreach (string i in a)
      if (i == s)
        return;   // already imported
    a.Add(s);
  }

  public void FindAndImport(string s) {
    // First look relative to the importing file.
    string dir = Path.GetDirectoryName(Gel_8.CurrentFile());
    string s1 = Path.Combine(dir, s);
    if (!File.Exists(s1)) {
      // Now look relative to the GEL2 directory.
      s1 = Path.Combine(Gel_8.gel_directory_, s);
      if (!File.Exists(s1)) {
        new Syntax_8().Error("import not found: ", s);
        Environment.Exit(0);
      }
    }
    Import(s1);
  }
  
  public void Add(Class_8 c) {
    c.SetProgram(this);
    classes_.Add(c);
  }

  public void AddOwn(Class_8 ^c) {
    own_classes_.Add(c);
  }

  public Class_8 FindClass(string name) {
    foreach (Class_8 c in classes_)
      if (c.name_ == name)
        return c;
    return null;
  }

  public string CurrentFile() {
    return scanner_.filename_;
  }

  public int Line() {
    return scanner_.Line();
  }

  string Builtin(string module) {
    string file = String.Format("{0}.gel", module);
    return Path.Combine(Gel_8.gel_directory_, file);
  }

  public bool Parse() {
    Parser ^parser = new Parser();
    for (int i = 0; i < gel_import_.Count; ++i) {
      string file = (string) gel_import_[i];
      scanner_ = new Scanner_8(file);
      parser.yyParse(scanner_);
      if (i == 0) {
        Import(Builtin("internal"));
        Import(Builtin("library"));
      }
    }
    return true;
  }

  public bool Resolve() {
    foreach (Class_8 c in classes_)
      if (!c.ResolveAll(this))
        return false;

    return true;
  }

  public bool Check() {
    Context_8 ^ctx = new Context_8(this);
    bool ok = true;

    // Make a first checking pass where we check only constant fields.
    foreach (Class_8 c in classes_)
      ok &= c.Check1(ctx);

    foreach (Class_8 c in classes_)
      ok &= c.Check(ctx);

    return ok;
  }

  Method_8 FindMain() {
    NonOwningArrayList ^methods = new NonOwningArrayList();
    foreach (Class_8 c in classes_) {
      c.GetMainMethod(methods);
    }
    if (methods.Count == 0) {
      Console.WriteLine("no Main() method found");
      return null;
    }
    if (methods.Count > 1) {
      Console.WriteLine("error: found more than one Main() method");
      return null;
    }
    return (Method_8) methods[0];
  }

  public void Eval(ArrayList /* of string */ args) {
    Method_8 m = FindMain();
    if (m == null)
      return;
    ArrayList ^a = new ArrayList();
    if (m.parameters_.Count > 0) {   // Main() takes a string[] argument
      GArray_8 ^arr = new GArray_8(new ArrayType_8(GString_8.type_), args.Count);
      for (int i = 0 ; i < args.Count ; ++i)
        arr.Set(i, new GString_8((string) args[i]));
      a.Add(arr);
    }
    foreach (Class_8 c in classes_)
      c.StaticInit();
    m.Invoke(null, a);
  }

  void EmitMain(SourceWriter_8 w, Method_8 main) {
    bool args = main.parameters_.Count > 0;
    w.Write("int main({0}) ", args ? "int argc, char *argv[]" : "");
    w.OpenBrace();
    w.IWriteLine("return gel_runmain({0}::Main{1});", main.GetClass().name_, args ? ", argc, argv" : "");
    w.CloseBrace();
  }

  public bool Emit(SourceWriter_8 w) {
    Method_8 main = FindMain();
    if (main == null)
      return false;

    w.WriteLine("#define MEMORY_OWN 1");
    if (safe_)
      w.WriteLine("#define MEMORY_SAFE 1");
    if (crt_alloc_)
      w.WriteLine("#define MEMORY_CRT 1");

    foreach (string f in cpp_import_)
      w.WriteLine("#include {0}", GString_8.EmitString(f));

    // We undefine NULL since Gel_8 code may legitimately define fields or variables with that name.
    // Generated code uses 0, not NULL, to indicate the null pointer.
    w.WriteLine("#undef NULL");

    w.WriteLine("");

    // Forward-declare all classes since C++ requires a class to be declared before its name can
    // be used as a type.
    foreach (Class_8 c in classes_)
      if (!(c.HasAttribute(Attribute_8.Extern)))
        w.WriteLine("class {0};", c.name_);
    w.WriteLine("");

    foreach (Class_8 c in classes_)
      c.EmitDeclaration(w);

    foreach (Class_8 c in classes_)
      c.Emit(w);

    EmitMain(w, main);
    return true;
  }

  // Emit C++ code.
  public bool Generate(string basename) {
    string cpp_file = basename + ".cpp";
    StreamWriter ^w = new StreamWriter(cpp_file);
    bool ok = Emit(new SourceWriter_8(w));
    w.Close();
    return ok;
  }

  static string[] ^vsdirs = { "Microsoft Visual Studio 8",
                            "Microsoft Visual Studio .NET 2003",
                            "Microsoft Visual Studio .NET 2002" };

  string VsVars(int i) {
    return String.Format("C:\\Program_8 Files\\{0}\\Common7\\Tools\\vsvars32.bat", vsdirs[i]);
  }

  string FindVsVars() {
    for (int i = 0; i < vsdirs.Length; ++i) {
      string f = VsVars(i);
      if (File.Exists(f))
        return f;
    }

    Console.WriteLine("Error: unable to find vsvars32.bat at any of the following locations:");
    Console.WriteLine("");
    for (int i = 0; i < vsdirs.Length; ++i)
      Console.WriteLine(VsVars(i));
    Console.WriteLine("");
    Console.WriteLine("Your Visual Studio installation may be invalid.  Aborting compilation.");
    return null;
  }

  // Report compilation error. Print error message from a file
  void ReportCompilationError(string error_msg_file) {
      Console.WriteLine(
        "Error: unable to compile generated C++ code.  You may have found a bug in the GEL2 compiler.");
      Console.WriteLine("C++ compiler output follows:");
      Console.WriteLine("");
      Console.WriteLine((new StreamReader(error_msg_file)).ReadToEnd());
  }

  void UnixCppCompile(string basename) {
    string command_out = Path.GetTempFileName();
    string dbg_options = debug_ ? "-g -DDEBUG" : "-O2 -DNDEBUG";
    StringBuilder ^sb = new StringBuilder();
    // -o basename, use basename as the executable name
    // -Werror, make all warnings into hard errors
    sb.AppendFormat("/usr/bin/g++ -o {0} -Werror {1} {2}.cpp",
                    basename, dbg_options, basename);

    // Append redirection of output
    sb.AppendFormat(" > {0} 2>&1", command_out);
 
    string sh_cmd = sb.ToString();

    if (Gel_8.verbose_) 
      Console.WriteLine(sh_cmd);
  
    if (Process.System(sh_cmd) !=0) {
      ReportCompilationError(command_out);
    }
    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".o");
  }

  // Run vsvars32.bat and the run the given command, redirecting output to a file.
  // We must always redirect output since vsvars32 prints a message "Setting environment..."
  // which we don't want users to see.
  int VsRun(string vsvars, string command, string output) {
    command = String.Format("(\"{0}\" & {1}) > \"{2}\"", 
                            vsvars, command, output);
    return Process.System(command);
  }

  void VsCppCompile(string basename) {
    string vsvars = FindVsVars();
    if (vsvars == null)
      return;
    string command_out = Path.GetTempFileName();

    string options = debug_ ?
      //  /MDd - runtime library: multithreaded debug DLL
      //  /Od - optimization: disabled
      //  /ZI - debug information format: Program_8 Database for Edit & Continue_8
      "/MDd /Od /ZI /D \"_DEBUG\"" :

      //  /MD - runtime library: multithreaded DLL
      //  /O2 - optimization: Maximize Speed
      //  /GL - optimization: Whole Program_8 Optimization
      "/MD /O2 /GL /D \"NDEBUG\"";

    StringBuilder ^sb = new StringBuilder();
    //  /WX - treat warnings as errors
    sb.AppendFormat("cl /nologo /WX {0} {1}.cpp", options, basename);
    string mode = debug_ ? "debug" : "release";
    if (!crt_alloc_)
      sb.AppendFormat(" {0}\\{1}\\dlmalloc.obj", Gel_8.gel_directory_, mode);
    sb.Append(" user32.lib shell32.lib shlwapi.lib");
    string command = sb.ToString();
    if (Gel_8.verbose_)
      Console.WriteLine(command);

    if (VsRun(vsvars, command, command_out) != 0) {
      ReportCompilationError(command_out);
    } else {
      // Run the manifest tool to embed the linker-generated manifest into the executable file;
      // this allows the executable to find the C runtime DLL even when the manifest file is absent.
      string mt_command = String.Format("mt -nologo -manifest {0}.exe.manifest -outputresource:\"{0}.exe;#1\"",
                              basename);
      if (Gel_8.verbose_)
        Console.WriteLine(mt_command);
      if (VsRun(vsvars, mt_command, command_out) != 0)
        Console.WriteLine("warning: could not run manifest tool");
    }

    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".obj");
    File.Delete(basename + ".exe.manifest");
  }

  // Invoke the C++ compiler to generate a native executable.
  void CppCompile(string basename) {
    if (Environment.OSVersion.Platform == PlatformID.Win32NT) 
      VsCppCompile(basename);
    else
      UnixCppCompile(basename);
  }

  public void Compile(string output, bool cpp_only) {
    if (output == null)
      output = Path.GetFileNameWithoutExtension((string) gel_import_[0]);
    if (Generate(output) && !cpp_only)
      CppCompile(output);
  }
}

class Scanner_8 : yyInput {
  public readonly string filename_;

  int line_;
  public int Line() { return line_; }

  StreamReader ^sr_;
  int token_;
  object ^ value_;

  int next_token_ = -1;
  object ^ next_value_;

  public Scanner_8 (string filename) {
    filename_ = filename;
    sr_ = new StreamReader(filename);
    line_ = 1;
  }

  public override int GetToken () {
    return token_;
  }

  public override object ^ GetValue () {
    return take value_;
  }

  int Read() {
    int i = sr_.Read();
    if (i == '\n')
      ++line_;
    return i;
  }

  bool Read(out char c) {
    int i = Read();
    c = (char) i;
    return i != -1;
  }

  char Peek() {
    return (char) sr_.Peek();
  }

  string ReadWord(char first) {
    StringBuilder ^sb = new StringBuilder();
    if (first != '\0')
      sb.Append(first);
    while (true) {
      char c = Peek();
      if (!Char.IsLetter(c) && !Char.IsDigit(c) && c != '_')
        break;
      sb.Append(c);
      Read();
    }
    return sb.ToString();
  }

  // Read to the end of the current line.
  string ReadLine() {
    StringBuilder ^sb = new StringBuilder();
    char c;
    while (Read(out c)) {
      if (c == '\n')
        break;
      sb.Append(c);
    }
    return sb.ToString();
  }

  // Read a comment delimited by /* ... */, assuming we've already read the opening /*.
  // Returns true on success, or false on EOF.
  bool ReadDelimitedComment() {
    char prev = (char) 0;
    while (true) {
      char c;
      if (!Read(out c)) {
        Console.WriteLine("warning: unterminated comment at end of file");
        return false;
      }
      if (c == '/' && prev == '*')
        return true;
      prev = c;
    }
  }

  // Preprocess input, handling whitespace, comments and directives; return the first
  // character not eaten by preprocessing, or -1 on EOF.
  int GetChar() {
    while (true) {
      int i = Read();
      if (i == -1)
        return -1;   // end of input
      if (i == 0)
        continue;   // end of this file; move on
      char c = (char) i;

      if (c == '\n' && Peek() == '#') {
        Read();
        string directive = ReadWord('\0');
        if (directive == "line") {
          ReadLine();
          continue;
        }
        Console.WriteLine("error: unknown preprocessing directive {0}", directive);
        Environment.Exit(0);
      }

      if (Char.IsWhiteSpace(c))
        continue;

      if (c == '/') {
        switch (Peek()) {
          case '/':  // single-line comment
            Read();
            int line = line_;
            string s = ReadLine();
            if (Gel_8.error_test_ && s.StartsWith(" error"))
              Gel_8.expected_error_lines_.Add(line);
            continue;

          case '*':  // comment delimited by /* ... */
            Read();   // move past opening '*'
            if (!ReadDelimitedComment())
              return (char) 0;
            continue;
        }
      }

      return c;
    }
  }

  bool IsDigit(char c, bool hex) {
    if (Char.IsDigit(c))
      return true;
    if (!hex)
      return false;
    return (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');
  }

  // Read a number, possibly including a decimal point and/or exponent.
  string ReadNumber(char first, bool hex, out bool real) {
    bool dot = false, exp = false;
    StringBuilder ^sb = new StringBuilder();
    sb.Append(first);
    if (first == '.')
      dot = true;

    while (true) {
      bool need_digit = false;
      char c = Peek();
      if (c == '.' && !hex && !dot && !exp) {
        sb.Append(c);
        Read();
        dot = true;
        c = Peek();
        need_digit = true;
      }
      else if ((c == 'e' || c == 'E') && !hex && !exp) {
        sb.Append(c);
        Read();
        exp = true;
        c = Peek();
        if (c == '+' || c == '-') {
          sb.Append(c);
          Read();
          c = Peek();
        }
        need_digit = true;
      }
      if (!IsDigit(c, hex)) {
        if (!need_digit)
          break;
        real = false;
        return null;
      }
      sb.Append(c);
      Read();
    }

    real = dot || exp;
    return sb.ToString();
  }

  int ParseNumber(char first, out object ^val) {
    bool hex = false;
    if (first == '0') {
      char p = Peek();
      if (p == 'x' || p == 'X') {
        Read();
        hex = true;
      }
    }
    bool real;
    string s = ReadNumber(first, hex, out real);
    if (s == null) {
      val = null;
      return Parser.SCAN_ERROR;
    }
    if (!hex) {
      switch (Peek()) {
        case 'F':
        case 'f':
          Read();
          val = Single.Parse(s);
          return Parser.FLOAT_LITERAL;
        case 'D':
        case 'd':
          Read();
          real = true;
        break;
    }
    }
    if (real) {
      val = Double.Parse(s);
      return Parser.DOUBLE_LITERAL;
    }
    val = int.Parse(s, hex ? NumberStyles.HexNumber : NumberStyles.Integer);
    return Parser.INT_LITERAL;
  }

  int ParseWord(char first, out object ^val) {
    string s = ReadWord(first);

    val = null;
    switch (s) {
      case "abstract": return Parser.ABSTRACT;
      case "as": return Parser.AS;
      case "base": return Parser.BASE;
      case "bool": return Parser.BOOL;
      case "break": return Parser.BREAK;
      case "case": return Parser.CASE;
      case "char": return Parser.CHAR;
      case "class": return Parser.CLASS;
      case "const": return Parser.CONST_TOKEN;
      case "continue": return Parser.CONTINUE;
      case "default": return Parser.DEFAULT;
      case "do": return Parser.DO;
      case "double": return Parser.DOUBLE;
      case "else": return Parser.ELSE;
      case "extern": return Parser.EXTERN;
      case "false": return Parser.FALSE_TOKEN;
      case "float": return Parser.FLOAT;
      case "for": return Parser.FOR;
      case "foreach": return Parser.FOREACH;
      case "if": return Parser.IF;
      case "import": return Parser.IMPORT;
      case "in": return Parser.IN_TOKEN;
      case "int": return Parser.INT;
      case "is": return Parser.IS;
      case "new": return Parser.NEW;
      case "null": return Parser.NULL;
      case "object": return Parser.OBJECT;
      case "out": return Parser.OUT_TOKEN;
      case "override": return Parser.OVERRIDE;
      case "pool": return Parser.POOL;
      case "private": return Parser.PRIVATE;
      case "protected": return Parser.PROTECTED;
      case "public": return Parser.PUBLIC;
      case "readonly": return Parser.READONLY;
      case "ref": return Parser.REF;
      case "return": return Parser.RETURN;
      case "short": return Parser.SHORT;
      case "static": return Parser.STATIC;
      case "string": return Parser.STRING;
      case "switch": return Parser.SWITCH;
      case "take": return Parser.TAKE;
      case "this": return Parser.THIS_TOKEN;
      case "true": return Parser.TRUE_TOKEN;
      case "virtual": return Parser.VIRTUAL;
      case "void": return Parser.VOID_TOKEN;
      case "while": return Parser.WHILE;
      default:
        val = s;
        return Parser.ID;
    }
  }

  bool ParseEscape(ref char c) {
    if (!Read(out c))
      return false;
    switch (c) {
      case '\'':
      case '\"':
      case '\\':
        break;
      case '0': c = '\0'; break;
      case 'n': c = '\n'; break;
      case 'r': c = '\r'; break;
      case 't': c = '\t'; break;
      default: return false;
    }
    return true;
  }

  int ParseChar(out object ^val) {
    val = null;
    char c;
    if (!Read(out c))
      return Parser.SCAN_ERROR;
    if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
    char d;
    if (!Read(out d) || d != '\'')
      return Parser.SCAN_ERROR;
    val = c;
    return Parser.CHAR_LITERAL;
  }

  int ParseString(out object ^val) {
    val = null;
    StringBuilder ^sb = new StringBuilder();
    while (true) {
      char c;
      if (!Read(out c))
        return Parser.SCAN_ERROR;
      if (c == '"')
        break;
      if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
      sb.Append(c);
    }
    val = sb.ToString();
    return Parser.STRING_LITERAL;
  }

  int ReadToken(out object ^val) {
    val = null;

    int i = GetChar();
    if (i == -1)
      return -1;
    char c = (char) i;

    if (Char.IsDigit(c) || c == '.' && Char.IsDigit(Peek()))
      return ParseNumber(c, out val);

    if (Char.IsLetter(c) || c == '_')
      return ParseWord(c, out val);

    if (c == '\'')
      return ParseChar(out val);

    if (c == '"')
      return ParseString(out val);

    char peek = Peek();
    int token = 0;
    switch (c.ToString() + peek.ToString()) {
      case "++": token = Parser.PLUS_PLUS; break;
      case "--": token = Parser.MINUS_MINUS; break;
      case "&&": token = Parser.OP_AND; break;
      case "||": token = Parser.OP_OR; break;
      case "==": token = Parser.OP_EQUAL; break;
      case "!=": token = Parser.OP_NE; break;
      case "<=": token = Parser.OP_LE; break;
      case "<<": token = Parser.OP_LEFT_SHIFT; break;
      case ">=": token = Parser.OP_GE; break;
      case ">>": token = Parser.OP_RIGHT_SHIFT; break;
      case "*=": token = Parser.STAR_EQUAL; break;
      case "/=": token = Parser.SLASH_EQUAL; break;
      case "%=": token = Parser.PERCENT_EQUAL; break;
      case "+=": token = Parser.PLUS_EQUAL; break;
      case "-=": token = Parser.MINUS_EQUAL; break;
      case "&=": token = Parser.AND_EQUAL; break;
      case "|=": token = Parser.OR_EQUAL; break;

      // Return_8 [] as a single token; this lets the parser distinguish the cases
      // "foo[] a;" and "foo[x] = 4" as soon as it reads the first token after the identifier "foo".
      case "[]": token = Parser.ARRAY_TYPE; break;
    }
    if (token != 0) {
      Read();
    } else token = c;

    val = token;
    return token;
  }

  public override bool Advance () {
    if (next_token_ != -1) {
      token_ = next_token_;
      value_ = take next_value_;
      next_token_ = -1;
    } else {
      token_ = ReadToken(out value_);
      if (token_ == -1) return false;
    }

    if (token_ == ')') {
      // We need to read one token ahead to determine whether this close parenthesis
      // ends a type cast.  See e.g. the discussion in the Cast_8 Expressions section
      // of the C# specification.
      next_token_ = ReadToken(out next_value_);
      switch (next_token_) {
        case -1:  // end of file
          break;
        case '!':
        case '(':
        case Parser.ID:
        case Parser.INT_LITERAL:
        case Parser.CHAR_LITERAL:
        case Parser.STRING_LITERAL:
          token_ = Parser.CAST_CLOSE_PAREN;
          break;
        default:
          if (next_token_ >= Parser.FIRST_KEYWORD && next_token_ <= Parser.LAST_KEYWORD &&
              next_token_ != Parser.AS && next_token_ != Parser.IS)
            token_ = Parser.CAST_CLOSE_PAREN;
          break;
      }
    }
    return true;
  }

  public override void Fatal() {
    new Syntax_8().Error("irrecoverable syntax error");
    Environment.Exit(1);
  }

}

class Gel_8 {
  public static bool verbose_;

  public static bool error_test_;
  public static bool print_type_sets_;

  public static readonly ArrayList /* of int */ ^expected_error_lines_ = new ArrayList();
  public static readonly ArrayList /* of int */ ^error_lines_ = new ArrayList();

  public static Program_8 ^program_;

  public static readonly string gel_directory_ = GetLibraryPath();

  static string GetLibraryPath() {
    return Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName); 
  }

  public static string CurrentFile() {
    return program_ == null ? "" : program_.CurrentFile();
  }

  public static int Line() {
    return program_ == null ? 0 : program_.Line();
  }

  public static void Exit() { Environment.Exit(0); }

  // Given two sorted ArrayLists a, b of ints, return an ArrayList containing all ints which appear
  // in [a] but not in [b].
  ArrayList ^Diff(ArrayList a, ArrayList b) {
    ArrayList ^ret = new ArrayList();
    int bi = 0;
    foreach (int i in a) {
      while (bi < b.Count && (int) b[bi] < i)
        ++bi;
      if (bi >= b.Count || (int) b[bi] > i)
        ret.Add(i);
    }
    return ret;
  }

  void WriteLineNumbers(ArrayList a) {
    for (int i = 0; i < a.Count; ++i) {
      if (i > 0)
        Console.Write(", ");
      Console.Write(a[i]);
    }
    Console.WriteLine("");
  }

  void ErrorTestReport() {
    Console.WriteLine("");
    ArrayList ^e = Diff(error_lines_, expected_error_lines_);
    if (e.Count > 0) {
      Console.Write("unexpected error at line ");
      WriteLineNumbers(e);
    }
    ArrayList ^e2 = Diff(expected_error_lines_, error_lines_);
    if (e2.Count > 0) {
      Console.Write("expected error at line ");
      WriteLineNumbers(e2);
    }
    if (e.Count == 0 && e2.Count == 0)
      Console.WriteLine("all errors expected");
  }

  void Usage_8() {
    Console.WriteLine("usage: gel <source-file> ... [args]");
    Console.WriteLine("       gel -c [-d] [-o <name>] [-u] [-v] [-cpp] <source-file> ...");
    Console.WriteLine("");
    Console.WriteLine("   -c: compile to native executable");
    Console.WriteLine("   -d: debug mode: disable optimizations, link with debug build of C runtime");
    Console.WriteLine("   -o: specify output filename");
    Console.WriteLine("   -u: unsafe: skip reference count checks");
    Console.WriteLine("   -v: verbose: display command used to invoke C++ compiler");
    Console.WriteLine(" -cpp: compile to C++ only");
  }

  public void Run(string[] args) {
    if (args.Length < 1) {
      Usage_8();
      return;
    }

    Internal_8.Init();

    program_ = new Program_8();
    bool compile = false;
    bool cpp_only = false;
    string output = null;
    int i;
    for (i = 0; i < args.Length && args[i].StartsWith("-"); ++i)
      switch (args[i]) {
        case "-c": compile = true; break;
        case "-d": program_.debug_ = true; break;
        case "-e": error_test_ = true; break;
        case "-o":
          if (++i >= args.Length) {
            Usage_8();
            return;
          }
          output = Path.GetFileNameWithoutExtension(args[i]);
          break;
        case "-u": program_.safe_ = false; break;
        case "-v": verbose_ = true; break;
        case "-cpp": cpp_only = true; break;
        case "-crt": program_.crt_alloc_ = true; break;
        case "-typeset": print_type_sets_ = true; break;
        default:
          Console.WriteLine("unrecognized option: {0}", args[i]);
          return;
      }

    for (; i < args.Length ; ++i)
      if (args[i].EndsWith(".gel"))
        program_.Import(args[i]);
      else {
        if (args[i] == "-")   // marker indicating end of source files
          ++i;
        break;
      }

    ArrayList ^program_args = new ArrayList();
    if (compile) {
      if (i < args.Length) {
        Console.WriteLine("file to compile has unrecognized extension: {0}", args[i]);
        return;
      }
    } else {
      for (; i < args.Length; ++i)
        program_args.Add(args[i]);
    }

    if (!program_.Parse())
      return;

    bool ok = program_.Resolve() && program_.Check();
    if (error_test_)
      ErrorTestReport();
    if (!ok)
      return;

    if (compile)
      program_.Compile(output, cpp_only);
    else program_.Eval(program_args);
  }

  public static void Main_8(string[] args) {
    new Gel_8().Run(args);
  }
}
/*
Copyright (c) 2006 Google Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

class Syntax_9 {
  public readonly string file_;
  public readonly int line_;

  public Syntax_9() { file_ = Gel_9.CurrentFile(); line_ = Gel_9.Line(); }

  static void Report(string file, int line, string type) {
    Console.Write("{0}({1}): ", file, line);
    Console.Write("{0}: ", type);
    if (Gel_9.error_test_)
      Gel_9.error_lines_.Add(line);
  }

  public void Error(string message) {
    Report(file_, line_, "error");
    Console.WriteLine(message);
  }

  public void Error(string format, object arg) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg);
  }

  public void Error(string format, object arg1, object arg2) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2);
  }

  public void Error(string format, object arg1, object arg2, object arg3) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2, arg3);
  }

  public void Warning(string message) {
    Report(file_, line_, "warning");
    Console.WriteLine(message);
  }
}

abstract class TypeExpr_9 : Syntax_9 {
  public abstract GType_9 Resolve(Program_9 program);
  public abstract TypeExpr_9 ^Copy();
}

class ConversionContext_9 {
  public const int Other = 0,
                   AssignVar = 1,
                   MethodArg = 2;
}

// GEL2 includes the following kinds of types:
// - simple types (int, bool, char, float, double): SimpleType_9
// - owned types (including array types): ArrayType_9 or Class_9 with Owned() => true
// - owning types: Owning_9
// - string: GString_9
// - null type: NullType_9
// - void: VoidType_9

abstract class GType_9 {
  public virtual bool IsOwned() { return false; }

  // A reference type is an owned, owning, string or null type.
  public virtual bool IsReference() { return true; }

  // A value type is a simple or string type.
  public virtual bool IsValue() { return false; }

  public virtual Class_9 Parent() { return GObject_9.type_; }
  
  // If_9 this is an owning type T ^ then return T; otherwise return this.
  public virtual GType_9 BaseType() { return this; }

  // Return_9 the set of types which may be destroyed when a variable of this type
  // is destroyed.
  public virtual TypeSet_9 VarDestroys() { return TypeSet_9.empty_; }

  // Return_9 the set of types which may be destroyed when a value of this concrete type
  // is destroyed.
  public virtual TypeSet_9 TypeDestroys() { return TypeSet_9.empty_; }

  public virtual void FindVarDestroys(int marker, TypeSet_9 set) { }

  public virtual void FindTypeDestroys(int marker, TypeSet_9 set) { }

  public virtual bool IsSubtype(GType_9 type) {
    for (GType_9 t = this; t != null ; t = t.Parent())
      if (type.Equals(t))
        return true;
    return false;
  }

  public virtual Owning_9 OwningType() { Debug.Assert(false); return null; }

  protected virtual bool CanConvertOwnership(GType_9 t, int context) {
    bool from_owning = this is Owning_9;
    bool to_owning = t is Owning_9;
    if (IsValue() && t.BaseType() == GObject_9.type_) {
      Debug.Assert(!from_owning);
      // boxing conversion yields an owning pointer; string->object conversion may
      // yield an owning or non-owning pointer
      return to_owning || context == ConversionContext_9.MethodArg || this == GString_9.type_;
    }
    if (BaseType() == GObject_9.type_ && t.IsValue()) {
      Debug.Assert(!to_owning);
      return true;  // an unboxing or object->string conversion, OK in any context
    }
    return from_owning == to_owning ||
           from_owning && !to_owning &&
             (context == ConversionContext_9.AssignVar || context == ConversionContext_9.MethodArg);
  }

  // Ensure that this class will inherit from Object in generated C++ code.
  public virtual void SetObjectInherit() { }

  // Return_9 true if there is a non-subtyping implicit conversion from this to t.
  public virtual bool CanConvert1(GType_9 t) { return false; }

  // Return_9 true if there is a non-subtyping explicit conversion from this to t.
  protected virtual bool CanConvertExplicit1(GType_9 t) { return false; }

  // Return_9 true if this type can be converted to type [to].
  public bool CanConvert(GType_9 to, int context, bool is_explicit, bool subtype_only) {
    if (!CanConvertOwnership(to, context))
      return false;

    GType_9 from_base = BaseType();
    GType_9 to_base = to.BaseType();
    if (from_base.Equals(to_base))
      return true;   // identity conversion

    // If_9 we ever perform a conversion to C ^, then C must have a vtable so that we can call
    // a virtual destructor when an owning pointer is destroyed.
    if (to is Owning_9 && this != Null_9.type_)
      to_base.SetVirtual();

    // If_9 we ever perform an explicit conversion from a class, that class must
    // have a vtable so that every instance of the class will have run-time type information.
    if (is_explicit)
      from_base.SetVirtual();

    // If_9 we ever convert between C and Object, then C must derive from Object in generated code.
    if (from_base == GObject_9.type_)
      to_base.SetObjectInherit();
    else if (to_base == GObject_9.type_)
      from_base.SetObjectInherit();

    return from_base.IsSubtype(to_base) ||
           !subtype_only && from_base.CanConvert1(to_base) ||
           is_explicit && (to_base.IsSubtype(from_base) ||
                           !subtype_only && from_base.CanConvertExplicit1(to_base));
  }

  public bool CanConvert(GType_9 t, int context) { return CanConvert(t, context, false, false); }
  public bool CanConvert(GType_9 t) { return CanConvert(t, ConversionContext_9.Other); }

  public bool CanConvertExplicit(GType_9 t, bool subtype_only) {
    return CanConvert(t, ConversionContext_9.Other, true, subtype_only);
  }

  public bool CheckConvert(Syntax_9 caller, GType_9 t, int context) {
    if (!CanConvert(t, context)) {
      caller.Error("can't convert {0} to {1}", this, t);
      return false;
    }
    return true;
  }

  public bool CheckConvert(Syntax_9 caller, GType_9 t) {
    return CheckConvert(caller, t, ConversionContext_9.Other);
  }

  // Return_9 a type to which the types [this] and t can both be implicitly converted.
  public GType_9 CommonType(Syntax_9 caller, GType_9 t) {
    if (CanConvert(t))
      return t;
    if (t.CanConvert(this))
      return this;
    caller.Error("incompatible types: {0} and {1}", this, t);
    return null;
  }

  public abstract SimpleValue_9 DefaultValue_9();

  static ArrayList ^empty_array_ = new ArrayList();
  public virtual ArrayList /* of Member_9 */ Members() { return empty_array_; }

  public Member_9 GetMatchingMember(Member_9 m1) {
    foreach (Member_9 m in Members())
      if (m.MatchSignature(m1))
        return m;
    return null;
  }

  // Find a match for m in this type or its ancestors, ignoring private members and
  // optionally ignoring overrides.
  public Member_9 FindMatchingMember(Member_9 m, bool override_ok) {
    for (GType_9 t = this ; t != null ; t = t.Parent()) {
      Member_9 m1 = t.GetMatchingMember(m);
      if (m1 != null && !m1.IsPrivate() && (override_ok || !m1.IsOverride()))
        return m1;
    }
    return null;
  }

  int Score(bool accessible, int mismatches) {
    return (accessible ? 0 : 100) + mismatches;
  }

  public Member_9 Lookup(Syntax_9 caller, Class_9 from_class, bool through_base,
                       int kind, string name, ArrayList /* of Argument_9 */ arguments, bool report_error) {
    Member_9 m1 = null;   // the best match we've found so far
    bool found_any = false;
    bool accessible = false;
    int score = -1;

    GType_9 this_type = BaseType();
    GType_9 t;
    for (t = this_type; t != null; t = (kind == MemberKind_9.Constructor_9 ? null : t.Parent())) {
      foreach (Member_9 m in t.Members())
        if (Member_9.MatchKind(m.Kind(), kind) && m.name_ == name && !m.IsOverride()) {
          found_any = true;
          int mismatches = 0;
          if (arguments != null && !m.IsApplicable(arguments, out mismatches))
            continue; // wrong argument count
          bool new_accessible = m.IsAccessible(from_class, this_type, through_base);
          int new_score = Score(new_accessible, mismatches);
          if (new_score == 0 && score == 0) {
            if (report_error)
              caller.Error("{0}: ambiguous {1} call", name, Member_9.ToString(kind));
            return null;
          }
          if (score == -1 || new_score < score) {
            m1 = m;
            score = new_score;
            accessible = new_accessible;
          }
        }
      if (score == 0)
        break;
    }

    if (score != 0) {
      if (report_error) {
        string k = Member_9.ToString(kind);
        if (!found_any)
          caller.Error("{0}: {1} not found", name, k);
        else if (score == -1) {
          string a = String.Format("{0} argument{1}", arguments.Count, arguments.Count == 1 ? "" : "s");
          caller.Error("{0}: no {1} overload takes {2}", name, k, a);
        } else if (!accessible)
          caller.Error("{0}: can't access {1} {2}",
                       name, m1.IsProtected() ? "protected" : "private", k);
        else {
          caller.Error("{0}: the best overloaded {1} match has some invalid arguments", name, k);
          m1.ReportMismatches(caller, arguments);
        }
      }
      return null;
    }

    // If_9 we've found a member of the Object class, then we're using this class as an object,
    // so in generated code it must ultimately inherit from Object, not _Object.
    if (t == GObject_9.type_)
      this_type.SetObjectInherit();

    if (through_base) {
      // As_9 a special case, whenever we're accessing through base we find the member which will
      // actually be invoked; this is not necessarily the same as the member we've just found
      // if the member is virtual.
      m1 = FindMatchingMember(m1, true);
      Debug.Assert(m1 != null);
    }

    return m1;
  }

  public virtual void SetVirtual() { }

  // Emit the name of the C++ class we use to hold instances of this type.
  public virtual string EmitTypeName() { Debug.Assert(false); return null; }

  // Return_9 a C++ type of the form "T<U>".  If_9 U ends with a '>', we emit an
  // extra space to avoid emitting the token >>, which will cause GCC to complain.
  public static string ConstructType(string generic, string type) {
    return String.Format("{0}<{1}{2}>", generic, type,
                         type.EndsWith(">") ? " " : "");
  }

  string EmitNonOwningPointer(string name) {
    if (Gel_9.program_.safe_)
      return ConstructType(this == GObject_9.type_ ? "_PtrRef" : "_Ptr", name);
    return String.Format("{0} *", name);
  }

  // Emit a C++ type used for variables holding instances of this type.
  public virtual string EmitType() {
    return EmitNonOwningPointer(EmitTypeName());
  }

  // Emit a C++ type used for expressions holding instances of this type.
  public virtual string EmitExprType() {
    return EmitTypeName() + " *";
  }

  public virtual string EmitReturnType() {
    return EmitExprType();
  }

  public virtual string EmitGenericType() {
    return IsReference() ? EmitNonOwningPointer("Object") : EmitType();
  }
}

class TypeSet_9 {
  NonOwningArrayList /* of GType_9 */ ^types_ = new NonOwningArrayList();

  public static readonly TypeSet_9 ^empty_ = new TypeSet_9();

  public void Add(GType_9 type) {
    for (int i = 0; i < types_.Count; ++i) {
      GType_9 t = (GType_9) types_[i];
      if (type.IsSubtype(t))
        return;
      if (t.IsSubtype(type)) {
        types_[i++] = type;
        while (i < types_.Count) {
          t = (GType_9) types_[i];
          if (t.IsSubtype(type))
            types_.RemoveAt(i);
          else ++i;
        }
        return;
      }
    }
    types_.Add(type);
  }

  public void Add(TypeSet_9 set) {
    foreach (GType_9 t in set.types_)
      Add(t);
  }

  public bool Contains(GType_9 type) {
    foreach (GType_9 t in types_)
      if (type.IsSubtype(t))
        return true;
    return false;
  }

  public bool IsObject() {
    return types_.Count > 0 && types_[0] == GObject_9.type_;
  }

  public override string ToString() {
    StringBuilder ^sb = new StringBuilder();
    sb.Append("{");
    foreach (GType_9 t in types_)
      sb.AppendFormat(" {0}", t.ToString());
    sb.Append(" }");
    return sb.ToString();
  }
}

class VoidType_9 : GType_9 {
  public override bool IsReference() { Debug.Assert(false); return false; }

  public override SimpleValue_9 DefaultValue_9() { Debug.Assert(false); return null; }

  public override string ToString() { return "void"; }

  public override string EmitExprType() { return "void"; }
  public override string EmitType() { return "void"; }
}

class Void_9 {
  public static readonly GType_9 ^type_ = new VoidType_9();
}

// an RValue_9, a Location_9 containing an RValue_9, or a LocationRef_9 pointing to a Location_9 containing an RValue_9
abstract class ValueOrLocation_9 {
  public abstract GValue_9 Get();
}

// a GValue_9 or a reference to a GValue_9
abstract class RValue_9 : ValueOrLocation_9 {
  public abstract RValue_9 ^CopyRef();
}

abstract class GValue_9 : RValue_9 {
  public override GValue_9 Get() { return this; }

  public abstract GType_9 Type();

  public override RValue_9 ^CopyRef() { return new Reference_9(this); }

  public virtual RValue_9 ^Get(Field_9 field) { Debug.Assert(false); return null; }
  public virtual RValue_9 ^Take_9(Field_9 field) { Debug.Assert(false); return null; }

  public virtual RValue_9 ^ConvertExplicit(ref RValue_9 ^this_own, GType_9 t) {
    // try implicit conversion
    RValue_9 ^v = Convert(ref this_own, t);
    if (v != this || Type().IsSubtype(t) )
      return v;

    Console.WriteLine("type cast failed: object of type {0} is not a {1}", Type(), t);
    Gel_9.Exit();
    return null;
  }

  // Implicitly convert this value to type t.
  public virtual RValue_9 ^Convert(ref RValue_9 ^this_own, GType_9 t) {
    return take this_own;
  }

  public virtual bool DefaultEquals(object o) { return Equals(o); }
  public virtual int DefaultHashCode() { return GetHashCode(); }
  public virtual string DefaultToString() { return ToString(); }

  public virtual RValue_9 ^Invoke(Method_9 m, ValueList_9 args) {
    switch (m.name_) {
      case "Equals": return new GBool_9(DefaultEquals(args.Object(0)));
      case "GetHashCode": return new GInt_9(DefaultHashCode());
      case "ToString": return new GString_9(DefaultToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class Reference_9 : RValue_9 {
  public readonly GValue_9 value_;    // a reference value, never a SimpleValue_9

  public Reference_9(GValue_9 v) { value_ = v; }

  public override GValue_9 Get() { return value_; }

  public override RValue_9 ^CopyRef() { return new Reference_9(value_); }
}

abstract class SimpleValue_9 : GValue_9 {
  public abstract SimpleValue_9 ^Copy();
  public override RValue_9 ^CopyRef() { return Copy(); }
  public abstract string Emit();
}

class GBool_9 : SimpleValue_9 {
  public readonly bool b_;

  public GBool_9(bool b) { b_ = b; }

  public override bool Equals(object o) {
    GBool_9 b = o as GBool_9;
    return b != null && b.b_ == b_;
  }

  public override int GetHashCode() { return b_.GetHashCode(); }

  public override SimpleValue_9 ^Copy() { return new GBool_9(b_); }

  public static readonly BoolClass_9 ^type_ = new BoolClass_9();

  public override GType_9 Type() { return type_; }

  public override string ToString() { return b_.ToString(); }

  public override string Emit() { return b_ ? "true" : "false"; }
}

class GInt_9 : SimpleValue_9 {
  public readonly int i_;

  public GInt_9(int i) { i_ = i; }

  public static readonly IntClass_9 ^type_ = new IntClass_9();

  public override GType_9 Type() { return type_; }

  public override bool Equals(object o) {
    GInt_9 i = o as GInt_9;
    return i != null && i.i_ == i_;
  }

  public override int GetHashCode() { return i_.GetHashCode(); }

  public override SimpleValue_9 ^Copy() { return new GInt_9(i_); }

  public override RValue_9 ^Convert(ref RValue_9 ^this_own, GType_9 t) {
    if (t == GFloat_9.type_)
      return new GFloat_9(i_);
    if (t == GDouble_9.type_)
      return new GDouble_9(i_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_9 ^ConvertExplicit(ref RValue_9 ^this_own, GType_9 t) {
    return t == GChar_9.type_ ? new GChar_9((char) i_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return i_.ToString(); }

  public override string Emit() { return i_.ToString(); }
}

class GFloat_9 : SimpleValue_9 {
  public readonly float f_;

  public GFloat_9(float f) { f_ = f; }

  public static readonly FloatClass_9 ^type_ = new FloatClass_9();

  public override GType_9 Type() { return type_; }

  public override bool Equals(object o) {
    GFloat_9 f = o as GFloat_9;
    return f != null && f.f_ == f_;
  }

  public override int GetHashCode() { return f_.GetHashCode(); }

  public override SimpleValue_9 ^Copy() { return new GFloat_9(f_); }

  public override RValue_9 ^Convert(ref RValue_9 ^this_own, GType_9 t) {
    if (t == GDouble_9.type_)
      return new GDouble_9(f_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_9 ^ConvertExplicit(ref RValue_9 ^this_own, GType_9 t) {
    return t == GInt_9.type_ ? new GInt_9((int) f_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return f_.ToString(); }

  public override string Emit() {
    string s = f_.ToString();
    return s + (s.IndexOf('.') == -1 ? ".0f" : "f");
  }
}

class GDouble_9 : SimpleValue_9 {
  public readonly double d_;

  public GDouble_9(double d) { d_ = d; }

  public static readonly DoubleClass_9 ^type_ = new DoubleClass_9();

  public override GType_9 Type() { return type_; }

  public override bool Equals(object o) {
    GDouble_9 d = o as GDouble_9;
    return d != null && d.d_ == d_;
  }

  public override int GetHashCode() { return d_.GetHashCode(); }

  public override SimpleValue_9 ^Copy() { return new GDouble_9(d_); }

  public override RValue_9 ^ConvertExplicit(ref RValue_9 ^this_own, GType_9 t) {
    if (t == GInt_9.type_)
      return new GInt_9((int) d_);
    if (t == GFloat_9.type_)
      return new GFloat_9((float) d_);
    return base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return d_.ToString(); }

  public override string Emit() {
    string s = d_.ToString();
    if (s.IndexOf('.') == -1)
      s = s + ".0";
    return s;
  }
}

class GChar_9 : SimpleValue_9 {
  public readonly char c_;

  public GChar_9(char c) { c_ = c; }

  public static readonly CharClass_9 ^type_ = new CharClass_9();

  public override GType_9 Type() { return type_; }

  public override bool Equals(object o) {
    GChar_9 c = o as GChar_9;
    return c != null && c.c_ == c_;
  }

  public override int GetHashCode() { return c_.GetHashCode(); }

  public override SimpleValue_9 ^Copy() { return new GChar_9(c_); }

  public override RValue_9 ^Convert(ref RValue_9 ^this_own, GType_9 t) {
    return t == GInt_9.type_ ? new GInt_9(c_) : base.Convert(ref this_own, t);
  }

  public override string ToString() { return c_.ToString(); }

  public static string Emit(char c) {
    switch (c) {
      case '\0': return "\\0";
      case '\n': return "\\n";
      case '\r': return "\\r";
      case '\t': return "\\t";
      case '\'': return "\\'";
      case '\"': return "\\\"";
      case '\\': return "\\\\";
    }
    if (c < 32) {
      Debug.Assert(false); return null;
    }
    return c.ToString();
  }

  public override string Emit() {
    return String.Format("'{0}'", Emit(c_));
  }
}

abstract class LocationOrRef_9 : ValueOrLocation_9 {
  public abstract Location_9 GetLoc();
}

class Location_9 : LocationOrRef_9 {
  public RValue_9 ^value_;

  public Location_9(RValue_9 ^val) { value_ = val; }

  public override GValue_9 Get() { return value_.Get(); }

  public override Location_9 GetLoc() { return this; }
}

// We allocate a LocationRef_9 when we need an owning reference to a Location_9 which we don't own.
class LocationRef_9 : LocationOrRef_9 {
  public readonly Location_9 location_;

  public LocationRef_9(Location_9 loc) { location_ = loc; }

  public override GValue_9 Get() { return location_.Get(); }

  public override Location_9 GetLoc() { return location_; }
}

class MapNode_9 {
  public readonly MapNode_9 ^next_;
  public readonly object key_;
  public ValueOrLocation_9 ^value_;   // (must appear after next_ so it will be destroyed first)

  public MapNode_9(object key, ValueOrLocation_9 ^value, MapNode_9 ^next) {
    key_ = key; value_ = value; next_ = next;
  }
}

class Map_9 {
  MapNode_9 ^nodes_;

  protected MapNode_9 Find1(object key) {
    for (MapNode_9 n = nodes_; n != null; n = n.next_)
      if (n.key_ == key)
        return n;
    return null;
  }

  protected virtual MapNode_9 Find(object key) {
    MapNode_9 n = Find1(key);
    Debug.Assert(n != null);
    return n;
  }

  public RValue_9 ^Get(object key) {
    return Find(key).value_.Get().CopyRef();
  }

  public RValue_9 ^Take_9(object key) {
    MapNode_9 n = Find(key);
    LocationOrRef_9 l = n.value_ as LocationOrRef_9;
    if (l != null)
      return take l.GetLoc().value_;
    return (RValue_9) take n.value_;
  }

  public void Set(object key, RValue_9 ^val) {
    MapNode_9 n = Find(key);
    LocationOrRef_9 l = n.value_ as LocationOrRef_9;
    if (l != null)
      l.GetLoc().value_ = val;
    else n.value_ = val;
  }

  public void Add(object key, ValueOrLocation_9 ^val) {
    nodes_ = new MapNode_9(key, val, take nodes_);
  }

  public Location_9 GetLocation(object key) {
    MapNode_9 n = Find(key);
    LocationOrRef_9 l = n.value_ as LocationOrRef_9;
    if (l != null)
      return l.GetLoc();
    Location_9 ^loc1 = new Location_9((RValue_9) take n.value_);
    Location_9 loc = loc1;
    n.value_ = loc1;
    return loc;
  }
}

class GObject_9 : GValue_9 {
  public readonly Class_9 class_;   // the class of this object

  Map_9 ^map_ = new Map_9();

  public GObject_9(Class_9 cl) {
    class_ = cl;
    while (cl != null) {
      foreach (Field_9 f in cl.fields_)
        map_.Add(f, f.Type().DefaultValue_9().Copy() );
      cl = cl.Parent();
    }
  }

  // the type of this object
  public override GType_9 Type() { return class_; }

  public override RValue_9 ^Get(Field_9 field) { return map_.Get(field); }
  public override RValue_9 ^Take_9(Field_9 field) { return map_.Take_9(field); }
  public void Set(Field_9 field, RValue_9 ^val) { map_.Set(field, val); }
  public Location_9 GetLocation(Field_9 field) { return map_.GetLocation(field); }

  public override int DefaultHashCode() { return base.GetHashCode(); }
  public override int GetHashCode() {
    GInt_9 ^i = (GInt_9) Invocation_9.InvokeMethod(this, GObject_9.type_.get_hash_code_, new ArrayList(), true);
    return i.i_;
  }

  public override bool DefaultEquals(object o) { return base.Equals(o); }
  public override bool Equals(object o) {
    GValue_9 v = o as GValue_9;
    if (v == null)
      return false;

    ArrayList ^args = new ArrayList();
    args.Add(v.CopyRef());
    GBool_9 ^b = (GBool_9) Invocation_9.InvokeMethod(this, GObject_9.type_.equals_, args, true);
    return b.b_;
  }

  public override string DefaultToString() { return String.Format("<object {0}>", class_.name_); }
  public override string ToString() {
    GString_9 ^s = (GString_9) Invocation_9.InvokeMethod(this, GObject_9.type_.to_string_, new ArrayList(), true);
    return s.s_;
  }

  // the Object class
  public static readonly ObjectClass_9 ^type_ = new ObjectClass_9();
}

class NullType_9 : GType_9 {
  public override string ToString() { return "null_type"; }

  public override SimpleValue_9 DefaultValue_9() { Debug.Assert(false); return null; }

  public override bool IsSubtype(GType_9 t1) {
    return t1.IsReference();
  }

  protected override bool CanConvertOwnership(GType_9 t, int context) {
    return true;    // conversion from null type to owning type is okay
  }

  public override string EmitType() { Debug.Assert(false); return null; }
}

class Null_9 : SimpleValue_9 {
  public Null_9() { }

  public static readonly NullType_9 ^type_ = new NullType_9();

  public override GType_9 Type() { return type_; }

  public override bool Equals(object o) {
    return o is Null_9;
  }

  public override SimpleValue_9 ^Copy() { return new Null_9(); }

  public override int GetHashCode() { return 0; }

  public static readonly Null_9 ^Instance = new Null_9();

  public override string ToString() { return ""; }

  public override string Emit() { return "0"; }
}

class Owning_9 : GType_9 {
  GType_9 base_type_;

  public Owning_9(GType_9 type) {
    base_type_ = type;
  }

  public override Class_9 Parent() { Debug.Assert(false); return null; }

  public override SimpleValue_9 DefaultValue_9() { return Null_9.Instance; }

  public override GType_9 BaseType() { return base_type_; }

  public override TypeSet_9 VarDestroys() { return base_type_.TypeDestroys(); }

  public override void FindVarDestroys(int marker, TypeSet_9 set) {
    base_type_.FindTypeDestroys(marker, set);
  }

  public override bool Equals(object o) {
    Owning_9 t = o as Owning_9;
    return t != null && t.base_type_.Equals(base_type_);
  }

  public override int GetHashCode() { return base_type_.GetHashCode() * 87; }

  public override string ToString() { return base_type_.ToString() + " ^"; }

  public override string EmitTypeName() {
    return base_type_.EmitTypeName();
  }

  string EmitType(string name) {
    return ConstructType(base_type_ == GObject_9.type_ ? "_OwnRef" : "_Own", name);
  }

  public override string EmitType() {
    // We represent an object ^ using a _OwnRef<Object>.
    // We represent a Foo ^ using an _Own<Foo>.
    return EmitType(EmitTypeName());
  }

  public override string EmitGenericType() {
    // We represent an object ^ [] using an _Array<_OwnRef<Object>>.
    // We represent a Foo ^ [] using an _Array<_Own<Object>>.
    return EmitType("Object");
  }
}

class OwningExpr_9 : TypeExpr_9 {
  readonly TypeExpr_9 ^expr_;

  public OwningExpr_9(TypeExpr_9 ^expr) { expr_ = expr; }

  public override TypeExpr_9 ^Copy() { return new OwningExpr_9(expr_.Copy()); }

  public override GType_9 Resolve(Program_9 program) {
    GType_9 t = expr_.Resolve(program);
    if (t == null)
        return null;
    if (t.IsValue()) {
      Error("^ cannot be applied to primitive types or strings");
      return null;
    }
    return t.OwningType();
  }
}

class GString_9 : SimpleValue_9 {
  public readonly string s_;

  public GString_9(string s) { s_ = s; }

  public static readonly StringClass_9 ^type_ = new StringClass_9();

  public override GType_9 Type() { return type_; }

  public override bool Equals(object o) {
    GString_9 s = o as GString_9;
    return s != null && s.s_ == s_;
  }

  public override SimpleValue_9 ^Copy() { return new GString_9(s_); }

  public override int GetHashCode() { return s_.GetHashCode(); }

  public override string ToString() { return s_; }

  public override RValue_9 ^Invoke(Method_9 m, ValueList_9 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StartsWith": return new GBool_9(s_.StartsWith(args.GetString(0)));
      case "EndsWith": return new GBool_9(s_.EndsWith(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public static string EmitStringConst(string s) {
    return String.Format("L{0}", EmitString(s));
  }

  public static string EmitString(string s) {
    StringBuilder ^sb = new StringBuilder();
    sb.Append('"');
    for (int i = 0; i < s.Length; ++i)
      sb.Append(GChar_9.Emit(s[i]));
    sb.Append('"');
    return sb.ToString();
  }

  public override string Emit() {
    string s = String.Format("new String({0})", EmitStringConst(s_));
    s = String.Format("_Ref<String>({0}).Get()", s);
    return s;
  }
}

abstract class Ownable_9 : GType_9 {
  Owning_9 ^owning_type_;

  public override Owning_9 OwningType() {
    if (owning_type_ == null)
      owning_type_ = new Owning_9(this);
    return owning_type_;
  }
}

class ArrayType_9 : Ownable_9 {
  GType_9 element_type_;

  public ArrayType_9(GType_9 type) {
    element_type_ = type;

    // Any type used generically must inherit from Object in C++ code.
    type.BaseType().SetObjectInherit();
  }

  public override bool IsOwned() { return true; }

  public override Class_9 Parent() { return GArray_9.array_class_; }

  public override SimpleValue_9 DefaultValue_9() { return Null_9.Instance; }

  public GType_9 ElementType() { return element_type_; }

  public override bool Equals(object o) {
    ArrayType_9 t = o as ArrayType_9;
    return (t != null && t.element_type_.Equals(element_type_));
  }

  public override TypeSet_9 TypeDestroys() { return element_type_.VarDestroys(); }

  public override void FindTypeDestroys(int marker, TypeSet_9 set) {
    element_type_.FindVarDestroys(marker, set);
  }

  public override int GetHashCode() { return element_type_.GetHashCode() * 77; }

  public override string EmitTypeName() {
    return ConstructType("_Array", element_type_.EmitGenericType());  
  }

  public override string ToString() {
    return element_type_.ToString() + "[]";
  }
}

class ArrayTypeExpr_9 : TypeExpr_9 {
  readonly TypeExpr_9 ^expr_;
  GType_9 ^type_;

  public ArrayTypeExpr_9(TypeExpr_9 ^expr) { expr_ = expr; }

  public override TypeExpr_9 ^Copy() { return new ArrayTypeExpr_9(expr_.Copy()); }

  public override GType_9 Resolve(Program_9 program) {
    GType_9 t = expr_.Resolve(program);
    return t == null ? null : (type_ = new ArrayType_9(t));
  }
}

class GArray_9 : GValue_9 {
  ArrayType_9 type_;

  ValueOrLocation_9^[] ^elements_;   // each element is a GValue_9 or a Location_9

  public override GType_9 Type() { return type_; }

  public GArray_9(ArrayType_9 type, int count) {
    type_ = type;
    elements_ = new ValueOrLocation_9^[count];
    for (int i = 0 ; i < count ; ++i)
      elements_[i] = type_.ElementType().DefaultValue_9().Copy();
  }

  void CheckIndex(int index) {
    if (index < 0 || index >= elements_.Length) {
      Console.WriteLine("error: array access out of bounds");
      Gel_9.Exit();
    }
  }

  public RValue_9 ^Get(int index) {
    CheckIndex(index);
    return elements_[index].Get().CopyRef();
  }

  public RValue_9 ^Take_9(int index) {
    CheckIndex(index);
    Location_9 loc = elements_[index] as Location_9;
    if (loc != null)
      return take loc.value_;
    return (RValue_9) (take elements_[index]);
  }

  public void Set(int index, RValue_9 ^val) {
    CheckIndex(index);
    Location_9 loc = elements_[index] as Location_9;
    if (loc != null)
      loc.value_ = val;
    else elements_[index] = val;
  }

  public Location_9 GetLocation(int index) {
    CheckIndex(index);
    Location_9 loc = elements_[index] as Location_9;
    if (loc != null)
      return loc;
    Location_9 ^loc1 = new Location_9((RValue_9) take elements_[index]);
    loc = loc1;
    elements_[index] = loc1;
    return loc;
  }

  public static readonly ArrayClass_9 ^array_class_ = new ArrayClass_9();

  public override RValue_9 ^Invoke(Method_9 m, ValueList_9 args) {
    if (m.GetClass() != array_class_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "CopyTo":
        GArray_9 a = (GArray_9) args.Object(0);
        if (!type_.Equals(a.type_)) {
          Console.WriteLine("error: can't copy between arrays of different types");
          Gel_9.Exit();
        }
        if (a.type_.ElementType() is Owning_9) {
          Console.WriteLine("error: can't copy to owning array");
          Gel_9.Exit();
        }
        // should check for index out of bounds here!
        int dest = args.Int(1);
        for (int i = 0 ; i < elements_.Length ; ++i)
          a.Set(dest + i, Get(i));
        return null;
      case "get_Length":
        return new GInt_9(elements_.Length);
      default:
        Debug.Assert(false); return null;
    }
  }
}

// A control graph object representing temporary variables destroyed when a top-level
// expression completes evaluation. 
class Temporaries_9 : Node_9 {
  NonOwningArrayList /* of GType_9 */ ^types_ = new NonOwningArrayList();
  TypeSet_9 ^destroys_;

  public void Add(GType_9 t) {
    Debug.Assert(t is Owning_9);
    types_.Add(t.BaseType());
  }

  public override TypeSet_9 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_9();
    foreach (GType_9 t in types_)
        destroys_.Add(t.TypeDestroys());
    }
    return destroys_;
  }
}

class Context_9 {
  public readonly Program_9 program_;   // containing program
  public readonly Class_9 class_;       // containing class
  public readonly Method_9 method_;     // containing method
  public readonly Escapable_9 escape_;  // containing switch, while, do, for, or foreach
  public readonly Loop_9 loop_;         // containing while, do, for, or foreach
  public Local_9 var_;    // chain of local variable declarations

  // subexpressions of the current top-level expression possibly yielding temporary objects
  NonOwningArrayList /* of Expression_9 */ ^temporaries_ = new NonOwningArrayList();

  public Context_9(Program_9 program) { program_ = program; }

  public Context_9(Class_9 cl) { program_ = cl.GetProgram(); class_ = cl; }

  // Copy a context; new variable declarations in either copy will not be visible in the other.
  public Context_9(Context_9 cx) {
    program_ = cx.program_;
    class_ = cx.class_;
    method_ = cx.method_;
    escape_ = cx.escape_;
    loop_ = cx.loop_;
    var_ = cx.var_;
  }

  public Context_9(Context_9 cx, Class_9 c) : this(cx) { class_ = c; }

  public Context_9(Context_9 cx, Method_9 m) : this(cx) { method_ = m; }

  public Context_9(Context_9 cx, Loop_9 l) : this(cx) {
    escape_ = l;
    loop_ = l;
  }

  public Context_9(Context_9 cx, Switch_9 s) : this(cx) { escape_ = s; }

  public bool IsStatic() { return method_ == null || method_.IsStatic(); }

  public void SetVar(Local_9 var) {
    var_ = var;
  }

  public Local_9 FindVar(string name) {
    for (Local_9 v = var_; v != null; v = v.next_)
      if (v.name_ == name)
        return v;
    return null;
  }

  public Control_9 Prev() { return program_.prev_; }

  public void SetPrev(Control_9 c) {
    Debug.Assert(c != null);
    program_.prev_ = c;
  }

  public void ClearPrev() { program_.prev_ = null; }

  // Called when we begin type-checking a top-level expression.
  public void EnterExpression() {
    Debug.Assert(temporaries_.Count == 0);
  }

  public void AddTemporary(Expression_9 e) {
    temporaries_.Add(e);
  }

  // Called when we've finished type-checking a top-level expression.
  public void FinishExpression() {
    Temporaries_9 t = null;
    foreach (Expression_9 e in temporaries_)
      if (!e.LosesOwnership()) {
        if (t == null)
          t = class_.NewTemporaries();
        t.Add(e.TemporaryType());
      }
    if (t != null)
      t.AddControl(this);
    temporaries_.Clear();
  }
}

class Env_9 : Map_9 {
  public readonly GValue_9 this_;
  readonly Env_9 next_;

  public Env_9(GValue_9 _this) { this_ = _this; next_ = null; }
  public Env_9(Env_9 next) { this_ = next.this_; next_ = next; }

  protected override MapNode_9 Find(object key) {
    for (Env_9 e = this; e != null; e = e.next_) {
      MapNode_9 n = e.Find1(key);
      if (n != null)
        return n;
    }
    Debug.Assert(false);
    return null;
  }

  public static readonly Env_9 ^static_ = new Env_9((GValue_9) null);
}

class TypeLiteral_9 : TypeExpr_9 {
  public readonly GType_9 type_;

  public TypeLiteral_9(GType_9 type) { type_ = type; }

  public override GType_9 Resolve(Program_9 program) {
    return type_;
  }

  public override TypeExpr_9 ^Copy() { return new TypeLiteral_9(type_); }
}

class TypeName_9 : TypeExpr_9 {
  string name_;

  public TypeName_9(string name) { name_ = name; }

  public override GType_9 Resolve(Program_9 program) {
    GType_9 type = program.FindClass(name_);
    if (type == null)
      Error("unknown type: {0}", name_);
    return type;
  }

  public override TypeExpr_9 ^Copy() { return new TypeName_9(name_); }
}

abstract class Traverser_9 {
  // Handle a graph item found in a depth first search; returns one of the exit codes below.
  public abstract int Handle(Control_9 control);

  public const int Continue_9 = 0,  // continue searching, including children of this node
                   Cut = 1,       // continue searching, excluding children of this node
                   Abort = 2;     // abort the search

}

// an item in the control graph: either a Node_9 or Joiner_9
abstract class Control_9 : Syntax_9 {
  public int marker_ = 0;    // marker for depth first search of control flow graph

  static int marker_value_ = 0;
  public static int GetMarkerValue() { return ++marker_value_; }

  // A node representing unreachability.  We could represent this using null, but it's
  // clearer to have this be explicit. 
  public static readonly Node_9 ^unreachable_ = new Node_9();

  // A helper function for Traverse.  If_9 we return true then we should cut the
  // traversal at this point.
  protected bool Visit(Traverser_9 traverser, int marker, out bool ok) {
    ok = true;
    if (marker_ == marker)
      return true;  // we've already seen this node
    marker_ = marker;
    int code = traverser.Handle(this);
    if (code == Traverser_9.Abort)
      ok = false;
    return (code != Traverser_9.Continue_9);
  }

  // Perform a depth-first search of the graph starting with this item, calling the
  // given Traverser_9 for each Node_9 found.  Returns false if the search was aborted.
  public abstract bool Traverse(Traverser_9 traverser, int marker);
}

// A node in the control graph.
class Node_9 : Control_9 {
  public Control_9 prev_;   // previous item in graph

  // add this node to the control graph
  public bool AddControl(Context_9 ctx) {
    Control_9 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      prev_ = prev;
      ctx.SetPrev(this);
      return true;
    }
    else return false;
  }

  // If_9 this node calls a method or constructor then return it; otherwise return null.
  // implementers: LValue_9, Invocation_9, New_9, Assign_9, Constructor_9
  public virtual Method_9 Calls() { return null; }

  // Return_9 the set of types which this node may destroy.
  // implementers: Assign_9, RefOutArgument_9, Scoped_9, Temporaries_9
  public virtual TypeSet_9 NodeDestroys() { return TypeSet_9.empty_; }

  // Return_9 true if this node assigns a value to the given Local_9.
  // implementers: Assign_9, RefOutArgument_9, VariableDeclaration_9, Method_9, ForEach_9
  public virtual bool Sets(Local_9 local) { return false; }

  // Return_9 true if this node takes ownership from the given local.
  // implementers: Name_9
  public virtual bool Takes(Local_9 local) { return false; }

  public bool CanDestroy(GType_9 type) {
    Method_9 m = Calls();
    if (m != null && m.Destroys().Contains(type))
      return true;
    return NodeDestroys().Contains(type);
  }

  public override bool Traverse(Traverser_9 traverser, int marker) {
    Node_9 n = this;
    Control_9 prev = null;

    // Traverse nodes iteratively until we come to a Join; this efficiently avoids
    // making a recursive call on each successive node.
    while (n != null) {
      bool ok;
      if (n.Visit(traverser, marker, out ok))
        return ok;
      prev = n.prev_;
      n = prev as Node_9;
    }
    Debug.Assert(prev != null);  // a Traverser_9 must end traversal before we run off the end
    return prev.Traverse(traverser, marker);
  }
}

class Joiner_9 : Control_9 {
  NonOwningArrayList /* of Control_9 */ ^prev_ = new NonOwningArrayList();

  public void Join(Control_9 c) {
    Debug.Assert(c != null);
    if (c == unreachable_)
      return;
    if (prev_.Count == 0 || c != prev_[0])
      prev_.Add(c);
  }

  // add this joiner to the control graph
  public void AddControl(Context_9 ctx) {
    Control_9 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      Join(prev);
      ctx.SetPrev(this);
    }
  }

  // Once we've finished merging paths into a Joiner_9, if the Joiner_9 points to only a single path
  // then as an optimization we can discard the Joiner_9 and just use that path instead.
  public Control_9 Combine() {
    switch (prev_.Count) {
      case 0:
        prev_ = null;
        return unreachable_;
      case 1:
        Control_9 c = (Control_9) prev_[0];
        prev_ = null;
        return c;
      default: return this;
    }
  }

  public override bool Traverse(Traverser_9 traverser, int marker) {
    bool ok;
    if (Visit(traverser, marker, out ok))
      return ok;

    foreach (Control_9 p in prev_)
      if (!p.Traverse(traverser, marker))
        return false;  // aborted
    return true;
  }
}

class ExprKind_9 {
  public const int Value = 0,

  // either a local variable, or an expression whose value is derived from local variables
                   Local_9 = 1,

                   Field_9 = 2,
                   Property_9 = 3,
                   Indexer_9 = 4,
                   Type = 5;
}

class SourceWriter_9 {
  public readonly StreamWriter writer_;
  int indent_ = 0;

  public SourceWriter_9(StreamWriter writer) { writer_ = writer; }

  public void AddIndent() { ++indent_; }
  public void SubIndent() { --indent_; }

  public void Indent(int adjust) {
    for (int i = 0; i < 2 * indent_ + adjust; ++i)
      writer_.Write(' ');
  }

  public void Indent() { Indent(0); }

  public void Write(string s) { writer_.Write(s); }
  public void Write(string s, object arg) { writer_.Write(s, arg); }
  public void Write(string s, object arg1, object arg2) { writer_.Write(s, arg1, arg2); }
  public void Write(string s, object arg1, object arg2, object arg3) { writer_.Write(s, arg1, arg2, arg3); }

  public void IWrite(string s) { Indent(); Write(s); }
  public void IWrite(string s, object arg) { Indent(); Write(s, arg); }
  public void IWrite(string s, object arg1, object arg2) { Indent(); Write(s, arg1, arg2); }
  public void IWrite(string s, object arg1, object arg2, object arg3) { Indent(); Write(s, arg1, arg2, arg3); }

  public void WriteLine(string s) { writer_.WriteLine(s); }
  public void WriteLine(string s, object arg) { writer_.WriteLine(s, arg); }
  public void WriteLine(string s, object arg1, object arg2) { writer_.WriteLine(s, arg1, arg2); }
  public void WriteLine(string s, object arg1, object arg2, object arg3) { writer_.WriteLine(s, arg1, arg2, arg3); }

  public void IWriteLine(string s) { Indent(); WriteLine(s); }
  public void IWriteLine(string s, object arg) { Indent(); WriteLine(s, arg); }
  public void IWriteLine(string s, object arg1, object arg2) { Indent(); WriteLine(s, arg1, arg2); }
  public void IWriteLine(string s, object arg1, object arg2, object arg3) { Indent(); WriteLine(s, arg1, arg2, arg3); }

  public void OpenBrace() { WriteLine("{"); AddIndent(); }
  public void CloseBrace() { SubIndent(); IWriteLine("}"); }
}

class Usage_9 {
  public const int Used = 0, LosesOwnership = 1, Unused = 2;
}

abstract class Expression_9 : Node_9 {
  protected int usage_ = Usage_9.Used;

  // start_ and end_ mark the points in the control graph where this expression is evaluated and used,
  // respectively.  If_9 this expression's type is owned, we use this information to determine whether
  // we need to emit a reference count for this expression.
  Control_9 start_;
  Control_9 end_;

  public abstract GType_9 Check(Context_9 ctx);

  public GType_9 CheckTop(Context_9 ctx) {
    ctx.EnterExpression();
    GType_9 t = Check(ctx);
    ctx.FinishExpression();
    return t;
  }

  public GType_9 CheckAndHold(Context_9 ctx) {
    GType_9 t = Check(ctx);
    if (t != null)
      HoldRef(ctx);
    return t;
  }

  // A fancier checking protocol implemented by lvalues and used by certain callers.
  public virtual GType_9 Check(Context_9 ctx, bool read, bool write, bool type_ok) {
    return Check(ctx);
  }

  public virtual int Kind() { return ExprKind_9.Value; }
  public virtual bool IsRefOutParameter() { return false; }

  public virtual bool IsTrueLiteral() { return false; }
  public virtual bool IsFalseLiteral() { return false; }

  // If_9 this expression is a local variable (possibly cast to a different type),
  // then return that local; otherwise return null.
  public virtual Local_9 GetLocal() { return null; }

  // Return_9 the type of an expression yielding a temporary object.
  // (It might be convenient to generalize this to be able to return any expression's type.)
  public virtual GType_9 TemporaryType() { Debug.Assert(false); return null; }

  public void HoldRef(Context_9 ctx) {
    start_ = ctx.Prev();
    Debug.Assert(start_ != null);
  }

  public void ReleaseRef(Context_9 ctx) {
    end_ = ctx.Prev();
    Debug.Assert(end_ != null);
  }

  public abstract RValue_9 ^Eval(Env_9 env);

  public bool Check(Context_9 ctx, GType_9 t2) {
    GType_9 t = Check(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public bool CheckTop(Context_9 ctx, GType_9 t2) {
    GType_9 t = CheckTop(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public RValue_9 ^Eval(Env_9 env, GType_9 t) {
    RValue_9 ^r = Eval(env);
    GValue_9 v = r.Get();
    return v.Convert(ref r, t);
  }

  public bool EvalBool(Env_9 env) { return ((GBool_9) Eval(env)).b_; }

  public int EvalInt(Env_9 env) {
    RValue_9 ^r = Eval(env, GInt_9.type_);
    GInt_9 i = (GInt_9) r;
    return i.i_;
  }

  public double EvalDouble(Env_9 env) { return ((GDouble_9) Eval(env, GDouble_9.type_)).d_; }
  public float EvalFloat(Env_9 env) { return ((GFloat_9) Eval(env, GFloat_9.type_)).f_; }
  public string EvalString(Env_9 env) { return ((GString_9) Eval(env)).s_; }

  public virtual bool IsConstant() {
    return false;
  }

  public bool CheckConstant() {
    if (IsConstant())
      return true;
    Error("expression must be a constant");
    return false;
  }

  public bool LosesOwnership() { return usage_ == Usage_9.LosesOwnership; }

  public virtual void LoseOwnership() {
    usage_ = Usage_9.LosesOwnership;
  }

  public void SetUnused() {
    Debug.Assert(usage_ == Usage_9.Used);
    usage_ = Usage_9.Unused;
  }

  protected static string EmitAllocate(string type, string args, bool lose_ownership) {
    // If_9 an allocated object never loses ownership then it can be stack allocated.  We
    // can't emit "&Foo(...)" since standard C++ doesn't allow us to take the address
    // of a temporary (both GCC and Visual C++ will allow this, but will emit a warning).
    // So instead we call a function _Addr() to get the address.
    return String.Format(
      !lose_ownership ? "{0}({1})._Addr<{0} *>()" : "new {0}({1})",
      type, args);
  }

  public void CheckLoseOwnership(GType_9 from, GType_9 to) {
    if (to is Owning_9)
      LoseOwnership();
  }

  public abstract string Emit();    // return a C++ expression representing this GEL2 expression

  public bool NeedsRef(GType_9 type) {
    return Gel_9.program_.safe_ && type.IsOwned() && ExpressionTraverser_9.NeedRef(start_, end_, this, type);
  }

  // Emit this expression, adding a reference-counting _Ptr wrapper if needed.
  public string EmitRef(GType_9 type) {
    string s = Emit();
    if (NeedsRef(type))
      s = String.Format("{0}({1}).Get()", type.EmitType(), s);
    return s;
  }

  // Emit an implicit conversion from type [source] to type [dest].
  public static string EmitImplicit(GType_9 source, GType_9 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (!source.IsReference() && dest == GObject_9.type_) {   // a boxing conversion
      Class_9 c = (Class_9) source;
      return EmitAllocate(c.name_, val, loses_ownership);
    }

    if (source == GInt_9.type_ && dest == GFloat_9.type_)
      // an implicit conversion in GEL2, but C++ compilers may warn if we don't use a cast
      return String.Format("static_cast<float>({0})", val);
    
    return val;
  }

  // Emit this expression, converting implicitly from type [source] to type [dest].
  public string Emit(GType_9 source, GType_9 dest) {
    return EmitImplicit(source, dest, Emit(), LosesOwnership());
  }

  public string EmitRef(GType_9 source, GType_9 dest) {
    return EmitImplicit(source, dest, EmitRef(source), LosesOwnership());
  }

  public static string EmitExplicit(GType_9 source, GType_9 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (source.CanConvert(dest)) {
      string v = EmitImplicit(source, dest, val, loses_ownership);
      if (v != val)
        return v;

      // There's nothing to do, but we emit a static_cast anyway since a GEL2 programmer
      // may use a type cast for method call disambiguation; we want to pass such casts onward.
      return String.Format("static_cast<{0} >({1})", dest.EmitExprType(), val);
    }

    if (source.IsReference() && dest.IsReference()) {
      string s = String.Format("_Cast<{0} *>({1})", dest.EmitTypeName(), val);
      ArrayType_9 at = dest as ArrayType_9;
      if (at != null) {
        GType_9 element_type = at.ElementType();
        if (element_type.IsReference())
          s = String.Format("({0})->CheckType(&typeid({1}))", s, element_type.EmitType());
      }
      return s;
    }

    if (source == GObject_9.type_ && !dest.IsReference())  // unboxing conversion
      return String.Format("_Unbox<{0} *>({1})->Value()", ((Class_9) dest).name_, val);

    if (!source.IsReference() && !dest.IsReference())
      return String.Format("static_cast<{0}>({1})", dest.EmitType(), val);

    Debug.Assert(false);
    return null;
  }

  public string EmitExplicit(GType_9 source, GType_9 dest) {
    return EmitExplicit(source, dest, Emit(), LosesOwnership());
  }

  public virtual string EmitArrow(GType_9 t, Member_9 m) {
    return String.Format("({0})->", EmitRef(t));
  }

  // Emit this expression as a local or field initializer, implicitly casting to [type].
  public void EmitAsInitializer(SourceWriter_9 w, GType_9 initializer_type, GType_9 type) {
    // For_9 owning variables, we must emit an initializer of the form "Foo var(val)" since
    // _Own has no copy constructor and hence GCC won't allow "Foo var = val".  For_9 other
    // variables either form is valid, but we emit the second form since it looks clearer.
    w.Write(type is Owning_9 ? "({0})" : " = {0}", Emit(initializer_type, type));
  }

  // Given a value retrieved from a variable, emit an accessor call if needed.
  protected string OwnSuffix(GType_9 t) {
    if (t is Owning_9)
      return LosesOwnership() ? ".Take_9()" : ".Get()";
    if (t == GString_9.type_ || Gel_9.program_.safe_ && t.IsReference() )
      return ".Get()";
    return "";
  }

  // Given a value returned from a function call, emit a wrapper and/or accessor call if needed.
  protected string Hold(GType_9 t, string s) {
    if (t == GString_9.type_)
      return s + ".Get()";
    if (t is Owning_9)
      switch (usage_) {
        case Usage_9.Used:  // does not lose ownership; we need a freeing wrapper
          return String.Format("{0}({1}).Get()", t.EmitType(), s);
        case Usage_9.LosesOwnership:
          return s;
        case Usage_9.Unused:  // a top-level owning expression
          return "delete " + s;
        default: Debug.Assert(false); break;
      }
    return s;
  }
}

class Literal_9 : Expression_9 {
  public readonly SimpleValue_9 ^value_;

  public Literal_9(SimpleValue_9 ^v) { value_ = v; }

  public override bool IsTrueLiteral() {
    GBool_9 b = value_ as GBool_9;
    return b != null && b.b_;
  }

  public override bool IsFalseLiteral() {
    GBool_9 b = value_ as GBool_9;
    return b != null && !b.b_;
  }

  public override GType_9 Check(Context_9 ctx) { return value_.Type(); }

  public override RValue_9 ^Eval(Env_9 env) { return value_.Copy(); }

  public override bool IsConstant() { return true; }

  public override string Emit() { return value_.Emit(); }
}

// An LValue_9 is an expression which can be assigned to: a Name_9, Dot_9, or Sub_9.
//
// In the control graph, an LValue_9 represents a read; if an LValue_9 is written then
// some other node (e.g. an Assign_9) will appear representing the write.
abstract class LValue_9 : Expression_9 {
  public override GType_9 Check(Context_9 ctx) {
    return Check(ctx, true, false, false);
  }

  public abstract override GType_9 Check(Context_9 ctx, bool read, bool write, bool type_ok);

  public abstract GType_9 StorageType();

  public virtual bool IsLocal() { return false; }
  public virtual bool IsLocal(Local_9 l) { return false; }

  public abstract PropertyOrIndexer_9 GetPropertyOrIndexer();

  public override Method_9 Calls() {
    PropertyOrIndexer_9 pi = GetPropertyOrIndexer();
    return pi == null ? null : pi.Getter();
  }

  public virtual void ReleaseAll(Context_9 ctx) { }

  // For_9 LValues, evaluation proceeds in two stages: the caller first calls Eval1(), then
  // passes the resulting values to EvalGet(), EvalSet() and/or EvalLocation().  This_9 lets
  // us evaluate the left side of an assignment expression before evaluating the right side,
  // and also lets us get and then set an indexer without evaluating its expression twice.

  public abstract void Eval1(Env_9 env, out RValue_9 ^v1, out RValue_9 ^v2);
  public abstract RValue_9 ^EvalGet(Env_9 env, RValue_9 ^v1, RValue_9 ^v2);
  public abstract void EvalSet(Env_9 env, RValue_9 ^v1, RValue_9 ^v2, RValue_9 ^val);
  public abstract Location_9 EvalLocation(Env_9 env, RValue_9 ^v1, RValue_9 ^v2);

  public override RValue_9 ^Eval(Env_9 env) {
    RValue_9 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalGet(env, val1, val2);
  }

  public void EvalSet(Env_9 env, RValue_9 ^v) {
    RValue_9 ^val1, val2;
    Eval1(env, out val1, out val2);
    EvalSet(env, val1, val2, v);
  }

  public Location_9 EvalLocation(Env_9 env) {
    RValue_9 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalLocation(env, val1, val2);
  }

  public abstract string EmitSet(string val);

  public abstract string EmitLocation();
}

class Name_9 : LValue_9 {
  public readonly string name_;

  protected Local_9 local_;
  protected LMember_9 field_;  // a field or property

  public Name_9(string n) { name_ = n; }

  public override bool IsLocal() { return local_ != null; }
  public override bool IsLocal(Local_9 l) { return local_ == l; }
  public override bool IsRefOutParameter() { return local_ is RefOutParameter_9; }

  public override bool IsConstant() {
    Debug.Assert(local_ != null || field_ != null);   // make sure we were already type checked
    return field_ is ConstField_9;
  }

  public override GType_9 Check(Context_9 ctx, bool read, bool write, bool type_ok) {
    local_ = ctx.FindVar(name_);
    if (local_ != null) {
      // For_9 reads, we add this Name_9 node to the flow graph; for writes,
      // the caller must add a node which defines this Name_9.
      if (read)
        if (AddControl(ctx))
          local_.AddUse(this);
      if (write)
        local_.SetMutable();
      return local_.ReadType();
    }

    GType_9 cl = type_ok ? ctx.program_.FindClass(name_) : null;
    field_ = (LMember_9) ctx.class_.Lookup(this, ctx.class_, false, MemberKind_9.Field_9, name_, null, cl == null);
    if (field_ != null) {
      if (!field_.CheckAccess(this, ctx, write, true, !ctx.IsStatic()))
        return null;
      if (read) {
        // Only property reads have side effects we need to register in the control graph.
        if (field_ is Property_9)
          AddControl(ctx);
      }
      return field_.Type().BaseType();
    }

    return cl;
  }

  public override int Kind() {
    if (local_ != null)
      return ExprKind_9.Local_9;
    if (field_ is Field_9)
      return ExprKind_9.Field_9;
    if (field_ is Property_9)
      return ExprKind_9.Property_9;
    Debug.Assert(field_ == null);
    return ExprKind_9.Type;
  }

  public override Local_9 GetLocal() { return local_; }

  public override GType_9 StorageType() { return local_ != null ? local_.Type() : field_.Type(); }

  public override bool Takes(Local_9 local) {
    return local_ == local && LosesOwnership() && local.Type() is Owning_9;
  }

  public override PropertyOrIndexer_9 GetPropertyOrIndexer() { return field_ as Property_9; }

  public override void Eval1(Env_9 env, out RValue_9 ^v1, out RValue_9 ^v2) { v1 = v2 = null; }

  public override RValue_9 ^EvalGet(Env_9 env, RValue_9 ^v1, RValue_9 ^v2) {
    if (LosesOwnership() && StorageType() is Owning_9)
      return local_ != null ? env.Take_9(local_) : field_.Take_9(env.this_);
    else return local_ != null ? env.Get(local_) : field_.Get(env.this_);
  }

  public override void EvalSet(Env_9 env, RValue_9 ^v1, RValue_9 ^v2, RValue_9 ^val) {
    if (local_ != null)
      env.Set(local_, val);
    else field_.Set((GObject_9) env.this_, val);
  }

  public override Location_9 EvalLocation(Env_9 env, RValue_9 ^v1, RValue_9 ^v2) {
    return local_ != null ? env.GetLocation(local_) : field_.GetLocation((GObject_9) env.this_);
  }

  public override string Emit() {
    if (local_ != null) {
      string s = local_.Emit();
      return local_.IsWrapper() ? s + OwnSuffix(local_.Type()) : s;
    }
    if (field_ != null)
      return field_.Emit() + OwnSuffix(field_.Type());
    return name_;
  }

  public override string EmitSet(string val) {
    if (local_ != null)
      return String.Format("{0} = {1}", local_.Emit(), val);
    Debug.Assert(field_ != null);
    return field_.EmitSet(val);
  }

  public override string EmitLocation() {
    if (local_ != null)
      return "&" + local_.Emit();
    if (field_ != null)
      return "&" + field_.Emit();
    return "&" + name_;
  }
}

class Parenthesized_9 : Expression_9 {
  Expression_9 ^expr_;

  public Parenthesized_9(Expression_9 ^e) { expr_ = e; }

  public override GType_9 Check(Context_9 ctx) { return expr_.Check(ctx); }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_9 ^Eval(Env_9 env) { return expr_.Eval(env); }

  public override string Emit() { return String.Format("({0})", expr_.Emit()); }
}

class PredefinedType_9 : Expression_9 {
  Class_9 type_;

  public PredefinedType_9(Class_9 type) { type_ = type; }

  public override GType_9 Check(Context_9 ctx) { Debug.Assert(false); return null; }

  public override GType_9 Check(Context_9 ctx, bool read, bool write, bool type_ok) {
    Debug.Assert(type_ok);
    return type_;
  }

  public override int Kind() {
    return ExprKind_9.Type;
  }

  public override RValue_9 ^Eval(Env_9 env) { Debug.Assert(false); return null; }

  public override string Emit() { return type_.name_; }
}

class Dot_9 : LValue_9 {
  Expression_9 ^expr_;  // set to null for a static invocation
  GType_9 expr_type_;
  string name_;

  LMember_9 field_;

  public Dot_9(Expression_9 ^expr, string name) { expr_ = expr; name_ = name; }

  public override bool IsConstant() {
    Debug.Assert(field_ != null);   // make sure we were already type checked
    return field_ is ConstField_9;
  }

  public override GType_9 Check(Context_9 ctx, bool read, bool write, bool type_ok) {
    expr_type_ = expr_.Check(ctx, true, false, true);
    if (expr_type_ == null)
      return null;
    bool is_static = (expr_.Kind() == ExprKind_9.Type);
    if (is_static)
      expr_ = null;
    else expr_.HoldRef(ctx);

    field_ = (LMember_9) expr_type_.Lookup(this, ctx.class_, expr_ is Base_9,
                                         MemberKind_9.Field_9, name_, null, true);
    if (field_ == null)
      return null;

    if (!field_.CheckAccess(this, ctx, write, is_static, !is_static))
      return null;

    if (read) {
      // Only property reads have side effects we need to register in the control graph.
      // (For_9 writes the caller, such as Assign_9, will add its own node.)
      if (field_ is Property_9)
        AddControl(ctx);
      if (expr_ != null)
        expr_.ReleaseRef(ctx);
    }

    return field_.Type().BaseType();
  }

  public override void ReleaseAll(Context_9 ctx) {
    if (expr_ != null)
      expr_.ReleaseRef(ctx);
  }

  public override int Kind() {
    if (field_ is Field_9)
      return ExprKind_9.Field_9;
    if (field_ is Property_9)
      return ExprKind_9.Property_9;
    Debug.Assert(false);
    return 0;
  }

  public override GType_9 StorageType() { return field_.Type(); }

  public override PropertyOrIndexer_9 GetPropertyOrIndexer() { return field_ as Property_9; }

  public override void Eval1(Env_9 env, out RValue_9 ^v1, out RValue_9 ^v2) {
    v1 = v2 = null;
    if (expr_ != null) {  // instance field
      v1 = expr_.Eval(env);
      if (v1 is Null_9) {
        Error("attempted to access field of null object");
        Gel_9.Exit();
      }
    }
  }

  public override RValue_9 ^EvalGet(Env_9 env, RValue_9 ^v1, RValue_9 ^v2) {
    GValue_9 obj = v1 == null ? null : v1.Get();
    return LosesOwnership() && field_.Type() is Owning_9 ? field_.Take_9(obj) : field_.Get(obj);
  }

  public override void EvalSet(Env_9 env, RValue_9 ^v1, RValue_9 ^v2, RValue_9 ^val) {
    GObject_9 obj = v1 == null ? null : (GObject_9) v1.Get();
    field_.Set(obj, val);
  }

  public override Location_9 EvalLocation(Env_9 env, RValue_9 ^v1, RValue_9 ^v2) {
    return field_.GetLocation((GObject_9) v1);
  }

  string EmitPrefix() {
    return expr_ != null ?
      expr_.EmitArrow(expr_type_, field_) :  // instance access
      field_.GetClass().name_ + "::";   // static access
  }

  public override string Emit() {
    string s = EmitPrefix() + field_.Emit();
    GType_9 t = field_.Type();
    return field_ is Property_9 ? Hold(t, s) : s + OwnSuffix(t);
  }

  public override string EmitSet(string val) {
    return EmitPrefix() + field_.EmitSet(val);
  }

  public override string EmitLocation() {
    return "&" + EmitPrefix() + field_.Emit();
  }
}

class Mode_9 {
  public const int In = 0,
                   Ref = 1,
                   Out = 2;

  public static string ToString(int mode) {
    switch (mode) {
      case In: return "";
      case Ref: return "ref ";
      case Out: return "out ";
      default: Debug.Assert(false); return null;
    }
  }
}

abstract class Argument_9 : Node_9 {
  protected GType_9 type_;

  public GType_9 Type() { return type_; }

  public abstract int GetMode();
  public string TypeString() { return Mode_9.ToString(GetMode()) + type_.ToString(); }

  public abstract bool Check(Context_9 ctx);
  public abstract void FinishCall(Context_9 ctx);

  public abstract void AddEval(ArrayList a, Env_9 env, GType_9 t);

  public abstract string Emit(GType_9 t);
}

class InArgument_9 : Argument_9 {
  public readonly Expression_9 ^expr_;

  public InArgument_9(Expression_9 ^expr) { expr_ = expr; }
  public InArgument_9(GType_9 type) { type_ = type; }

  public override int GetMode() { return 0; }

  public override bool Check(Context_9 ctx) {
    if (type_ == null)
      type_ = expr_.CheckAndHold(ctx);
    return type_ != null;
  }

  public override void FinishCall(Context_9 ctx) {
    expr_.ReleaseRef(ctx);
  }

  public override void AddEval(ArrayList a, Env_9 env, GType_9 t) {
    a.Add(expr_.Eval(env, t));
  }

  public override string Emit(GType_9 t) {
    return expr_.EmitRef(type_, t);
  }
}

class RefOutArgument_9 : Argument_9 {
  public readonly int mode_;
  public readonly LValue_9 ^lvalue_;

  public RefOutArgument_9(int mode, LValue_9 ^lvalue) { mode_ = mode; lvalue_ = lvalue; }

  public override int GetMode() { return mode_; }

  public override bool Check(Context_9 ctx) {
    type_ = lvalue_.Check(ctx, mode_ == Mode_9.Ref, true, false);
    if (type_ == null)
      return false;
    if (lvalue_.Kind() == ExprKind_9.Indexer_9) {
      Error("can't pass indexer as ref or out argument");
      return false;
    }
    return true;
  }

  public override void FinishCall(Context_9 ctx) {
    AddControl(ctx);
  }

  public override bool Sets(Local_9 local) { return lvalue_.IsLocal(local); }

  public override TypeSet_9 NodeDestroys() { return lvalue_.StorageType().VarDestroys(); }

  public GType_9 StorageType() { return lvalue_.StorageType(); }

  public override void AddEval(ArrayList a, Env_9 env, GType_9 t) {
    a.Add(new LocationRef_9(lvalue_.EvalLocation(env)));
  }

  public override string Emit(GType_9 t) { return lvalue_.EmitLocation(); }
}

class Invocation_9 : Expression_9 {
  Expression_9 ^obj_;    // may be null
  GType_9 obj_type_;
  string name_;
  ArrayList /* of Argument_9 */ ^arguments_;

  Method_9 method_;

  public Invocation_9(Expression_9 ^obj, string name, ArrayList ^arguments) {
    obj_ = obj; name_ = name; arguments_ = arguments;
  }

  public static Method_9 CheckInvoke(Node_9 caller, Context_9 ctx, bool through_base, GType_9 type,
                                   string name, ArrayList /* of Argument_9 */ arguments,
                                   int kind) {
    foreach (Argument_9 arg in arguments)
      if (!arg.Check(ctx))
        return null;

    // Add the caller to the graph; this node represents the invocation itself.
    caller.AddControl(ctx);

    // Now we can release temporary expressions and add control graph nodes representing
    // assignments to ref and out parameters.
    foreach (Argument_9 arg in arguments)
      arg.FinishCall(ctx);

    Method_9 m = (Method_9) type.Lookup(caller, ctx.class_, through_base, kind, name, arguments, true);
    if (m != null)
      for (int i = 0; i < m.parameters_.Count; ++i) {
        Parameter_9 p = m.Param(i);
        if (p.GetMode() == Mode_9.In) {
          InArgument_9 a = (InArgument_9) arguments[i];
          a.expr_.CheckLoseOwnership(a.Type(), p.Type());
        }
      }
    return m;
  }

  public override GType_9 Check(Context_9 ctx) {
    GType_9 t;
    bool is_class = false;  // true when calling a static method using a class name

    if (obj_ == null)
      t = ctx.class_;
    else {
      t = obj_type_ = obj_.Check(ctx, true, false, true);
      if (t == null)
        return null;
      if (obj_.Kind() == ExprKind_9.Type)
        is_class = true;
      else obj_.HoldRef(ctx);
    }

    method_ = CheckInvoke(this, ctx, obj_ is Base_9, t, name_, arguments_, MemberKind_9.Method_9);
    if (method_ == null)
      return null;

    if (method_ is Constructor_9) {
      Error("can't call constructor directly");
      return null;
    }

    if (obj_ == null) {
      if (!method_.IsStatic() && ctx.IsStatic()) {
        Error("can't call instance method in static context");
        return null;
      }
    } else {
      obj_.ReleaseRef(ctx);
      if (is_class) {
        if (!method_.IsStatic()) {
          Error("can't invoke non-static method through class name");
          return null;
        }
      } else {
        if (method_.IsStatic()) {
          Error("can't invoke static method through object");
          return null;
        }
      }
    }

    GType_9 ret = method_.ReturnType();
    if (ret is Owning_9)
      ctx.AddTemporary(this);
    return ret;
  }

  public override GType_9 TemporaryType() { return method_.ReturnType(); }

  public override Method_9 Calls() { return method_; }

  public static RValue_9 ^InvokeMethod(GValue_9 obj, Method_9 m, ArrayList /* of RValue_9 */ values,
                                    bool virtual_ok) {
    if (m.IsVirtual() && virtual_ok) {
      GType_9 t = obj.Type();
      m = (Method_9) t.FindMatchingMember(m, true);
      Debug.Assert(m != null);
    }
    return m.Invoke(obj, values);
  }

  public static RValue_9 ^CallMethod(Env_9 env, GValue_9 obj,
                                  Method_9 m, ArrayList /* of Argument_9 */ args,
                                  bool virtual_ok) {
    ArrayList /* of ValueOrLocation_9 */ ^values = new ArrayList();
    int i;
    for (i = 0 ; i < args.Count ; ++i) {
      Argument_9 a = (Argument_9) args[i];
      a.AddEval(values, env, m.Param(i).Type());
    }
    return InvokeMethod(obj, m, values, virtual_ok);
  }

  public RValue_9 ^Eval(Env_9 env, Expression_9 obj, Method_9 m, ArrayList /* of Argument_9 */ args) {
    RValue_9 ^r;
    GValue_9 v;
    if (m.IsStatic())
      v = null;
    else {
      if (obj == null)
        v = env.this_;
      else {
        r = obj.Eval(env);
        v = r.Get();
        if (v is Null_9) {
          Error("attempted to call method on null object");
          Gel_9.Exit();
        }
      }
    }

    return CallMethod(env, v, m, args, !(obj is Base_9));
  }

  public override RValue_9 ^Eval(Env_9 env) {
    return Eval(env, obj_, method_, arguments_);
  }

  public static string EmitArguments(Method_9 m, ArrayList /* of Argument_9 */ arguments) {
    StringBuilder ^sb = new StringBuilder();
    Debug.Assert(m.parameters_.Count == arguments.Count);
    for (int i = 0; i < arguments.Count; ++i) {
      if (i > 0)
        sb.Append(", ");
      Argument_9 a = (Argument_9)arguments[i];
      sb.Append(a.Emit(m.Param(i).Type()));
    }
    return sb.ToString();
  }

  public override string Emit() {
    StringBuilder ^sb = new StringBuilder();
    if (obj_ != null) {
      if (method_.IsStatic())
        sb.AppendFormat("{0}::", obj_.Emit());
      else if (obj_type_.IsReference())
        sb.Append(obj_.EmitArrow(obj_type_, method_));
      else sb.AppendFormat("({0})->", obj_.Emit(obj_type_, GObject_9.type_));   // box values
    }
    sb.AppendFormat("{0} ({1})", method_.name_, EmitArguments(method_, arguments_));
    return Hold(method_.ReturnType(), sb.ToString());
  }
}

// an expression of the form a[b]
class Sub_9 : LValue_9 {
  readonly Expression_9 ^base_;
  GType_9 base_type_;
  readonly Expression_9 ^index_;
  GType_9 index_type_;

  GType_9 element_type_;    // for array accesses; null for indexers
  Indexer_9 indexer_;

  public Sub_9(Expression_9 ^base_exp, Expression_9 ^index) { base_ = base_exp; index_ = index; }

  public override GType_9 Check(Context_9 ctx, bool read, bool write, bool type_ok) {
    base_type_ = base_.CheckAndHold(ctx);
    if (base_type_ == null)
      return null;

    index_type_ = index_.CheckAndHold(ctx);
    if (index_type_ == null)
      return null;

    if (read)
      ReleaseAll(ctx);

    ArrayType_9 at = base_type_.BaseType() as ArrayType_9;
    if (at != null) {
      if (!index_type_.CheckConvert(this, GInt_9.type_))
        return null;
      element_type_ = at.ElementType();
      return element_type_.BaseType();
    }

    ArrayList ^arguments = new ArrayList();
    arguments.Add(new InArgument_9(index_type_));

    indexer_ = (Indexer_9) base_type_.Lookup(this, ctx.class_, base_ is Base_9,
                                           MemberKind_9.Indexer_9, null, arguments, true);
    if (indexer_ == null)
      return null;

    if (read && !indexer_.CheckAssigning(this, ctx, false) ||
        write && !indexer_.CheckAssigning(this, ctx, true))
      return null;

    if (read)
      AddControl(ctx);

    return indexer_.Type();
  }

  public override void ReleaseAll(Context_9 ctx) {
    base_.ReleaseRef(ctx);
    index_.ReleaseRef(ctx);
  }

  public override int Kind() {
    return element_type_ != null ? ExprKind_9.Field_9 : ExprKind_9.Indexer_9;
  }

  public override GType_9 StorageType() {
    return element_type_ != null ? element_type_ : indexer_.Type();
  }

  public override PropertyOrIndexer_9 GetPropertyOrIndexer() { return indexer_; }

  public override void Eval1(Env_9 env, out RValue_9 ^v1, out RValue_9 ^v2) {
    v1 = base_.Eval(env);
    if (v1 is Null_9) {
      Error("attempted array or indexer access through null");
      Gel_9.Exit();
    }
    v2 = index_.Eval(env);
  }

  int Index(RValue_9 ^v) {
    // ++ We get an ownership error if we combine the following two lines into one; why?
    v = v.Get().Convert(ref v, GInt_9.type_);
    return ((GInt_9) v).i_;
  }

  public override RValue_9 ^EvalGet(Env_9 env, RValue_9 ^v1, RValue_9 ^v2) {
    if (indexer_ == null) {
      GArray_9 arr = (GArray_9) v1.Get();
      int i = Index(v2);
      return LosesOwnership() && element_type_ is Owning_9 ? arr.Take_9(i) : arr.Get(i);
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    return Invocation_9.InvokeMethod(v1.Get(), indexer_.Getter(), args, true);
  }

  public override void EvalSet(Env_9 env, RValue_9 ^v1, RValue_9 ^v2, RValue_9 ^val) {
    if (indexer_ == null) {
      ((GArray_9) v1.Get()).Set(Index(v2), val);
      return;
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    args.Add(val);
    Invocation_9.InvokeMethod(v1.Get(), indexer_.Setter(), args, true);
  }

  public override Location_9 EvalLocation(Env_9 env, RValue_9 ^v1, RValue_9 ^v2) {
    int i = ((GInt_9) v2).i_;
    return ((GArray_9) v1).GetLocation(i);
  }

  string EmitBase() {
    return base_.EmitArrow(base_type_, indexer_);
  }

  string EmitIndex() {
    return index_.Emit(index_type_, indexer_ != null ? indexer_.parameter_.Type() : GInt_9.type_);
  }

  public override string Emit() {
    string get = String.Format("{0}get_Item({1})", EmitBase(), EmitIndex());
    if (element_type_ != null) {
      get = get + OwnSuffix(element_type_);
      if (!element_type_.IsValue())
        get = String.Format("static_cast<{0} >({1})", element_type_.EmitExprType(), get);
      return get;
    } else return Hold(indexer_.Type(), get);
  }

  public override string EmitSet(string val) {
    return String.Format(element_type_ != null ? "{0}get_Item({1}) = {2}" : "{0}set_Item({1}, {2})",
       EmitBase(), EmitIndex(), val);
  }

  public override string EmitLocation() {
    return String.Format("{0}get_location({1})", EmitBase(), EmitIndex());
  }
}

class This_9 : Expression_9 {
  public override GType_9 Check(Context_9 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access this in a static context");
      return null;
    }
    return ctx.class_;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    return new Reference_9(env.this_);
  }

  public override string Emit() { return "this"; }
}

class Base_9 : Expression_9 {
  Class_9 parent_;

  public override GType_9 Check(Context_9 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access base in a static context");
      return null;
    }
    parent_ = ctx.class_.Parent();
    if (parent_ == null) {
      Error("can't access base: class has no parent");
      return null;
    }
    return parent_;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    return new Reference_9(env.this_);
  }

  public override string Emit() { return "this"; }

  public override string EmitArrow(GType_9 t, Member_9 m) {
    return m.GetClass().name_ + "::"; 
  }
}

class New_9 : Expression_9 {
  Expression_9 ^creator_;    // either a pool or null
  TypeExpr_9 ^type_expr_;
  ArrayList /* of Expression_9 */ ^arguments_;

  Class_9 class_;
  Constructor_9 constructor_;

  public New_9(Expression_9 ^creator, TypeExpr_9 ^expr, ArrayList ^arguments) {
    creator_ = creator;
    type_expr_ = expr;
    arguments_ = arguments;
  }

  GType_9 Type() {
    return creator_ == null ? (GType_9) class_.OwningType() : class_;
  }

  public override GType_9 TemporaryType() { return Type(); }    

  public override GType_9 Check(Context_9 ctx) {
    if (creator_ != null) {
      GType_9 c = creator_.Check(ctx);
      if (c == null)
        return null;
      if (!c.BaseType().IsSubtype(PoolClass_9.instance_)) {
        Error("object creator must be a pool");
        return null;
      }
    }
    GType_9 t = type_expr_.Resolve(ctx.program_);
    if (t == null)
      return null;
    class_ = (Class_9) t;
    if (class_.HasAttribute(Attribute_9.Abstract)) {
      Error("can't instantiate abstract class");
      return null;
    }
    if (creator_ != null) {
      class_.NeedDestroy(); // every pool-allocated class needs the _Destroy1 and _Destroy2 methods
      class_.SetVirtual();  // every pool-allocated class must be virtual
    }

    constructor_ = (Constructor_9) Invocation_9.CheckInvoke(this, ctx, false, class_,
                                      class_.name_, arguments_, MemberKind_9.Constructor_9);
    if (constructor_ == null)
      return null;

    GType_9 type = Type();
    if (type is Owning_9)
      ctx.AddTemporary(this);
    return type;
  }

  public override Method_9 Calls() { return constructor_; }

  public override RValue_9 ^Eval(Env_9 env) {
    GValue_9 ^obj = class_.New_9();
    Invocation_9.CallMethod(env, obj, constructor_, arguments_, false);
    return obj;
  }

  public override string Emit() {
    string args = Invocation_9.EmitArguments(constructor_, arguments_);

    return creator_ == null ?
      EmitAllocate(class_.name_, args, LosesOwnership()) :
      String.Format("new ({0}->Alloc(sizeof({1}))) {1}({2})", creator_.Emit(), class_.name_, args);
  }
}

class ArrayInitializer_9 : Expression_9 {
  public readonly ArrayList /* of Expression_9 */ ^initializers_;

  public ArrayInitializer_9(ArrayList ^initializers) { initializers_ = initializers; }

  public override GType_9 Check(Context_9 ctx) {
    Error("only static fields may have array initializers");
    return null;
  }

  public bool CheckElements(Context_9 ctx, GType_9 element_type) {
    foreach (Expression_9 e in initializers_)
      if (!e.CheckConstant() || !e.Check(ctx, element_type))
        return false;
    return true;
  }

  public override RValue_9 ^Eval(Env_9 env) { Debug.Assert(false); return null; }

  public GArray_9 ^Eval(ArrayType_9 type) {
    GArray_9 ^a = new GArray_9(type, initializers_.Count);
    for (int i = 0; i < initializers_.Count; ++i) {
      Expression_9 e = (Expression_9) initializers_[i];
      a.Set(i, e.Eval(Env_9.static_, type.ElementType()));
    }
    return a;
  }

  public override string Emit() { Debug.Assert(false); return null; }

  public void Emit(SourceWriter_9 w) {
    int count = initializers_.Count;
    int per_row = 12;

    w.Write("{ ");
    if (count > per_row) {    // format onto multiple rows
      w.WriteLine("");
      w.AddIndent();
      w.Indent();
    }
    for (int i = 0; i < count; ++i) {
      if (i > 0) {
        w.Write(", ");
        if (i % per_row == 0) {
          w.WriteLine("");
          w.Indent();
        }
      }
      Expression_9 e = (Expression_9) initializers_[i];
      SimpleValue_9 ^v = (SimpleValue_9) e.Eval(Env_9.static_);
      w.Write(v.Emit());
    }
    if (count > per_row) {
      w.SubIndent();
      w.WriteLine("");
    }
    w.Write(" }");
  }
}

class NewArray_9 : Expression_9 {
  TypeExpr_9 ^element_type_expr_;
  int dimensions_;
  ArrayType_9 ^array_type_;

  Expression_9 ^count_;

  public NewArray_9(TypeExpr_9 ^element_type_expr, int dimensions, Expression_9 ^count) {
    element_type_expr_ = element_type_expr;
    dimensions_ = dimensions;
    count_ = count;
  }

  GType_9 Type() {
    return (GType_9) array_type_.OwningType();
  }

  public override GType_9 TemporaryType() { return Type(); }

  public override GType_9 Check(Context_9 ctx) {
    if (element_type_expr_ is ArrayTypeExpr_9) {
      Error("syntax error in new expression");
      return null;
    }
    for (int i = 0; i < dimensions_; ++i)
      element_type_expr_ = new ArrayTypeExpr_9(take element_type_expr_);
    GType_9 element_type = element_type_expr_.Resolve(ctx.program_);
    if (element_type == null)
      return null;
    array_type_ = new ArrayType_9(element_type);

    if (!count_.Check(ctx, GInt_9.type_))
      return null;

    GType_9 t = Type();
    if (t is Owning_9)
      ctx.AddTemporary(this);
    return t;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    return new GArray_9(array_type_, count_.EvalInt(env));
  }

  public override string Emit() {
    GType_9 t = array_type_.ElementType();
    string array_type = GType_9.ConstructType(
      t is Owning_9 ? "_Array" : "_CopyableArray",
      t.EmitGenericType());
    string args = String.Format("&typeid({0}), {1}", t.EmitType(), count_.Emit());
    return EmitAllocate(array_type, args, LosesOwnership());
  }
}

abstract class Unary_9 : Expression_9 {
  protected Expression_9 ^exp_;

  protected Unary_9(Expression_9 ^e) { exp_ = e; }

  public override bool IsConstant() { return exp_.IsConstant(); }
}

// unary minus operator
class Minus_9 : Unary_9 {
  GType_9 type_;

  public Minus_9(Expression_9 ^e) : base(e) { }

  public override GType_9 Check(Context_9 ctx) {
    type_ = exp_.Check(ctx);
    if (type_ != GInt_9.type_ && type_ != GFloat_9.type_ && type_ != GDouble_9.type_) {
      Error("- operator cannot be applied to value of type {0}", type_);
      return null;
    }
    return type_;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    if (type_ == GInt_9.type_) {
    int i = exp_.EvalInt(env);
    return new GInt_9(-i);
  }
    if (type_ == GFloat_9.type_) {
      float f = exp_.EvalFloat(env);
      return new GFloat_9(-f);
    }
    if (type_ == GDouble_9.type_) {
      double d = exp_.EvalDouble(env);
      return new GDouble_9(-d);
    }
    Debug.Assert(false);
    return null;
  }

  public override string Emit() { return "-" + exp_.Emit(); }
}

class Not_9 : Unary_9 {
  public Not_9(Expression_9 ^e) : base(e) { }

  public override GType_9 Check(Context_9 ctx) {
    return exp_.Check(ctx, GBool_9.type_) ? GBool_9.type_ : null;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    bool b = exp_.EvalBool(env);
    return new GBool_9(!b);
  }

  public override string Emit() { return "!" + exp_.Emit(); }
}

// the bitwise complement (~) operator
class Complement_9 : Unary_9 {
  public Complement_9(Expression_9 ^e) : base(e) { }

  public override GType_9 Check(Context_9 ctx) {
    return exp_.Check(ctx, GInt_9.type_) ? GInt_9.type_ : null;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    int i = exp_.EvalInt(env);
    return new GInt_9(~i);
  }

  public override string Emit() { return "~" + exp_.Emit(); }
}

class IncDec_9 : Expression_9 {
  bool pre_;    // true for pre-increment/decrement; false for post-increment/decrement
  bool inc_;
  LValue_9 ^lvalue_;

  public IncDec_9(bool pre, bool inc, LValue_9 ^lvalue) { pre_ = pre; inc_ = inc; lvalue_ = lvalue; }

  public override GType_9 Check(Context_9 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    GType_9 t = lvalue_.Check(ctx, true, true, false);
    if (t == null)
      return null;
    if (lvalue_.Kind() == ExprKind_9.Indexer_9) {
      Error("++ and -- can't yet operate on indexers");
      return null;
    }
    if (t != GInt_9.type_) {
      Error("++ and -- can operate only on integers");
      return null;
    }
    return GInt_9.type_;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    Location_9 loc = lvalue_.EvalLocation(env);
    GInt_9 ^i = (GInt_9) take loc.value_;
    loc.value_ = new GInt_9(inc_ ? i.i_ + 1 : i.i_ - 1);
    return pre_ ? ((GInt_9) loc.value_).Copy() : i;
  }

  string EmitOp() { return inc_ ? "++" : "--"; }

  public override string Emit() {
    return pre_ ? EmitOp() + lvalue_.Emit() : lvalue_.Emit() + EmitOp();
  }
}

abstract class Conversion_9 : Expression_9 {
  protected Expression_9 ^expr_;
  protected TypeExpr_9 ^type_expr_;

  protected GType_9 from_base_;
  protected GType_9 to_type_, to_base_;

  protected Conversion_9(Expression_9 ^expr, TypeExpr_9 ^type_expr) {
    expr_ = expr; type_expr_ = type_expr;
  }

  protected bool CheckConversion(Context_9 ctx, bool subtype_only) {
    GType_9 from = expr_.Check(ctx);
    if (from == null)
      return false;
    from_base_ = from.BaseType();

    to_base_ = type_expr_.Resolve(ctx.program_);
    if (to_base_ == null)
      return false;
    if (!to_base_.IsValue() &&
       (from is Owning_9 || from_base_.IsValue()))
      to_type_ = to_base_.OwningType();
    else to_type_ = to_base_;

    if (!from.CanConvertExplicit(to_type_, subtype_only)) {
      Error("can't convert from {0} to {1}", from_base_, to_base_);
      return false;
    }
    return true;
  }
}

class Cast_9 : Conversion_9 {
  public Cast_9(Expression_9 ^expr, TypeExpr_9 ^type_expr) : base(expr, type_expr) { }

  public override Local_9 GetLocal() { return expr_.GetLocal(); }
  
  public override GType_9 Check(Context_9 ctx) {
    return CheckConversion(ctx, false) ? to_type_ : null;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_9.Local_9 ? ExprKind_9.Local_9 : ExprKind_9.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_9 ^Eval(Env_9 env) {
    RValue_9 ^r = expr_.Eval(env);
    return r.Get().ConvertExplicit(ref r, to_base_);
  }

  public override string Emit() {
    return expr_.EmitExplicit(from_base_, to_type_);
  }
}

class Binary_9 : Expression_9 {
  int op_;
  Expression_9 ^left_, right_;
  GType_9 left_type_, right_type_;
  GType_9 type_;

  const int CONCATENATE = 0;

  public Binary_9(Expression_9 ^left, int op, Expression_9 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public static GType_9 Promote(Syntax_9 caller, GType_9 left, int op, GType_9 right) {
    if (left.CanConvert(GInt_9.type_) && right.CanConvert(GInt_9.type_))
      return GInt_9.type_;
    if (left.CanConvert(GFloat_9.type_) && right.CanConvert(GFloat_9.type_))
      return GFloat_9.type_;
    if (left.CanConvert(GDouble_9.type_) && right.CanConvert(GDouble_9.type_))
      return GDouble_9.type_;
    caller.Error("can't apply operator {0} to operands of type {1} and {2}", OpName(op), left, right);
    return null;
  }

  bool CheckIntArgs() {
    if (left_type_.CheckConvert(this, GInt_9.type_) && right_type_.CheckConvert(this, GInt_9.type_)) {
      type_ = GInt_9.type_;
      return true;
    }
    return false;
  }

  public override GType_9 Check(Context_9 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);

    if (op_ == '+' && (left_type_ == GString_9.type_ || right_type_ == GString_9.type_)) {
      op_ = CONCATENATE;

      // If_9 we'll be calling ToString() on a class, ensure that it will inherit from
      // Object in generated code.
      if (left_type_ != GString_9.type_)
        left_type_.CanConvert(GObject_9.type_);
      if (right_type_ != GString_9.type_)
        right_type_.CanConvert(GObject_9.type_);

      return GString_9.type_;
    }

    switch (op_) {
      case '*':
      case '/':
      case '+':
      case '-':
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_;

      case '%':
      case Parser.OP_LEFT_SHIFT:
      case Parser.OP_RIGHT_SHIFT:
        return CheckIntArgs() ? GInt_9.type_ : null;

      case '&':
      case '|':
        if (left_type_ == GBool_9.type_ && right_type_ == GBool_9.type_)
          type_ = GBool_9.type_;
        else {
          if (!CheckIntArgs())
            return null;
          type_ = GInt_9.type_;
        }
        return type_;

      case '<':
      case Parser.OP_LE:
      case '>':
      case Parser.OP_GE:
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_ == null ? null : GBool_9.type_;

      default:
        Debug.Assert(false);
        return null;
    }
  }

  public static GBool_9 ^BoolOp(bool x, int op, bool y) {
    switch (op) {
      case '&': return new GBool_9(x & y);
      case '|': return new GBool_9(x | y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_9 ^IntOp(int x, int op, int y) {
    switch (op) {
      case '*': return new GInt_9(x * y);
      case '/': return new GInt_9(x / y);
      case '%': return new GInt_9(x % y);
      case '+': return new GInt_9(x + y);
      case '-': return new GInt_9(x - y);
      case Parser.OP_LEFT_SHIFT: return new GInt_9(x << y);
      case Parser.OP_RIGHT_SHIFT: return new GInt_9(x >> y);
      case '&': return new GInt_9(x & y);
      case '|': return new GInt_9(x | y);
      case '<': return new GBool_9(x < y);
      case Parser.OP_LE: return new GBool_9(x <= y);
      case '>': return new GBool_9(x > y);
      case Parser.OP_GE: return new GBool_9(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_9 ^FloatOp(float x, int op, float y) {
    switch (op) {
      case '*': return new GFloat_9(x * y);
      case '/': return new GFloat_9(x / y);
      case '+': return new GFloat_9(x + y);
      case '-': return new GFloat_9(x - y);
      case '<': return new GBool_9(x < y);
      case Parser.OP_LE: return new GBool_9(x <= y);
      case '>': return new GBool_9(x > y);
      case Parser.OP_GE: return new GBool_9(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_9 ^DoubleOp(double x, int op, double y) {
    switch (op) {
      case '*': return new GDouble_9(x * y);
      case '/': return new GDouble_9(x / y);
      case '+': return new GDouble_9(x + y);
      case '-': return new GDouble_9(x - y);
      case '<': return new GBool_9(x < y);
      case Parser.OP_LE: return new GBool_9(x <= y);
      case '>': return new GBool_9(x > y);
      case Parser.OP_GE: return new GBool_9(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public override RValue_9 ^Eval(Env_9 env) {
    if (op_ == CONCATENATE)
      return new GString_9(left_.Eval(env).ToString() + right_.Eval(env).ToString());

    if (type_ == GBool_9.type_)
      return BoolOp(left_.EvalBool(env), op_, right_.EvalBool(env));
    if (type_ == GInt_9.type_)
      return IntOp(left_.EvalInt(env), op_, right_.EvalInt(env));
    if (type_ == GFloat_9.type_)
      return FloatOp(left_.EvalFloat(env), op_, right_.EvalFloat(env));
    if (type_ == GDouble_9.type_)
      return DoubleOp(left_.EvalDouble(env), op_, right_.EvalDouble(env));

    Debug.Assert(false);
    return null;
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  static string OpName(int op) {
    switch (op) {
      case Parser.OP_LEFT_SHIFT: return "<<";
      case Parser.OP_RIGHT_SHIFT: return ">>";
      case Parser.OP_LE: return "<=";
      case Parser.OP_GE: return ">=";
      default: return ((char) op).ToString();
    }
  }

  public override string Emit() {
    if (op_ == CONCATENATE)
      return Hold(GString_9.type_,
        String.Format("String::_Concat({0}, {1})",
          left_.EmitRef(left_type_, GObject_9.type_), right_.Emit(right_type_, GObject_9.type_)));

    return String.Format("{0} {1} {2}",
      left_.EmitRef(left_type_), OpName(op_), right_.Emit() );
  }
}

class Equality_9 : Expression_9 {
  bool equal_;    // true for ==, false for !=
  Expression_9 ^left_, right_;
  GType_9 left_type_, right_type_, type_;

  public Equality_9(Expression_9 ^left, int op, Expression_9 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_EQUAL: equal_ = true; break;
      case Parser.OP_NE: equal_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_9 Check(Context_9 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);
    if (left_type_.IsReference() != right_type_.IsReference()) {
      Error("can't compare types {0} and {1}", left_type_, right_type_);
      return null;
    }
    type_ = left_type_.BaseType().CommonType(this, right_type_.BaseType());
    return type_ == null ? null : GBool_9.type_;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    RValue_9 ^left = left_.Eval(env, type_);
    RValue_9 ^right = right_.Eval(env, type_);
    bool eq = left.Get().DefaultEquals(right.Get());
    return new GBool_9(equal_ ? eq : !eq);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    string emit_left = left_.EmitRef(left_type_);
    string emit_right = right_.Emit();
    if (type_ == GString_9.type_)
      return String.Format("{0}String::_Equals({1}, {2})",
                           equal_ ? "" : "!", emit_left, emit_right);
    return String.Format("{0} {1} {2}", emit_left, equal_ ? "==" : "!=", emit_right);
  }
}

class Is_9 : Conversion_9 {
  public Is_9(Expression_9 ^expr, TypeExpr_9 ^type_expr) : base(expr, type_expr) { }

  public override GType_9 Check(Context_9 ctx) {
    return CheckConversion(ctx, true) ? GBool_9.type_ : null;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    RValue_9 ^r = expr_.Eval(env);
    GValue_9 v = r.Get();
    return new GBool_9(!(v is Null_9) && v.Type().IsSubtype(to_base_));
  }

  public override string Emit() {
    if (from_base_.IsReference()) {
      Class_9 c = (Class_9) to_base_;
      return String.Format("dynamic_cast<{0} *>({1}) != 0", c.name_, expr_.Emit());
    }
    return to_base_ == from_base_ || to_base_ == GObject_9.type_ ? "true" : "false";
  }
}

class As_9 : Conversion_9 {
  public As_9(Expression_9 ^expr, TypeExpr_9 ^type_expr) : base(expr, type_expr) { }

  public override Local_9 GetLocal() { return expr_.GetLocal(); }

  public override GType_9 Check(Context_9 ctx) {
    if (!CheckConversion(ctx, true))
      return null;
    if (!to_base_.IsReference()) {
      Error("as operator must convert to reference type");
      return null;
    }
    return to_type_;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_9.Local_9 ? ExprKind_9.Local_9 : ExprKind_9.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_9 ^Eval(Env_9 env) {
    RValue_9 ^r = expr_.Eval(env);
    return r.Get().Type().IsSubtype(to_base_) ? r : Null_9.Instance.Copy();
  }

  public override string Emit() {
    if (from_base_.CanConvert(to_base_))
      return expr_.Emit(from_base_, to_base_);
    Class_9 c = (Class_9) to_base_;
    return String.Format("dynamic_cast<{0} *>({1})", c.name_, expr_.Emit());
  }
}

// a && or || operator
class LogicalOp_9 : Expression_9 {
  bool and_;  // true => &&, false => ||
  Expression_9 ^left_, right_;
  Joiner_9 ^join_ = new Joiner_9();

  public LogicalOp_9(Expression_9 ^left, int op, Expression_9 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_AND: and_ = true; break;
      case Parser.OP_OR: and_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_9 Check(Context_9 ctx) {
    if (!left_.Check(ctx, GBool_9.type_))
      return null;

    join_.Join(ctx.Prev());
    if (!right_.Check(ctx, GBool_9.type_))
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    return GBool_9.type_;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    bool left = left_.EvalBool(env);
    bool b = and_ ? left && right_.EvalBool(env) : left || right_.EvalBool(env);
    return new GBool_9(b);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    return String.Format("{0} {1} {2}", left_.Emit(), and_ ? "&&" : "||", right_.Emit());
  }

}

// the ?: operator
class Conditional_9 : Expression_9 {
  Expression_9 ^condition_;
  Expression_9 ^if_true_, if_false_;

  GType_9 true_type_, false_type_;
  GType_9 type_;
  Joiner_9 ^join_ = new Joiner_9();

  public Conditional_9(Expression_9 ^condition, Expression_9 ^if_true, Expression_9 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override GType_9 Check(Context_9 ctx) {
    if (!condition_.Check(ctx, GBool_9.type_))
      return null;

    Control_9 c = ctx.Prev();

    true_type_ = if_true_.Check(ctx);
    if (true_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    false_type_ = if_false_.Check(ctx);
    if (false_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    type_ = true_type_.CommonType(this, false_type_);
    return type_;
  }

  public override int Kind() {
    return if_true_.Kind() == ExprKind_9.Local_9 && if_false_.Kind() == ExprKind_9.Local_9 ? ExprKind_9.Local_9 : ExprKind_9.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    if_true_.LoseOwnership();
    if_false_.LoseOwnership();
  }

  public override RValue_9 ^Eval(Env_9 env) {
    return condition_.EvalBool(env) ? if_true_.Eval(env, type_) : if_false_.Eval(env, type_);
  }

  public override string Emit() {
    return String.Format("{0} ? {1} : {2}", condition_.Emit(),
                         if_true_.Emit(true_type_, type_), if_false_.Emit(false_type_, type_));
  }
}

class Assign_9 : Expression_9 {
  LValue_9 ^left_;
  Expression_9 ^right_;

  GType_9 left_type_, right_type_;

  public Assign_9(LValue_9 ^left, Expression_9 ^right) {
    left_ = left; right_ = right;
  }

  public static bool CheckAssign(Syntax_9 caller, GType_9 left_type, Expression_9 right, GType_9 right_type) {
    if (!right_type.CheckConvert(caller, left_type,
      right.Kind() == ExprKind_9.Local_9 ? ConversionContext_9.AssignVar : ConversionContext_9.Other))
      return false;
    right.CheckLoseOwnership(right_type, left_type);
    return true;
  }

  public override GType_9 Check(Context_9 ctx) {
    left_type_ = left_.Check(ctx, false, true, false);
    if (left_type_ == null)
      return null;

    right_type_ = right_.Check(ctx, true, false, false);
    if (right_type_ == null || !CheckAssign(this, left_.StorageType(), right_, right_type_))
      return null;
    right_.HoldRef(ctx);

    AddControl(ctx);
    left_.ReleaseAll(ctx);
    right_.ReleaseRef(ctx);
    return left_type_;
  }

  public override Method_9 Calls() {
    PropertyOrIndexer_9 pi = left_.GetPropertyOrIndexer();
    return pi == null ? null : pi.Setter();
  }

  public override bool Sets(Local_9 local) { return left_.IsLocal(local); }

  public override TypeSet_9 NodeDestroys() {
    return left_.GetPropertyOrIndexer() != null ? TypeSet_9.empty_ : left_.StorageType().VarDestroys();
  }

  public override RValue_9 ^Eval(Env_9 env) {
    RValue_9 ^v1, v2;
    left_.Eval1(env, out v1, out v2);
    RValue_9 ^val = right_.Eval(env, left_type_);
    RValue_9 ^ret = val.CopyRef();
    left_.EvalSet(env, v1, v2, val);
    return ret;
  }

  public override string Emit() {
    return left_.EmitSet(right_.EmitRef(right_type_, left_type_));
  }
}

// a compound assignment operator such as += or -=
class CompoundAssign_9 : Expression_9 {
  LValue_9 ^left_;
  int op_;
  Expression_9 ^right_;

  GType_9 type_;

  public CompoundAssign_9(LValue_9 ^left, int op, Expression_9 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public override GType_9 Check(Context_9 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    type_ = left_.Check(ctx, true, true, false);
    if (type_ == null)
      return null;
    if (left_.Kind() == ExprKind_9.Indexer_9) {
      Error("compound assignments don't yet work on indexers");
      return null;
    }
    if (type_ == GBool_9.type_ && (op_ == '&' || op_ == '|')) {
      if (!right_.Check(ctx, GBool_9.type_))
        return null;
      return type_;
    }
    if (type_ != GInt_9.type_ && type_ != GFloat_9.type_ && type_ != GDouble_9.type_) {
      Error("compound assignment operator {0}= can't operate on object of type {1}", (char) op_, type_);
      return null;
    }
    if (!right_.Check(ctx, type_))
      return null;
    return type_;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    Location_9 loc = left_.EvalLocation(env);
    if (type_ == GBool_9.type_) {
      bool x = ((GBool_9) loc.value_).b_;
      bool y = right_.EvalBool(env);
      loc.value_ = Binary_9.BoolOp(x, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GInt_9.type_) {
      GInt_9 x = (GInt_9) loc.value_;
      int y = right_.EvalInt(env);
      loc.value_ = Binary_9.IntOp(x.i_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GFloat_9.type_) {
      GFloat_9 x = (GFloat_9) loc.value_;
      float y = right_.EvalFloat(env);
      loc.value_ = Binary_9.FloatOp(x.f_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GDouble_9.type_) {
      GDouble_9 x = (GDouble_9) loc.value_;
      double y = right_.EvalDouble(env);
      loc.value_ = Binary_9.DoubleOp(x.d_, op_, y);
      return loc.value_.CopyRef();
    } else {
      Debug.Assert(false);
      return null;
    }
  }

  public override string Emit() {
    return String.Format("{0} {1}= {2}", left_.Emit(), (char) op_, right_.Emit());
  }
}

class Take_9 : Expression_9 {
  LValue_9 ^exp_;
  Owning_9 type_;

  public Take_9(LValue_9 ^exp) { exp_ = exp; }

  public override GType_9 Check(Context_9 ctx) {
    GType_9 t = exp_.Check(ctx);
    if (t == null)
      return null;
    type_ = exp_.StorageType() as Owning_9;
    if (type_ == null) {
      Error("take must be applied to owning pointer");
      return null;
    }
    exp_.LoseOwnership();
    ctx.AddTemporary(this);
    return type_;
  }

  public override GType_9 TemporaryType() { return type_; }

  public override RValue_9 ^Eval(Env_9 env) {
    RValue_9 ^v = exp_.Eval(env);
    exp_.EvalSet(env, Null_9.Instance.Copy());
    return v;
  }

  public override string Emit() {
    return Hold(exp_.StorageType(), exp_.Emit());
  }
}

abstract class Statement_9 : Node_9 {
  public abstract bool Check(Context_9 ctx);
  public abstract RValue_9 ^Eval(Env_9 env);

  public abstract void Emit(SourceWriter_9 w);

  public virtual void EmitEmbedded(SourceWriter_9 w) {
    w.WriteLine("");
    w.AddIndent();
    w.Indent();
    Emit(w);
    w.SubIndent();
  }

  public virtual void EmitInExistingBlock(SourceWriter_9 w) {
    w.Indent();
    Emit(w);
  }
}

class StatementList_9 {
  public readonly ArrayList /* of Statement_9 */ ^statements_ = new ArrayList();

  public void Add(Statement_9 ^s) { statements_.Add(s); }

  public bool Check(Context_9 ctx) {
    bool ok = true;
    foreach (Statement_9 s in statements_)
      ok &= s.Check(ctx);
    return ok;
  }

  public RValue_9 ^Eval(Env_9 env) {
    foreach (Statement_9 s in statements_) {
      RValue_9 ^v = s.Eval(env);
      if (v != null)
        return v;
    }
    return null;
  }

  public void Emit(SourceWriter_9 w) {
    foreach (Statement_9 s in statements_) {
      w.Indent();
      s.Emit(w);
    }
  }
}

class EmptyStatement_9 : InlineStatement_9 {
  public EmptyStatement_9() { }

  public override bool Check(Context_9 ctx) { return true; }
  public override RValue_9 ^Eval(Env_9 env) { return null; }
  public override void EmitInline(SourceWriter_9 w) { }

  public static readonly EmptyStatement_9 ^instance_ = new EmptyStatement_9();
}

// A Scoped_9 is a statement defining one or more local variables.  If_9 a Scoped_9 appears in the
// control graph, then it destroys those variables when traversed.
abstract class Scoped_9 : Statement_9 {
  protected Local_9 start_;   // the first local outside this statement
  protected Local_9 top_;     // the top local defined inside this statement

  TypeSet_9 ^destroys_;

  protected void SetStartVar(Context_9 ctx) { start_ = top_ = ctx.var_; }
  protected void SetTopVar(Context_9 ctx) { top_ = ctx.var_; }

  public Local_9 GetStart() { return start_; }
  public Local_9 GetTop() { return top_; }

  public override TypeSet_9 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_9();
    for (Local_9 l = top_; l != start_; l = l.next_)
        destroys_.Add(l.Type().VarDestroys());
    }
    return destroys_;
  }
}

class Block_9 : Scoped_9 {
  public readonly StatementList_9 ^list_;

  public Block_9(StatementList_9 ^list) { list_ = list; }

  public bool Absent() { return list_ == null; }

  public override bool Check(Context_9 ctx) {
    Context_9 ^ctx1 = new Context_9(ctx);   // don't pass declarations outside block
    SetStartVar(ctx1);

    if (!list_.Check(ctx1))
      return false;

    SetTopVar(ctx1);

    // Add this Block_9 to the control graph; this represents the destruction of variables
    // within the block at block exit.
    AddControl(ctx1);

    return true;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    return list_.Eval(new Env_9(env));
  }

  public static Block_9 ^EmptyBlock() { return new Block_9(new StatementList_9()); }

  public override void Emit(SourceWriter_9 w) {
    w.OpenBrace();
    list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitEmbedded(SourceWriter_9 w) {
    w.Write(" ");
    Emit(w);
  }

  public override void EmitInExistingBlock(SourceWriter_9 w) {
    list_.Emit(w);
  }
}

class MemberKind_9 {
  public const int
    Field_9 = 0,
    Method_9 = 1,
    Property_9 = 2,
    Indexer_9 = 3,
    Constructor_9 = 4;
}

class Named_9 : Node_9 {
  public readonly TypeExpr_9 ^type_expr_;   // may be null for certain objects such as constructors
  protected GType_9 type_;

  public readonly string name_;

  public Named_9(TypeExpr_9 ^type_expr, string name) {
    type_expr_ = type_expr;
    name_ = name;
  }

  public GType_9 Type() { return type_; }

  public virtual bool Resolve(Program_9 program) {
    if (type_expr_ == null || type_ != null)
      return true;
    type_ = type_expr_.Resolve(program);
    return type_ != null;
  }
}

abstract class Member_9 : Named_9 {
  protected Class_9 class_;    // containing class

  public readonly int attributes_;

  protected Member_9(int attributes, TypeExpr_9 ^type_expr, string name) : base(type_expr, name) {
    attributes_ = attributes;
  }

  public abstract int Kind();

  public static string ToString(int kind) {
    switch (kind) {
      case MemberKind_9.Field_9: return "field";
      case MemberKind_9.Method_9: return "method";
      case MemberKind_9.Property_9: return "property";
      case MemberKind_9.Indexer_9: return "indexer";
      case MemberKind_9.Constructor_9: return "constructor";
      default: Debug.Assert(false); return null;
    }
  }

  public string KindString() { return ToString(Kind()); }

  protected abstract int ValidAttributes();

  public Class_9 GetClass() { return class_; }
  public void SetClass(Class_9 cl) { class_ = cl; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public bool IsOverride() { return HasAttribute(Attribute_9.Override); }

  public bool IsProtected() { return HasAttribute(Attribute_9.Protected); }

  public bool IsPublic() { return HasAttribute(Attribute_9.Public); }

  public bool IsPrivate() { return !HasAttribute(Attribute_9.Public | Attribute_9.Protected); }

  public bool IsVirtual() {
    return HasAttribute(Attribute_9.Virtual | Attribute_9.Abstract | Attribute_9.Override);
  }

  static ArrayList ^empty_ = new ArrayList();

  public virtual ArrayList /* of Parameter_9 */ Parameters() { return empty_; }

  public Parameter_9 Param(int i) {
    return (Parameter_9) Parameters()[i];
  }

  public bool IsAccessible(Class_9 from_class, GType_9 through_type, bool through_base) {
    if (IsPublic())
      return true;

    // In GEL2 (as in C# and C++), a class [from_class] can access a protected member of
    // a class C only if [from_class] is a subtype of C and the access is
    // through a subtype of [from_class].  See e.g. C# 3.5.3 "Protected Access for Instance Members".
    if (IsProtected())
      return through_base || from_class.IsSubtype(class_) && through_type.IsSubtype(from_class);

    // default private access
    return from_class == class_;
  }

  public static bool MatchKind(int kind1, int kind2) {
    return kind1 == kind2 ||
           kind1 == MemberKind_9.Field_9 && kind2 == MemberKind_9.Property_9 ||
           kind1 == MemberKind_9.Property_9 && kind2 == MemberKind_9.Field_9;
  }

  public bool MatchSignature(Member_9 m) {
    if (!MatchKind(Kind(), m.Kind()))
      return false;

    if (name_ != m.name_ || Parameters().Count != m.Parameters().Count)
      return false;

    int i = 0;
    foreach (Parameter_9 p in m.Parameters()) {
      Parameter_9 q = Param(i);
      if (!p.Match(q))
        return false;
      ++i;
    }
    return true;
  }

  public bool IsApplicable(ArrayList arguments, out int mismatches) {
    mismatches = 0;
    if (Parameters().Count != arguments.Count)
      return false;
    int i = 0;
    foreach (Argument_9 a in arguments) {
      if (!Param(i).CanReceive(a))
        ++mismatches;
      ++i;
    }
    return true;
  }

  public void ReportMismatches(Syntax_9 caller, ArrayList arguments) {
    Debug.Assert(Parameters().Count == arguments.Count);
    int i = 0;
    foreach (Argument_9 a in arguments) {
      Parameter_9 p = Param(i);
      if (!p.CanReceive(a))
        caller.Error("argument {0}: can't convert from {1} to {2}", i + 1, a.TypeString(), p.TypeString());
      ++i;
    }
  }

  protected virtual void AddOverride(Member_9 m) { }

  bool CheckOverride(Context_9 ctx) {
    Class_9 parent = ctx.class_.Parent();
    Member_9 m = parent != null ? parent.FindMatchingMember(this, false) : null;
    if (m != null) {
      if (this is Field_9) {
        Error("can't define field with same name as field/property in superclass");
        return false;
      }
      if (m is Field_9) {
        Error("can't define property with same name as field in superclass");
        return false;
      }
      if (!HasAttribute(Attribute_9.Override)) {
        Error("must use override keyword to override superclass {0}", KindString());
        return false;
      }
      if (HasAttribute(Attribute_9.Virtual)) {
        Error("{0} with override or abstract keyword cannot be marked virtual", KindString());
        return false;
      }
      if (!m.IsVirtual()) {
        Error("attempting to override non-virtual {0}", KindString());
        return false;
      }
      if (!m.Type().Equals(Type())) {
        Error("can't override {0} with different return type", KindString());
        return false;
      }
      if (m.IsPublic() != IsPublic()) {
        Error("override {0} must have same accessibility as {0} it overrides", KindString());
        return false;
      }
      m.AddOverride(this);
    } else if (HasAttribute(Attribute_9.Override)) {
      Error("can't find {0} to override", KindString());
      return false;
    }
    return true;
  }

  bool CheckAccessibility() {
    int n = 0;
    if ((attributes_ & Attribute_9.Private) != 0)
      ++n;
    if ((attributes_ & Attribute_9.Protected) != 0)
      ++n;
    if ((attributes_ & Attribute_9.Public) != 0)
      ++n;
    if (n > 1) {
      Error("only one access level (private, protected, public) may be specified");
      return false;
    }

    if (IsVirtual() && IsPrivate()) {
      Error("a virtual or abstract {0} may not be private", KindString());
      return false;
    }

    return true;
  }

  public virtual bool Check(Context_9 ctx) {
    if (!AttributeUtil_9.CheckOnly(attributes_, ValidAttributes())) {
      Error("illegal {0} attribute", KindString());
      return false;
    }

    if (HasAttribute(Attribute_9.Abstract) && !ctx.class_.HasAttribute(Attribute_9.Abstract)) {
      Error("an abstract {0} can be defined only in an abstract class", KindString());
      return false;
    }

    if (name_ == class_.name_ && !(this is Constructor_9)) {
      Error("{0} cannot have same name as enclosing class", KindString());
      return false;
    }

    if (class_.GetMatchingMember(this) != this) {
      Error("{0} {1} appears twice in same class", KindString(), name_ != null ? name_ : "");
      return false;
    }

    return CheckOverride(ctx) && CheckAccessibility();
  }
}

// a member which represents a storage location: a field, property, or indexer
abstract class LMember_9 : Member_9 {
  protected LMember_9(int attributes, TypeExpr_9 ^type_expr, string name)
    : base(attributes, type_expr, name) { }

  public bool IsConstOrStatic() {
    return HasAttribute(Attribute_9.Const | Attribute_9.Static);
  }

  protected bool CheckStatic(Syntax_9 caller, bool static_ok, bool instance_ok) {
    if (!static_ok && IsConstOrStatic()) {
      caller.Error("{0} {1} is static", KindString(), name_);
      return false;
    }
    if (!instance_ok && !IsConstOrStatic()) {
      caller.Error("{0} {1} is not static", KindString(), name_);
      return false;
    }
    return true;
  }

  public abstract bool CheckAssigning(Syntax_9 caller, Context_9 ctx, bool assigning);

  public bool CheckAccess(Syntax_9 caller, Context_9 ctx, bool assigning, bool static_ok, bool instance_ok) {
    return CheckStatic(caller, static_ok, instance_ok) && CheckAssigning(caller, ctx, assigning);
  }

  public abstract Location_9 GetLocation(GObject_9 obj);

  // These methods are for fields and properties; indexers have their own versions which take
  // an extra index argument.
  public virtual RValue_9 ^Get(GValue_9 obj) { Debug.Assert(false); return null; }
  public virtual RValue_9 ^Take_9(GValue_9 obj) { Debug.Assert(false); return null; }
  public virtual void Set(GObject_9 obj, RValue_9 ^val)  { Debug.Assert(false); }

  public virtual string Emit()  { Debug.Assert(false); return null; }
  public virtual string EmitSet(string val)  { Debug.Assert(false); return null; }
}

class Field_9 : LMember_9 {
  protected Expression_9 ^initializer_;    // or null if none
  protected GType_9 initializer_type_;

  public Field_9(int attributes, TypeExpr_9 ^type_expr, string name, Expression_9 ^initializer)
  : base(attributes, type_expr, name) {
    initializer_ = initializer;
  }

  // Create a field for an internal class.  Such fields will never be type checked.
  public Field_9(GType_9 type, string name) : this(Attribute_9.Public | Attribute_9.ReadOnly, null, name, null) {
    type_ = type;
  }

  public static Field_9 ^New_9(int attributes, TypeExpr_9 ^type_expr, string name, Expression_9 ^initializer) {
    if ((attributes & Attribute_9.Static) != 0)
      return new StaticField_9(attributes, type_expr, name, initializer);
    if ((attributes & Attribute_9.Const) != 0)
      return new ConstField_9(attributes, type_expr, name, initializer);
    return new Field_9(attributes, type_expr, name, initializer);
  }

  public override int Kind() { return MemberKind_9.Field_9; }

  public Expression_9 Initializer() { return initializer_; }

  protected virtual bool CheckInitializer(Context_9 ctx) {
    if (initializer_ == null)
      return true;

    ctx.EnterExpression();
    initializer_type_ = initializer_.Check(ctx);
    bool b = initializer_type_ != null &&
             Assign_9.CheckAssign(this, type_, initializer_, initializer_type_);
    ctx.FinishExpression();
    return b;
  }

  protected override int ValidAttributes() {
    return Attribute_9.Const | Attribute_9.Private | Attribute_9.Protected | Attribute_9.Public |
           Attribute_9.ReadOnly | Attribute_9.Static;
  }

  public override bool Check(Context_9 ctx) {
    if (!base.Check(ctx))
      return false;

    // We build up a small control graph even when checking field initializers; we do this
    // since expression-checking code uses the graph to determine when temporary
    // ref counts are needed.
    prev_ = unreachable_;
    ctx.SetPrev(this);

    bool b = CheckInitializer(ctx);

    ctx.ClearPrev();
    return b;
  }

  public override bool CheckAssigning(Syntax_9 caller, Context_9 ctx, bool assigning) {
    if (assigning) {
      if (HasAttribute(Attribute_9.Const)) {
        caller.Error("can't assign to const field");
        return false;
      }
      if (HasAttribute(Attribute_9.ReadOnly) &&
          (ctx.class_ != class_ || !(ctx.method_ is Constructor_9)) ) {
        caller.Error("readonly field {0} can only be assigned in constructor", name_);
        return false;
      }
    }
    return true;
  }

  public override RValue_9 ^Get(GValue_9 obj) { return obj.Get(this); }
  public override RValue_9 ^Take_9(GValue_9 obj) { return obj.Take_9(this); }
  public override void Set(GObject_9 obj, RValue_9 ^val) { obj.Set(this, val); }
  public override Location_9 GetLocation(GObject_9 obj) { return obj.GetLocation(this); }

  protected void WriteField(SourceWriter_9 w, bool declaration) {
    w.Indent();
    if (declaration && IsConstOrStatic())
      w.Write("static ");
    w.Write("{0} ", type_.EmitType());
    if (this is ConstField_9)
      w.Write("const ");
    if (!declaration)
      w.Write("{0}::", class_.name_);
    w.Write(name_);
  }

  protected void WriteDeclaration(SourceWriter_9 w) { WriteField(w, true); }
  protected void WriteDefinition(SourceWriter_9 w) { WriteField(w, false); }

  public virtual void EmitDeclaration(SourceWriter_9 w) {
    WriteDeclaration(w);
    w.WriteLine(";");
  }

  public void EmitInitializer(SourceWriter_9 w) {
    w.IWrite("{0} = ", name_);
    if (initializer_ != null)
      w.Write(initializer_.Emit(initializer_type_, type_));
    else w.Write(type_.DefaultValue_9().Emit());
    w.WriteLine(";");
  }

  public virtual void Emit(SourceWriter_9 w) { }

  public override string Emit() { return name_; }

  public override string EmitSet(string val) {
    return String.Format("{0} = {1}", name_, val);
  }
}

class StaticField_9 : Field_9 {
  protected Location_9 ^loc_;

  public StaticField_9(int attributes, TypeExpr_9 ^type_expr, string name, Expression_9 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_9 ctx) {
    if (!base.Check(ctx))
      return false;
    loc_ = new Location_9(Type().DefaultValue_9().Copy());
    return true;
  }

  protected override bool CheckInitializer(Context_9 ctx) {
    ArrayInitializer_9 ai = initializer_ as ArrayInitializer_9;
    if (ai != null) {
      GType_9 type = type_;
      Owning_9 o = type as Owning_9;
      type = (o != null) ? o.BaseType() : null;
      ArrayType_9 at = type as ArrayType_9;
      if (at == null) {
        Error("only owning arrays may have initializers");
        return false;
      }
      return ai.CheckElements(ctx, at.ElementType());
    }

    return base.CheckInitializer(ctx);
  }

  public virtual void Init() {
    ArrayInitializer_9 ai = initializer_ as ArrayInitializer_9;
    if (ai != null)
      loc_.value_ = ai.Eval((ArrayType_9) type_.BaseType());
    else if (initializer_ != null)
      loc_.value_ = initializer_.Eval(Env_9.static_, type_);
  }

  public override RValue_9 ^Get(GValue_9 obj) { return loc_.Get().CopyRef(); }
  public override RValue_9 ^Take_9(GValue_9 obj) { return take loc_.value_; }
  public override void Set(GObject_9 obj, RValue_9 ^val) { loc_.value_ = val; }
  public override Location_9 GetLocation(GObject_9 obj) { return loc_; }

  public override void Emit(SourceWriter_9 w) {
    ArrayInitializer_9 ai = initializer_ as ArrayInitializer_9;
    if (ai != null) {
      GType_9 element_type = ((ArrayType_9) type_.BaseType()).ElementType();
      string varname = String.Format("_{0}_{1}", class_.name_, name_);
      w.Write("{0} {1}[] = ", element_type.EmitGenericType(), varname);
      ai.Emit(w);
      w.WriteLine(";");
      WriteDefinition(w);
      w.Write("(new {0}", GType_9.ConstructType("_StaticArray", element_type.EmitGenericType()));
      w.Write("(&typeid({0}), {1}, {2}))", element_type.EmitType(), ai.initializers_.Count, varname);
    } else {
      WriteDefinition(w);
      if (initializer_ != null)
        initializer_.EmitAsInitializer(w, initializer_type_, type_);
    }
    w.WriteLine(";");
    w.WriteLine("");
  }
}

class ConstField_9 : Field_9 {
  protected SimpleValue_9 ^value_;

  public ConstField_9(int attributes, TypeExpr_9 ^type_expr, string name, Expression_9 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_9 ctx) {
    if (!base.Check(ctx))
      return false;
    return initializer_.CheckConstant();
  }

  SimpleValue_9 ^Get() {
    if (value_ == DefaultValue_9.instance_) {
      Error("circular dependency among constant fields");
      Gel_9.Exit();
    }
    if (value_ == null) {
      value_ = new DefaultValue_9();    // marker used to catch circular const references
      value_ = (SimpleValue_9)initializer_.Eval(Env_9.static_, type_);
    }
    return value_.Copy();
  }

  public override RValue_9 ^Get(GValue_9 obj) {
    return Get();
  }

  public override void Set(GObject_9 obj, RValue_9 ^val) { Debug.Assert(false); }
  public override Location_9 GetLocation(GObject_9 obj) { Debug.Assert(false); return null; }

  public override void EmitDeclaration(SourceWriter_9 w) {
    WriteDeclaration(w);
    if (type_ is IntegralType_9)
      w.Write(" = {0}", Get().Emit());
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_9 w) {
    WriteDefinition(w);
    if (!(type_ is IntegralType_9)) {
      w.WriteLine(" = {0};", Get().Emit());
    }
    w.WriteLine(";");
  }
}

class ExpressionTraverser_9 : Traverser_9 {
  readonly Control_9 start_;
  Local_9 local_;
  GType_9 type_;
  bool assign_;
  bool destroy_;

  public ExpressionTraverser_9(Control_9 start, Local_9 local, GType_9 type) {
    start_ = start; local_ = local; type_ = type;
  }

  public override int Handle(Control_9 control) {
    if (control == start_)
      return Cut;
    Node_9 node = control as Node_9;
    if (node != null) {
      if (!destroy_ && node.CanDestroy(type_))
        destroy_ = true;
      else if (local_ != null && node.Sets(local_))
        assign_ = true;
    }
    return Continue_9;
  }

  // Return_9 true if the given expression needs a reference count while we evaluate
  // the control graph nodes between [start] and [end].
  // A local variable needs a ref count if it is assigned to and the object
  // the variable previously pointed to might possibly be destroyed.
  // Any other expression needs a ref count if the object it evaluates to
  // might possibly be destroyed.
  public static bool NeedRef(Control_9 start, Control_9 end, Expression_9 expr, GType_9 type) {
    Debug.Assert(start != null && end != null);
    if (start == end || !type.IsOwned() || expr is This_9 || expr is Base_9)
      return false;
    Local_9 local = expr.GetLocal();
    ExpressionTraverser_9 ^et = new ExpressionTraverser_9(start, local, type);
    end.Traverse(et, Control_9.GetMarkerValue());
    return et.destroy_ && (local == null || et.assign_);
  }
}

abstract class LocalHandler_9 {
  public abstract bool Handle(Local_9 local, Node_9 node, Name_9 use);
}

class LocalChecker_9 : LocalHandler_9 {
  public override bool Handle(Local_9 local, Node_9 node, Name_9 use) {
    if (node == Control_9.unreachable_) {
      if (use != null)
        use.Error("variable {0} may be used before it is assigned a value", use.name_);
      else
        local.Error("out parameter {0} must be assigned before leaving method", local.name_);
      return false;
    }
    if (node.Takes(local)) {
      Name_9 name = (Name_9) node;
      name.Error("can't transfer ownership from {0}: value may be used again", name.name_);
      return false;
    }
    return true;
  }
}

class LocalRefAnalyzer_9 : LocalHandler_9 {
  public override bool Handle(Local_9 local, Node_9 node, Name_9 use) {
    Debug.Assert(node != Control_9.unreachable_);
    if (node.CanDestroy(local.Type())) {
      local.NeedsRef();
      return false;   // abort search
    }
    return true;
  }
}

class LocalTraverser_9 : Traverser_9 {
  readonly Local_9 local_;
  readonly LocalHandler_9 handler_;
  Name_9 use_;

  public LocalTraverser_9(Local_9 local, LocalHandler_9 handler) {
    local_ = local;
    handler_ = handler;
  }

  public void SetUse(Name_9 use) { use_ = use; }

  public override int Handle(Control_9 control) {
    Node_9 node = control as Node_9;
    if (node == null)
      return Continue_9;

    if (node.Sets(local_))
      return Cut;

    return handler_.Handle(local_, node, use_) ? Continue_9 : Abort;
  }
}

class Local_9 : Named_9 {
  protected Expression_9 ^initializer_;    // or null if none
  protected GType_9 initializer_type_;

  public Local_9 next_;    // next variable upward in scope chain

  NonOwningArrayList /* of Name_9 */ ^uses_ = new NonOwningArrayList();    // all uses of this variable

  protected bool mutable_;   // true if this local may ever change after it's first initialized

  protected bool needs_ref_;    // true if this variable needs a reference count in emitted code

  public Expression_9 Initializer() { return initializer_; }

  public void NeedsRef() { needs_ref_ = true; }

  public virtual string Emit() { return name_; }

  // Return_9 true if we represent this local using a smart pointer wrapper (i.e.
  // _Ptr, _Own, _OwnRef or _Ref).
  public virtual bool IsWrapper() {
    return type_ is Owning_9 || type_ == GString_9.type_ || needs_ref_;
  }

  public Local_9(TypeExpr_9 ^type_expr, string name, Expression_9 ^initializer) : base(type_expr, name) {
    initializer_ = initializer;
    next_ = null;
  }

  public bool Check(Context_9 ctx) {
    Local_9 decl = ctx.FindVar(name_);
    if (decl != null) {
      Error("error: variable already defined");
      return false;
    }

    if (initializer_ != null) {
      ctx.EnterExpression();
      initializer_type_ = initializer_.Check(ctx);
      bool ok = initializer_type_ != null &&
                Assign_9.CheckAssign(this, type_, initializer_, initializer_type_);

      // Add this Local_9 to the control graph.  We need to do this before calling
      // FinishExpression since the Local_9 will be initialized before temporaries 
      // are destroyed.
      AddControl(ctx);

      ctx.FinishExpression();
      if (!ok)
        return false;
    }

    next_ = ctx.var_;
    ctx.SetVar(this);

    ctx.method_.AddVar(this);
    return true;
  }

  public override bool Sets(Local_9 local) {
    return this == local && initializer_ != null;
  }

  public virtual GType_9 ReadType() {
    return type_;
  }

  public void AddUse(Name_9 name) {
    uses_.Add(name);
  }

  public void SetMutable() { mutable_ = true; }

  // Traverse the control graph nodes where this local is live, calling the given
  // LocalHandler_9's Handle method on each node.
  public bool Traverse(Method_9 method, LocalHandler_9 h) {
    LocalTraverser_9 ^t = new LocalTraverser_9(this, h);
    int marker = Control_9.GetMarkerValue();
    foreach (Name_9 name in uses_) {
      t.SetUse(name);
      if (!name.prev_.Traverse(t, marker))
        return false;
    }

    Parameter_9 p = this as Parameter_9;
    if (p != null && p.GetMode() == Mode_9.Out) {
      t.SetUse(null);
      if (!method.exit_.Traverse(t, marker))
        return false;
    }
    return true;
  }

  // check variable usage once control flow graph is complete
  public bool CheckUsage(Method_9 method) {
    return Traverse(method, new LocalChecker_9());
  }

  // Determine whether this Local_9 needs a reference count.  This_9 can happen only after
  // we've built up a control graph for all methods.
  public void ComputeRef(Method_9 method) {
    // For_9 now, a variable of type object always needs a reference count since it may
    // contain a string and we don't yet detect string destruction in the graph traversal.
    if (type_ == GObject_9.type_)
      NeedsRef();
    else if (type_.IsOwned())
      Traverse(method, new LocalRefAnalyzer_9());
  }

  public void EvalInit(Env_9 env) {
    env.Add(this, initializer_ != null ? initializer_.Eval(env, type_) : null);
  }

  protected virtual string EmitDeclarationType() {
    return IsWrapper() ? type_.EmitType() : type_.EmitExprType();
  }

  public virtual string EmitDeclarationName() { return name_; }

  public void EmitDeclaration(SourceWriter_9 w) {
    w.Write("{0} {1}", EmitDeclarationType(), EmitDeclarationName());
  }

  public void EmitInitializer(SourceWriter_9 w) {
    if (initializer_ != null)
      initializer_.EmitAsInitializer(w, initializer_type_, type_);
  }
}

class Parameter_9 : Local_9 {
  public Parameter_9(TypeExpr_9 ^type_expr, string name) : base(type_expr, name, null) { }

  // We represent some parameters using both a C++ parameter and a C++ local, which
  // have different types; we call these dual parameters.  For_9 such parameters
  // param_name_ is the C++ parameter name.
  string param_name_;

  public static Parameter_9 ^New_9(int mode, TypeExpr_9 ^type_expr, string name) {
    return mode == 0 ? new Parameter_9(type_expr, name) :
                               new RefOutParameter_9(mode, type_expr, name);
  }

  public virtual int GetMode() { return 0; }
  public string TypeString() { return Mode_9.ToString(GetMode()) + type_.ToString(); }

  public virtual Parameter_9 ^Copy() {
    return new Parameter_9(new TypeLiteral_9(type_), name_);
  }

  public virtual bool CanReceive(Argument_9 a) {
    return a.GetMode() == 0 && a.Type().CanConvert(type_, ConversionContext_9.MethodArg);
  }

  public bool Match(Parameter_9 p) {
    return GetMode() == p.GetMode() && type_.Equals(p.type_);
  }

  public override bool IsWrapper() {
    return type_ is Owning_9 || type_ == GString_9.type_ || mutable_ && needs_ref_;
  }

  public void CheckParameterUsage(Method_9 method) {
    if (type_ is Owning_9 && !(this is RefOutParameter_9)) {
      // We need both a C++ parameter and a C++ local: the parameter type can't be
      // _Own<>, since _Own has no public copy constructor and GCC doesn't allow passing
      // by value when a class's copy constructor is private.
      string n = name_;
      do {
        n = "_" + n;
      } while (method.HasLocal(n));
      param_name_ = n;
    }
  }

  protected override string EmitDeclarationType() {
    // For_9 owning parameters the declaration type is the expression type since we can't
    // pass _Own<> by value.
    return type_ is Owning_9 ? type_.EmitExprType() : base.EmitDeclarationType();
  }

  public override string EmitDeclarationName() {
    return param_name_ != null ? param_name_ : name_;
  }

  public void EmitExtraDeclaration(SourceWriter_9 w) {
    if (param_name_ != null)
      w.IWriteLine("{0} {1}({2});", type_.EmitType(), name_, param_name_);
  }
}

class RefOutParameter_9 : Parameter_9 {
  public readonly int mode_;
  public override int GetMode() { return mode_; }

  public RefOutParameter_9(int mode, TypeExpr_9 ^type_expr, string name) : base(type_expr, name) {
    mode_ = mode;
    mutable_ = true;
  }

  public override Parameter_9 ^Copy() { Debug.Assert(false); return null; }

  public override bool CanReceive(Argument_9 a) {
    if (mode_ != a.GetMode())
      return false;
    RefOutArgument_9 ra = (RefOutArgument_9) a;
    return type_.Equals(ra.StorageType());
  }

  public override GType_9 ReadType() {
    // If_9 a ref parameter has an owning type, we require the user to use the take operator to take
    // ownership of the value, since taking ownership has the visible side effect of clearing the
    // value the ref parameter points to.
    return mode_ == Mode_9.Ref ? type_.BaseType() : type_;
  }

  public override string Emit() {
    return "(*" + name_ + ")";
  }

  protected override string EmitDeclarationType() {
    return type_.EmitType() + " *";
  }
}

abstract class InlineStatement_9 : Statement_9 {
  public abstract void EmitInline(SourceWriter_9 w);

  public override void Emit(SourceWriter_9 w) {
    EmitInline(w);
    w.WriteLine(";");
  }
}

class VariableDeclaration_9 : InlineStatement_9 {
  ArrayList /* of Local_9 */ ^locals_ = new ArrayList();

  public VariableDeclaration_9(TypeExpr_9 ^type_expr, string name, Expression_9 ^initializer) {
    locals_.Add(new Local_9(type_expr, name, initializer));
  }

  public void Add(string name, Expression_9 ^initializer) {
    TypeExpr_9 ^t = ((Local_9) locals_[0]).type_expr_.Copy();
    locals_.Add(new Local_9(t, name, initializer));
  }

  public override bool Check(Context_9 ctx) {
    // local variables are not resolved during the Resolve phase, so we must resolve them here
    foreach (Local_9 l in locals_)
      if (!l.Resolve(ctx.program_) || !l.Check(ctx))
        return false;

    return true;
  }

  // Return_9 the type of all variables in this VariableDeclaration_9.
  public GType_9 Type() { return ((Local_9) locals_[0]).Type(); }

  public override RValue_9 ^Eval(Env_9 env) {
    foreach (Local_9 l in locals_)
      l.EvalInit(env);
    return null;
  }

  void Emit(SourceWriter_9 w, bool in_line) {
    if (in_line)
      Debug.Assert(locals_.Count == 1);

    foreach (Local_9 l in locals_) {
      l.EmitDeclaration(w);
      l.EmitInitializer(w);
      if (!in_line)
        w.WriteLine(";");
    }
  }

  public override void EmitInline(SourceWriter_9 w) { Emit(w, true); }
  public override void Emit(SourceWriter_9 w) { Emit(w, false); }
}

class ExpressionStatement_9 : InlineStatement_9 {
  Expression_9 ^exp_;

  public ExpressionStatement_9(Expression_9 ^e) {
    exp_ = e;
  }

  public override bool Check(Context_9 ctx) {
    if (exp_.CheckTop(ctx) == null)
      return false;
    exp_.SetUnused();
    return true;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    exp_.Eval(env);   // discard expression value
    return null;
  }

  public override void EmitInline(SourceWriter_9 w) {
    w.Write(exp_.Emit());
  }

}

class If_9 : Statement_9 {
  Expression_9 ^condition_;
  Statement_9 ^if_true_;
  Statement_9 ^if_false_;
  Joiner_9 ^join_ = new Joiner_9();

  public If_9(Expression_9 ^condition, Statement_9 ^if_true, Statement_9 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override bool Check(Context_9 ctx) {
    if (!condition_.Check(ctx, GBool_9.type_))
      return false;

    Control_9 c = ctx.Prev();

    if (!if_true_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    if (if_false_ != null && !if_false_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());
    return true;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    if (condition_.EvalBool(env))
      return if_true_.Eval(env);
    else
      return if_false_ != null ? if_false_.Eval(env) : null;
  }

  public override void Emit(SourceWriter_9 w) {
    w.Write("if ({0})", condition_.Emit());
    if_true_.EmitEmbedded(w);
    if (if_false_ != null) {
      w.IWrite("else");
      if_false_.EmitEmbedded(w);
    }
  }

}

class DefaultValue_9 : SimpleValue_9 {
  public DefaultValue_9() { }
  public static readonly DefaultValue_9 ^instance_ = new DefaultValue_9();

  public override SimpleValue_9 ^Copy() { Debug.Assert(false); return null; }
  public override GType_9 Type()  { Debug.Assert(false); return null; }
  public override string Emit() { Debug.Assert(false); return null; }
}

// A section in a switch statement.
//
// In GEL2, unlike C# and C++, local variables declared in a switch section are visible only
// in that section.  There doesn't seem to be much point in allowing sections to share locals
// since GEL2 (like C#) doesn't allow control to fall through from one section to the next.  This_9 also
// makes compiling to C++ slightly easier since C++ doesn't allow local variables in switch sections
// other than the last to have initializers (see e.g. C++ Primer, 4th ed., 6.6.5 "Variable Definitions
// inside a switch").

class SwitchSection_9 : Node_9 {
  ArrayList /* of Expression_9 */ ^cases_;     // null represents default:
  public readonly Block_9 ^block_;

  ArrayList /* of GValue_9 */ ^values_ = new ArrayList();

  public SwitchSection_9(ArrayList ^cases, StatementList_9 ^statements) {
    cases_ = cases;
    block_ = new Block_9(statements);
  }

  public bool Check(Context_9 ctx, GType_9 switch_type, OwningHashtable all_values, out bool is_default) {
    is_default = false;
    foreach (Expression_9 e in cases_) {
      GValue_9 ^v;
      if (e == null) {
        is_default = true;
        v = new DefaultValue_9();
      } else {
        if (!e.Check(ctx, switch_type) || !e.CheckConstant())
          return false;
        v = (GValue_9) e.Eval(Env_9.static_, switch_type);
      }
      if (all_values.ContainsKey(v)) {
        Error("switch statement cannot contain the same value twice");
        return false;
      }
      all_values.Set(v, null);
      values_.Add(v);
    }
    return block_.Check(ctx);
  }

  public bool Match(GValue_9 v) {
    foreach (GValue_9 val in values_)
      if (val.Equals(v))
        return true;
    return false;
  }

  public void Emit(SourceWriter_9 w) {
    foreach (Expression_9 c in cases_)
      if (c == null)
        w.IWriteLine("default:");
      else w.IWriteLine("case {0}:", c.Emit());
    w.Indent();
    block_.Emit(w);
  }

  public void EmitString(SourceWriter_9 w) {
    w.IWrite("if (");
    for (int i = 0 ; i < values_.Count ; ++i) {
      if (i > 0) {
        w.WriteLine(" ||");
        w.IWrite("    ");
      }
      w.Write("_s->_Equals({0})", 
              GString_9.EmitStringConst(((GString_9) values_[i]).s_));
    }
    w.Write(") ");
    block_.Emit(w);
  }
}

abstract class Escapable_9 : Scoped_9 {
  public readonly Joiner_9 ^exit_ = new Joiner_9();
}

class Switch_9 : Escapable_9 {
  Expression_9 ^expr_;
  GType_9 type_;
  ArrayList /* of SwitchSection_9 */ ^sections_;
  SwitchSection_9 default_;    // or null if no default section

  public Switch_9(Expression_9 ^expr, ArrayList ^sections) { expr_ = expr; sections_ = sections; }

  public override bool Check(Context_9 ctx) {
    SetStartVar(ctx);
    type_ = expr_.CheckTop(ctx);
    if (type_ == null)
      return false;
    if (type_ != GInt_9.type_ && type_ != GChar_9.type_ && type_ != GString_9.type_) {
      Error("switch expression must be of type int, char or string");
      return false;
    }
    Context_9 ^ctx1 = new Context_9(ctx, this);
    OwningHashtable ^values = new OwningHashtable();
    Control_9 c = ctx1.Prev();
    foreach (SwitchSection_9 s in sections_) {
      bool is_default;
      ctx1.SetPrev(c);
      if (!s.Check(ctx1, type_, values, out is_default))
        return false;
      if (is_default)
        default_ = s;
      if (ctx1.Prev() != unreachable_) {
        s.Error("switch case may not fall through to following case");
        return false;
      }
    }
    if (default_ == null)
      exit_.Join(c);
    ctx1.SetPrev(exit_.Combine());
    return true;
  }

  SwitchSection_9 FindSection(GValue_9 v) {
    foreach (SwitchSection_9 s in sections_)
      if (s.Match(v))
        return s;
    return default_;
  }

  RValue_9 ^CatchBreak(RValue_9 ^v) {
    return v is BreakValue_9 ? null : v;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    RValue_9 ^v = expr_.Eval(env);
    if (v == null)
      return null;
    SwitchSection_9 s = FindSection(v.Get());
    if (s == null)
      return null;
    return CatchBreak(s.block_.Eval(env));
  }

  public override void Emit(SourceWriter_9 w) {
    if (type_ == GString_9.type_) {
      // For_9 now, we implement a switch on strings using a sequence of if statements.  We wrap
      // the sequence in a dummy switch statement so that break statements will work properly.
      // If_9 the switch statement has just a default: label then the Microsoft C++ compiler issues
      // a warning, and if it has just a case 0: label then the compiler doesn't realize that the
      // case will always be executed, which may lead to warnings about not all code paths returning
      // a value.  So we use both default: and case 0:, which seems to work fine.
      w.Write("switch (0) ");
      w.OpenBrace();
      w.IWriteLine("case 0:");
      w.IWriteLine("default:");
      w.IWriteLine("StringPtr _s = {0};", expr_.Emit());
      foreach (SwitchSection_9 s in sections_)
        if (s != default_)
          s.EmitString(w);
      if (default_ != null)
        default_.block_.Emit(w);
      w.CloseBrace();
    } else {
      w.Write("switch ({0}) ", expr_.Emit());
      w.OpenBrace();

      foreach (SwitchSection_9 s in sections_)
        s.Emit(w);

      w.CloseBrace();
    }
  }
}

abstract class Loop_9 : Escapable_9 {
  public readonly Joiner_9 ^loop_ = new Joiner_9();
}

abstract class ForOrWhile_9 : Loop_9 {
  protected Expression_9 ^condition_;
  protected Statement_9 ^statement_;

  protected ForOrWhile_9(Expression_9 ^condition, Statement_9 ^statement) {
    condition_ = condition; statement_ = statement;
  }

  protected abstract InlineStatement_9 Initializer();
  protected abstract InlineStatement_9 Iterator();

  public override bool Check(Context_9 prev_ctx) {
    Context_9 ^ctx = new Context_9(prev_ctx, this);   // initializer may declare new local variable
    SetStartVar(ctx);
    if (!Initializer().Check(ctx))
      return false;
    SetTopVar(ctx);

    loop_.AddControl(ctx);

    if (!condition_.CheckTop(ctx, GBool_9.type_))
      return false;

    if (!condition_.IsTrueLiteral())  // we may exit the loop at this point
      exit_.Join(ctx.Prev());  

    if (!statement_.Check(ctx))
      return false;

    if (!Iterator().Check(ctx))
      return false;

    loop_.Join(ctx.Prev());  // loop back to top

    ctx.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy any local defined in an initializer above.
    AddControl(ctx);

    return true;
  }

  public override RValue_9 ^Eval(Env_9 outer_env) {
    Env_9 ^env = new Env_9(outer_env);   // initializer may declare new local
    for (Initializer().Eval(env); condition_.EvalBool(env); Iterator().Eval(env)) {
      RValue_9 ^v = statement_.Eval(env);
      if (v is BreakValue_9)
        break;
      if (v is ContinueValue_9)
        continue;
      if (v != null)
        return v;
    }
    return null;
  }
}

class While_9 : ForOrWhile_9 {
  public While_9(Expression_9 ^condition, Statement_9 ^statement) : base(condition, statement) { }

  protected override InlineStatement_9 Initializer()  { return EmptyStatement_9.instance_; }
  protected override InlineStatement_9 Iterator()  { return EmptyStatement_9.instance_; }

  public override void Emit(SourceWriter_9 w) {
    w.Write("while ({0})", condition_.Emit());
    statement_.EmitEmbedded(w);
  }
}

class For_9 : ForOrWhile_9 {
  InlineStatement_9 ^initializer_;
  InlineStatement_9 ^iterator_;

  public For_9(InlineStatement_9 ^initializer, Expression_9 ^condition, InlineStatement_9 ^iterator,
             Statement_9 ^statement)
    : base(condition != null ? condition : new Literal_9(new GBool_9(true)),
           statement) {
    initializer_ = initializer != null ? initializer : new EmptyStatement_9();
    iterator_ = iterator != null ? iterator : new EmptyStatement_9();
  }

  protected override InlineStatement_9 Initializer()  { return initializer_; }
  protected override InlineStatement_9 Iterator()  { return iterator_; }

  public override void Emit(SourceWriter_9 w) {
    w.Write("for (");
    initializer_.EmitInline(w);
    w.Write("; {0}; ", condition_.Emit());
    iterator_.EmitInline(w);
    w.Write(")");
    statement_.EmitEmbedded(w);
  }
}

class Do_9 : Loop_9 {
  Statement_9 ^statement_;
  Expression_9 ^condition_;

  Joiner_9 ^join_ = new Joiner_9();

  public Do_9(Statement_9 ^statement, Expression_9 ^condition) {
    statement_ = statement;
    condition_ = condition;
  }

  public override bool Check(Context_9 ctx) {
    join_.AddControl(ctx);

    Context_9 ^ctx1 = new Context_9(ctx, this);
    SetStartVar(ctx);

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx.Prev());  // continue statements jump here
    ctx.SetPrev(loop_.Combine());

    if (!condition_.CheckTop(ctx, GBool_9.type_))
      return false;

    if (!condition_.IsFalseLiteral())
      join_.Join(ctx.Prev());   // loop back to top
    if (!condition_.IsTrueLiteral())
      exit_.Join(ctx.Prev());   // fall through to exit
    ctx.SetPrev(exit_.Combine());

    return true;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    do {
      RValue_9 ^v = statement_.Eval(env);
      if (v is BreakValue_9)
        break;
      if (v is ContinueValue_9)
        continue;
      if (v != null)
        return v;
    } while (condition_.EvalBool(env));
    return null;
  }

  public override void Emit(SourceWriter_9 w) {
    w.IWrite("do");
    statement_.EmitEmbedded(w);
    w.IWriteLine("while ({0});", condition_.Emit());
  }
}

// A helper class for ForEach_9: a node defining a single variable in the control graph.
class Definer_9 : Node_9 {
  Local_9 local_;

  public Definer_9(Local_9 local) { local_ = local; }

  public override bool Sets(Local_9 local) {
    return local_ == local;
  }
}

class ForEach_9 : Loop_9 {
  Local_9 ^local_;
  Expression_9 ^expr_;
  GType_9 expr_type_;
  Statement_9 ^statement_;

  Property_9 count_;
  Indexer_9 indexer_;

  Definer_9 ^definer_;

  public ForEach_9(TypeExpr_9 ^type_expr, string name, Expression_9 ^expr, Statement_9 ^statement) {
    local_ = new Local_9(type_expr, name, null);
    expr_ = expr;
    statement_ = statement;
  }

  public override bool Check(Context_9 ctx) {
    if (!local_.Resolve(ctx.program_))
      return false;

    expr_type_ = expr_.CheckTop(ctx);
    if (expr_type_ == null)
      return false;

    count_ = expr_type_.Lookup(this, ctx.class_, false, MemberKind_9.Property_9, "Count", null, false) as Property_9;
    if (count_ == null) {
      Error("object enumerable by foreach must have an accessible property Count");
      return false;
    }
    if (count_.Type() != GInt_9.type_) {
      Error("object enumerable by foreach must have a property Count of type int");
      return false;
    }

    ArrayList ^args = new ArrayList();
    args.Add(new InArgument_9(GInt_9.type_));
    indexer_ = (Indexer_9) expr_type_.Lookup(this, ctx.class_, false, MemberKind_9.Indexer_9, null, args, false);
    if (indexer_ == null) {
      Error("object enumerable by foreach must have an accessible indexer on integers");
      return false;
    }
    if (!indexer_.CheckAssigning(this, ctx, false))
      return false;

    GType_9 indexer_type = indexer_.Type();
    GType_9 iterator_type = local_.Type();
    if (!indexer_type.CanConvertExplicit(iterator_type, false)) {
      Error("enumeration type {0} is not explicitly convertible to iteration variable type {1}",
        indexer_type, iterator_type);
      return false;
    }

    Context_9 ^ctx1 = new Context_9(ctx, this);

    SetStartVar(ctx1);
    if (!local_.Check(ctx1))   // will add local to scope chain
      return false;
    SetTopVar(ctx1);

    // Add a control graph node representing the creation of the local above.
    definer_ = new Definer_9(local_);
    definer_.AddControl(ctx1);

    loop_.AddControl(ctx1);   // continue statements jump here

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx1.Prev());   // loop back to top

    exit_.Join(loop_);  // any loop iteration may exit

    ctx1.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy the local variable created above.
    AddControl(ctx1);

    return true;
  }

  public override RValue_9 ^Eval(Env_9 outer_env) {
    RValue_9 ^r = expr_.Eval(outer_env);
    GValue_9 e = r.Get();
    if (e is Null_9) {
      Error("foreach: can't iterate over null object");
      Gel_9.Exit();
    }

    int count = ((GInt_9) count_.Get(e)).i_;

    Env_9 ^env = new Env_9(outer_env);
    env.Add(local_, null);
    for (int i = 0 ; i < count ; ++i) {
      RValue_9 ^v = indexer_.Get(e, new GInt_9(i));
      env.Set(local_, v.Get().ConvertExplicit(ref v, local_.Type()));
      RValue_9 ^s = statement_.Eval(env);
      if (s is BreakValue_9)
        break;
      if (s is ContinueValue_9)
        continue;
      if (s != null)
        return s;
    }
    return null;
  }

  public override void Emit(SourceWriter_9 w) {
    w.OpenBrace();
    w.IWriteLine("{0} _collection = {1};", expr_type_.BaseType().EmitType(), expr_.Emit());
    w.IWriteLine("int _count = _collection->get_Count();");
    w.IWrite("for (int _i = 0 ; _i < _count ; ++_i) ");
    w.OpenBrace();
    w.Indent();
    local_.EmitDeclaration(w);
    w.WriteLine(" = {0}; ",
      Expression_9.EmitExplicit(indexer_.Type(), local_.Type(), "_collection->get_Item(_i)", true));
    statement_.EmitInExistingBlock(w);
    w.CloseBrace();
    w.CloseBrace();
  }
}

class BreakValue_9 : GValue_9 {
  public BreakValue_9() { }

  public static readonly BreakValue_9 ^instance_ = new BreakValue_9();

  public override GType_9 Type()  { Debug.Assert(false); return null; }
}

abstract class BreakOrContinue_9 : Scoped_9 {
  protected void Link(Context_9 ctx, Scoped_9 target, Joiner_9 joiner) {
    // When traversed in the control graph, we destroy all variables in the scopes we are exiting,
    // excluding variables defined in the containing Escapable_9 or Loop_9.
    start_ = target.GetTop();
    SetTopVar(ctx);

    prev_ = ctx.Prev();
    if (prev_ != unreachable_)
      joiner.Join(this);

    ctx.SetPrev(unreachable_);
  }
}

class Break_9 : BreakOrContinue_9 {
  public override bool Check(Context_9 ctx) {
    Escapable_9 e = ctx.escape_;
    if (e == null) {
      Error("break statement must appear inside a while, do, for, foreach or switch statement");
      return false;
    }
    Link(ctx, e, e.exit_);
    return true;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    return new BreakValue_9();
  }

  public override void Emit(SourceWriter_9 w) {
    w.WriteLine("break;");
  }
}

class ContinueValue_9 : GValue_9 {
  public ContinueValue_9() { }

  public static readonly ContinueValue_9 ^instance_ = new ContinueValue_9();

  public override GType_9 Type()  { Debug.Assert(false); return null; }
}

class Continue_9 : BreakOrContinue_9 {
  public override bool Check(Context_9 ctx) {
    Loop_9 l = ctx.loop_;
    if (l == null) {
      Error("continue statement must appear inside a while, do, for or foreach statement");
      return false;
    }
    Link(ctx, l, l.loop_);
    return true;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    return new ContinueValue_9();
  }

  public override void Emit(SourceWriter_9 w) {
    w.WriteLine("continue;");
  }
}

class Return_9 : Statement_9 {
  Expression_9 ^exp_;    // null if no return value
  GType_9 exp_type_;
  GType_9 type_;

  public Return_9(Expression_9 ^exp) {
    exp_ = exp;
  }

  public override bool Check(Context_9 ctx) {
    if (exp_ == null) {
      if (ctx.method_.ReturnType() != Void_9.type_) {
        Error("error: returning value from function returning void");
        return false;
      }
    } else {
      type_ = ctx.method_.ReturnType();
      ctx.EnterExpression();
      exp_type_ = exp_.CheckAndHold(ctx);
      if (exp_type_ == null ||
          !exp_type_.CheckConvert(this, type_,
            exp_.IsRefOutParameter() ? ConversionContext_9.AssignVar : ConversionContext_9.Other))
        return false;
      exp_.CheckLoseOwnership(exp_type_, type_);
      ctx.FinishExpression();
      exp_.ReleaseRef(ctx);
    }

    ctx.method_.JoinReturn(ctx);
    ctx.SetPrev(unreachable_);
    return true;
  }

  public override RValue_9 ^Eval(Env_9 env) {
    return exp_ != null ? exp_.Eval(env, type_)
                        : Null_9.Instance.Copy();    // an arbitrary value
  }

  public override void Emit(SourceWriter_9 w) {
    if (exp_ != null && exp_.NeedsRef(exp_type_)) {
      // If_9 exp_ needs a reference count, that reference count needs to survive the destruction
      // of temporaries, so we can't simply emit a temporary reference count wrapper.  For_9 example,
      // when compiling the expression "return (new Foo()).Fun();", if Fun() returns a Foo then we
      // need a wrapper, and we can't generate "return _Ptr<Fun>(Foo().Fun()).Get()" since the _Ptr<Fun>
      // wrapper will be destroyed before the temporary Foo() object is destroyed.  So we need to
      // use an extra variable here.
      w.OpenBrace();
      w.IWriteLine("{0} __ret = {1};", exp_type_.EmitType(), exp_.Emit());
      w.IWriteLine("return __ret.Get();");
      w.CloseBrace();
    } else {
      w.Write("return ");
      if (exp_ != null)
        w.Write(exp_.Emit(exp_type_, type_));
      w.WriteLine(";");
    }
  }
}

class Attribute_9 {
  public const int Abstract = 1,
  Const = 2,
  Extern = 4,
  Override = 8,
  Private = 16,
  Protected = 32,
  Public = 64,
  ReadOnly = 128,
  Ref = 256,
  Static = 512,
  Virtual = 1024,
  Setter = 2048;
}

class AttributeUtil_9 {
  public static bool CheckOnly(int a, int allowed) {
    return (a & ~allowed) == 0;
  }
}

class MethodTraverser_9 : Traverser_9 {
  Method_9 method_;

  public MethodTraverser_9(Method_9 method) { method_ = method; }

  public override int Handle(Control_9 control) {
    if (control == Control_9.unreachable_)
      return Cut;

    Node_9 node = control as Node_9;
    if (node != null) {
      Method_9 c = node.Calls();
      if (c != null)
        method_.calls_.Add(c);
      method_.internal_destroys_.Add(node.NodeDestroys());
    }

    return Continue_9;
  }
}

class Method_9 : Member_9 {
  public readonly ArrayList /* of Parameter_9 */ ^parameters_;

  protected Block_9 ^body_;

  public Joiner_9 ^exit_ = new Joiner_9();

  // all parameters and locals defined in this method
  readonly NonOwningArrayList /* of Local_9 */ ^locals_ = new NonOwningArrayList();

  NonOwningArrayList /* of Method_9 */ ^overrides_;   // list of all overrides (virtual methods only)

  // methods called from this method
  public readonly NonOwningArrayList /* of Method_9 */ ^calls_ = new NonOwningArrayList();

  // Types destroyed inside this method, not including types destroyed through
  // calls to other methods.
  public readonly TypeSet_9 ^internal_destroys_ = new TypeSet_9();

  // Types destroyed inside this method or in any methods called by this method.
  TypeSet_9 ^destroys_;

  TypeSet_9 ^parameter_destroys_;

  // A marker used when performing a depth-first search of the method graph to compute destroys_.
  int method_marker_;

  public Method_9(int attributes, TypeExpr_9 ^return_type_expr,
                string name, ArrayList /* of Parameter_9 */ ^parameters, Block_9 ^body)
    : base(attributes, return_type_expr, name) {
    parameters_ = parameters;
    body_ = body;
  }

  public override int Kind() { return MemberKind_9.Method_9; }

  public GType_9 ReturnType() { return type_; }

  public override ArrayList Parameters() {
    return parameters_;
  }

  public bool IsExtern() { return class_.IsExtern(); }

  public bool IsStatic() {
    return HasAttribute(Attribute_9.Static);
  }

  public override bool Resolve(Program_9 program) {
    if (!base.Resolve(program))
      return false;
    foreach (Parameter_9 p in parameters_)
      if (!p.Resolve(program))
        return false;
    return true;
  }

  public void AddVar(Local_9 v) {
    locals_.Add(v);
  }

  public override bool Sets(Local_9 local) {
    foreach (Parameter_9 p in parameters_)
      if (p == local && p.GetMode() != Mode_9.Out)
        return true;
    return false;
  }

  public void JoinReturn(Context_9 ctx) {
    exit_.Join(ctx.Prev());
  }

  public const int kValidAttributes =
    Attribute_9.Abstract | Attribute_9.Override |
    Attribute_9.Private | Attribute_9.Protected | Attribute_9.Public |
    Attribute_9.Static | Attribute_9.Virtual | Attribute_9.Setter;

  protected override int ValidAttributes() {
    return kValidAttributes;
  }

  // overridden by Constructor_9 subclass
  protected virtual bool CheckEntry(Context_9 ctx) { return true; }

  // overridden by Constructor_9 subclass
  public override bool Check(Context_9 prev_ctx) {
    if (!base.Check(prev_ctx))
      return false;

    bool abstract_or_extern = HasAttribute(Attribute_9.Abstract) || IsExtern();

    if (body_.Absent()) {
      if (!abstract_or_extern) {
        Error("a method without a body must be abstract or extern");
        return false;
      }
      return true;
    } 

    if (abstract_or_extern) {
      Error("an abstract or extern method cannot have a body");
      return false;
    }

    Context_9 ^ctx = new Context_9(prev_ctx, this);

    prev_ = unreachable_;
    ctx.SetPrev(this);    // begin the control graph with this Method_9

    foreach (Parameter_9 p in parameters_)
      if (!p.Check(ctx))
        return false;

    if (!CheckEntry(ctx))
      return false;

    if (!body_.Check(ctx))
      return false;

    if (!(this is Constructor_9) && type_ != Void_9.type_ && ctx.Prev() != unreachable_) {
      Error("method must return a value");
      return false;
    }
    JoinReturn(ctx);

    ctx.ClearPrev();  // control graph is complete

    // Traverse the control graph to build calls_ and internal_destroys_.
    MethodTraverser_9 ^mt = new MethodTraverser_9(this);
    exit_.Traverse(mt, Control_9.GetMarkerValue());

    bool ok = true;
    foreach (Local_9 v in locals_)    // for all locals and parameters
      ok &= v.CheckUsage(this);

    foreach (Parameter_9 p in parameters_)
      p.CheckParameterUsage(this);

    return ok;
  }

  // Determine whether each local variable needs a reference count.
  protected void ComputeRefs() {
    foreach (Local_9 v in locals_)
      v.ComputeRef(this);
  }

  // Return_9 true if this method has a local or parameter with the given name.
  public bool HasLocal(string name) {
    foreach (Local_9 l in locals_)
      if (l.name_ == name)
        return true;
    return false;
  }

  public override TypeSet_9 NodeDestroys() {
    if (parameter_destroys_ == null) {
      parameter_destroys_ = new TypeSet_9();
    foreach (Parameter_9 p in parameters_)
        parameter_destroys_.Add(p.Type().VarDestroys());
    }
    return parameter_destroys_;
  }

  protected override void AddOverride(Member_9 m) {
    if (overrides_ == null)
      overrides_ = new NonOwningArrayList();
    overrides_.Add((Method_9) m);
  }

  bool Visit(int marker, TypeSet_9 set) {
    if (method_marker_ == marker)
      return true;

    method_marker_ = marker;
    set.Add(internal_destroys_);
    if (set.IsObject())
      return false;   // we already have object; no point in traversing further

    foreach (Method_9 m in calls_)
      if (!m.Visit(marker, set))
        return false;

    if (overrides_ != null)
      foreach (Method_9 m in overrides_)
        if (!m.Visit(marker, set))
          return false;

    return true;
  }

  public TypeSet_9 Destroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_9();
      Visit(Control_9.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  // overridden by Constructor_9 subclass
  public virtual RValue_9 ^Eval(Env_9 env) {
    return body_.Eval(env);
  }

  public RValue_9 ^Invoke(GValue_9 obj, ArrayList /* of ValueOrLocation_9 */ values) {
    if (body_.Absent()) { // an external method
      ValueList_9 ^list = new ValueList_9(values);
      if (IsStatic())
        return class_.InvokeStatic(this, list);   // let the class handle it
      return obj.Invoke(this, list);   // let the object handle it
    }

    Env_9 ^env = new Env_9(obj);
    Debug.Assert(values.Count == parameters_.Count);
    for (int i = 0 ; i < values.Count ; ++i)
      env.Add((Parameter_9) parameters_[i], (ValueOrLocation_9) values.Take(i));

    return Eval(env);
  }

  protected void EmitParameterNames(SourceWriter_9 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      w.Write(Param(i).EmitDeclarationName());
    }
    w.Write(")");
  }

  protected void EmitParameters(SourceWriter_9 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      Param(i).EmitDeclaration(w);
    }
    w.Write(") ");
  }

  void EmitAttributes(SourceWriter_9 w, bool declaration) {
    w.Indent();
    if (!IsStatic() && !IsVirtual())
      return;

    if (!declaration)
      w.Write("/* ");
    if (IsStatic())
      w.Write("static ");
    if (IsVirtual())
      w.Write("virtual ");
    if (!declaration)
      w.Write("*/ ");
  }

  void EmitSignature(SourceWriter_9 w, bool declaration) {
    EmitAttributes(w, declaration);
    w.Write("{0} ", type_.EmitReturnType());
    if (!declaration)
      w.Write("{0}::", class_.name_);
    if (HasAttribute(Attribute_9.Setter))
      w.Write("_");
    w.Write(name_);
    EmitParameters(w);
  }

  public virtual void EmitDeclaration(SourceWriter_9 w) {
    ComputeRefs();
    EmitSignature(w, true);
    if (body_.Absent())
      w.Write("= 0");
    w.WriteLine(";");

    if (HasAttribute(Attribute_9.Setter)) {
      w.WriteLine("");
      EmitAttributes(w, true);
      w.Write("{0} ", Param(parameters_.Count - 1).Type().EmitType());
      w.Write(name_);
      EmitParameters(w);
      w.OpenBrace();
      w.IWrite("_{0}", name_);
      EmitParameterNames(w);
      w.WriteLine(";");
      w.IWriteLine("return value;");
      w.CloseBrace();
    }
  }

  protected void EmitExtraDeclarations(SourceWriter_9 w) {
    foreach (Parameter_9 p in parameters_)
      p.EmitExtraDeclaration(w);
  }

  public virtual void Emit(SourceWriter_9 w) {
    if (!body_.Absent()) {
      EmitSignature(w, false);
      w.OpenBrace();
      EmitExtraDeclarations(w);
      body_.list_.Emit(w);
      w.CloseBrace();
      w.WriteLine("");
    }
    if (Gel_9.print_type_sets_)
      Console.WriteLine("{0}.{1}: {2}", class_.name_, name_, Destroys());
  }
}

class Constructor_9 : Method_9 {
  bool call_base_;
  ArrayList /* of Argument_9 */ ^initializer_params_;

  Constructor_9 initializer_;

  bool invoked_;  // true if another constructor invokes this one using : base() or : this()

  public Constructor_9(int attributes, string name, ArrayList ^parameters,
                     bool call_base, ArrayList ^initializer_params, Block_9 ^body)
    : base(attributes, null, name, parameters, body) {
    call_base_ = call_base;
    initializer_params_ = initializer_params;
  }

  public Constructor_9(int attributes, string name, ArrayList ^parameters, Block_9 ^body)
    : this(attributes, name, parameters, true, new ArrayList(), body) { }

  public override int Kind() { return MemberKind_9.Constructor_9; }

  protected override int ValidAttributes() {
    return Attribute_9.Private | Attribute_9.Protected | Attribute_9.Public;
  }

  public override bool Check(Context_9 ctx) {
    if (name_ != class_.name_) {
      Error("constructor name must match class name");
      return false;
    }
    return base.Check(ctx);
  }

  protected override bool CheckEntry(Context_9 ctx) {
    Class_9 c = call_base_ ? class_.Parent() : class_;
    if (c != null || initializer_params_.Count > 0) {
      initializer_ = (Constructor_9) Invocation_9.CheckInvoke(this, ctx, call_base_, c,
                                      c.name_, initializer_params_, MemberKind_9.Constructor_9);
      if (initializer_ == null)
        return false;
      if (initializer_ == this) {
        Error("constructor initializer invokes itself");
        return false;
      }
      initializer_.invoked_ = true;
    }
    return true;
  }

  // A Constructor_9 node in the control graph represents the call to the base constructor;
  // this node gets added when we call Invocation_9.CheckInvoke() above.
  public override Method_9 Calls() { return initializer_; }

  public override RValue_9 ^Eval(Env_9 env) {
    if (initializer_ == null || initializer_.class_ != class_) {
      // run instance variable initializers
      foreach (Field_9 f in class_.fields_)
        if (!f.IsConstOrStatic() && f.Initializer() != null)
          ((GObject_9) env.this_).Set(f, f.Initializer().Eval(Env_9.static_, f.Type()));
    }
    if (initializer_ != null)
      Invocation_9.CallMethod(env, env.this_, initializer_, initializer_params_, false);
    return body_.Eval(env);
  }

  void EmitInitializerArgs(SourceWriter_9 w) {
    w.WriteLine("({0});", Invocation_9.EmitArguments(initializer_, initializer_params_));
  }

  void EmitConstructorBody(SourceWriter_9 w) {
    w.OpenBrace();
    EmitExtraDeclarations(w);
    if (call_base_) {
      if (class_.constructors_.Count > 1)
        w.IWriteLine("_Init();");
      else class_.EmitInitializers(w);

      Class_9 parent = class_.Parent();
      if (parent != GObject_9.type_) {
        w.IWrite("{0}::_Construct", parent.name_);
        EmitInitializerArgs(w);
      }
    } else {
      w.IWrite("_Construct");
      EmitInitializerArgs(w);
    }

    body_.list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitDeclaration(SourceWriter_9 w) {
    ComputeRefs();

    // If_9 we're invoked by some other constructor then we need to declare a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void _Construct");
      EmitParameters(w);
      w.WriteLine(";");
    }

    // Now declare the actual C++ constructor.
    w.IWrite(name_);
    EmitParameters(w);
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_9 w) {
    // If_9 we're invoked by some other constructor then we need to emit a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void {0}::_Construct", name_);
      EmitParameters(w);
      EmitConstructorBody(w);
      w.WriteLine("");
    }

    // Now emit the actual C++ constructor.
    w.IWrite("{0}::{1}", name_, name_);
    EmitParameters(w);
    Class_9 parent = class_.Parent();
    if (parent != GObject_9.type_)
      w.Write(": {0}((Dummy *) 0) ", parent.name_);

    if (invoked_) {   // call the _Construct method we just generated
      w.Write("{ _Construct");
      EmitParameterNames(w);
      w.WriteLine("; }");
    } else EmitConstructorBody(w);
    w.WriteLine("");
  }
}

abstract class PropertyOrIndexer_9 : LMember_9 {
  // If_9 a get accessor is not declared at all, then get_block_ will be null; if it is
  // declared, but has an empty body ("get;") then get_block_ will be a Block_9 whose list_ is
  // null.  We need to distinguish these cases since for abstract or extern properties the
  // presence of a get accessor with an empty body indicates that a property is readable.
  // (set_block_ works similarly.)
  Block_9 ^get_block_, set_block_;

  protected Method_9 getter_, setter_;

  protected PropertyOrIndexer_9(int attributes, TypeExpr_9 ^type_expr, string name,
                              string id1, Block_9 ^block1, string id2, Block_9 ^block2)
    : base(attributes, type_expr, name) {
    StoreAccessor(id1, block1);
    if (id2 != null)
      StoreAccessor(id2, block2);
    if (id1 == id2)
      Error("can't have two {0} accessors", id1);
  }

  void StoreAccessor(string id, Block_9 ^block) {
    // Note that we don't have scanner tokens GET and SET since these are not keywords in GEL2.
    switch (id) {
      case "get": get_block_ = block; return;
      case "set": set_block_ = block; return;
    }
    Error("expected get or set");
  }

  public Method_9 Getter() { return getter_; }
  public Method_9 Setter() { return setter_; }

  protected abstract string BaseName();

  ArrayList ^CopyParameters() {
    ArrayList ^a = new ArrayList();
    foreach (Parameter_9 p in Parameters())
      a.Add(p.Copy());
    return a;
  }

  public override bool Check(Context_9 ctx) {
    if (!base.Check(ctx))
      return false;

    if (get_block_ != null) {
      Method_9 ^m = new Method_9(attributes_, new TypeLiteral_9(type_), "get_" + BaseName(), CopyParameters(), take get_block_);
      getter_ = m;
      class_.Add(m);
      if (!getter_.Resolve(ctx.program_) || !getter_.Check(ctx))
        return false;
    }

    if (set_block_ != null) {
      ArrayList ^set_params = CopyParameters();
      set_params.Add(new Parameter_9(new TypeLiteral_9(type_), "value"));
      Method_9 ^m = new Method_9(attributes_ | Attribute_9.Setter,
                           new TypeLiteral_9(Void_9.type_), "set_" + BaseName(), set_params, take set_block_);
      setter_ = m;
      class_.Add(m);
      if (!setter_.Resolve(ctx.program_) || !setter_.Check(ctx))
        return false;
    }

    return true;
  }

  public override bool CheckAssigning(Syntax_9 caller, Context_9 ctx, bool assigning) {
    if (assigning && set_block_ == null && setter_ == null) {
      caller.Error("can't assign to read-only {0}", KindString());
      return false;
    }
    if (!assigning && get_block_ == null && getter_ == null) {
      caller.Error("can't read from write-only {0}", KindString());
      return false;
    }
    return true;
  }

  public override Location_9 GetLocation(GObject_9 obj) { Debug.Assert(false); return null; }
}

class Property_9 : PropertyOrIndexer_9 {
  public Property_9(int attributes, TypeExpr_9 ^type_expr, string name,
                  string id1, Block_9 ^block1, string id2, Block_9 ^block2)
    : base(attributes, type_expr, name, id1, block1, id2, block2) { }

  public override int Kind() { return MemberKind_9.Property_9; }

  protected override int ValidAttributes() {
    return Method_9.kValidAttributes;
  }

  protected override string BaseName() { return name_; }

  public override RValue_9 ^Get(GValue_9 obj) {
    return Invocation_9.InvokeMethod(obj, getter_, new ArrayList(), true);
  }

  public override void Set(GObject_9 obj, RValue_9 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(val);
    Invocation_9.InvokeMethod(obj, setter_, a, true);
  }

  public override string Emit() {
    return String.Format("get_{0}()", name_);
  }

  public override string EmitSet(string val) {
    return String.Format("set_{0}({1})", name_, val);
  }
}

class Indexer_9 : PropertyOrIndexer_9 {
  public readonly Parameter_9 parameter_;

  ArrayList /* of Parameter_9 */ ^parameters_;

  public Indexer_9(int attributes, TypeExpr_9 ^type_expr, Parameter_9 ^parameter,
                 string id1, Block_9 ^block1, string id2, Block_9 ^block2)
    : base(attributes, type_expr, null, id1, block1, id2, block2) {
    parameter_ = parameter;

    parameters_ = new ArrayList();
    parameters_.Add(parameter);
  }

  public override int Kind() { return MemberKind_9.Indexer_9; }

  public override bool Resolve(Program_9 program) {
    return base.Resolve(program) && parameter_.Resolve(program);
  }

  protected override int ValidAttributes() {
    return Attribute_9.Abstract | Attribute_9.Override |
    Attribute_9.Private | Attribute_9.Protected | Attribute_9.Public | Attribute_9.Virtual;
  }

  protected override string BaseName() { return "Item"; }

  public override bool Check(Context_9 ctx) {
    if (parameter_ is RefOutParameter_9) {
      Error("indexer parameter may not be ref or out");
      return false;
    }

    return base.Check(ctx);
  }

  public override ArrayList /* of Parameter_9 */ Parameters() {
    return parameters_; 
  }

  public RValue_9 ^Get(GValue_9 obj, RValue_9 ^index) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    return Invocation_9.InvokeMethod(obj, getter_, a, true);
  }

  public void Set(GObject_9 obj, RValue_9 ^index, RValue_9 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    a.Add(val);
    Invocation_9.InvokeMethod(obj, setter_, a, true);
  }
}

class Class_9 : Ownable_9 {
  Syntax_9 ^syntax_ = new Syntax_9();
  Program_9 program_;   // containing program
  int attributes_;
  public readonly string name_;
  string parent_name_;    // or null if not specified

  Class_9 parent_;

  public readonly NonOwningArrayList /* of Field_9 */ ^fields_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Method_9 */ ^methods_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Property_9 */ ^properties_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Indexer_9 */ ^indexers_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Constructor_9 */ ^constructors_ = new NonOwningArrayList();

  public readonly ArrayList /* of Member_9 */ ^members_ = new ArrayList();

  public readonly ArrayList /* of Temporaries_9 */ ^temporaries_ = new ArrayList();

  public readonly NonOwningArrayList /* of Class_9 */ ^subclasses_ = new NonOwningArrayList();
  bool emitted_;

  // If_9 virtual_ is true, then this class needs a vtable; we set this for a class C
  // in any of the following cases:
  // - the program converts some type T to C ^ (for then a C ^ may hold a T, and when
  // the owning pointer is destroyed we need to know which destructor to call)
  // - the program explicitly converts from C to some other type (so we need RTTI for C)
  bool virtual_;
  
  // If_9 object_inherit_ is true, then this class must derive from Object in generated C++
  // code; we set this for a class C in any of the following cases:
  // - a member lookup in C yields a member in Object
  // - the program converts from C to Object or from Object to C
  // - the class is used in a generic context, i.e. in the type C [] or C ^ [].  All such types
  //   use the generic compiled classes Array<Object> / Array<_Own<Object>>, and so in this case we need
  //   to be able to cast between C and Object.
  //
  // If_9 object_inherit_ is true then this class and all its superclasses will have vtables since
  // the C++ Object class has a vtable.
  bool object_inherit_;

  bool need_destroy_;  // true if we need to emit _Destroy methods for this class

  // The set of types which may be destroyed when an instance of this class is destroyed.
  TypeSet_9 ^destroys_;

  // A marker used in performing a depth-first search to construct the destroys_ type set.
  int marker_;

  protected Class_9(string name) { name_ = name; }

  public static Class_9 New_9(int attributes, string name, string parent_name) {
    Class_9 c = Internal_9.Find(name);
    if (c == null) {
      Class_9 ^c1 = new Class_9(name);
      c = c1;
      Gel_9.program_.AddOwn(c1);
    }

    c.attributes_ = attributes;
    c.parent_name_ = parent_name;

    return c;
  }

  public override bool IsOwned() { return true; }

  public Program_9 GetProgram() { return program_; }
  public void SetProgram(Program_9 p) { program_ = p; }

  public bool IsExtern() { return HasAttribute(Attribute_9.Extern); }

  public override Class_9 Parent() { return parent_; }

  public override string ToString() { return name_; }

  public override ArrayList Members() { return members_; }

  public override SimpleValue_9 DefaultValue_9() { return Null_9.Instance; }

  public override void SetVirtual() { virtual_ = true; }
  public override void SetObjectInherit() { object_inherit_ = true;  }
  public void NeedDestroy() { need_destroy_ = true; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public virtual GValue_9 ^New_9() { return new GObject_9(this); }
  public virtual RValue_9 ^InvokeStatic(Method_9 m, ValueList_9 args) { Debug.Assert(false); return null; }

  public void Add(Field_9 ^f) { f.SetClass(this); fields_.Add(f); members_.Add(f);  }

  public virtual void Add(Method_9 ^m) { m.SetClass(this); methods_.Add(m); members_.Add(m);  }

  public void Add(Property_9 ^p) { p.SetClass(this); properties_.Add(p); members_.Add(p);  }

  public void Add(Indexer_9 ^i) { i.SetClass(this); indexers_.Add(i); members_.Add(i); }

  public void AddConstructor(Constructor_9 ^c) { c.SetClass(this); constructors_.Add(c); members_.Add(c);  }

  public NonOwningArrayList /* of Member_9 */ ^FindAbstractMembers() {
    NonOwningArrayList /* of Member_9 */ ^a;
    if (parent_ != null)  {
      a = parent_.FindAbstractMembers();

      // remove members overridden in this class
      int i = 0;
      while (i < a.Count) {
        Member_9 m = (Member_9) a[i];
        Member_9 n = GetMatchingMember(m);
        if (n != null) {
          Debug.Assert(n.HasAttribute(Attribute_9.Abstract | Attribute_9.Override));
          a.RemoveAt(i);
        } else ++i;
      }
    } else a = new NonOwningArrayList();

    // add abstract members from this class
    foreach (Member_9 m in members_) {
      if (m.HasAttribute(Attribute_9.Abstract))
        a.Add(m);
    }

    return a;
  }

  public bool ResolveAll(Program_9 program) {
    if (parent_name_ != null) {
      parent_ = program.FindClass(parent_name_);
      if (parent_ == null) {
        syntax_.Error("can't find parent class {0}", parent_name_);
        return false;
      }
    } else if (this == GObject_9.type_)
      parent_ = null;
    else parent_ = GObject_9.type_;
    if (parent_ != null)
      parent_.subclasses_.Add(this);

    foreach (Member_9 m in members_)
      if (!m.Resolve(program))
        return false;

    if (!IsExtern() && constructors_.Count == 0)
      // add a default constructor
      AddConstructor(new Constructor_9(Attribute_9.Public, name_, new ArrayList(), Block_9.EmptyBlock()));

    return true;
  }

  // In our first checking pass we check all constant fields since we may need to evaluate them
  // in the course of checking other code.
  public bool Check1(Context_9 prev_ctx) {
    if (!AttributeUtil_9.CheckOnly(attributes_,
         Attribute_9.Abstract | Attribute_9.Extern | Attribute_9.Public)) {
      syntax_.Error("illegal class attribute");
      return false;
    }

    if (prev_ctx.program_.FindClass(name_) != this) {
      syntax_.Error("can't have two classes named {0}", name_);
      return false;
    }

    Context_9 ^ctx = new Context_9(prev_ctx, this);
    bool ok = true;
    foreach (Field_9 f in fields_) {
      ConstField_9 cf = f as ConstField_9;
      if (cf != null)
        ok &= cf.Check(ctx);
    }
    return ok;
  }

  public bool Check(Context_9 prev_ctx) {
    Context_9 ^ctx = new Context_9(prev_ctx, this);

    bool ok = true;

    foreach (Member_9 m in members_)
      if (m is Field_9 && !(m is ConstField_9) || m is Method_9)
        ok &= m.Check(ctx);

    // We need to check properties and indexers separately since they add methods to the members_
    // array as they are checked.
    foreach (Property_9 p in properties_)
      ok &= p.Check(ctx);
    foreach (Indexer_9 i in indexers_)
      ok &= i.Check(ctx);

    if (!HasAttribute(Attribute_9.Abstract)) {
      NonOwningArrayList ^a = FindAbstractMembers();
      if (a.Count > 0) {
        foreach (Member_9 m in a)
          syntax_.Error("class does not define inherited abstract {0} {1}", m.KindString(), m.name_);
        ok = false;
      }
    }

    return ok;
  }

  public void GetMainMethod(NonOwningArrayList /* of Method_9 */ result) {
    foreach (Method_9 m in methods_)
      if (m.name_ == "Main" && m.IsPublic() && m.IsStatic() && m.ReturnType() == Void_9.type_) {
        int c = m.parameters_.Count;
        if (c > 1)
          continue;
        if (c == 1) {
          Parameter_9 p = m.Param(0);
          if (p.GetMode() != 0 || !p.Type().Equals(new ArrayType_9(GString_9.type_)) )
            continue;
        }
        result.Add(m);
      }
  }

  public override void FindTypeDestroys(int marker, TypeSet_9 set) {
    if (marker_ == marker)
      return;
    marker_ = marker;
    set.Add(this);
    for (Class_9 c = this; c != null; c = c.parent_) {
      if (c != this && c.marker_ == marker)
        break;
      foreach (Field_9 f in c.fields_)
        if (!f.IsConstOrStatic())
          f.Type().FindVarDestroys(marker, set);
    }
    foreach (Class_9 c in subclasses_)
      c.FindTypeDestroys(marker, set);
  }

  public override TypeSet_9 TypeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_9();
      FindTypeDestroys(Control_9.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  public Temporaries_9 NewTemporaries() {
    Temporaries_9 ^t = new Temporaries_9();
    Temporaries_9 ret = t;
    temporaries_.Add(t);
    return ret;
  }

  public void StaticInit() {
    foreach (Field_9 f in fields_) {
      StaticField_9 sf = f as StaticField_9;
      if (sf != null)
        sf.Init();
    }
  }

  public override string EmitTypeName() { return name_; }

  int EmitAccess(SourceWriter_9 w, int old_access, int new_access) {
    new_access = (new_access & Attribute_9.Public) != 0 ? Attribute_9.Public : Attribute_9.Protected;

    if (new_access != old_access) {
      switch (new_access) {
        case Attribute_9.Protected:
          w.Indent(-1);
          w.WriteLine("protected:");
          break;
        case Attribute_9.Public:
          w.Indent(-1);
          w.WriteLine("public:");
          break;
        default:
          Debug.Assert(false);
          break;
      }
    }

    return new_access;
  }

  public void EmitInitializers(SourceWriter_9 w) {
    foreach (Field_9 f in fields_)
      if (!f.IsConstOrStatic())
        f.EmitInitializer(w);
  }

  // Return_9 true if this top-level class must inherit from Object.
  bool ObjectInherit() {
    if (object_inherit_)
      return true;
    foreach (Class_9 c in subclasses_)
      if (c.ObjectInherit())
        return true;
    return false;
  }

  public void EmitDeclaration(SourceWriter_9 w) {
    if (emitted_ || IsExtern())
      return;

    // C++ requires a parent class to appear before its subclasses in a source file.
    parent_.EmitDeclaration(w);

    emitted_ = true;

    w.Write("class {0} ", name_);
    if (parent_ != null)
      w.Write(": public {0} ",
              parent_ == GObject_9.type_ && !ObjectInherit() ? "_Object" : parent_.name_);
    w.OpenBrace();

    int access = 0;

    if (fields_.Count > 0) {
      foreach (Field_9 f in fields_) {
        access = EmitAccess(w, access, f.attributes_);
        f.EmitDeclaration(w);
      }
      w.WriteLine("");
    }

    if (subclasses_.Count > 0) {
      access = EmitAccess(w, access, Attribute_9.Protected);
      w.IWrite("{0}(Dummy *dummy) ", name_);
      if (parent_ != GObject_9.type_)
        w.Write(": {0}(dummy) ", parent_.name_);
      w.WriteLine("{ }");
      w.WriteLine("");
    }

    // If_9 we have more than one constructor, emit an _Init() method which constructors can
    // call to initialize instance variables.
    if (constructors_.Count > 1) {
      access = EmitAccess(w, access, Attribute_9.Protected);
      w.IWriteLine("void _Init();");
      w.WriteLine("");
    }

    foreach (Constructor_9 c in constructors_) {
      access = EmitAccess(w, access, c.attributes_);
      c.EmitDeclaration(w);
    }

    if (virtual_) {
      access = EmitAccess(w, access, Attribute_9.Public);
      w.IWrite("virtual ~{0}()", name_);
      w.WriteLine(" { }");
      w.WriteLine("");
    }

    if (need_destroy_) {
      access = EmitAccess(w, access, Attribute_9.Public);
      w.IWriteLine("GEL_OBJECT({0})", name_);
      w.WriteLine("");
    }

    foreach (Method_9 m in methods_) {
      access = EmitAccess(w, access, m.attributes_);
      m.EmitDeclaration(w);
    }

    w.SubIndent();
    w.WriteLine("};");
    w.WriteLine("");
  }

  public void Emit(SourceWriter_9 w) {
    if (IsExtern())
      return;

    if (fields_.Count > 0) {
      foreach (Field_9 f in fields_)
        f.Emit(w);
      w.WriteLine("");
    }

    if (constructors_.Count > 1) {
      w.IWrite("void {0}::_Init() ", name_);
      w.OpenBrace();
      EmitInitializers(w);
      w.CloseBrace();
      w.WriteLine("");
    }

    foreach (Constructor_9 c in constructors_)
      c.Emit(w);

    foreach (Method_9 m in methods_)
      m.Emit(w);

    if (Gel_9.print_type_sets_)
      Console.WriteLine("~{0}: {1}", name_, TypeDestroys());
  }
}

class ClassPtr_9 {
  public readonly Class_9 class_;

  public ClassPtr_9(Class_9 c) { class_ = c; }
}

class ValueList_9 {
  public ArrayList list_;
  public ValueList_9(ArrayList list) { list_ = list; }

  public GValue_9 Object(int i) { return ((RValue_9) list_[i]).Get(); }
  public bool Bool(int i) { return ((GBool_9) list_[i]).b_; }
  public int Int(int i) { return ((GInt_9) list_[i]).i_; }
  public char Char(int i) { return ((GChar_9) list_[i]).c_; }
  public string GetString(int i) { return ((GString_9) list_[i]).s_; }
}

class Internal_9 : Class_9 {
  static NonOwningArrayList /* of Internal_9 */ ^all_ = new NonOwningArrayList();

  protected Internal_9(string name) : base(name) { }

  public static Internal_9 Find(string name) {
    foreach (Internal_9 p in all_)
      if (p.name_ == name)
        return p;
    return null;
  }

  static void Add(Internal_9 p) { all_.Add(p); }

  public static void Init() {
    Add(GObject_9.type_);
    Add(GArray_9.array_class_);
    Add(GBool_9.type_);
    Add(GChar_9.type_);
    Add(GDouble_9.type_);
    Add(GFloat_9.type_);
    Add(GInt_9.type_);
    Add(GString_9.type_);
    Add(GStringBuilder_9.type_);
    Add(PoolClass_9.instance_);
    Add(DebugClass_9.instance_);
    Add(EnvironmentClass_9.instance_);

    Add(ConsoleClass_9.instance_);
    Add(FileClass_9.instance_);
    Add(PathClass_9.instance_);
    Add(GStreamReader_9.type_);
  }
}

class ObjectClass_9 : Internal_9 {
  public Method_9 equals_;
  public Method_9 get_hash_code_;
  public Method_9 to_string_;

  public ObjectClass_9() : base("Object") { }

  public override void Add(Method_9 ^m) {
    switch (m.name_) {
      case "Equals": equals_ = m; break;
      case "GetHashCode": get_hash_code_ = m; break;
      case "ToString": to_string_ = m; break;
    }
    base.Add(m);
  }
}

class ArrayClass_9 : Internal_9 {
  public ArrayClass_9() : base("Array") { }
}

abstract class SimpleType_9 : Internal_9 {
  protected SimpleType_9(string name) : base(name) { }

  public override bool IsOwned() { return false; }
  public override bool IsReference() { return false; }
  public override bool IsValue() { return true; }

  public override string EmitExprType() { return EmitType(); }
  public override string EmitType() { Debug.Assert(false); return null; }
}

abstract class IntegralType_9 : SimpleType_9 {
  protected IntegralType_9(string name) : base(name) { }
}

class BoolClass_9 : IntegralType_9 {
  public BoolClass_9() : base("Bool") { }

  static GBool_9 ^default_ = new GBool_9(false);
  public override SimpleValue_9 DefaultValue_9() { return default_; }

  public override string ToString() { return "bool"; }

  public override string EmitType() { return "bool"; }
}

class CharClass_9 : IntegralType_9 {
  public CharClass_9() : base("Char") { }

  static GChar_9 ^default_ = new GChar_9('\0');

  public override SimpleValue_9 DefaultValue_9() { return default_; }

  public override bool CanConvert1(GType_9 t) { return t == GInt_9.type_; }

  public override string ToString() { return "char"; }

  public override RValue_9 ^InvokeStatic(Method_9 m, ValueList_9 args) {
    switch (m.name_) {
      case "IsDigit": return new GBool_9(Char.IsDigit(args.Char(0)));
      case "IsLetter": return new GBool_9(Char.IsLetter(args.Char(0)));
      case "IsWhiteSpace": return new GBool_9(Char.IsWhiteSpace(args.Char(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "wchar_t"; }
}

class IntClass_9 : IntegralType_9 {
  public IntClass_9() : base("Int") { }

  static GInt_9 ^default_ = new GInt_9(0);

  public override SimpleValue_9 DefaultValue_9() { return default_; }

  public override bool CanConvert1(GType_9 t) {
    return t == GFloat_9.type_ || t == GDouble_9.type_;
  }

  protected override bool CanConvertExplicit1(GType_9 t) {
    return t == GChar_9.type_;
  }

  public override string ToString() { return "int"; }

  public override RValue_9 ^InvokeStatic(Method_9 m, ValueList_9 args) {
    switch (m.name_) {
      case "Parse": return new GInt_9(int.Parse(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "int"; }
}

class FloatClass_9 : SimpleType_9 {
  public FloatClass_9() : base("Single") { }

  static GFloat_9 ^default_ = new GFloat_9(0.0f);

  public override SimpleValue_9 DefaultValue_9() { return default_; }

  public override bool CanConvert1(GType_9 t) {
    return t == GDouble_9.type_;
  }

  protected override bool CanConvertExplicit1(GType_9 t) {
    return t == GInt_9.type_;
  }

  public override string ToString() { return "float"; }

  public override string EmitType() { return "float"; }
}

class DoubleClass_9 : SimpleType_9 {
  public DoubleClass_9() : base("Double") { }

  static GDouble_9 ^default_ = new GDouble_9(0.0d);

  public override SimpleValue_9 DefaultValue_9() { return default_; }

  protected override bool CanConvertExplicit1(GType_9 t) {
    return t == GInt_9.type_ || t == GFloat_9.type_;
  }

  public override string ToString() { return "double"; }

  public override string EmitType() { return "double"; }
}

class StringClass_9 : Internal_9 {
  public StringClass_9() : base("String") { }

  public override bool IsOwned() { return false; }
  public override bool IsValue() { return true; }

  public override string ToString() { return "string"; }

  public override string EmitType() {
    return "_Ref<String>";
  }

  public override string EmitReturnType() {
    return EmitType();
  }

  public override string EmitGenericType() {
    return EmitType();
  }

  public override RValue_9 ^InvokeStatic(Method_9 m, ValueList_9 args) {
    switch (m.name_) {
      case "Format": return new GString_9(String.Format(args.GetString(0), args.Object(1)));
      default: Debug.Assert(false); return null;
    }
  }
}

class StringBuilderClass_9 : Internal_9 {
  public StringBuilderClass_9() : base("StringBuilder") { }
  public override GValue_9 ^New_9() { return new GStringBuilder_9(); }
}

class GStringBuilder_9 : GValue_9 {
  readonly StringBuilder ^b_ = new StringBuilder();

  public static readonly StringBuilderClass_9 ^type_ = new StringBuilderClass_9();

  public override GType_9 Type() { return type_; }

  public override RValue_9 ^Invoke(Method_9 m, ValueList_9 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "Append": b_.Append(args.Char(0)); return null;
      case "ToString": return new GString_9(b_.ToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class PoolClass_9 : Internal_9 {
  public PoolClass_9() : base("Pool") { }

  public static PoolClass_9 ^instance_ = new PoolClass_9();
}

class DebugClass_9 : Internal_9 {
  public DebugClass_9() : base("Debug") { }
  public static readonly DebugClass_9 ^instance_ = new DebugClass_9();
  
  public override RValue_9 ^InvokeStatic(Method_9 m, ValueList_9 args) {
    switch (m.name_) {
      case "Assert": Debug.Assert(args.Bool(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

class EnvironmentClass_9 : Internal_9 {
  public EnvironmentClass_9() : base("Environment") { }
  public static readonly EnvironmentClass_9 ^instance_ = new EnvironmentClass_9();

  public override RValue_9 ^InvokeStatic(Method_9 m, ValueList_9 args) {
    switch (m.name_) {
      case "Exit": Environment.Exit(args.Int(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

// built-in I/O classes

class ConsoleClass_9 : Internal_9 {
  public ConsoleClass_9() : base("Console") { }

  public override RValue_9 ^InvokeStatic(Method_9 m, ValueList_9 args) {
    switch (m.name_) {
      case "Write":
        switch (m.parameters_.Count) {
          case 1: Console.Write(args.Object(0)); return null;
          case 2: Console.Write(args.GetString(0), args.Object(1)); return null;
          case 3: Console.Write(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      case "WriteLine":
        switch (m.parameters_.Count) {
          case 1: Console.WriteLine(args.Object(0)); return null;
          case 2: Console.WriteLine(args.GetString(0), args.Object(1)); return null;
          case 3: Console.WriteLine(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly ConsoleClass_9 ^instance_ = new ConsoleClass_9();
}

class FileClass_9 : Internal_9 {
  public FileClass_9() : base("File") { }

  public override RValue_9 ^InvokeStatic(Method_9 m, ValueList_9 args) {
    switch (m.name_) {
      case "Delete": File.Delete(args.GetString(0)); return null;
      case "Exists": return new GBool_9(File.Exists(args.ToString()));
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly FileClass_9 ^instance_ = new FileClass_9();
}

class PathClass_9 : Internal_9 {
  public PathClass_9() : base("Path") { }

  public override RValue_9 ^InvokeStatic(Method_9 m, ValueList_9 args) {
    switch (m.name_) {
      case "GetTempFileName": return new GString_9(Path.GetTempFileName());
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly PathClass_9 ^instance_ = new PathClass_9();
}

class StreamReaderClass_9 : Internal_9 {
  public StreamReaderClass_9() : base("StreamReader") { }
  public override GValue_9 ^New_9() { return new GStreamReader_9(); }
}

class GStreamReader_9 : GValue_9 {
  StreamReader ^reader_;

  public static readonly StreamReaderClass_9 ^type_ = new StreamReaderClass_9();

  public override GType_9 Type() { return type_; }

  public override RValue_9 ^Invoke(Method_9 m, ValueList_9 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StreamReader": reader_ = new StreamReader(args.GetString(0)); return null;
      case "Read": return new GInt_9(reader_.Read());
      case "Peek": return new GInt_9(reader_.Peek());
      default: Debug.Assert(false); return null;
    }
  }
}

class Program_9 {
  ArrayList /* of string */ ^gel_import_ = new ArrayList();
  ArrayList /* of string */ ^cpp_import_ = new ArrayList();

  static Scanner_9 ^scanner_;

  NonOwningArrayList ^classes_ = new NonOwningArrayList();
  ArrayList ^own_classes_ = new ArrayList();

  public bool crt_alloc_;
  public bool debug_;
  public bool safe_ = true;

  public Control_9 prev_;   // previous node in control flow graph, used during graph construction

  public void Import(string s) {
    ArrayList a = null;
    string extension = Path.GetExtension(s);
    switch (extension) {
      case ".gel": a = gel_import_; break;
      case ".cpp": a = cpp_import_; break;
      default:
        new Syntax_9().Error("can't import file with extension {0}", extension);
        Environment.Exit(0);
        break;
    }
    foreach (string i in a)
      if (i == s)
        return;   // already imported
    a.Add(s);
  }

  public void FindAndImport(string s) {
    // First look relative to the importing file.
    string dir = Path.GetDirectoryName(Gel_9.CurrentFile());
    string s1 = Path.Combine(dir, s);
    if (!File.Exists(s1)) {
      // Now look relative to the GEL2 directory.
      s1 = Path.Combine(Gel_9.gel_directory_, s);
      if (!File.Exists(s1)) {
        new Syntax_9().Error("import not found: ", s);
        Environment.Exit(0);
      }
    }
    Import(s1);
  }
  
  public void Add(Class_9 c) {
    c.SetProgram(this);
    classes_.Add(c);
  }

  public void AddOwn(Class_9 ^c) {
    own_classes_.Add(c);
  }

  public Class_9 FindClass(string name) {
    foreach (Class_9 c in classes_)
      if (c.name_ == name)
        return c;
    return null;
  }

  public string CurrentFile() {
    return scanner_.filename_;
  }

  public int Line() {
    return scanner_.Line();
  }

  string Builtin(string module) {
    string file = String.Format("{0}.gel", module);
    return Path.Combine(Gel_9.gel_directory_, file);
  }

  public bool Parse() {
    Parser ^parser = new Parser();
    for (int i = 0; i < gel_import_.Count; ++i) {
      string file = (string) gel_import_[i];
      scanner_ = new Scanner_9(file);
      parser.yyParse(scanner_);
      if (i == 0) {
        Import(Builtin("internal"));
        Import(Builtin("library"));
      }
    }
    return true;
  }

  public bool Resolve() {
    foreach (Class_9 c in classes_)
      if (!c.ResolveAll(this))
        return false;

    return true;
  }

  public bool Check() {
    Context_9 ^ctx = new Context_9(this);
    bool ok = true;

    // Make a first checking pass where we check only constant fields.
    foreach (Class_9 c in classes_)
      ok &= c.Check1(ctx);

    foreach (Class_9 c in classes_)
      ok &= c.Check(ctx);

    return ok;
  }

  Method_9 FindMain() {
    NonOwningArrayList ^methods = new NonOwningArrayList();
    foreach (Class_9 c in classes_) {
      c.GetMainMethod(methods);
    }
    if (methods.Count == 0) {
      Console.WriteLine("no Main() method found");
      return null;
    }
    if (methods.Count > 1) {
      Console.WriteLine("error: found more than one Main() method");
      return null;
    }
    return (Method_9) methods[0];
  }

  public void Eval(ArrayList /* of string */ args) {
    Method_9 m = FindMain();
    if (m == null)
      return;
    ArrayList ^a = new ArrayList();
    if (m.parameters_.Count > 0) {   // Main() takes a string[] argument
      GArray_9 ^arr = new GArray_9(new ArrayType_9(GString_9.type_), args.Count);
      for (int i = 0 ; i < args.Count ; ++i)
        arr.Set(i, new GString_9((string) args[i]));
      a.Add(arr);
    }
    foreach (Class_9 c in classes_)
      c.StaticInit();
    m.Invoke(null, a);
  }

  void EmitMain(SourceWriter_9 w, Method_9 main) {
    bool args = main.parameters_.Count > 0;
    w.Write("int main({0}) ", args ? "int argc, char *argv[]" : "");
    w.OpenBrace();
    w.IWriteLine("return gel_runmain({0}::Main{1});", main.GetClass().name_, args ? ", argc, argv" : "");
    w.CloseBrace();
  }

  public bool Emit(SourceWriter_9 w) {
    Method_9 main = FindMain();
    if (main == null)
      return false;

    w.WriteLine("#define MEMORY_OWN 1");
    if (safe_)
      w.WriteLine("#define MEMORY_SAFE 1");
    if (crt_alloc_)
      w.WriteLine("#define MEMORY_CRT 1");

    foreach (string f in cpp_import_)
      w.WriteLine("#include {0}", GString_9.EmitString(f));

    // We undefine NULL since Gel_9 code may legitimately define fields or variables with that name.
    // Generated code uses 0, not NULL, to indicate the null pointer.
    w.WriteLine("#undef NULL");

    w.WriteLine("");

    // Forward-declare all classes since C++ requires a class to be declared before its name can
    // be used as a type.
    foreach (Class_9 c in classes_)
      if (!(c.HasAttribute(Attribute_9.Extern)))
        w.WriteLine("class {0};", c.name_);
    w.WriteLine("");

    foreach (Class_9 c in classes_)
      c.EmitDeclaration(w);

    foreach (Class_9 c in classes_)
      c.Emit(w);

    EmitMain(w, main);
    return true;
  }

  // Emit C++ code.
  public bool Generate(string basename) {
    string cpp_file = basename + ".cpp";
    StreamWriter ^w = new StreamWriter(cpp_file);
    bool ok = Emit(new SourceWriter_9(w));
    w.Close();
    return ok;
  }

  static string[] ^vsdirs = { "Microsoft Visual Studio 8",
                            "Microsoft Visual Studio .NET 2003",
                            "Microsoft Visual Studio .NET 2002" };

  string VsVars(int i) {
    return String.Format("C:\\Program_9 Files\\{0}\\Common7\\Tools\\vsvars32.bat", vsdirs[i]);
  }

  string FindVsVars() {
    for (int i = 0; i < vsdirs.Length; ++i) {
      string f = VsVars(i);
      if (File.Exists(f))
        return f;
    }

    Console.WriteLine("Error: unable to find vsvars32.bat at any of the following locations:");
    Console.WriteLine("");
    for (int i = 0; i < vsdirs.Length; ++i)
      Console.WriteLine(VsVars(i));
    Console.WriteLine("");
    Console.WriteLine("Your Visual Studio installation may be invalid.  Aborting compilation.");
    return null;
  }

  // Report compilation error. Print error message from a file
  void ReportCompilationError(string error_msg_file) {
      Console.WriteLine(
        "Error: unable to compile generated C++ code.  You may have found a bug in the GEL2 compiler.");
      Console.WriteLine("C++ compiler output follows:");
      Console.WriteLine("");
      Console.WriteLine((new StreamReader(error_msg_file)).ReadToEnd());
  }

  void UnixCppCompile(string basename) {
    string command_out = Path.GetTempFileName();
    string dbg_options = debug_ ? "-g -DDEBUG" : "-O2 -DNDEBUG";
    StringBuilder ^sb = new StringBuilder();
    // -o basename, use basename as the executable name
    // -Werror, make all warnings into hard errors
    sb.AppendFormat("/usr/bin/g++ -o {0} -Werror {1} {2}.cpp",
                    basename, dbg_options, basename);

    // Append redirection of output
    sb.AppendFormat(" > {0} 2>&1", command_out);
 
    string sh_cmd = sb.ToString();

    if (Gel_9.verbose_) 
      Console.WriteLine(sh_cmd);
  
    if (Process.System(sh_cmd) !=0) {
      ReportCompilationError(command_out);
    }
    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".o");
  }

  // Run vsvars32.bat and the run the given command, redirecting output to a file.
  // We must always redirect output since vsvars32 prints a message "Setting environment..."
  // which we don't want users to see.
  int VsRun(string vsvars, string command, string output) {
    command = String.Format("(\"{0}\" & {1}) > \"{2}\"", 
                            vsvars, command, output);
    return Process.System(command);
  }

  void VsCppCompile(string basename) {
    string vsvars = FindVsVars();
    if (vsvars == null)
      return;
    string command_out = Path.GetTempFileName();

    string options = debug_ ?
      //  /MDd - runtime library: multithreaded debug DLL
      //  /Od - optimization: disabled
      //  /ZI - debug information format: Program_9 Database for Edit & Continue_9
      "/MDd /Od /ZI /D \"_DEBUG\"" :

      //  /MD - runtime library: multithreaded DLL
      //  /O2 - optimization: Maximize Speed
      //  /GL - optimization: Whole Program_9 Optimization
      "/MD /O2 /GL /D \"NDEBUG\"";

    StringBuilder ^sb = new StringBuilder();
    //  /WX - treat warnings as errors
    sb.AppendFormat("cl /nologo /WX {0} {1}.cpp", options, basename);
    string mode = debug_ ? "debug" : "release";
    if (!crt_alloc_)
      sb.AppendFormat(" {0}\\{1}\\dlmalloc.obj", Gel_9.gel_directory_, mode);
    sb.Append(" user32.lib shell32.lib shlwapi.lib");
    string command = sb.ToString();
    if (Gel_9.verbose_)
      Console.WriteLine(command);

    if (VsRun(vsvars, command, command_out) != 0) {
      ReportCompilationError(command_out);
    } else {
      // Run the manifest tool to embed the linker-generated manifest into the executable file;
      // this allows the executable to find the C runtime DLL even when the manifest file is absent.
      string mt_command = String.Format("mt -nologo -manifest {0}.exe.manifest -outputresource:\"{0}.exe;#1\"",
                              basename);
      if (Gel_9.verbose_)
        Console.WriteLine(mt_command);
      if (VsRun(vsvars, mt_command, command_out) != 0)
        Console.WriteLine("warning: could not run manifest tool");
    }

    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".obj");
    File.Delete(basename + ".exe.manifest");
  }

  // Invoke the C++ compiler to generate a native executable.
  void CppCompile(string basename) {
    if (Environment.OSVersion.Platform == PlatformID.Win32NT) 
      VsCppCompile(basename);
    else
      UnixCppCompile(basename);
  }

  public void Compile(string output, bool cpp_only) {
    if (output == null)
      output = Path.GetFileNameWithoutExtension((string) gel_import_[0]);
    if (Generate(output) && !cpp_only)
      CppCompile(output);
  }
}

class Scanner_9 : yyInput {
  public readonly string filename_;

  int line_;
  public int Line() { return line_; }

  StreamReader ^sr_;
  int token_;
  object ^ value_;

  int next_token_ = -1;
  object ^ next_value_;

  public Scanner_9 (string filename) {
    filename_ = filename;
    sr_ = new StreamReader(filename);
    line_ = 1;
  }

  public override int GetToken () {
    return token_;
  }

  public override object ^ GetValue () {
    return take value_;
  }

  int Read() {
    int i = sr_.Read();
    if (i == '\n')
      ++line_;
    return i;
  }

  bool Read(out char c) {
    int i = Read();
    c = (char) i;
    return i != -1;
  }

  char Peek() {
    return (char) sr_.Peek();
  }

  string ReadWord(char first) {
    StringBuilder ^sb = new StringBuilder();
    if (first != '\0')
      sb.Append(first);
    while (true) {
      char c = Peek();
      if (!Char.IsLetter(c) && !Char.IsDigit(c) && c != '_')
        break;
      sb.Append(c);
      Read();
    }
    return sb.ToString();
  }

  // Read to the end of the current line.
  string ReadLine() {
    StringBuilder ^sb = new StringBuilder();
    char c;
    while (Read(out c)) {
      if (c == '\n')
        break;
      sb.Append(c);
    }
    return sb.ToString();
  }

  // Read a comment delimited by /* ... */, assuming we've already read the opening /*.
  // Returns true on success, or false on EOF.
  bool ReadDelimitedComment() {
    char prev = (char) 0;
    while (true) {
      char c;
      if (!Read(out c)) {
        Console.WriteLine("warning: unterminated comment at end of file");
        return false;
      }
      if (c == '/' && prev == '*')
        return true;
      prev = c;
    }
  }

  // Preprocess input, handling whitespace, comments and directives; return the first
  // character not eaten by preprocessing, or -1 on EOF.
  int GetChar() {
    while (true) {
      int i = Read();
      if (i == -1)
        return -1;   // end of input
      if (i == 0)
        continue;   // end of this file; move on
      char c = (char) i;

      if (c == '\n' && Peek() == '#') {
        Read();
        string directive = ReadWord('\0');
        if (directive == "line") {
          ReadLine();
          continue;
        }
        Console.WriteLine("error: unknown preprocessing directive {0}", directive);
        Environment.Exit(0);
      }

      if (Char.IsWhiteSpace(c))
        continue;

      if (c == '/') {
        switch (Peek()) {
          case '/':  // single-line comment
            Read();
            int line = line_;
            string s = ReadLine();
            if (Gel_9.error_test_ && s.StartsWith(" error"))
              Gel_9.expected_error_lines_.Add(line);
            continue;

          case '*':  // comment delimited by /* ... */
            Read();   // move past opening '*'
            if (!ReadDelimitedComment())
              return (char) 0;
            continue;
        }
      }

      return c;
    }
  }

  bool IsDigit(char c, bool hex) {
    if (Char.IsDigit(c))
      return true;
    if (!hex)
      return false;
    return (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');
  }

  // Read a number, possibly including a decimal point and/or exponent.
  string ReadNumber(char first, bool hex, out bool real) {
    bool dot = false, exp = false;
    StringBuilder ^sb = new StringBuilder();
    sb.Append(first);
    if (first == '.')
      dot = true;

    while (true) {
      bool need_digit = false;
      char c = Peek();
      if (c == '.' && !hex && !dot && !exp) {
        sb.Append(c);
        Read();
        dot = true;
        c = Peek();
        need_digit = true;
      }
      else if ((c == 'e' || c == 'E') && !hex && !exp) {
        sb.Append(c);
        Read();
        exp = true;
        c = Peek();
        if (c == '+' || c == '-') {
          sb.Append(c);
          Read();
          c = Peek();
        }
        need_digit = true;
      }
      if (!IsDigit(c, hex)) {
        if (!need_digit)
          break;
        real = false;
        return null;
      }
      sb.Append(c);
      Read();
    }

    real = dot || exp;
    return sb.ToString();
  }

  int ParseNumber(char first, out object ^val) {
    bool hex = false;
    if (first == '0') {
      char p = Peek();
      if (p == 'x' || p == 'X') {
        Read();
        hex = true;
      }
    }
    bool real;
    string s = ReadNumber(first, hex, out real);
    if (s == null) {
      val = null;
      return Parser.SCAN_ERROR;
    }
    if (!hex) {
      switch (Peek()) {
        case 'F':
        case 'f':
          Read();
          val = Single.Parse(s);
          return Parser.FLOAT_LITERAL;
        case 'D':
        case 'd':
          Read();
          real = true;
        break;
    }
    }
    if (real) {
      val = Double.Parse(s);
      return Parser.DOUBLE_LITERAL;
    }
    val = int.Parse(s, hex ? NumberStyles.HexNumber : NumberStyles.Integer);
    return Parser.INT_LITERAL;
  }

  int ParseWord(char first, out object ^val) {
    string s = ReadWord(first);

    val = null;
    switch (s) {
      case "abstract": return Parser.ABSTRACT;
      case "as": return Parser.AS;
      case "base": return Parser.BASE;
      case "bool": return Parser.BOOL;
      case "break": return Parser.BREAK;
      case "case": return Parser.CASE;
      case "char": return Parser.CHAR;
      case "class": return Parser.CLASS;
      case "const": return Parser.CONST_TOKEN;
      case "continue": return Parser.CONTINUE;
      case "default": return Parser.DEFAULT;
      case "do": return Parser.DO;
      case "double": return Parser.DOUBLE;
      case "else": return Parser.ELSE;
      case "extern": return Parser.EXTERN;
      case "false": return Parser.FALSE_TOKEN;
      case "float": return Parser.FLOAT;
      case "for": return Parser.FOR;
      case "foreach": return Parser.FOREACH;
      case "if": return Parser.IF;
      case "import": return Parser.IMPORT;
      case "in": return Parser.IN_TOKEN;
      case "int": return Parser.INT;
      case "is": return Parser.IS;
      case "new": return Parser.NEW;
      case "null": return Parser.NULL;
      case "object": return Parser.OBJECT;
      case "out": return Parser.OUT_TOKEN;
      case "override": return Parser.OVERRIDE;
      case "pool": return Parser.POOL;
      case "private": return Parser.PRIVATE;
      case "protected": return Parser.PROTECTED;
      case "public": return Parser.PUBLIC;
      case "readonly": return Parser.READONLY;
      case "ref": return Parser.REF;
      case "return": return Parser.RETURN;
      case "short": return Parser.SHORT;
      case "static": return Parser.STATIC;
      case "string": return Parser.STRING;
      case "switch": return Parser.SWITCH;
      case "take": return Parser.TAKE;
      case "this": return Parser.THIS_TOKEN;
      case "true": return Parser.TRUE_TOKEN;
      case "virtual": return Parser.VIRTUAL;
      case "void": return Parser.VOID_TOKEN;
      case "while": return Parser.WHILE;
      default:
        val = s;
        return Parser.ID;
    }
  }

  bool ParseEscape(ref char c) {
    if (!Read(out c))
      return false;
    switch (c) {
      case '\'':
      case '\"':
      case '\\':
        break;
      case '0': c = '\0'; break;
      case 'n': c = '\n'; break;
      case 'r': c = '\r'; break;
      case 't': c = '\t'; break;
      default: return false;
    }
    return true;
  }

  int ParseChar(out object ^val) {
    val = null;
    char c;
    if (!Read(out c))
      return Parser.SCAN_ERROR;
    if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
    char d;
    if (!Read(out d) || d != '\'')
      return Parser.SCAN_ERROR;
    val = c;
    return Parser.CHAR_LITERAL;
  }

  int ParseString(out object ^val) {
    val = null;
    StringBuilder ^sb = new StringBuilder();
    while (true) {
      char c;
      if (!Read(out c))
        return Parser.SCAN_ERROR;
      if (c == '"')
        break;
      if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
      sb.Append(c);
    }
    val = sb.ToString();
    return Parser.STRING_LITERAL;
  }

  int ReadToken(out object ^val) {
    val = null;

    int i = GetChar();
    if (i == -1)
      return -1;
    char c = (char) i;

    if (Char.IsDigit(c) || c == '.' && Char.IsDigit(Peek()))
      return ParseNumber(c, out val);

    if (Char.IsLetter(c) || c == '_')
      return ParseWord(c, out val);

    if (c == '\'')
      return ParseChar(out val);

    if (c == '"')
      return ParseString(out val);

    char peek = Peek();
    int token = 0;
    switch (c.ToString() + peek.ToString()) {
      case "++": token = Parser.PLUS_PLUS; break;
      case "--": token = Parser.MINUS_MINUS; break;
      case "&&": token = Parser.OP_AND; break;
      case "||": token = Parser.OP_OR; break;
      case "==": token = Parser.OP_EQUAL; break;
      case "!=": token = Parser.OP_NE; break;
      case "<=": token = Parser.OP_LE; break;
      case "<<": token = Parser.OP_LEFT_SHIFT; break;
      case ">=": token = Parser.OP_GE; break;
      case ">>": token = Parser.OP_RIGHT_SHIFT; break;
      case "*=": token = Parser.STAR_EQUAL; break;
      case "/=": token = Parser.SLASH_EQUAL; break;
      case "%=": token = Parser.PERCENT_EQUAL; break;
      case "+=": token = Parser.PLUS_EQUAL; break;
      case "-=": token = Parser.MINUS_EQUAL; break;
      case "&=": token = Parser.AND_EQUAL; break;
      case "|=": token = Parser.OR_EQUAL; break;

      // Return_9 [] as a single token; this lets the parser distinguish the cases
      // "foo[] a;" and "foo[x] = 4" as soon as it reads the first token after the identifier "foo".
      case "[]": token = Parser.ARRAY_TYPE; break;
    }
    if (token != 0) {
      Read();
    } else token = c;

    val = token;
    return token;
  }

  public override bool Advance () {
    if (next_token_ != -1) {
      token_ = next_token_;
      value_ = take next_value_;
      next_token_ = -1;
    } else {
      token_ = ReadToken(out value_);
      if (token_ == -1) return false;
    }

    if (token_ == ')') {
      // We need to read one token ahead to determine whether this close parenthesis
      // ends a type cast.  See e.g. the discussion in the Cast_9 Expressions section
      // of the C# specification.
      next_token_ = ReadToken(out next_value_);
      switch (next_token_) {
        case -1:  // end of file
          break;
        case '!':
        case '(':
        case Parser.ID:
        case Parser.INT_LITERAL:
        case Parser.CHAR_LITERAL:
        case Parser.STRING_LITERAL:
          token_ = Parser.CAST_CLOSE_PAREN;
          break;
        default:
          if (next_token_ >= Parser.FIRST_KEYWORD && next_token_ <= Parser.LAST_KEYWORD &&
              next_token_ != Parser.AS && next_token_ != Parser.IS)
            token_ = Parser.CAST_CLOSE_PAREN;
          break;
      }
    }
    return true;
  }

  public override void Fatal() {
    new Syntax_9().Error("irrecoverable syntax error");
    Environment.Exit(1);
  }

}

class Gel_9 {
  public static bool verbose_;

  public static bool error_test_;
  public static bool print_type_sets_;

  public static readonly ArrayList /* of int */ ^expected_error_lines_ = new ArrayList();
  public static readonly ArrayList /* of int */ ^error_lines_ = new ArrayList();

  public static Program_9 ^program_;

  public static readonly string gel_directory_ = GetLibraryPath();

  static string GetLibraryPath() {
    return Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName); 
  }

  public static string CurrentFile() {
    return program_ == null ? "" : program_.CurrentFile();
  }

  public static int Line() {
    return program_ == null ? 0 : program_.Line();
  }

  public static void Exit() { Environment.Exit(0); }

  // Given two sorted ArrayLists a, b of ints, return an ArrayList containing all ints which appear
  // in [a] but not in [b].
  ArrayList ^Diff(ArrayList a, ArrayList b) {
    ArrayList ^ret = new ArrayList();
    int bi = 0;
    foreach (int i in a) {
      while (bi < b.Count && (int) b[bi] < i)
        ++bi;
      if (bi >= b.Count || (int) b[bi] > i)
        ret.Add(i);
    }
    return ret;
  }

  void WriteLineNumbers(ArrayList a) {
    for (int i = 0; i < a.Count; ++i) {
      if (i > 0)
        Console.Write(", ");
      Console.Write(a[i]);
    }
    Console.WriteLine("");
  }

  void ErrorTestReport() {
    Console.WriteLine("");
    ArrayList ^e = Diff(error_lines_, expected_error_lines_);
    if (e.Count > 0) {
      Console.Write("unexpected error at line ");
      WriteLineNumbers(e);
    }
    ArrayList ^e2 = Diff(expected_error_lines_, error_lines_);
    if (e2.Count > 0) {
      Console.Write("expected error at line ");
      WriteLineNumbers(e2);
    }
    if (e.Count == 0 && e2.Count == 0)
      Console.WriteLine("all errors expected");
  }

  void Usage_9() {
    Console.WriteLine("usage: gel <source-file> ... [args]");
    Console.WriteLine("       gel -c [-d] [-o <name>] [-u] [-v] [-cpp] <source-file> ...");
    Console.WriteLine("");
    Console.WriteLine("   -c: compile to native executable");
    Console.WriteLine("   -d: debug mode: disable optimizations, link with debug build of C runtime");
    Console.WriteLine("   -o: specify output filename");
    Console.WriteLine("   -u: unsafe: skip reference count checks");
    Console.WriteLine("   -v: verbose: display command used to invoke C++ compiler");
    Console.WriteLine(" -cpp: compile to C++ only");
  }

  public void Run(string[] args) {
    if (args.Length < 1) {
      Usage_9();
      return;
    }

    Internal_9.Init();

    program_ = new Program_9();
    bool compile = false;
    bool cpp_only = false;
    string output = null;
    int i;
    for (i = 0; i < args.Length && args[i].StartsWith("-"); ++i)
      switch (args[i]) {
        case "-c": compile = true; break;
        case "-d": program_.debug_ = true; break;
        case "-e": error_test_ = true; break;
        case "-o":
          if (++i >= args.Length) {
            Usage_9();
            return;
          }
          output = Path.GetFileNameWithoutExtension(args[i]);
          break;
        case "-u": program_.safe_ = false; break;
        case "-v": verbose_ = true; break;
        case "-cpp": cpp_only = true; break;
        case "-crt": program_.crt_alloc_ = true; break;
        case "-typeset": print_type_sets_ = true; break;
        default:
          Console.WriteLine("unrecognized option: {0}", args[i]);
          return;
      }

    for (; i < args.Length ; ++i)
      if (args[i].EndsWith(".gel"))
        program_.Import(args[i]);
      else {
        if (args[i] == "-")   // marker indicating end of source files
          ++i;
        break;
      }

    ArrayList ^program_args = new ArrayList();
    if (compile) {
      if (i < args.Length) {
        Console.WriteLine("file to compile has unrecognized extension: {0}", args[i]);
        return;
      }
    } else {
      for (; i < args.Length; ++i)
        program_args.Add(args[i]);
    }

    if (!program_.Parse())
      return;

    bool ok = program_.Resolve() && program_.Check();
    if (error_test_)
      ErrorTestReport();
    if (!ok)
      return;

    if (compile)
      program_.Compile(output, cpp_only);
    else program_.Eval(program_args);
  }

  public static void Main_9(string[] args) {
    new Gel_9().Run(args);
  }
}
/*
Copyright (c) 2006 Google Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

class Syntax_10 {
  public readonly string file_;
  public readonly int line_;

  public Syntax_10() { file_ = Gel_10.CurrentFile(); line_ = Gel_10.Line(); }

  static void Report(string file, int line, string type) {
    Console.Write("{0}({1}): ", file, line);
    Console.Write("{0}: ", type);
    if (Gel_10.error_test_)
      Gel_10.error_lines_.Add(line);
  }

  public void Error(string message) {
    Report(file_, line_, "error");
    Console.WriteLine(message);
  }

  public void Error(string format, object arg) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg);
  }

  public void Error(string format, object arg1, object arg2) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2);
  }

  public void Error(string format, object arg1, object arg2, object arg3) {
    Report(file_, line_, "error");
    Console.WriteLine(format, arg1, arg2, arg3);
  }

  public void Warning(string message) {
    Report(file_, line_, "warning");
    Console.WriteLine(message);
  }
}

abstract class TypeExpr_10 : Syntax_10 {
  public abstract GType_10 Resolve(Program_10 program);
  public abstract TypeExpr_10 ^Copy();
}

class ConversionContext_10 {
  public const int Other = 0,
                   AssignVar = 1,
                   MethodArg = 2;
}

// GEL2 includes the following kinds of types:
// - simple types (int, bool, char, float, double): SimpleType_10
// - owned types (including array types): ArrayType_10 or Class_10 with Owned() => true
// - owning types: Owning_10
// - string: GString_10
// - null type: NullType_10
// - void: VoidType_10

abstract class GType_10 {
  public virtual bool IsOwned() { return false; }

  // A reference type is an owned, owning, string or null type.
  public virtual bool IsReference() { return true; }

  // A value type is a simple or string type.
  public virtual bool IsValue() { return false; }

  public virtual Class_10 Parent() { return GObject_10.type_; }
  
  // If_10 this is an owning type T ^ then return T; otherwise return this.
  public virtual GType_10 BaseType() { return this; }

  // Return_10 the set of types which may be destroyed when a variable of this type
  // is destroyed.
  public virtual TypeSet_10 VarDestroys() { return TypeSet_10.empty_; }

  // Return_10 the set of types which may be destroyed when a value of this concrete type
  // is destroyed.
  public virtual TypeSet_10 TypeDestroys() { return TypeSet_10.empty_; }

  public virtual void FindVarDestroys(int marker, TypeSet_10 set) { }

  public virtual void FindTypeDestroys(int marker, TypeSet_10 set) { }

  public virtual bool IsSubtype(GType_10 type) {
    for (GType_10 t = this; t != null ; t = t.Parent())
      if (type.Equals(t))
        return true;
    return false;
  }

  public virtual Owning_10 OwningType() { Debug.Assert(false); return null; }

  protected virtual bool CanConvertOwnership(GType_10 t, int context) {
    bool from_owning = this is Owning_10;
    bool to_owning = t is Owning_10;
    if (IsValue() && t.BaseType() == GObject_10.type_) {
      Debug.Assert(!from_owning);
      // boxing conversion yields an owning pointer; string->object conversion may
      // yield an owning or non-owning pointer
      return to_owning || context == ConversionContext_10.MethodArg || this == GString_10.type_;
    }
    if (BaseType() == GObject_10.type_ && t.IsValue()) {
      Debug.Assert(!to_owning);
      return true;  // an unboxing or object->string conversion, OK in any context
    }
    return from_owning == to_owning ||
           from_owning && !to_owning &&
             (context == ConversionContext_10.AssignVar || context == ConversionContext_10.MethodArg);
  }

  // Ensure that this class will inherit from Object in generated C++ code.
  public virtual void SetObjectInherit() { }

  // Return_10 true if there is a non-subtyping implicit conversion from this to t.
  public virtual bool CanConvert1(GType_10 t) { return false; }

  // Return_10 true if there is a non-subtyping explicit conversion from this to t.
  protected virtual bool CanConvertExplicit1(GType_10 t) { return false; }

  // Return_10 true if this type can be converted to type [to].
  public bool CanConvert(GType_10 to, int context, bool is_explicit, bool subtype_only) {
    if (!CanConvertOwnership(to, context))
      return false;

    GType_10 from_base = BaseType();
    GType_10 to_base = to.BaseType();
    if (from_base.Equals(to_base))
      return true;   // identity conversion

    // If_10 we ever perform a conversion to C ^, then C must have a vtable so that we can call
    // a virtual destructor when an owning pointer is destroyed.
    if (to is Owning_10 && this != Null_10.type_)
      to_base.SetVirtual();

    // If_10 we ever perform an explicit conversion from a class, that class must
    // have a vtable so that every instance of the class will have run-time type information.
    if (is_explicit)
      from_base.SetVirtual();

    // If_10 we ever convert between C and Object, then C must derive from Object in generated code.
    if (from_base == GObject_10.type_)
      to_base.SetObjectInherit();
    else if (to_base == GObject_10.type_)
      from_base.SetObjectInherit();

    return from_base.IsSubtype(to_base) ||
           !subtype_only && from_base.CanConvert1(to_base) ||
           is_explicit && (to_base.IsSubtype(from_base) ||
                           !subtype_only && from_base.CanConvertExplicit1(to_base));
  }

  public bool CanConvert(GType_10 t, int context) { return CanConvert(t, context, false, false); }
  public bool CanConvert(GType_10 t) { return CanConvert(t, ConversionContext_10.Other); }

  public bool CanConvertExplicit(GType_10 t, bool subtype_only) {
    return CanConvert(t, ConversionContext_10.Other, true, subtype_only);
  }

  public bool CheckConvert(Syntax_10 caller, GType_10 t, int context) {
    if (!CanConvert(t, context)) {
      caller.Error("can't convert {0} to {1}", this, t);
      return false;
    }
    return true;
  }

  public bool CheckConvert(Syntax_10 caller, GType_10 t) {
    return CheckConvert(caller, t, ConversionContext_10.Other);
  }

  // Return_10 a type to which the types [this] and t can both be implicitly converted.
  public GType_10 CommonType(Syntax_10 caller, GType_10 t) {
    if (CanConvert(t))
      return t;
    if (t.CanConvert(this))
      return this;
    caller.Error("incompatible types: {0} and {1}", this, t);
    return null;
  }

  public abstract SimpleValue_10 DefaultValue_10();

  static ArrayList ^empty_array_ = new ArrayList();
  public virtual ArrayList /* of Member_10 */ Members() { return empty_array_; }

  public Member_10 GetMatchingMember(Member_10 m1) {
    foreach (Member_10 m in Members())
      if (m.MatchSignature(m1))
        return m;
    return null;
  }

  // Find a match for m in this type or its ancestors, ignoring private members and
  // optionally ignoring overrides.
  public Member_10 FindMatchingMember(Member_10 m, bool override_ok) {
    for (GType_10 t = this ; t != null ; t = t.Parent()) {
      Member_10 m1 = t.GetMatchingMember(m);
      if (m1 != null && !m1.IsPrivate() && (override_ok || !m1.IsOverride()))
        return m1;
    }
    return null;
  }

  int Score(bool accessible, int mismatches) {
    return (accessible ? 0 : 100) + mismatches;
  }

  public Member_10 Lookup(Syntax_10 caller, Class_10 from_class, bool through_base,
                       int kind, string name, ArrayList /* of Argument_10 */ arguments, bool report_error) {
    Member_10 m1 = null;   // the best match we've found so far
    bool found_any = false;
    bool accessible = false;
    int score = -1;

    GType_10 this_type = BaseType();
    GType_10 t;
    for (t = this_type; t != null; t = (kind == MemberKind_10.Constructor_10 ? null : t.Parent())) {
      foreach (Member_10 m in t.Members())
        if (Member_10.MatchKind(m.Kind(), kind) && m.name_ == name && !m.IsOverride()) {
          found_any = true;
          int mismatches = 0;
          if (arguments != null && !m.IsApplicable(arguments, out mismatches))
            continue; // wrong argument count
          bool new_accessible = m.IsAccessible(from_class, this_type, through_base);
          int new_score = Score(new_accessible, mismatches);
          if (new_score == 0 && score == 0) {
            if (report_error)
              caller.Error("{0}: ambiguous {1} call", name, Member_10.ToString(kind));
            return null;
          }
          if (score == -1 || new_score < score) {
            m1 = m;
            score = new_score;
            accessible = new_accessible;
          }
        }
      if (score == 0)
        break;
    }

    if (score != 0) {
      if (report_error) {
        string k = Member_10.ToString(kind);
        if (!found_any)
          caller.Error("{0}: {1} not found", name, k);
        else if (score == -1) {
          string a = String.Format("{0} argument{1}", arguments.Count, arguments.Count == 1 ? "" : "s");
          caller.Error("{0}: no {1} overload takes {2}", name, k, a);
        } else if (!accessible)
          caller.Error("{0}: can't access {1} {2}",
                       name, m1.IsProtected() ? "protected" : "private", k);
        else {
          caller.Error("{0}: the best overloaded {1} match has some invalid arguments", name, k);
          m1.ReportMismatches(caller, arguments);
        }
      }
      return null;
    }

    // If_10 we've found a member of the Object class, then we're using this class as an object,
    // so in generated code it must ultimately inherit from Object, not _Object.
    if (t == GObject_10.type_)
      this_type.SetObjectInherit();

    if (through_base) {
      // As_10 a special case, whenever we're accessing through base we find the member which will
      // actually be invoked; this is not necessarily the same as the member we've just found
      // if the member is virtual.
      m1 = FindMatchingMember(m1, true);
      Debug.Assert(m1 != null);
    }

    return m1;
  }

  public virtual void SetVirtual() { }

  // Emit the name of the C++ class we use to hold instances of this type.
  public virtual string EmitTypeName() { Debug.Assert(false); return null; }

  // Return_10 a C++ type of the form "T<U>".  If_10 U ends with a '>', we emit an
  // extra space to avoid emitting the token >>, which will cause GCC to complain.
  public static string ConstructType(string generic, string type) {
    return String.Format("{0}<{1}{2}>", generic, type,
                         type.EndsWith(">") ? " " : "");
  }

  string EmitNonOwningPointer(string name) {
    if (Gel_10.program_.safe_)
      return ConstructType(this == GObject_10.type_ ? "_PtrRef" : "_Ptr", name);
    return String.Format("{0} *", name);
  }

  // Emit a C++ type used for variables holding instances of this type.
  public virtual string EmitType() {
    return EmitNonOwningPointer(EmitTypeName());
  }

  // Emit a C++ type used for expressions holding instances of this type.
  public virtual string EmitExprType() {
    return EmitTypeName() + " *";
  }

  public virtual string EmitReturnType() {
    return EmitExprType();
  }

  public virtual string EmitGenericType() {
    return IsReference() ? EmitNonOwningPointer("Object") : EmitType();
  }
}

class TypeSet_10 {
  NonOwningArrayList /* of GType_10 */ ^types_ = new NonOwningArrayList();

  public static readonly TypeSet_10 ^empty_ = new TypeSet_10();

  public void Add(GType_10 type) {
    for (int i = 0; i < types_.Count; ++i) {
      GType_10 t = (GType_10) types_[i];
      if (type.IsSubtype(t))
        return;
      if (t.IsSubtype(type)) {
        types_[i++] = type;
        while (i < types_.Count) {
          t = (GType_10) types_[i];
          if (t.IsSubtype(type))
            types_.RemoveAt(i);
          else ++i;
        }
        return;
      }
    }
    types_.Add(type);
  }

  public void Add(TypeSet_10 set) {
    foreach (GType_10 t in set.types_)
      Add(t);
  }

  public bool Contains(GType_10 type) {
    foreach (GType_10 t in types_)
      if (type.IsSubtype(t))
        return true;
    return false;
  }

  public bool IsObject() {
    return types_.Count > 0 && types_[0] == GObject_10.type_;
  }

  public override string ToString() {
    StringBuilder ^sb = new StringBuilder();
    sb.Append("{");
    foreach (GType_10 t in types_)
      sb.AppendFormat(" {0}", t.ToString());
    sb.Append(" }");
    return sb.ToString();
  }
}

class VoidType_10 : GType_10 {
  public override bool IsReference() { Debug.Assert(false); return false; }

  public override SimpleValue_10 DefaultValue_10() { Debug.Assert(false); return null; }

  public override string ToString() { return "void"; }

  public override string EmitExprType() { return "void"; }
  public override string EmitType() { return "void"; }
}

class Void_10 {
  public static readonly GType_10 ^type_ = new VoidType_10();
}

// an RValue_10, a Location_10 containing an RValue_10, or a LocationRef_10 pointing to a Location_10 containing an RValue_10
abstract class ValueOrLocation_10 {
  public abstract GValue_10 Get();
}

// a GValue_10 or a reference to a GValue_10
abstract class RValue_10 : ValueOrLocation_10 {
  public abstract RValue_10 ^CopyRef();
}

abstract class GValue_10 : RValue_10 {
  public override GValue_10 Get() { return this; }

  public abstract GType_10 Type();

  public override RValue_10 ^CopyRef() { return new Reference_10(this); }

  public virtual RValue_10 ^Get(Field_10 field) { Debug.Assert(false); return null; }
  public virtual RValue_10 ^Take_10(Field_10 field) { Debug.Assert(false); return null; }

  public virtual RValue_10 ^ConvertExplicit(ref RValue_10 ^this_own, GType_10 t) {
    // try implicit conversion
    RValue_10 ^v = Convert(ref this_own, t);
    if (v != this || Type().IsSubtype(t) )
      return v;

    Console.WriteLine("type cast failed: object of type {0} is not a {1}", Type(), t);
    Gel_10.Exit();
    return null;
  }

  // Implicitly convert this value to type t.
  public virtual RValue_10 ^Convert(ref RValue_10 ^this_own, GType_10 t) {
    return take this_own;
  }

  public virtual bool DefaultEquals(object o) { return Equals(o); }
  public virtual int DefaultHashCode() { return GetHashCode(); }
  public virtual string DefaultToString() { return ToString(); }

  public virtual RValue_10 ^Invoke(Method_10 m, ValueList_10 args) {
    switch (m.name_) {
      case "Equals": return new GBool_10(DefaultEquals(args.Object(0)));
      case "GetHashCode": return new GInt_10(DefaultHashCode());
      case "ToString": return new GString_10(DefaultToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class Reference_10 : RValue_10 {
  public readonly GValue_10 value_;    // a reference value, never a SimpleValue_10

  public Reference_10(GValue_10 v) { value_ = v; }

  public override GValue_10 Get() { return value_; }

  public override RValue_10 ^CopyRef() { return new Reference_10(value_); }
}

abstract class SimpleValue_10 : GValue_10 {
  public abstract SimpleValue_10 ^Copy();
  public override RValue_10 ^CopyRef() { return Copy(); }
  public abstract string Emit();
}

class GBool_10 : SimpleValue_10 {
  public readonly bool b_;

  public GBool_10(bool b) { b_ = b; }

  public override bool Equals(object o) {
    GBool_10 b = o as GBool_10;
    return b != null && b.b_ == b_;
  }

  public override int GetHashCode() { return b_.GetHashCode(); }

  public override SimpleValue_10 ^Copy() { return new GBool_10(b_); }

  public static readonly BoolClass_10 ^type_ = new BoolClass_10();

  public override GType_10 Type() { return type_; }

  public override string ToString() { return b_.ToString(); }

  public override string Emit() { return b_ ? "true" : "false"; }
}

class GInt_10 : SimpleValue_10 {
  public readonly int i_;

  public GInt_10(int i) { i_ = i; }

  public static readonly IntClass_10 ^type_ = new IntClass_10();

  public override GType_10 Type() { return type_; }

  public override bool Equals(object o) {
    GInt_10 i = o as GInt_10;
    return i != null && i.i_ == i_;
  }

  public override int GetHashCode() { return i_.GetHashCode(); }

  public override SimpleValue_10 ^Copy() { return new GInt_10(i_); }

  public override RValue_10 ^Convert(ref RValue_10 ^this_own, GType_10 t) {
    if (t == GFloat_10.type_)
      return new GFloat_10(i_);
    if (t == GDouble_10.type_)
      return new GDouble_10(i_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_10 ^ConvertExplicit(ref RValue_10 ^this_own, GType_10 t) {
    return t == GChar_10.type_ ? new GChar_10((char) i_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return i_.ToString(); }

  public override string Emit() { return i_.ToString(); }
}

class GFloat_10 : SimpleValue_10 {
  public readonly float f_;

  public GFloat_10(float f) { f_ = f; }

  public static readonly FloatClass_10 ^type_ = new FloatClass_10();

  public override GType_10 Type() { return type_; }

  public override bool Equals(object o) {
    GFloat_10 f = o as GFloat_10;
    return f != null && f.f_ == f_;
  }

  public override int GetHashCode() { return f_.GetHashCode(); }

  public override SimpleValue_10 ^Copy() { return new GFloat_10(f_); }

  public override RValue_10 ^Convert(ref RValue_10 ^this_own, GType_10 t) {
    if (t == GDouble_10.type_)
      return new GDouble_10(f_);
    return base.Convert(ref this_own, t);
  }

  public override RValue_10 ^ConvertExplicit(ref RValue_10 ^this_own, GType_10 t) {
    return t == GInt_10.type_ ? new GInt_10((int) f_) : base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return f_.ToString(); }

  public override string Emit() {
    string s = f_.ToString();
    return s + (s.IndexOf('.') == -1 ? ".0f" : "f");
  }
}

class GDouble_10 : SimpleValue_10 {
  public readonly double d_;

  public GDouble_10(double d) { d_ = d; }

  public static readonly DoubleClass_10 ^type_ = new DoubleClass_10();

  public override GType_10 Type() { return type_; }

  public override bool Equals(object o) {
    GDouble_10 d = o as GDouble_10;
    return d != null && d.d_ == d_;
  }

  public override int GetHashCode() { return d_.GetHashCode(); }

  public override SimpleValue_10 ^Copy() { return new GDouble_10(d_); }

  public override RValue_10 ^ConvertExplicit(ref RValue_10 ^this_own, GType_10 t) {
    if (t == GInt_10.type_)
      return new GInt_10((int) d_);
    if (t == GFloat_10.type_)
      return new GFloat_10((float) d_);
    return base.ConvertExplicit(ref this_own, t);
  }

  public override string ToString() { return d_.ToString(); }

  public override string Emit() {
    string s = d_.ToString();
    if (s.IndexOf('.') == -1)
      s = s + ".0";
    return s;
  }
}

class GChar_10 : SimpleValue_10 {
  public readonly char c_;

  public GChar_10(char c) { c_ = c; }

  public static readonly CharClass_10 ^type_ = new CharClass_10();

  public override GType_10 Type() { return type_; }

  public override bool Equals(object o) {
    GChar_10 c = o as GChar_10;
    return c != null && c.c_ == c_;
  }

  public override int GetHashCode() { return c_.GetHashCode(); }

  public override SimpleValue_10 ^Copy() { return new GChar_10(c_); }

  public override RValue_10 ^Convert(ref RValue_10 ^this_own, GType_10 t) {
    return t == GInt_10.type_ ? new GInt_10(c_) : base.Convert(ref this_own, t);
  }

  public override string ToString() { return c_.ToString(); }

  public static string Emit(char c) {
    switch (c) {
      case '\0': return "\\0";
      case '\n': return "\\n";
      case '\r': return "\\r";
      case '\t': return "\\t";
      case '\'': return "\\'";
      case '\"': return "\\\"";
      case '\\': return "\\\\";
    }
    if (c < 32) {
      Debug.Assert(false); return null;
    }
    return c.ToString();
  }

  public override string Emit() {
    return String.Format("'{0}'", Emit(c_));
  }
}

abstract class LocationOrRef_10 : ValueOrLocation_10 {
  public abstract Location_10 GetLoc();
}

class Location_10 : LocationOrRef_10 {
  public RValue_10 ^value_;

  public Location_10(RValue_10 ^val) { value_ = val; }

  public override GValue_10 Get() { return value_.Get(); }

  public override Location_10 GetLoc() { return this; }
}

// We allocate a LocationRef_10 when we need an owning reference to a Location_10 which we don't own.
class LocationRef_10 : LocationOrRef_10 {
  public readonly Location_10 location_;

  public LocationRef_10(Location_10 loc) { location_ = loc; }

  public override GValue_10 Get() { return location_.Get(); }

  public override Location_10 GetLoc() { return location_; }
}

class MapNode_10 {
  public readonly MapNode_10 ^next_;
  public readonly object key_;
  public ValueOrLocation_10 ^value_;   // (must appear after next_ so it will be destroyed first)

  public MapNode_10(object key, ValueOrLocation_10 ^value, MapNode_10 ^next) {
    key_ = key; value_ = value; next_ = next;
  }
}

class Map_10 {
  MapNode_10 ^nodes_;

  protected MapNode_10 Find1(object key) {
    for (MapNode_10 n = nodes_; n != null; n = n.next_)
      if (n.key_ == key)
        return n;
    return null;
  }

  protected virtual MapNode_10 Find(object key) {
    MapNode_10 n = Find1(key);
    Debug.Assert(n != null);
    return n;
  }

  public RValue_10 ^Get(object key) {
    return Find(key).value_.Get().CopyRef();
  }

  public RValue_10 ^Take_10(object key) {
    MapNode_10 n = Find(key);
    LocationOrRef_10 l = n.value_ as LocationOrRef_10;
    if (l != null)
      return take l.GetLoc().value_;
    return (RValue_10) take n.value_;
  }

  public void Set(object key, RValue_10 ^val) {
    MapNode_10 n = Find(key);
    LocationOrRef_10 l = n.value_ as LocationOrRef_10;
    if (l != null)
      l.GetLoc().value_ = val;
    else n.value_ = val;
  }

  public void Add(object key, ValueOrLocation_10 ^val) {
    nodes_ = new MapNode_10(key, val, take nodes_);
  }

  public Location_10 GetLocation(object key) {
    MapNode_10 n = Find(key);
    LocationOrRef_10 l = n.value_ as LocationOrRef_10;
    if (l != null)
      return l.GetLoc();
    Location_10 ^loc1 = new Location_10((RValue_10) take n.value_);
    Location_10 loc = loc1;
    n.value_ = loc1;
    return loc;
  }
}

class GObject_10 : GValue_10 {
  public readonly Class_10 class_;   // the class of this object

  Map_10 ^map_ = new Map_10();

  public GObject_10(Class_10 cl) {
    class_ = cl;
    while (cl != null) {
      foreach (Field_10 f in cl.fields_)
        map_.Add(f, f.Type().DefaultValue_10().Copy() );
      cl = cl.Parent();
    }
  }

  // the type of this object
  public override GType_10 Type() { return class_; }

  public override RValue_10 ^Get(Field_10 field) { return map_.Get(field); }
  public override RValue_10 ^Take_10(Field_10 field) { return map_.Take_10(field); }
  public void Set(Field_10 field, RValue_10 ^val) { map_.Set(field, val); }
  public Location_10 GetLocation(Field_10 field) { return map_.GetLocation(field); }

  public override int DefaultHashCode() { return base.GetHashCode(); }
  public override int GetHashCode() {
    GInt_10 ^i = (GInt_10) Invocation_10.InvokeMethod(this, GObject_10.type_.get_hash_code_, new ArrayList(), true);
    return i.i_;
  }

  public override bool DefaultEquals(object o) { return base.Equals(o); }
  public override bool Equals(object o) {
    GValue_10 v = o as GValue_10;
    if (v == null)
      return false;

    ArrayList ^args = new ArrayList();
    args.Add(v.CopyRef());
    GBool_10 ^b = (GBool_10) Invocation_10.InvokeMethod(this, GObject_10.type_.equals_, args, true);
    return b.b_;
  }

  public override string DefaultToString() { return String.Format("<object {0}>", class_.name_); }
  public override string ToString() {
    GString_10 ^s = (GString_10) Invocation_10.InvokeMethod(this, GObject_10.type_.to_string_, new ArrayList(), true);
    return s.s_;
  }

  // the Object class
  public static readonly ObjectClass_10 ^type_ = new ObjectClass_10();
}

class NullType_10 : GType_10 {
  public override string ToString() { return "null_type"; }

  public override SimpleValue_10 DefaultValue_10() { Debug.Assert(false); return null; }

  public override bool IsSubtype(GType_10 t1) {
    return t1.IsReference();
  }

  protected override bool CanConvertOwnership(GType_10 t, int context) {
    return true;    // conversion from null type to owning type is okay
  }

  public override string EmitType() { Debug.Assert(false); return null; }
}

class Null_10 : SimpleValue_10 {
  public Null_10() { }

  public static readonly NullType_10 ^type_ = new NullType_10();

  public override GType_10 Type() { return type_; }

  public override bool Equals(object o) {
    return o is Null_10;
  }

  public override SimpleValue_10 ^Copy() { return new Null_10(); }

  public override int GetHashCode() { return 0; }

  public static readonly Null_10 ^Instance = new Null_10();

  public override string ToString() { return ""; }

  public override string Emit() { return "0"; }
}

class Owning_10 : GType_10 {
  GType_10 base_type_;

  public Owning_10(GType_10 type) {
    base_type_ = type;
  }

  public override Class_10 Parent() { Debug.Assert(false); return null; }

  public override SimpleValue_10 DefaultValue_10() { return Null_10.Instance; }

  public override GType_10 BaseType() { return base_type_; }

  public override TypeSet_10 VarDestroys() { return base_type_.TypeDestroys(); }

  public override void FindVarDestroys(int marker, TypeSet_10 set) {
    base_type_.FindTypeDestroys(marker, set);
  }

  public override bool Equals(object o) {
    Owning_10 t = o as Owning_10;
    return t != null && t.base_type_.Equals(base_type_);
  }

  public override int GetHashCode() { return base_type_.GetHashCode() * 87; }

  public override string ToString() { return base_type_.ToString() + " ^"; }

  public override string EmitTypeName() {
    return base_type_.EmitTypeName();
  }

  string EmitType(string name) {
    return ConstructType(base_type_ == GObject_10.type_ ? "_OwnRef" : "_Own", name);
  }

  public override string EmitType() {
    // We represent an object ^ using a _OwnRef<Object>.
    // We represent a Foo ^ using an _Own<Foo>.
    return EmitType(EmitTypeName());
  }

  public override string EmitGenericType() {
    // We represent an object ^ [] using an _Array<_OwnRef<Object>>.
    // We represent a Foo ^ [] using an _Array<_Own<Object>>.
    return EmitType("Object");
  }
}

class OwningExpr_10 : TypeExpr_10 {
  readonly TypeExpr_10 ^expr_;

  public OwningExpr_10(TypeExpr_10 ^expr) { expr_ = expr; }

  public override TypeExpr_10 ^Copy() { return new OwningExpr_10(expr_.Copy()); }

  public override GType_10 Resolve(Program_10 program) {
    GType_10 t = expr_.Resolve(program);
    if (t == null)
        return null;
    if (t.IsValue()) {
      Error("^ cannot be applied to primitive types or strings");
      return null;
    }
    return t.OwningType();
  }
}

class GString_10 : SimpleValue_10 {
  public readonly string s_;

  public GString_10(string s) { s_ = s; }

  public static readonly StringClass_10 ^type_ = new StringClass_10();

  public override GType_10 Type() { return type_; }

  public override bool Equals(object o) {
    GString_10 s = o as GString_10;
    return s != null && s.s_ == s_;
  }

  public override SimpleValue_10 ^Copy() { return new GString_10(s_); }

  public override int GetHashCode() { return s_.GetHashCode(); }

  public override string ToString() { return s_; }

  public override RValue_10 ^Invoke(Method_10 m, ValueList_10 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StartsWith": return new GBool_10(s_.StartsWith(args.GetString(0)));
      case "EndsWith": return new GBool_10(s_.EndsWith(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public static string EmitStringConst(string s) {
    return String.Format("L{0}", EmitString(s));
  }

  public static string EmitString(string s) {
    StringBuilder ^sb = new StringBuilder();
    sb.Append('"');
    for (int i = 0; i < s.Length; ++i)
      sb.Append(GChar_10.Emit(s[i]));
    sb.Append('"');
    return sb.ToString();
  }

  public override string Emit() {
    string s = String.Format("new String({0})", EmitStringConst(s_));
    s = String.Format("_Ref<String>({0}).Get()", s);
    return s;
  }
}

abstract class Ownable_10 : GType_10 {
  Owning_10 ^owning_type_;

  public override Owning_10 OwningType() {
    if (owning_type_ == null)
      owning_type_ = new Owning_10(this);
    return owning_type_;
  }
}

class ArrayType_10 : Ownable_10 {
  GType_10 element_type_;

  public ArrayType_10(GType_10 type) {
    element_type_ = type;

    // Any type used generically must inherit from Object in C++ code.
    type.BaseType().SetObjectInherit();
  }

  public override bool IsOwned() { return true; }

  public override Class_10 Parent() { return GArray_10.array_class_; }

  public override SimpleValue_10 DefaultValue_10() { return Null_10.Instance; }

  public GType_10 ElementType() { return element_type_; }

  public override bool Equals(object o) {
    ArrayType_10 t = o as ArrayType_10;
    return (t != null && t.element_type_.Equals(element_type_));
  }

  public override TypeSet_10 TypeDestroys() { return element_type_.VarDestroys(); }

  public override void FindTypeDestroys(int marker, TypeSet_10 set) {
    element_type_.FindVarDestroys(marker, set);
  }

  public override int GetHashCode() { return element_type_.GetHashCode() * 77; }

  public override string EmitTypeName() {
    return ConstructType("_Array", element_type_.EmitGenericType());  
  }

  public override string ToString() {
    return element_type_.ToString() + "[]";
  }
}

class ArrayTypeExpr_10 : TypeExpr_10 {
  readonly TypeExpr_10 ^expr_;
  GType_10 ^type_;

  public ArrayTypeExpr_10(TypeExpr_10 ^expr) { expr_ = expr; }

  public override TypeExpr_10 ^Copy() { return new ArrayTypeExpr_10(expr_.Copy()); }

  public override GType_10 Resolve(Program_10 program) {
    GType_10 t = expr_.Resolve(program);
    return t == null ? null : (type_ = new ArrayType_10(t));
  }
}

class GArray_10 : GValue_10 {
  ArrayType_10 type_;

  ValueOrLocation_10^[] ^elements_;   // each element is a GValue_10 or a Location_10

  public override GType_10 Type() { return type_; }

  public GArray_10(ArrayType_10 type, int count) {
    type_ = type;
    elements_ = new ValueOrLocation_10^[count];
    for (int i = 0 ; i < count ; ++i)
      elements_[i] = type_.ElementType().DefaultValue_10().Copy();
  }

  void CheckIndex(int index) {
    if (index < 0 || index >= elements_.Length) {
      Console.WriteLine("error: array access out of bounds");
      Gel_10.Exit();
    }
  }

  public RValue_10 ^Get(int index) {
    CheckIndex(index);
    return elements_[index].Get().CopyRef();
  }

  public RValue_10 ^Take_10(int index) {
    CheckIndex(index);
    Location_10 loc = elements_[index] as Location_10;
    if (loc != null)
      return take loc.value_;
    return (RValue_10) (take elements_[index]);
  }

  public void Set(int index, RValue_10 ^val) {
    CheckIndex(index);
    Location_10 loc = elements_[index] as Location_10;
    if (loc != null)
      loc.value_ = val;
    else elements_[index] = val;
  }

  public Location_10 GetLocation(int index) {
    CheckIndex(index);
    Location_10 loc = elements_[index] as Location_10;
    if (loc != null)
      return loc;
    Location_10 ^loc1 = new Location_10((RValue_10) take elements_[index]);
    loc = loc1;
    elements_[index] = loc1;
    return loc;
  }

  public static readonly ArrayClass_10 ^array_class_ = new ArrayClass_10();

  public override RValue_10 ^Invoke(Method_10 m, ValueList_10 args) {
    if (m.GetClass() != array_class_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "CopyTo":
        GArray_10 a = (GArray_10) args.Object(0);
        if (!type_.Equals(a.type_)) {
          Console.WriteLine("error: can't copy between arrays of different types");
          Gel_10.Exit();
        }
        if (a.type_.ElementType() is Owning_10) {
          Console.WriteLine("error: can't copy to owning array");
          Gel_10.Exit();
        }
        // should check for index out of bounds here!
        int dest = args.Int(1);
        for (int i = 0 ; i < elements_.Length ; ++i)
          a.Set(dest + i, Get(i));
        return null;
      case "get_Length":
        return new GInt_10(elements_.Length);
      default:
        Debug.Assert(false); return null;
    }
  }
}

// A control graph object representing temporary variables destroyed when a top-level
// expression completes evaluation. 
class Temporaries_10 : Node_10 {
  NonOwningArrayList /* of GType_10 */ ^types_ = new NonOwningArrayList();
  TypeSet_10 ^destroys_;

  public void Add(GType_10 t) {
    Debug.Assert(t is Owning_10);
    types_.Add(t.BaseType());
  }

  public override TypeSet_10 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_10();
    foreach (GType_10 t in types_)
        destroys_.Add(t.TypeDestroys());
    }
    return destroys_;
  }
}

class Context_10 {
  public readonly Program_10 program_;   // containing program
  public readonly Class_10 class_;       // containing class
  public readonly Method_10 method_;     // containing method
  public readonly Escapable_10 escape_;  // containing switch, while, do, for, or foreach
  public readonly Loop_10 loop_;         // containing while, do, for, or foreach
  public Local_10 var_;    // chain of local variable declarations

  // subexpressions of the current top-level expression possibly yielding temporary objects
  NonOwningArrayList /* of Expression_10 */ ^temporaries_ = new NonOwningArrayList();

  public Context_10(Program_10 program) { program_ = program; }

  public Context_10(Class_10 cl) { program_ = cl.GetProgram(); class_ = cl; }

  // Copy a context; new variable declarations in either copy will not be visible in the other.
  public Context_10(Context_10 cx) {
    program_ = cx.program_;
    class_ = cx.class_;
    method_ = cx.method_;
    escape_ = cx.escape_;
    loop_ = cx.loop_;
    var_ = cx.var_;
  }

  public Context_10(Context_10 cx, Class_10 c) : this(cx) { class_ = c; }

  public Context_10(Context_10 cx, Method_10 m) : this(cx) { method_ = m; }

  public Context_10(Context_10 cx, Loop_10 l) : this(cx) {
    escape_ = l;
    loop_ = l;
  }

  public Context_10(Context_10 cx, Switch_10 s) : this(cx) { escape_ = s; }

  public bool IsStatic() { return method_ == null || method_.IsStatic(); }

  public void SetVar(Local_10 var) {
    var_ = var;
  }

  public Local_10 FindVar(string name) {
    for (Local_10 v = var_; v != null; v = v.next_)
      if (v.name_ == name)
        return v;
    return null;
  }

  public Control_10 Prev() { return program_.prev_; }

  public void SetPrev(Control_10 c) {
    Debug.Assert(c != null);
    program_.prev_ = c;
  }

  public void ClearPrev() { program_.prev_ = null; }

  // Called when we begin type-checking a top-level expression.
  public void EnterExpression() {
    Debug.Assert(temporaries_.Count == 0);
  }

  public void AddTemporary(Expression_10 e) {
    temporaries_.Add(e);
  }

  // Called when we've finished type-checking a top-level expression.
  public void FinishExpression() {
    Temporaries_10 t = null;
    foreach (Expression_10 e in temporaries_)
      if (!e.LosesOwnership()) {
        if (t == null)
          t = class_.NewTemporaries();
        t.Add(e.TemporaryType());
      }
    if (t != null)
      t.AddControl(this);
    temporaries_.Clear();
  }
}

class Env_10 : Map_10 {
  public readonly GValue_10 this_;
  readonly Env_10 next_;

  public Env_10(GValue_10 _this) { this_ = _this; next_ = null; }
  public Env_10(Env_10 next) { this_ = next.this_; next_ = next; }

  protected override MapNode_10 Find(object key) {
    for (Env_10 e = this; e != null; e = e.next_) {
      MapNode_10 n = e.Find1(key);
      if (n != null)
        return n;
    }
    Debug.Assert(false);
    return null;
  }

  public static readonly Env_10 ^static_ = new Env_10((GValue_10) null);
}

class TypeLiteral_10 : TypeExpr_10 {
  public readonly GType_10 type_;

  public TypeLiteral_10(GType_10 type) { type_ = type; }

  public override GType_10 Resolve(Program_10 program) {
    return type_;
  }

  public override TypeExpr_10 ^Copy() { return new TypeLiteral_10(type_); }
}

class TypeName_10 : TypeExpr_10 {
  string name_;

  public TypeName_10(string name) { name_ = name; }

  public override GType_10 Resolve(Program_10 program) {
    GType_10 type = program.FindClass(name_);
    if (type == null)
      Error("unknown type: {0}", name_);
    return type;
  }

  public override TypeExpr_10 ^Copy() { return new TypeName_10(name_); }
}

abstract class Traverser_10 {
  // Handle a graph item found in a depth first search; returns one of the exit codes below.
  public abstract int Handle(Control_10 control);

  public const int Continue_10 = 0,  // continue searching, including children of this node
                   Cut = 1,       // continue searching, excluding children of this node
                   Abort = 2;     // abort the search

}

// an item in the control graph: either a Node_10 or Joiner_10
abstract class Control_10 : Syntax_10 {
  public int marker_ = 0;    // marker for depth first search of control flow graph

  static int marker_value_ = 0;
  public static int GetMarkerValue() { return ++marker_value_; }

  // A node representing unreachability.  We could represent this using null, but it's
  // clearer to have this be explicit. 
  public static readonly Node_10 ^unreachable_ = new Node_10();

  // A helper function for Traverse.  If_10 we return true then we should cut the
  // traversal at this point.
  protected bool Visit(Traverser_10 traverser, int marker, out bool ok) {
    ok = true;
    if (marker_ == marker)
      return true;  // we've already seen this node
    marker_ = marker;
    int code = traverser.Handle(this);
    if (code == Traverser_10.Abort)
      ok = false;
    return (code != Traverser_10.Continue_10);
  }

  // Perform a depth-first search of the graph starting with this item, calling the
  // given Traverser_10 for each Node_10 found.  Returns false if the search was aborted.
  public abstract bool Traverse(Traverser_10 traverser, int marker);
}

// A node in the control graph.
class Node_10 : Control_10 {
  public Control_10 prev_;   // previous item in graph

  // add this node to the control graph
  public bool AddControl(Context_10 ctx) {
    Control_10 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      prev_ = prev;
      ctx.SetPrev(this);
      return true;
    }
    else return false;
  }

  // If_10 this node calls a method or constructor then return it; otherwise return null.
  // implementers: LValue_10, Invocation_10, New_10, Assign_10, Constructor_10
  public virtual Method_10 Calls() { return null; }

  // Return_10 the set of types which this node may destroy.
  // implementers: Assign_10, RefOutArgument_10, Scoped_10, Temporaries_10
  public virtual TypeSet_10 NodeDestroys() { return TypeSet_10.empty_; }

  // Return_10 true if this node assigns a value to the given Local_10.
  // implementers: Assign_10, RefOutArgument_10, VariableDeclaration_10, Method_10, ForEach_10
  public virtual bool Sets(Local_10 local) { return false; }

  // Return_10 true if this node takes ownership from the given local.
  // implementers: Name_10
  public virtual bool Takes(Local_10 local) { return false; }

  public bool CanDestroy(GType_10 type) {
    Method_10 m = Calls();
    if (m != null && m.Destroys().Contains(type))
      return true;
    return NodeDestroys().Contains(type);
  }

  public override bool Traverse(Traverser_10 traverser, int marker) {
    Node_10 n = this;
    Control_10 prev = null;

    // Traverse nodes iteratively until we come to a Join; this efficiently avoids
    // making a recursive call on each successive node.
    while (n != null) {
      bool ok;
      if (n.Visit(traverser, marker, out ok))
        return ok;
      prev = n.prev_;
      n = prev as Node_10;
    }
    Debug.Assert(prev != null);  // a Traverser_10 must end traversal before we run off the end
    return prev.Traverse(traverser, marker);
  }
}

class Joiner_10 : Control_10 {
  NonOwningArrayList /* of Control_10 */ ^prev_ = new NonOwningArrayList();

  public void Join(Control_10 c) {
    Debug.Assert(c != null);
    if (c == unreachable_)
      return;
    if (prev_.Count == 0 || c != prev_[0])
      prev_.Add(c);
  }

  // add this joiner to the control graph
  public void AddControl(Context_10 ctx) {
    Control_10 prev = ctx.Prev();
    Debug.Assert(prev != null);
    if (prev != unreachable_) {   // we're in a live code path
      Join(prev);
      ctx.SetPrev(this);
    }
  }

  // Once we've finished merging paths into a Joiner_10, if the Joiner_10 points to only a single path
  // then as an optimization we can discard the Joiner_10 and just use that path instead.
  public Control_10 Combine() {
    switch (prev_.Count) {
      case 0:
        prev_ = null;
        return unreachable_;
      case 1:
        Control_10 c = (Control_10) prev_[0];
        prev_ = null;
        return c;
      default: return this;
    }
  }

  public override bool Traverse(Traverser_10 traverser, int marker) {
    bool ok;
    if (Visit(traverser, marker, out ok))
      return ok;

    foreach (Control_10 p in prev_)
      if (!p.Traverse(traverser, marker))
        return false;  // aborted
    return true;
  }
}

class ExprKind_10 {
  public const int Value = 0,

  // either a local variable, or an expression whose value is derived from local variables
                   Local_10 = 1,

                   Field_10 = 2,
                   Property_10 = 3,
                   Indexer_10 = 4,
                   Type = 5;
}

class SourceWriter_10 {
  public readonly StreamWriter writer_;
  int indent_ = 0;

  public SourceWriter_10(StreamWriter writer) { writer_ = writer; }

  public void AddIndent() { ++indent_; }
  public void SubIndent() { --indent_; }

  public void Indent(int adjust) {
    for (int i = 0; i < 2 * indent_ + adjust; ++i)
      writer_.Write(' ');
  }

  public void Indent() { Indent(0); }

  public void Write(string s) { writer_.Write(s); }
  public void Write(string s, object arg) { writer_.Write(s, arg); }
  public void Write(string s, object arg1, object arg2) { writer_.Write(s, arg1, arg2); }
  public void Write(string s, object arg1, object arg2, object arg3) { writer_.Write(s, arg1, arg2, arg3); }

  public void IWrite(string s) { Indent(); Write(s); }
  public void IWrite(string s, object arg) { Indent(); Write(s, arg); }
  public void IWrite(string s, object arg1, object arg2) { Indent(); Write(s, arg1, arg2); }
  public void IWrite(string s, object arg1, object arg2, object arg3) { Indent(); Write(s, arg1, arg2, arg3); }

  public void WriteLine(string s) { writer_.WriteLine(s); }
  public void WriteLine(string s, object arg) { writer_.WriteLine(s, arg); }
  public void WriteLine(string s, object arg1, object arg2) { writer_.WriteLine(s, arg1, arg2); }
  public void WriteLine(string s, object arg1, object arg2, object arg3) { writer_.WriteLine(s, arg1, arg2, arg3); }

  public void IWriteLine(string s) { Indent(); WriteLine(s); }
  public void IWriteLine(string s, object arg) { Indent(); WriteLine(s, arg); }
  public void IWriteLine(string s, object arg1, object arg2) { Indent(); WriteLine(s, arg1, arg2); }
  public void IWriteLine(string s, object arg1, object arg2, object arg3) { Indent(); WriteLine(s, arg1, arg2, arg3); }

  public void OpenBrace() { WriteLine("{"); AddIndent(); }
  public void CloseBrace() { SubIndent(); IWriteLine("}"); }
}

class Usage_10 {
  public const int Used = 0, LosesOwnership = 1, Unused = 2;
}

abstract class Expression_10 : Node_10 {
  protected int usage_ = Usage_10.Used;

  // start_ and end_ mark the points in the control graph where this expression is evaluated and used,
  // respectively.  If_10 this expression's type is owned, we use this information to determine whether
  // we need to emit a reference count for this expression.
  Control_10 start_;
  Control_10 end_;

  public abstract GType_10 Check(Context_10 ctx);

  public GType_10 CheckTop(Context_10 ctx) {
    ctx.EnterExpression();
    GType_10 t = Check(ctx);
    ctx.FinishExpression();
    return t;
  }

  public GType_10 CheckAndHold(Context_10 ctx) {
    GType_10 t = Check(ctx);
    if (t != null)
      HoldRef(ctx);
    return t;
  }

  // A fancier checking protocol implemented by lvalues and used by certain callers.
  public virtual GType_10 Check(Context_10 ctx, bool read, bool write, bool type_ok) {
    return Check(ctx);
  }

  public virtual int Kind() { return ExprKind_10.Value; }
  public virtual bool IsRefOutParameter() { return false; }

  public virtual bool IsTrueLiteral() { return false; }
  public virtual bool IsFalseLiteral() { return false; }

  // If_10 this expression is a local variable (possibly cast to a different type),
  // then return that local; otherwise return null.
  public virtual Local_10 GetLocal() { return null; }

  // Return_10 the type of an expression yielding a temporary object.
  // (It might be convenient to generalize this to be able to return any expression's type.)
  public virtual GType_10 TemporaryType() { Debug.Assert(false); return null; }

  public void HoldRef(Context_10 ctx) {
    start_ = ctx.Prev();
    Debug.Assert(start_ != null);
  }

  public void ReleaseRef(Context_10 ctx) {
    end_ = ctx.Prev();
    Debug.Assert(end_ != null);
  }

  public abstract RValue_10 ^Eval(Env_10 env);

  public bool Check(Context_10 ctx, GType_10 t2) {
    GType_10 t = Check(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public bool CheckTop(Context_10 ctx, GType_10 t2) {
    GType_10 t = CheckTop(ctx);
    return t == null ? false : t.CheckConvert(this, t2);
  }

  public RValue_10 ^Eval(Env_10 env, GType_10 t) {
    RValue_10 ^r = Eval(env);
    GValue_10 v = r.Get();
    return v.Convert(ref r, t);
  }

  public bool EvalBool(Env_10 env) { return ((GBool_10) Eval(env)).b_; }

  public int EvalInt(Env_10 env) {
    RValue_10 ^r = Eval(env, GInt_10.type_);
    GInt_10 i = (GInt_10) r;
    return i.i_;
  }

  public double EvalDouble(Env_10 env) { return ((GDouble_10) Eval(env, GDouble_10.type_)).d_; }
  public float EvalFloat(Env_10 env) { return ((GFloat_10) Eval(env, GFloat_10.type_)).f_; }
  public string EvalString(Env_10 env) { return ((GString_10) Eval(env)).s_; }

  public virtual bool IsConstant() {
    return false;
  }

  public bool CheckConstant() {
    if (IsConstant())
      return true;
    Error("expression must be a constant");
    return false;
  }

  public bool LosesOwnership() { return usage_ == Usage_10.LosesOwnership; }

  public virtual void LoseOwnership() {
    usage_ = Usage_10.LosesOwnership;
  }

  public void SetUnused() {
    Debug.Assert(usage_ == Usage_10.Used);
    usage_ = Usage_10.Unused;
  }

  protected static string EmitAllocate(string type, string args, bool lose_ownership) {
    // If_10 an allocated object never loses ownership then it can be stack allocated.  We
    // can't emit "&Foo(...)" since standard C++ doesn't allow us to take the address
    // of a temporary (both GCC and Visual C++ will allow this, but will emit a warning).
    // So instead we call a function _Addr() to get the address.
    return String.Format(
      !lose_ownership ? "{0}({1})._Addr<{0} *>()" : "new {0}({1})",
      type, args);
  }

  public void CheckLoseOwnership(GType_10 from, GType_10 to) {
    if (to is Owning_10)
      LoseOwnership();
  }

  public abstract string Emit();    // return a C++ expression representing this GEL2 expression

  public bool NeedsRef(GType_10 type) {
    return Gel_10.program_.safe_ && type.IsOwned() && ExpressionTraverser_10.NeedRef(start_, end_, this, type);
  }

  // Emit this expression, adding a reference-counting _Ptr wrapper if needed.
  public string EmitRef(GType_10 type) {
    string s = Emit();
    if (NeedsRef(type))
      s = String.Format("{0}({1}).Get()", type.EmitType(), s);
    return s;
  }

  // Emit an implicit conversion from type [source] to type [dest].
  public static string EmitImplicit(GType_10 source, GType_10 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (!source.IsReference() && dest == GObject_10.type_) {   // a boxing conversion
      Class_10 c = (Class_10) source;
      return EmitAllocate(c.name_, val, loses_ownership);
    }

    if (source == GInt_10.type_ && dest == GFloat_10.type_)
      // an implicit conversion in GEL2, but C++ compilers may warn if we don't use a cast
      return String.Format("static_cast<float>({0})", val);
    
    return val;
  }

  // Emit this expression, converting implicitly from type [source] to type [dest].
  public string Emit(GType_10 source, GType_10 dest) {
    return EmitImplicit(source, dest, Emit(), LosesOwnership());
  }

  public string EmitRef(GType_10 source, GType_10 dest) {
    return EmitImplicit(source, dest, EmitRef(source), LosesOwnership());
  }

  public static string EmitExplicit(GType_10 source, GType_10 dest, string val, bool loses_ownership) {
    source = source.BaseType();
    dest = dest.BaseType();

    if (source.CanConvert(dest)) {
      string v = EmitImplicit(source, dest, val, loses_ownership);
      if (v != val)
        return v;

      // There's nothing to do, but we emit a static_cast anyway since a GEL2 programmer
      // may use a type cast for method call disambiguation; we want to pass such casts onward.
      return String.Format("static_cast<{0} >({1})", dest.EmitExprType(), val);
    }

    if (source.IsReference() && dest.IsReference()) {
      string s = String.Format("_Cast<{0} *>({1})", dest.EmitTypeName(), val);
      ArrayType_10 at = dest as ArrayType_10;
      if (at != null) {
        GType_10 element_type = at.ElementType();
        if (element_type.IsReference())
          s = String.Format("({0})->CheckType(&typeid({1}))", s, element_type.EmitType());
      }
      return s;
    }

    if (source == GObject_10.type_ && !dest.IsReference())  // unboxing conversion
      return String.Format("_Unbox<{0} *>({1})->Value()", ((Class_10) dest).name_, val);

    if (!source.IsReference() && !dest.IsReference())
      return String.Format("static_cast<{0}>({1})", dest.EmitType(), val);

    Debug.Assert(false);
    return null;
  }

  public string EmitExplicit(GType_10 source, GType_10 dest) {
    return EmitExplicit(source, dest, Emit(), LosesOwnership());
  }

  public virtual string EmitArrow(GType_10 t, Member_10 m) {
    return String.Format("({0})->", EmitRef(t));
  }

  // Emit this expression as a local or field initializer, implicitly casting to [type].
  public void EmitAsInitializer(SourceWriter_10 w, GType_10 initializer_type, GType_10 type) {
    // For_10 owning variables, we must emit an initializer of the form "Foo var(val)" since
    // _Own has no copy constructor and hence GCC won't allow "Foo var = val".  For_10 other
    // variables either form is valid, but we emit the second form since it looks clearer.
    w.Write(type is Owning_10 ? "({0})" : " = {0}", Emit(initializer_type, type));
  }

  // Given a value retrieved from a variable, emit an accessor call if needed.
  protected string OwnSuffix(GType_10 t) {
    if (t is Owning_10)
      return LosesOwnership() ? ".Take_10()" : ".Get()";
    if (t == GString_10.type_ || Gel_10.program_.safe_ && t.IsReference() )
      return ".Get()";
    return "";
  }

  // Given a value returned from a function call, emit a wrapper and/or accessor call if needed.
  protected string Hold(GType_10 t, string s) {
    if (t == GString_10.type_)
      return s + ".Get()";
    if (t is Owning_10)
      switch (usage_) {
        case Usage_10.Used:  // does not lose ownership; we need a freeing wrapper
          return String.Format("{0}({1}).Get()", t.EmitType(), s);
        case Usage_10.LosesOwnership:
          return s;
        case Usage_10.Unused:  // a top-level owning expression
          return "delete " + s;
        default: Debug.Assert(false); break;
      }
    return s;
  }
}

class Literal_10 : Expression_10 {
  public readonly SimpleValue_10 ^value_;

  public Literal_10(SimpleValue_10 ^v) { value_ = v; }

  public override bool IsTrueLiteral() {
    GBool_10 b = value_ as GBool_10;
    return b != null && b.b_;
  }

  public override bool IsFalseLiteral() {
    GBool_10 b = value_ as GBool_10;
    return b != null && !b.b_;
  }

  public override GType_10 Check(Context_10 ctx) { return value_.Type(); }

  public override RValue_10 ^Eval(Env_10 env) { return value_.Copy(); }

  public override bool IsConstant() { return true; }

  public override string Emit() { return value_.Emit(); }
}

// An LValue_10 is an expression which can be assigned to: a Name_10, Dot_10, or Sub_10.
//
// In the control graph, an LValue_10 represents a read; if an LValue_10 is written then
// some other node (e.g. an Assign_10) will appear representing the write.
abstract class LValue_10 : Expression_10 {
  public override GType_10 Check(Context_10 ctx) {
    return Check(ctx, true, false, false);
  }

  public abstract override GType_10 Check(Context_10 ctx, bool read, bool write, bool type_ok);

  public abstract GType_10 StorageType();

  public virtual bool IsLocal() { return false; }
  public virtual bool IsLocal(Local_10 l) { return false; }

  public abstract PropertyOrIndexer_10 GetPropertyOrIndexer();

  public override Method_10 Calls() {
    PropertyOrIndexer_10 pi = GetPropertyOrIndexer();
    return pi == null ? null : pi.Getter();
  }

  public virtual void ReleaseAll(Context_10 ctx) { }

  // For_10 LValues, evaluation proceeds in two stages: the caller first calls Eval1(), then
  // passes the resulting values to EvalGet(), EvalSet() and/or EvalLocation().  This_10 lets
  // us evaluate the left side of an assignment expression before evaluating the right side,
  // and also lets us get and then set an indexer without evaluating its expression twice.

  public abstract void Eval1(Env_10 env, out RValue_10 ^v1, out RValue_10 ^v2);
  public abstract RValue_10 ^EvalGet(Env_10 env, RValue_10 ^v1, RValue_10 ^v2);
  public abstract void EvalSet(Env_10 env, RValue_10 ^v1, RValue_10 ^v2, RValue_10 ^val);
  public abstract Location_10 EvalLocation(Env_10 env, RValue_10 ^v1, RValue_10 ^v2);

  public override RValue_10 ^Eval(Env_10 env) {
    RValue_10 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalGet(env, val1, val2);
  }

  public void EvalSet(Env_10 env, RValue_10 ^v) {
    RValue_10 ^val1, val2;
    Eval1(env, out val1, out val2);
    EvalSet(env, val1, val2, v);
  }

  public Location_10 EvalLocation(Env_10 env) {
    RValue_10 ^val1, val2;
    Eval1(env, out val1, out val2);
    return EvalLocation(env, val1, val2);
  }

  public abstract string EmitSet(string val);

  public abstract string EmitLocation();
}

class Name_10 : LValue_10 {
  public readonly string name_;

  protected Local_10 local_;
  protected LMember_10 field_;  // a field or property

  public Name_10(string n) { name_ = n; }

  public override bool IsLocal() { return local_ != null; }
  public override bool IsLocal(Local_10 l) { return local_ == l; }
  public override bool IsRefOutParameter() { return local_ is RefOutParameter_10; }

  public override bool IsConstant() {
    Debug.Assert(local_ != null || field_ != null);   // make sure we were already type checked
    return field_ is ConstField_10;
  }

  public override GType_10 Check(Context_10 ctx, bool read, bool write, bool type_ok) {
    local_ = ctx.FindVar(name_);
    if (local_ != null) {
      // For_10 reads, we add this Name_10 node to the flow graph; for writes,
      // the caller must add a node which defines this Name_10.
      if (read)
        if (AddControl(ctx))
          local_.AddUse(this);
      if (write)
        local_.SetMutable();
      return local_.ReadType();
    }

    GType_10 cl = type_ok ? ctx.program_.FindClass(name_) : null;
    field_ = (LMember_10) ctx.class_.Lookup(this, ctx.class_, false, MemberKind_10.Field_10, name_, null, cl == null);
    if (field_ != null) {
      if (!field_.CheckAccess(this, ctx, write, true, !ctx.IsStatic()))
        return null;
      if (read) {
        // Only property reads have side effects we need to register in the control graph.
        if (field_ is Property_10)
          AddControl(ctx);
      }
      return field_.Type().BaseType();
    }

    return cl;
  }

  public override int Kind() {
    if (local_ != null)
      return ExprKind_10.Local_10;
    if (field_ is Field_10)
      return ExprKind_10.Field_10;
    if (field_ is Property_10)
      return ExprKind_10.Property_10;
    Debug.Assert(field_ == null);
    return ExprKind_10.Type;
  }

  public override Local_10 GetLocal() { return local_; }

  public override GType_10 StorageType() { return local_ != null ? local_.Type() : field_.Type(); }

  public override bool Takes(Local_10 local) {
    return local_ == local && LosesOwnership() && local.Type() is Owning_10;
  }

  public override PropertyOrIndexer_10 GetPropertyOrIndexer() { return field_ as Property_10; }

  public override void Eval1(Env_10 env, out RValue_10 ^v1, out RValue_10 ^v2) { v1 = v2 = null; }

  public override RValue_10 ^EvalGet(Env_10 env, RValue_10 ^v1, RValue_10 ^v2) {
    if (LosesOwnership() && StorageType() is Owning_10)
      return local_ != null ? env.Take_10(local_) : field_.Take_10(env.this_);
    else return local_ != null ? env.Get(local_) : field_.Get(env.this_);
  }

  public override void EvalSet(Env_10 env, RValue_10 ^v1, RValue_10 ^v2, RValue_10 ^val) {
    if (local_ != null)
      env.Set(local_, val);
    else field_.Set((GObject_10) env.this_, val);
  }

  public override Location_10 EvalLocation(Env_10 env, RValue_10 ^v1, RValue_10 ^v2) {
    return local_ != null ? env.GetLocation(local_) : field_.GetLocation((GObject_10) env.this_);
  }

  public override string Emit() {
    if (local_ != null) {
      string s = local_.Emit();
      return local_.IsWrapper() ? s + OwnSuffix(local_.Type()) : s;
    }
    if (field_ != null)
      return field_.Emit() + OwnSuffix(field_.Type());
    return name_;
  }

  public override string EmitSet(string val) {
    if (local_ != null)
      return String.Format("{0} = {1}", local_.Emit(), val);
    Debug.Assert(field_ != null);
    return field_.EmitSet(val);
  }

  public override string EmitLocation() {
    if (local_ != null)
      return "&" + local_.Emit();
    if (field_ != null)
      return "&" + field_.Emit();
    return "&" + name_;
  }
}

class Parenthesized_10 : Expression_10 {
  Expression_10 ^expr_;

  public Parenthesized_10(Expression_10 ^e) { expr_ = e; }

  public override GType_10 Check(Context_10 ctx) { return expr_.Check(ctx); }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_10 ^Eval(Env_10 env) { return expr_.Eval(env); }

  public override string Emit() { return String.Format("({0})", expr_.Emit()); }
}

class PredefinedType_10 : Expression_10 {
  Class_10 type_;

  public PredefinedType_10(Class_10 type) { type_ = type; }

  public override GType_10 Check(Context_10 ctx) { Debug.Assert(false); return null; }

  public override GType_10 Check(Context_10 ctx, bool read, bool write, bool type_ok) {
    Debug.Assert(type_ok);
    return type_;
  }

  public override int Kind() {
    return ExprKind_10.Type;
  }

  public override RValue_10 ^Eval(Env_10 env) { Debug.Assert(false); return null; }

  public override string Emit() { return type_.name_; }
}

class Dot_10 : LValue_10 {
  Expression_10 ^expr_;  // set to null for a static invocation
  GType_10 expr_type_;
  string name_;

  LMember_10 field_;

  public Dot_10(Expression_10 ^expr, string name) { expr_ = expr; name_ = name; }

  public override bool IsConstant() {
    Debug.Assert(field_ != null);   // make sure we were already type checked
    return field_ is ConstField_10;
  }

  public override GType_10 Check(Context_10 ctx, bool read, bool write, bool type_ok) {
    expr_type_ = expr_.Check(ctx, true, false, true);
    if (expr_type_ == null)
      return null;
    bool is_static = (expr_.Kind() == ExprKind_10.Type);
    if (is_static)
      expr_ = null;
    else expr_.HoldRef(ctx);

    field_ = (LMember_10) expr_type_.Lookup(this, ctx.class_, expr_ is Base_10,
                                         MemberKind_10.Field_10, name_, null, true);
    if (field_ == null)
      return null;

    if (!field_.CheckAccess(this, ctx, write, is_static, !is_static))
      return null;

    if (read) {
      // Only property reads have side effects we need to register in the control graph.
      // (For_10 writes the caller, such as Assign_10, will add its own node.)
      if (field_ is Property_10)
        AddControl(ctx);
      if (expr_ != null)
        expr_.ReleaseRef(ctx);
    }

    return field_.Type().BaseType();
  }

  public override void ReleaseAll(Context_10 ctx) {
    if (expr_ != null)
      expr_.ReleaseRef(ctx);
  }

  public override int Kind() {
    if (field_ is Field_10)
      return ExprKind_10.Field_10;
    if (field_ is Property_10)
      return ExprKind_10.Property_10;
    Debug.Assert(false);
    return 0;
  }

  public override GType_10 StorageType() { return field_.Type(); }

  public override PropertyOrIndexer_10 GetPropertyOrIndexer() { return field_ as Property_10; }

  public override void Eval1(Env_10 env, out RValue_10 ^v1, out RValue_10 ^v2) {
    v1 = v2 = null;
    if (expr_ != null) {  // instance field
      v1 = expr_.Eval(env);
      if (v1 is Null_10) {
        Error("attempted to access field of null object");
        Gel_10.Exit();
      }
    }
  }

  public override RValue_10 ^EvalGet(Env_10 env, RValue_10 ^v1, RValue_10 ^v2) {
    GValue_10 obj = v1 == null ? null : v1.Get();
    return LosesOwnership() && field_.Type() is Owning_10 ? field_.Take_10(obj) : field_.Get(obj);
  }

  public override void EvalSet(Env_10 env, RValue_10 ^v1, RValue_10 ^v2, RValue_10 ^val) {
    GObject_10 obj = v1 == null ? null : (GObject_10) v1.Get();
    field_.Set(obj, val);
  }

  public override Location_10 EvalLocation(Env_10 env, RValue_10 ^v1, RValue_10 ^v2) {
    return field_.GetLocation((GObject_10) v1);
  }

  string EmitPrefix() {
    return expr_ != null ?
      expr_.EmitArrow(expr_type_, field_) :  // instance access
      field_.GetClass().name_ + "::";   // static access
  }

  public override string Emit() {
    string s = EmitPrefix() + field_.Emit();
    GType_10 t = field_.Type();
    return field_ is Property_10 ? Hold(t, s) : s + OwnSuffix(t);
  }

  public override string EmitSet(string val) {
    return EmitPrefix() + field_.EmitSet(val);
  }

  public override string EmitLocation() {
    return "&" + EmitPrefix() + field_.Emit();
  }
}

class Mode_10 {
  public const int In = 0,
                   Ref = 1,
                   Out = 2;

  public static string ToString(int mode) {
    switch (mode) {
      case In: return "";
      case Ref: return "ref ";
      case Out: return "out ";
      default: Debug.Assert(false); return null;
    }
  }
}

abstract class Argument_10 : Node_10 {
  protected GType_10 type_;

  public GType_10 Type() { return type_; }

  public abstract int GetMode();
  public string TypeString() { return Mode_10.ToString(GetMode()) + type_.ToString(); }

  public abstract bool Check(Context_10 ctx);
  public abstract void FinishCall(Context_10 ctx);

  public abstract void AddEval(ArrayList a, Env_10 env, GType_10 t);

  public abstract string Emit(GType_10 t);
}

class InArgument_10 : Argument_10 {
  public readonly Expression_10 ^expr_;

  public InArgument_10(Expression_10 ^expr) { expr_ = expr; }
  public InArgument_10(GType_10 type) { type_ = type; }

  public override int GetMode() { return 0; }

  public override bool Check(Context_10 ctx) {
    if (type_ == null)
      type_ = expr_.CheckAndHold(ctx);
    return type_ != null;
  }

  public override void FinishCall(Context_10 ctx) {
    expr_.ReleaseRef(ctx);
  }

  public override void AddEval(ArrayList a, Env_10 env, GType_10 t) {
    a.Add(expr_.Eval(env, t));
  }

  public override string Emit(GType_10 t) {
    return expr_.EmitRef(type_, t);
  }
}

class RefOutArgument_10 : Argument_10 {
  public readonly int mode_;
  public readonly LValue_10 ^lvalue_;

  public RefOutArgument_10(int mode, LValue_10 ^lvalue) { mode_ = mode; lvalue_ = lvalue; }

  public override int GetMode() { return mode_; }

  public override bool Check(Context_10 ctx) {
    type_ = lvalue_.Check(ctx, mode_ == Mode_10.Ref, true, false);
    if (type_ == null)
      return false;
    if (lvalue_.Kind() == ExprKind_10.Indexer_10) {
      Error("can't pass indexer as ref or out argument");
      return false;
    }
    return true;
  }

  public override void FinishCall(Context_10 ctx) {
    AddControl(ctx);
  }

  public override bool Sets(Local_10 local) { return lvalue_.IsLocal(local); }

  public override TypeSet_10 NodeDestroys() { return lvalue_.StorageType().VarDestroys(); }

  public GType_10 StorageType() { return lvalue_.StorageType(); }

  public override void AddEval(ArrayList a, Env_10 env, GType_10 t) {
    a.Add(new LocationRef_10(lvalue_.EvalLocation(env)));
  }

  public override string Emit(GType_10 t) { return lvalue_.EmitLocation(); }
}

class Invocation_10 : Expression_10 {
  Expression_10 ^obj_;    // may be null
  GType_10 obj_type_;
  string name_;
  ArrayList /* of Argument_10 */ ^arguments_;

  Method_10 method_;

  public Invocation_10(Expression_10 ^obj, string name, ArrayList ^arguments) {
    obj_ = obj; name_ = name; arguments_ = arguments;
  }

  public static Method_10 CheckInvoke(Node_10 caller, Context_10 ctx, bool through_base, GType_10 type,
                                   string name, ArrayList /* of Argument_10 */ arguments,
                                   int kind) {
    foreach (Argument_10 arg in arguments)
      if (!arg.Check(ctx))
        return null;

    // Add the caller to the graph; this node represents the invocation itself.
    caller.AddControl(ctx);

    // Now we can release temporary expressions and add control graph nodes representing
    // assignments to ref and out parameters.
    foreach (Argument_10 arg in arguments)
      arg.FinishCall(ctx);

    Method_10 m = (Method_10) type.Lookup(caller, ctx.class_, through_base, kind, name, arguments, true);
    if (m != null)
      for (int i = 0; i < m.parameters_.Count; ++i) {
        Parameter_10 p = m.Param(i);
        if (p.GetMode() == Mode_10.In) {
          InArgument_10 a = (InArgument_10) arguments[i];
          a.expr_.CheckLoseOwnership(a.Type(), p.Type());
        }
      }
    return m;
  }

  public override GType_10 Check(Context_10 ctx) {
    GType_10 t;
    bool is_class = false;  // true when calling a static method using a class name

    if (obj_ == null)
      t = ctx.class_;
    else {
      t = obj_type_ = obj_.Check(ctx, true, false, true);
      if (t == null)
        return null;
      if (obj_.Kind() == ExprKind_10.Type)
        is_class = true;
      else obj_.HoldRef(ctx);
    }

    method_ = CheckInvoke(this, ctx, obj_ is Base_10, t, name_, arguments_, MemberKind_10.Method_10);
    if (method_ == null)
      return null;

    if (method_ is Constructor_10) {
      Error("can't call constructor directly");
      return null;
    }

    if (obj_ == null) {
      if (!method_.IsStatic() && ctx.IsStatic()) {
        Error("can't call instance method in static context");
        return null;
      }
    } else {
      obj_.ReleaseRef(ctx);
      if (is_class) {
        if (!method_.IsStatic()) {
          Error("can't invoke non-static method through class name");
          return null;
        }
      } else {
        if (method_.IsStatic()) {
          Error("can't invoke static method through object");
          return null;
        }
      }
    }

    GType_10 ret = method_.ReturnType();
    if (ret is Owning_10)
      ctx.AddTemporary(this);
    return ret;
  }

  public override GType_10 TemporaryType() { return method_.ReturnType(); }

  public override Method_10 Calls() { return method_; }

  public static RValue_10 ^InvokeMethod(GValue_10 obj, Method_10 m, ArrayList /* of RValue_10 */ values,
                                    bool virtual_ok) {
    if (m.IsVirtual() && virtual_ok) {
      GType_10 t = obj.Type();
      m = (Method_10) t.FindMatchingMember(m, true);
      Debug.Assert(m != null);
    }
    return m.Invoke(obj, values);
  }

  public static RValue_10 ^CallMethod(Env_10 env, GValue_10 obj,
                                  Method_10 m, ArrayList /* of Argument_10 */ args,
                                  bool virtual_ok) {
    ArrayList /* of ValueOrLocation_10 */ ^values = new ArrayList();
    int i;
    for (i = 0 ; i < args.Count ; ++i) {
      Argument_10 a = (Argument_10) args[i];
      a.AddEval(values, env, m.Param(i).Type());
    }
    return InvokeMethod(obj, m, values, virtual_ok);
  }

  public RValue_10 ^Eval(Env_10 env, Expression_10 obj, Method_10 m, ArrayList /* of Argument_10 */ args) {
    RValue_10 ^r;
    GValue_10 v;
    if (m.IsStatic())
      v = null;
    else {
      if (obj == null)
        v = env.this_;
      else {
        r = obj.Eval(env);
        v = r.Get();
        if (v is Null_10) {
          Error("attempted to call method on null object");
          Gel_10.Exit();
        }
      }
    }

    return CallMethod(env, v, m, args, !(obj is Base_10));
  }

  public override RValue_10 ^Eval(Env_10 env) {
    return Eval(env, obj_, method_, arguments_);
  }

  public static string EmitArguments(Method_10 m, ArrayList /* of Argument_10 */ arguments) {
    StringBuilder ^sb = new StringBuilder();
    Debug.Assert(m.parameters_.Count == arguments.Count);
    for (int i = 0; i < arguments.Count; ++i) {
      if (i > 0)
        sb.Append(", ");
      Argument_10 a = (Argument_10)arguments[i];
      sb.Append(a.Emit(m.Param(i).Type()));
    }
    return sb.ToString();
  }

  public override string Emit() {
    StringBuilder ^sb = new StringBuilder();
    if (obj_ != null) {
      if (method_.IsStatic())
        sb.AppendFormat("{0}::", obj_.Emit());
      else if (obj_type_.IsReference())
        sb.Append(obj_.EmitArrow(obj_type_, method_));
      else sb.AppendFormat("({0})->", obj_.Emit(obj_type_, GObject_10.type_));   // box values
    }
    sb.AppendFormat("{0} ({1})", method_.name_, EmitArguments(method_, arguments_));
    return Hold(method_.ReturnType(), sb.ToString());
  }
}

// an expression of the form a[b]
class Sub_10 : LValue_10 {
  readonly Expression_10 ^base_;
  GType_10 base_type_;
  readonly Expression_10 ^index_;
  GType_10 index_type_;

  GType_10 element_type_;    // for array accesses; null for indexers
  Indexer_10 indexer_;

  public Sub_10(Expression_10 ^base_exp, Expression_10 ^index) { base_ = base_exp; index_ = index; }

  public override GType_10 Check(Context_10 ctx, bool read, bool write, bool type_ok) {
    base_type_ = base_.CheckAndHold(ctx);
    if (base_type_ == null)
      return null;

    index_type_ = index_.CheckAndHold(ctx);
    if (index_type_ == null)
      return null;

    if (read)
      ReleaseAll(ctx);

    ArrayType_10 at = base_type_.BaseType() as ArrayType_10;
    if (at != null) {
      if (!index_type_.CheckConvert(this, GInt_10.type_))
        return null;
      element_type_ = at.ElementType();
      return element_type_.BaseType();
    }

    ArrayList ^arguments = new ArrayList();
    arguments.Add(new InArgument_10(index_type_));

    indexer_ = (Indexer_10) base_type_.Lookup(this, ctx.class_, base_ is Base_10,
                                           MemberKind_10.Indexer_10, null, arguments, true);
    if (indexer_ == null)
      return null;

    if (read && !indexer_.CheckAssigning(this, ctx, false) ||
        write && !indexer_.CheckAssigning(this, ctx, true))
      return null;

    if (read)
      AddControl(ctx);

    return indexer_.Type();
  }

  public override void ReleaseAll(Context_10 ctx) {
    base_.ReleaseRef(ctx);
    index_.ReleaseRef(ctx);
  }

  public override int Kind() {
    return element_type_ != null ? ExprKind_10.Field_10 : ExprKind_10.Indexer_10;
  }

  public override GType_10 StorageType() {
    return element_type_ != null ? element_type_ : indexer_.Type();
  }

  public override PropertyOrIndexer_10 GetPropertyOrIndexer() { return indexer_; }

  public override void Eval1(Env_10 env, out RValue_10 ^v1, out RValue_10 ^v2) {
    v1 = base_.Eval(env);
    if (v1 is Null_10) {
      Error("attempted array or indexer access through null");
      Gel_10.Exit();
    }
    v2 = index_.Eval(env);
  }

  int Index(RValue_10 ^v) {
    // ++ We get an ownership error if we combine the following two lines into one; why?
    v = v.Get().Convert(ref v, GInt_10.type_);
    return ((GInt_10) v).i_;
  }

  public override RValue_10 ^EvalGet(Env_10 env, RValue_10 ^v1, RValue_10 ^v2) {
    if (indexer_ == null) {
      GArray_10 arr = (GArray_10) v1.Get();
      int i = Index(v2);
      return LosesOwnership() && element_type_ is Owning_10 ? arr.Take_10(i) : arr.Get(i);
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    return Invocation_10.InvokeMethod(v1.Get(), indexer_.Getter(), args, true);
  }

  public override void EvalSet(Env_10 env, RValue_10 ^v1, RValue_10 ^v2, RValue_10 ^val) {
    if (indexer_ == null) {
      ((GArray_10) v1.Get()).Set(Index(v2), val);
      return;
    }
    ArrayList ^args = new ArrayList();
    args.Add(v2);
    args.Add(val);
    Invocation_10.InvokeMethod(v1.Get(), indexer_.Setter(), args, true);
  }

  public override Location_10 EvalLocation(Env_10 env, RValue_10 ^v1, RValue_10 ^v2) {
    int i = ((GInt_10) v2).i_;
    return ((GArray_10) v1).GetLocation(i);
  }

  string EmitBase() {
    return base_.EmitArrow(base_type_, indexer_);
  }

  string EmitIndex() {
    return index_.Emit(index_type_, indexer_ != null ? indexer_.parameter_.Type() : GInt_10.type_);
  }

  public override string Emit() {
    string get = String.Format("{0}get_Item({1})", EmitBase(), EmitIndex());
    if (element_type_ != null) {
      get = get + OwnSuffix(element_type_);
      if (!element_type_.IsValue())
        get = String.Format("static_cast<{0} >({1})", element_type_.EmitExprType(), get);
      return get;
    } else return Hold(indexer_.Type(), get);
  }

  public override string EmitSet(string val) {
    return String.Format(element_type_ != null ? "{0}get_Item({1}) = {2}" : "{0}set_Item({1}, {2})",
       EmitBase(), EmitIndex(), val);
  }

  public override string EmitLocation() {
    return String.Format("{0}get_location({1})", EmitBase(), EmitIndex());
  }
}

class This_10 : Expression_10 {
  public override GType_10 Check(Context_10 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access this in a static context");
      return null;
    }
    return ctx.class_;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    return new Reference_10(env.this_);
  }

  public override string Emit() { return "this"; }
}

class Base_10 : Expression_10 {
  Class_10 parent_;

  public override GType_10 Check(Context_10 ctx) {
    if (ctx.IsStatic()) {
      Error("can't access base in a static context");
      return null;
    }
    parent_ = ctx.class_.Parent();
    if (parent_ == null) {
      Error("can't access base: class has no parent");
      return null;
    }
    return parent_;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    return new Reference_10(env.this_);
  }

  public override string Emit() { return "this"; }

  public override string EmitArrow(GType_10 t, Member_10 m) {
    return m.GetClass().name_ + "::"; 
  }
}

class New_10 : Expression_10 {
  Expression_10 ^creator_;    // either a pool or null
  TypeExpr_10 ^type_expr_;
  ArrayList /* of Expression_10 */ ^arguments_;

  Class_10 class_;
  Constructor_10 constructor_;

  public New_10(Expression_10 ^creator, TypeExpr_10 ^expr, ArrayList ^arguments) {
    creator_ = creator;
    type_expr_ = expr;
    arguments_ = arguments;
  }

  GType_10 Type() {
    return creator_ == null ? (GType_10) class_.OwningType() : class_;
  }

  public override GType_10 TemporaryType() { return Type(); }    

  public override GType_10 Check(Context_10 ctx) {
    if (creator_ != null) {
      GType_10 c = creator_.Check(ctx);
      if (c == null)
        return null;
      if (!c.BaseType().IsSubtype(PoolClass_10.instance_)) {
        Error("object creator must be a pool");
        return null;
      }
    }
    GType_10 t = type_expr_.Resolve(ctx.program_);
    if (t == null)
      return null;
    class_ = (Class_10) t;
    if (class_.HasAttribute(Attribute_10.Abstract)) {
      Error("can't instantiate abstract class");
      return null;
    }
    if (creator_ != null) {
      class_.NeedDestroy(); // every pool-allocated class needs the _Destroy1 and _Destroy2 methods
      class_.SetVirtual();  // every pool-allocated class must be virtual
    }

    constructor_ = (Constructor_10) Invocation_10.CheckInvoke(this, ctx, false, class_,
                                      class_.name_, arguments_, MemberKind_10.Constructor_10);
    if (constructor_ == null)
      return null;

    GType_10 type = Type();
    if (type is Owning_10)
      ctx.AddTemporary(this);
    return type;
  }

  public override Method_10 Calls() { return constructor_; }

  public override RValue_10 ^Eval(Env_10 env) {
    GValue_10 ^obj = class_.New_10();
    Invocation_10.CallMethod(env, obj, constructor_, arguments_, false);
    return obj;
  }

  public override string Emit() {
    string args = Invocation_10.EmitArguments(constructor_, arguments_);

    return creator_ == null ?
      EmitAllocate(class_.name_, args, LosesOwnership()) :
      String.Format("new ({0}->Alloc(sizeof({1}))) {1}({2})", creator_.Emit(), class_.name_, args);
  }
}

class ArrayInitializer_10 : Expression_10 {
  public readonly ArrayList /* of Expression_10 */ ^initializers_;

  public ArrayInitializer_10(ArrayList ^initializers) { initializers_ = initializers; }

  public override GType_10 Check(Context_10 ctx) {
    Error("only static fields may have array initializers");
    return null;
  }

  public bool CheckElements(Context_10 ctx, GType_10 element_type) {
    foreach (Expression_10 e in initializers_)
      if (!e.CheckConstant() || !e.Check(ctx, element_type))
        return false;
    return true;
  }

  public override RValue_10 ^Eval(Env_10 env) { Debug.Assert(false); return null; }

  public GArray_10 ^Eval(ArrayType_10 type) {
    GArray_10 ^a = new GArray_10(type, initializers_.Count);
    for (int i = 0; i < initializers_.Count; ++i) {
      Expression_10 e = (Expression_10) initializers_[i];
      a.Set(i, e.Eval(Env_10.static_, type.ElementType()));
    }
    return a;
  }

  public override string Emit() { Debug.Assert(false); return null; }

  public void Emit(SourceWriter_10 w) {
    int count = initializers_.Count;
    int per_row = 12;

    w.Write("{ ");
    if (count > per_row) {    // format onto multiple rows
      w.WriteLine("");
      w.AddIndent();
      w.Indent();
    }
    for (int i = 0; i < count; ++i) {
      if (i > 0) {
        w.Write(", ");
        if (i % per_row == 0) {
          w.WriteLine("");
          w.Indent();
        }
      }
      Expression_10 e = (Expression_10) initializers_[i];
      SimpleValue_10 ^v = (SimpleValue_10) e.Eval(Env_10.static_);
      w.Write(v.Emit());
    }
    if (count > per_row) {
      w.SubIndent();
      w.WriteLine("");
    }
    w.Write(" }");
  }
}

class NewArray_10 : Expression_10 {
  TypeExpr_10 ^element_type_expr_;
  int dimensions_;
  ArrayType_10 ^array_type_;

  Expression_10 ^count_;

  public NewArray_10(TypeExpr_10 ^element_type_expr, int dimensions, Expression_10 ^count) {
    element_type_expr_ = element_type_expr;
    dimensions_ = dimensions;
    count_ = count;
  }

  GType_10 Type() {
    return (GType_10) array_type_.OwningType();
  }

  public override GType_10 TemporaryType() { return Type(); }

  public override GType_10 Check(Context_10 ctx) {
    if (element_type_expr_ is ArrayTypeExpr_10) {
      Error("syntax error in new expression");
      return null;
    }
    for (int i = 0; i < dimensions_; ++i)
      element_type_expr_ = new ArrayTypeExpr_10(take element_type_expr_);
    GType_10 element_type = element_type_expr_.Resolve(ctx.program_);
    if (element_type == null)
      return null;
    array_type_ = new ArrayType_10(element_type);

    if (!count_.Check(ctx, GInt_10.type_))
      return null;

    GType_10 t = Type();
    if (t is Owning_10)
      ctx.AddTemporary(this);
    return t;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    return new GArray_10(array_type_, count_.EvalInt(env));
  }

  public override string Emit() {
    GType_10 t = array_type_.ElementType();
    string array_type = GType_10.ConstructType(
      t is Owning_10 ? "_Array" : "_CopyableArray",
      t.EmitGenericType());
    string args = String.Format("&typeid({0}), {1}", t.EmitType(), count_.Emit());
    return EmitAllocate(array_type, args, LosesOwnership());
  }
}

abstract class Unary_10 : Expression_10 {
  protected Expression_10 ^exp_;

  protected Unary_10(Expression_10 ^e) { exp_ = e; }

  public override bool IsConstant() { return exp_.IsConstant(); }
}

// unary minus operator
class Minus_10 : Unary_10 {
  GType_10 type_;

  public Minus_10(Expression_10 ^e) : base(e) { }

  public override GType_10 Check(Context_10 ctx) {
    type_ = exp_.Check(ctx);
    if (type_ != GInt_10.type_ && type_ != GFloat_10.type_ && type_ != GDouble_10.type_) {
      Error("- operator cannot be applied to value of type {0}", type_);
      return null;
    }
    return type_;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    if (type_ == GInt_10.type_) {
    int i = exp_.EvalInt(env);
    return new GInt_10(-i);
  }
    if (type_ == GFloat_10.type_) {
      float f = exp_.EvalFloat(env);
      return new GFloat_10(-f);
    }
    if (type_ == GDouble_10.type_) {
      double d = exp_.EvalDouble(env);
      return new GDouble_10(-d);
    }
    Debug.Assert(false);
    return null;
  }

  public override string Emit() { return "-" + exp_.Emit(); }
}

class Not_10 : Unary_10 {
  public Not_10(Expression_10 ^e) : base(e) { }

  public override GType_10 Check(Context_10 ctx) {
    return exp_.Check(ctx, GBool_10.type_) ? GBool_10.type_ : null;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    bool b = exp_.EvalBool(env);
    return new GBool_10(!b);
  }

  public override string Emit() { return "!" + exp_.Emit(); }
}

// the bitwise complement (~) operator
class Complement_10 : Unary_10 {
  public Complement_10(Expression_10 ^e) : base(e) { }

  public override GType_10 Check(Context_10 ctx) {
    return exp_.Check(ctx, GInt_10.type_) ? GInt_10.type_ : null;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    int i = exp_.EvalInt(env);
    return new GInt_10(~i);
  }

  public override string Emit() { return "~" + exp_.Emit(); }
}

class IncDec_10 : Expression_10 {
  bool pre_;    // true for pre-increment/decrement; false for post-increment/decrement
  bool inc_;
  LValue_10 ^lvalue_;

  public IncDec_10(bool pre, bool inc, LValue_10 ^lvalue) { pre_ = pre; inc_ = inc; lvalue_ = lvalue; }

  public override GType_10 Check(Context_10 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    GType_10 t = lvalue_.Check(ctx, true, true, false);
    if (t == null)
      return null;
    if (lvalue_.Kind() == ExprKind_10.Indexer_10) {
      Error("++ and -- can't yet operate on indexers");
      return null;
    }
    if (t != GInt_10.type_) {
      Error("++ and -- can operate only on integers");
      return null;
    }
    return GInt_10.type_;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    Location_10 loc = lvalue_.EvalLocation(env);
    GInt_10 ^i = (GInt_10) take loc.value_;
    loc.value_ = new GInt_10(inc_ ? i.i_ + 1 : i.i_ - 1);
    return pre_ ? ((GInt_10) loc.value_).Copy() : i;
  }

  string EmitOp() { return inc_ ? "++" : "--"; }

  public override string Emit() {
    return pre_ ? EmitOp() + lvalue_.Emit() : lvalue_.Emit() + EmitOp();
  }
}

abstract class Conversion_10 : Expression_10 {
  protected Expression_10 ^expr_;
  protected TypeExpr_10 ^type_expr_;

  protected GType_10 from_base_;
  protected GType_10 to_type_, to_base_;

  protected Conversion_10(Expression_10 ^expr, TypeExpr_10 ^type_expr) {
    expr_ = expr; type_expr_ = type_expr;
  }

  protected bool CheckConversion(Context_10 ctx, bool subtype_only) {
    GType_10 from = expr_.Check(ctx);
    if (from == null)
      return false;
    from_base_ = from.BaseType();

    to_base_ = type_expr_.Resolve(ctx.program_);
    if (to_base_ == null)
      return false;
    if (!to_base_.IsValue() &&
       (from is Owning_10 || from_base_.IsValue()))
      to_type_ = to_base_.OwningType();
    else to_type_ = to_base_;

    if (!from.CanConvertExplicit(to_type_, subtype_only)) {
      Error("can't convert from {0} to {1}", from_base_, to_base_);
      return false;
    }
    return true;
  }
}

class Cast_10 : Conversion_10 {
  public Cast_10(Expression_10 ^expr, TypeExpr_10 ^type_expr) : base(expr, type_expr) { }

  public override Local_10 GetLocal() { return expr_.GetLocal(); }
  
  public override GType_10 Check(Context_10 ctx) {
    return CheckConversion(ctx, false) ? to_type_ : null;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_10.Local_10 ? ExprKind_10.Local_10 : ExprKind_10.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_10 ^Eval(Env_10 env) {
    RValue_10 ^r = expr_.Eval(env);
    return r.Get().ConvertExplicit(ref r, to_base_);
  }

  public override string Emit() {
    return expr_.EmitExplicit(from_base_, to_type_);
  }
}

class Binary_10 : Expression_10 {
  int op_;
  Expression_10 ^left_, right_;
  GType_10 left_type_, right_type_;
  GType_10 type_;

  const int CONCATENATE = 0;

  public Binary_10(Expression_10 ^left, int op, Expression_10 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public static GType_10 Promote(Syntax_10 caller, GType_10 left, int op, GType_10 right) {
    if (left.CanConvert(GInt_10.type_) && right.CanConvert(GInt_10.type_))
      return GInt_10.type_;
    if (left.CanConvert(GFloat_10.type_) && right.CanConvert(GFloat_10.type_))
      return GFloat_10.type_;
    if (left.CanConvert(GDouble_10.type_) && right.CanConvert(GDouble_10.type_))
      return GDouble_10.type_;
    caller.Error("can't apply operator {0} to operands of type {1} and {2}", OpName(op), left, right);
    return null;
  }

  bool CheckIntArgs() {
    if (left_type_.CheckConvert(this, GInt_10.type_) && right_type_.CheckConvert(this, GInt_10.type_)) {
      type_ = GInt_10.type_;
      return true;
    }
    return false;
  }

  public override GType_10 Check(Context_10 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);

    if (op_ == '+' && (left_type_ == GString_10.type_ || right_type_ == GString_10.type_)) {
      op_ = CONCATENATE;

      // If_10 we'll be calling ToString() on a class, ensure that it will inherit from
      // Object in generated code.
      if (left_type_ != GString_10.type_)
        left_type_.CanConvert(GObject_10.type_);
      if (right_type_ != GString_10.type_)
        right_type_.CanConvert(GObject_10.type_);

      return GString_10.type_;
    }

    switch (op_) {
      case '*':
      case '/':
      case '+':
      case '-':
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_;

      case '%':
      case Parser.OP_LEFT_SHIFT:
      case Parser.OP_RIGHT_SHIFT:
        return CheckIntArgs() ? GInt_10.type_ : null;

      case '&':
      case '|':
        if (left_type_ == GBool_10.type_ && right_type_ == GBool_10.type_)
          type_ = GBool_10.type_;
        else {
          if (!CheckIntArgs())
            return null;
          type_ = GInt_10.type_;
        }
        return type_;

      case '<':
      case Parser.OP_LE:
      case '>':
      case Parser.OP_GE:
        type_ = Promote(this, left_type_, op_, right_type_);
        return type_ == null ? null : GBool_10.type_;

      default:
        Debug.Assert(false);
        return null;
    }
  }

  public static GBool_10 ^BoolOp(bool x, int op, bool y) {
    switch (op) {
      case '&': return new GBool_10(x & y);
      case '|': return new GBool_10(x | y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_10 ^IntOp(int x, int op, int y) {
    switch (op) {
      case '*': return new GInt_10(x * y);
      case '/': return new GInt_10(x / y);
      case '%': return new GInt_10(x % y);
      case '+': return new GInt_10(x + y);
      case '-': return new GInt_10(x - y);
      case Parser.OP_LEFT_SHIFT: return new GInt_10(x << y);
      case Parser.OP_RIGHT_SHIFT: return new GInt_10(x >> y);
      case '&': return new GInt_10(x & y);
      case '|': return new GInt_10(x | y);
      case '<': return new GBool_10(x < y);
      case Parser.OP_LE: return new GBool_10(x <= y);
      case '>': return new GBool_10(x > y);
      case Parser.OP_GE: return new GBool_10(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_10 ^FloatOp(float x, int op, float y) {
    switch (op) {
      case '*': return new GFloat_10(x * y);
      case '/': return new GFloat_10(x / y);
      case '+': return new GFloat_10(x + y);
      case '-': return new GFloat_10(x - y);
      case '<': return new GBool_10(x < y);
      case Parser.OP_LE: return new GBool_10(x <= y);
      case '>': return new GBool_10(x > y);
      case Parser.OP_GE: return new GBool_10(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public static GValue_10 ^DoubleOp(double x, int op, double y) {
    switch (op) {
      case '*': return new GDouble_10(x * y);
      case '/': return new GDouble_10(x / y);
      case '+': return new GDouble_10(x + y);
      case '-': return new GDouble_10(x - y);
      case '<': return new GBool_10(x < y);
      case Parser.OP_LE: return new GBool_10(x <= y);
      case '>': return new GBool_10(x > y);
      case Parser.OP_GE: return new GBool_10(x >= y);
      default: Debug.Assert(false); return null;
    }
  }

  public override RValue_10 ^Eval(Env_10 env) {
    if (op_ == CONCATENATE)
      return new GString_10(left_.Eval(env).ToString() + right_.Eval(env).ToString());

    if (type_ == GBool_10.type_)
      return BoolOp(left_.EvalBool(env), op_, right_.EvalBool(env));
    if (type_ == GInt_10.type_)
      return IntOp(left_.EvalInt(env), op_, right_.EvalInt(env));
    if (type_ == GFloat_10.type_)
      return FloatOp(left_.EvalFloat(env), op_, right_.EvalFloat(env));
    if (type_ == GDouble_10.type_)
      return DoubleOp(left_.EvalDouble(env), op_, right_.EvalDouble(env));

    Debug.Assert(false);
    return null;
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  static string OpName(int op) {
    switch (op) {
      case Parser.OP_LEFT_SHIFT: return "<<";
      case Parser.OP_RIGHT_SHIFT: return ">>";
      case Parser.OP_LE: return "<=";
      case Parser.OP_GE: return ">=";
      default: return ((char) op).ToString();
    }
  }

  public override string Emit() {
    if (op_ == CONCATENATE)
      return Hold(GString_10.type_,
        String.Format("String::_Concat({0}, {1})",
          left_.EmitRef(left_type_, GObject_10.type_), right_.Emit(right_type_, GObject_10.type_)));

    return String.Format("{0} {1} {2}",
      left_.EmitRef(left_type_), OpName(op_), right_.Emit() );
  }
}

class Equality_10 : Expression_10 {
  bool equal_;    // true for ==, false for !=
  Expression_10 ^left_, right_;
  GType_10 left_type_, right_type_, type_;

  public Equality_10(Expression_10 ^left, int op, Expression_10 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_EQUAL: equal_ = true; break;
      case Parser.OP_NE: equal_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_10 Check(Context_10 ctx) {
    left_type_ = left_.CheckAndHold(ctx);
    right_type_ = right_.Check(ctx);
    if (left_type_ == null || right_type_ == null)
      return null;
    left_.ReleaseRef(ctx);
    if (left_type_.IsReference() != right_type_.IsReference()) {
      Error("can't compare types {0} and {1}", left_type_, right_type_);
      return null;
    }
    type_ = left_type_.BaseType().CommonType(this, right_type_.BaseType());
    return type_ == null ? null : GBool_10.type_;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    RValue_10 ^left = left_.Eval(env, type_);
    RValue_10 ^right = right_.Eval(env, type_);
    bool eq = left.Get().DefaultEquals(right.Get());
    return new GBool_10(equal_ ? eq : !eq);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    string emit_left = left_.EmitRef(left_type_);
    string emit_right = right_.Emit();
    if (type_ == GString_10.type_)
      return String.Format("{0}String::_Equals({1}, {2})",
                           equal_ ? "" : "!", emit_left, emit_right);
    return String.Format("{0} {1} {2}", emit_left, equal_ ? "==" : "!=", emit_right);
  }
}

class Is_10 : Conversion_10 {
  public Is_10(Expression_10 ^expr, TypeExpr_10 ^type_expr) : base(expr, type_expr) { }

  public override GType_10 Check(Context_10 ctx) {
    return CheckConversion(ctx, true) ? GBool_10.type_ : null;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    RValue_10 ^r = expr_.Eval(env);
    GValue_10 v = r.Get();
    return new GBool_10(!(v is Null_10) && v.Type().IsSubtype(to_base_));
  }

  public override string Emit() {
    if (from_base_.IsReference()) {
      Class_10 c = (Class_10) to_base_;
      return String.Format("dynamic_cast<{0} *>({1}) != 0", c.name_, expr_.Emit());
    }
    return to_base_ == from_base_ || to_base_ == GObject_10.type_ ? "true" : "false";
  }
}

class As_10 : Conversion_10 {
  public As_10(Expression_10 ^expr, TypeExpr_10 ^type_expr) : base(expr, type_expr) { }

  public override Local_10 GetLocal() { return expr_.GetLocal(); }

  public override GType_10 Check(Context_10 ctx) {
    if (!CheckConversion(ctx, true))
      return null;
    if (!to_base_.IsReference()) {
      Error("as operator must convert to reference type");
      return null;
    }
    return to_type_;
  }

  public override int Kind() {
    return expr_.Kind() == ExprKind_10.Local_10 ? ExprKind_10.Local_10 : ExprKind_10.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    expr_.LoseOwnership();
  }

  public override RValue_10 ^Eval(Env_10 env) {
    RValue_10 ^r = expr_.Eval(env);
    return r.Get().Type().IsSubtype(to_base_) ? r : Null_10.Instance.Copy();
  }

  public override string Emit() {
    if (from_base_.CanConvert(to_base_))
      return expr_.Emit(from_base_, to_base_);
    Class_10 c = (Class_10) to_base_;
    return String.Format("dynamic_cast<{0} *>({1})", c.name_, expr_.Emit());
  }
}

// a && or || operator
class LogicalOp_10 : Expression_10 {
  bool and_;  // true => &&, false => ||
  Expression_10 ^left_, right_;
  Joiner_10 ^join_ = new Joiner_10();

  public LogicalOp_10(Expression_10 ^left, int op, Expression_10 ^right) {
    left_ = left;
    switch (op) {
      case Parser.OP_AND: and_ = true; break;
      case Parser.OP_OR: and_ = false; break;
      default: Debug.Assert(false); break;
    }
    right_ = right;
  }

  public override GType_10 Check(Context_10 ctx) {
    if (!left_.Check(ctx, GBool_10.type_))
      return null;

    join_.Join(ctx.Prev());
    if (!right_.Check(ctx, GBool_10.type_))
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    return GBool_10.type_;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    bool left = left_.EvalBool(env);
    bool b = and_ ? left && right_.EvalBool(env) : left || right_.EvalBool(env);
    return new GBool_10(b);
  }

  public override bool IsConstant() { return left_.IsConstant() && right_.IsConstant(); }

  public override string Emit() {
    return String.Format("{0} {1} {2}", left_.Emit(), and_ ? "&&" : "||", right_.Emit());
  }

}

// the ?: operator
class Conditional_10 : Expression_10 {
  Expression_10 ^condition_;
  Expression_10 ^if_true_, if_false_;

  GType_10 true_type_, false_type_;
  GType_10 type_;
  Joiner_10 ^join_ = new Joiner_10();

  public Conditional_10(Expression_10 ^condition, Expression_10 ^if_true, Expression_10 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override GType_10 Check(Context_10 ctx) {
    if (!condition_.Check(ctx, GBool_10.type_))
      return null;

    Control_10 c = ctx.Prev();

    true_type_ = if_true_.Check(ctx);
    if (true_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    false_type_ = if_false_.Check(ctx);
    if (false_type_ == null)
      return null;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());

    type_ = true_type_.CommonType(this, false_type_);
    return type_;
  }

  public override int Kind() {
    return if_true_.Kind() == ExprKind_10.Local_10 && if_false_.Kind() == ExprKind_10.Local_10 ? ExprKind_10.Local_10 : ExprKind_10.Value;
  }

  public override void LoseOwnership() {
    base.LoseOwnership();
    if_true_.LoseOwnership();
    if_false_.LoseOwnership();
  }

  public override RValue_10 ^Eval(Env_10 env) {
    return condition_.EvalBool(env) ? if_true_.Eval(env, type_) : if_false_.Eval(env, type_);
  }

  public override string Emit() {
    return String.Format("{0} ? {1} : {2}", condition_.Emit(),
                         if_true_.Emit(true_type_, type_), if_false_.Emit(false_type_, type_));
  }
}

class Assign_10 : Expression_10 {
  LValue_10 ^left_;
  Expression_10 ^right_;

  GType_10 left_type_, right_type_;

  public Assign_10(LValue_10 ^left, Expression_10 ^right) {
    left_ = left; right_ = right;
  }

  public static bool CheckAssign(Syntax_10 caller, GType_10 left_type, Expression_10 right, GType_10 right_type) {
    if (!right_type.CheckConvert(caller, left_type,
      right.Kind() == ExprKind_10.Local_10 ? ConversionContext_10.AssignVar : ConversionContext_10.Other))
      return false;
    right.CheckLoseOwnership(right_type, left_type);
    return true;
  }

  public override GType_10 Check(Context_10 ctx) {
    left_type_ = left_.Check(ctx, false, true, false);
    if (left_type_ == null)
      return null;

    right_type_ = right_.Check(ctx, true, false, false);
    if (right_type_ == null || !CheckAssign(this, left_.StorageType(), right_, right_type_))
      return null;
    right_.HoldRef(ctx);

    AddControl(ctx);
    left_.ReleaseAll(ctx);
    right_.ReleaseRef(ctx);
    return left_type_;
  }

  public override Method_10 Calls() {
    PropertyOrIndexer_10 pi = left_.GetPropertyOrIndexer();
    return pi == null ? null : pi.Setter();
  }

  public override bool Sets(Local_10 local) { return left_.IsLocal(local); }

  public override TypeSet_10 NodeDestroys() {
    return left_.GetPropertyOrIndexer() != null ? TypeSet_10.empty_ : left_.StorageType().VarDestroys();
  }

  public override RValue_10 ^Eval(Env_10 env) {
    RValue_10 ^v1, v2;
    left_.Eval1(env, out v1, out v2);
    RValue_10 ^val = right_.Eval(env, left_type_);
    RValue_10 ^ret = val.CopyRef();
    left_.EvalSet(env, v1, v2, val);
    return ret;
  }

  public override string Emit() {
    return left_.EmitSet(right_.EmitRef(right_type_, left_type_));
  }
}

// a compound assignment operator such as += or -=
class CompoundAssign_10 : Expression_10 {
  LValue_10 ^left_;
  int op_;
  Expression_10 ^right_;

  GType_10 type_;

  public CompoundAssign_10(LValue_10 ^left, int op, Expression_10 ^right) {
    left_ = left; op_ = op; right_ = right;
  }

  public override GType_10 Check(Context_10 ctx) {
    // We don't bother to store a node in the control graph indicating that this lvalue
    // is written after we read it; it must be valid when it's read, and writing it afterward
    // has no effect on liveness.
    type_ = left_.Check(ctx, true, true, false);
    if (type_ == null)
      return null;
    if (left_.Kind() == ExprKind_10.Indexer_10) {
      Error("compound assignments don't yet work on indexers");
      return null;
    }
    if (type_ == GBool_10.type_ && (op_ == '&' || op_ == '|')) {
      if (!right_.Check(ctx, GBool_10.type_))
        return null;
      return type_;
    }
    if (type_ != GInt_10.type_ && type_ != GFloat_10.type_ && type_ != GDouble_10.type_) {
      Error("compound assignment operator {0}= can't operate on object of type {1}", (char) op_, type_);
      return null;
    }
    if (!right_.Check(ctx, type_))
      return null;
    return type_;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    Location_10 loc = left_.EvalLocation(env);
    if (type_ == GBool_10.type_) {
      bool x = ((GBool_10) loc.value_).b_;
      bool y = right_.EvalBool(env);
      loc.value_ = Binary_10.BoolOp(x, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GInt_10.type_) {
      GInt_10 x = (GInt_10) loc.value_;
      int y = right_.EvalInt(env);
      loc.value_ = Binary_10.IntOp(x.i_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GFloat_10.type_) {
      GFloat_10 x = (GFloat_10) loc.value_;
      float y = right_.EvalFloat(env);
      loc.value_ = Binary_10.FloatOp(x.f_, op_, y);
      return loc.value_.CopyRef();
    } else if (type_ == GDouble_10.type_) {
      GDouble_10 x = (GDouble_10) loc.value_;
      double y = right_.EvalDouble(env);
      loc.value_ = Binary_10.DoubleOp(x.d_, op_, y);
      return loc.value_.CopyRef();
    } else {
      Debug.Assert(false);
      return null;
    }
  }

  public override string Emit() {
    return String.Format("{0} {1}= {2}", left_.Emit(), (char) op_, right_.Emit());
  }
}

class Take_10 : Expression_10 {
  LValue_10 ^exp_;
  Owning_10 type_;

  public Take_10(LValue_10 ^exp) { exp_ = exp; }

  public override GType_10 Check(Context_10 ctx) {
    GType_10 t = exp_.Check(ctx);
    if (t == null)
      return null;
    type_ = exp_.StorageType() as Owning_10;
    if (type_ == null) {
      Error("take must be applied to owning pointer");
      return null;
    }
    exp_.LoseOwnership();
    ctx.AddTemporary(this);
    return type_;
  }

  public override GType_10 TemporaryType() { return type_; }

  public override RValue_10 ^Eval(Env_10 env) {
    RValue_10 ^v = exp_.Eval(env);
    exp_.EvalSet(env, Null_10.Instance.Copy());
    return v;
  }

  public override string Emit() {
    return Hold(exp_.StorageType(), exp_.Emit());
  }
}

abstract class Statement_10 : Node_10 {
  public abstract bool Check(Context_10 ctx);
  public abstract RValue_10 ^Eval(Env_10 env);

  public abstract void Emit(SourceWriter_10 w);

  public virtual void EmitEmbedded(SourceWriter_10 w) {
    w.WriteLine("");
    w.AddIndent();
    w.Indent();
    Emit(w);
    w.SubIndent();
  }

  public virtual void EmitInExistingBlock(SourceWriter_10 w) {
    w.Indent();
    Emit(w);
  }
}

class StatementList_10 {
  public readonly ArrayList /* of Statement_10 */ ^statements_ = new ArrayList();

  public void Add(Statement_10 ^s) { statements_.Add(s); }

  public bool Check(Context_10 ctx) {
    bool ok = true;
    foreach (Statement_10 s in statements_)
      ok &= s.Check(ctx);
    return ok;
  }

  public RValue_10 ^Eval(Env_10 env) {
    foreach (Statement_10 s in statements_) {
      RValue_10 ^v = s.Eval(env);
      if (v != null)
        return v;
    }
    return null;
  }

  public void Emit(SourceWriter_10 w) {
    foreach (Statement_10 s in statements_) {
      w.Indent();
      s.Emit(w);
    }
  }
}

class EmptyStatement_10 : InlineStatement_10 {
  public EmptyStatement_10() { }

  public override bool Check(Context_10 ctx) { return true; }
  public override RValue_10 ^Eval(Env_10 env) { return null; }
  public override void EmitInline(SourceWriter_10 w) { }

  public static readonly EmptyStatement_10 ^instance_ = new EmptyStatement_10();
}

// A Scoped_10 is a statement defining one or more local variables.  If_10 a Scoped_10 appears in the
// control graph, then it destroys those variables when traversed.
abstract class Scoped_10 : Statement_10 {
  protected Local_10 start_;   // the first local outside this statement
  protected Local_10 top_;     // the top local defined inside this statement

  TypeSet_10 ^destroys_;

  protected void SetStartVar(Context_10 ctx) { start_ = top_ = ctx.var_; }
  protected void SetTopVar(Context_10 ctx) { top_ = ctx.var_; }

  public Local_10 GetStart() { return start_; }
  public Local_10 GetTop() { return top_; }

  public override TypeSet_10 NodeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_10();
    for (Local_10 l = top_; l != start_; l = l.next_)
        destroys_.Add(l.Type().VarDestroys());
    }
    return destroys_;
  }
}

class Block_10 : Scoped_10 {
  public readonly StatementList_10 ^list_;

  public Block_10(StatementList_10 ^list) { list_ = list; }

  public bool Absent() { return list_ == null; }

  public override bool Check(Context_10 ctx) {
    Context_10 ^ctx1 = new Context_10(ctx);   // don't pass declarations outside block
    SetStartVar(ctx1);

    if (!list_.Check(ctx1))
      return false;

    SetTopVar(ctx1);

    // Add this Block_10 to the control graph; this represents the destruction of variables
    // within the block at block exit.
    AddControl(ctx1);

    return true;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    return list_.Eval(new Env_10(env));
  }

  public static Block_10 ^EmptyBlock() { return new Block_10(new StatementList_10()); }

  public override void Emit(SourceWriter_10 w) {
    w.OpenBrace();
    list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitEmbedded(SourceWriter_10 w) {
    w.Write(" ");
    Emit(w);
  }

  public override void EmitInExistingBlock(SourceWriter_10 w) {
    list_.Emit(w);
  }
}

class MemberKind_10 {
  public const int
    Field_10 = 0,
    Method_10 = 1,
    Property_10 = 2,
    Indexer_10 = 3,
    Constructor_10 = 4;
}

class Named_10 : Node_10 {
  public readonly TypeExpr_10 ^type_expr_;   // may be null for certain objects such as constructors
  protected GType_10 type_;

  public readonly string name_;

  public Named_10(TypeExpr_10 ^type_expr, string name) {
    type_expr_ = type_expr;
    name_ = name;
  }

  public GType_10 Type() { return type_; }

  public virtual bool Resolve(Program_10 program) {
    if (type_expr_ == null || type_ != null)
      return true;
    type_ = type_expr_.Resolve(program);
    return type_ != null;
  }
}

abstract class Member_10 : Named_10 {
  protected Class_10 class_;    // containing class

  public readonly int attributes_;

  protected Member_10(int attributes, TypeExpr_10 ^type_expr, string name) : base(type_expr, name) {
    attributes_ = attributes;
  }

  public abstract int Kind();

  public static string ToString(int kind) {
    switch (kind) {
      case MemberKind_10.Field_10: return "field";
      case MemberKind_10.Method_10: return "method";
      case MemberKind_10.Property_10: return "property";
      case MemberKind_10.Indexer_10: return "indexer";
      case MemberKind_10.Constructor_10: return "constructor";
      default: Debug.Assert(false); return null;
    }
  }

  public string KindString() { return ToString(Kind()); }

  protected abstract int ValidAttributes();

  public Class_10 GetClass() { return class_; }
  public void SetClass(Class_10 cl) { class_ = cl; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public bool IsOverride() { return HasAttribute(Attribute_10.Override); }

  public bool IsProtected() { return HasAttribute(Attribute_10.Protected); }

  public bool IsPublic() { return HasAttribute(Attribute_10.Public); }

  public bool IsPrivate() { return !HasAttribute(Attribute_10.Public | Attribute_10.Protected); }

  public bool IsVirtual() {
    return HasAttribute(Attribute_10.Virtual | Attribute_10.Abstract | Attribute_10.Override);
  }

  static ArrayList ^empty_ = new ArrayList();

  public virtual ArrayList /* of Parameter_10 */ Parameters() { return empty_; }

  public Parameter_10 Param(int i) {
    return (Parameter_10) Parameters()[i];
  }

  public bool IsAccessible(Class_10 from_class, GType_10 through_type, bool through_base) {
    if (IsPublic())
      return true;

    // In GEL2 (as in C# and C++), a class [from_class] can access a protected member of
    // a class C only if [from_class] is a subtype of C and the access is
    // through a subtype of [from_class].  See e.g. C# 3.5.3 "Protected Access for Instance Members".
    if (IsProtected())
      return through_base || from_class.IsSubtype(class_) && through_type.IsSubtype(from_class);

    // default private access
    return from_class == class_;
  }

  public static bool MatchKind(int kind1, int kind2) {
    return kind1 == kind2 ||
           kind1 == MemberKind_10.Field_10 && kind2 == MemberKind_10.Property_10 ||
           kind1 == MemberKind_10.Property_10 && kind2 == MemberKind_10.Field_10;
  }

  public bool MatchSignature(Member_10 m) {
    if (!MatchKind(Kind(), m.Kind()))
      return false;

    if (name_ != m.name_ || Parameters().Count != m.Parameters().Count)
      return false;

    int i = 0;
    foreach (Parameter_10 p in m.Parameters()) {
      Parameter_10 q = Param(i);
      if (!p.Match(q))
        return false;
      ++i;
    }
    return true;
  }

  public bool IsApplicable(ArrayList arguments, out int mismatches) {
    mismatches = 0;
    if (Parameters().Count != arguments.Count)
      return false;
    int i = 0;
    foreach (Argument_10 a in arguments) {
      if (!Param(i).CanReceive(a))
        ++mismatches;
      ++i;
    }
    return true;
  }

  public void ReportMismatches(Syntax_10 caller, ArrayList arguments) {
    Debug.Assert(Parameters().Count == arguments.Count);
    int i = 0;
    foreach (Argument_10 a in arguments) {
      Parameter_10 p = Param(i);
      if (!p.CanReceive(a))
        caller.Error("argument {0}: can't convert from {1} to {2}", i + 1, a.TypeString(), p.TypeString());
      ++i;
    }
  }

  protected virtual void AddOverride(Member_10 m) { }

  bool CheckOverride(Context_10 ctx) {
    Class_10 parent = ctx.class_.Parent();
    Member_10 m = parent != null ? parent.FindMatchingMember(this, false) : null;
    if (m != null) {
      if (this is Field_10) {
        Error("can't define field with same name as field/property in superclass");
        return false;
      }
      if (m is Field_10) {
        Error("can't define property with same name as field in superclass");
        return false;
      }
      if (!HasAttribute(Attribute_10.Override)) {
        Error("must use override keyword to override superclass {0}", KindString());
        return false;
      }
      if (HasAttribute(Attribute_10.Virtual)) {
        Error("{0} with override or abstract keyword cannot be marked virtual", KindString());
        return false;
      }
      if (!m.IsVirtual()) {
        Error("attempting to override non-virtual {0}", KindString());
        return false;
      }
      if (!m.Type().Equals(Type())) {
        Error("can't override {0} with different return type", KindString());
        return false;
      }
      if (m.IsPublic() != IsPublic()) {
        Error("override {0} must have same accessibility as {0} it overrides", KindString());
        return false;
      }
      m.AddOverride(this);
    } else if (HasAttribute(Attribute_10.Override)) {
      Error("can't find {0} to override", KindString());
      return false;
    }
    return true;
  }

  bool CheckAccessibility() {
    int n = 0;
    if ((attributes_ & Attribute_10.Private) != 0)
      ++n;
    if ((attributes_ & Attribute_10.Protected) != 0)
      ++n;
    if ((attributes_ & Attribute_10.Public) != 0)
      ++n;
    if (n > 1) {
      Error("only one access level (private, protected, public) may be specified");
      return false;
    }

    if (IsVirtual() && IsPrivate()) {
      Error("a virtual or abstract {0} may not be private", KindString());
      return false;
    }

    return true;
  }

  public virtual bool Check(Context_10 ctx) {
    if (!AttributeUtil_10.CheckOnly(attributes_, ValidAttributes())) {
      Error("illegal {0} attribute", KindString());
      return false;
    }

    if (HasAttribute(Attribute_10.Abstract) && !ctx.class_.HasAttribute(Attribute_10.Abstract)) {
      Error("an abstract {0} can be defined only in an abstract class", KindString());
      return false;
    }

    if (name_ == class_.name_ && !(this is Constructor_10)) {
      Error("{0} cannot have same name as enclosing class", KindString());
      return false;
    }

    if (class_.GetMatchingMember(this) != this) {
      Error("{0} {1} appears twice in same class", KindString(), name_ != null ? name_ : "");
      return false;
    }

    return CheckOverride(ctx) && CheckAccessibility();
  }
}

// a member which represents a storage location: a field, property, or indexer
abstract class LMember_10 : Member_10 {
  protected LMember_10(int attributes, TypeExpr_10 ^type_expr, string name)
    : base(attributes, type_expr, name) { }

  public bool IsConstOrStatic() {
    return HasAttribute(Attribute_10.Const | Attribute_10.Static);
  }

  protected bool CheckStatic(Syntax_10 caller, bool static_ok, bool instance_ok) {
    if (!static_ok && IsConstOrStatic()) {
      caller.Error("{0} {1} is static", KindString(), name_);
      return false;
    }
    if (!instance_ok && !IsConstOrStatic()) {
      caller.Error("{0} {1} is not static", KindString(), name_);
      return false;
    }
    return true;
  }

  public abstract bool CheckAssigning(Syntax_10 caller, Context_10 ctx, bool assigning);

  public bool CheckAccess(Syntax_10 caller, Context_10 ctx, bool assigning, bool static_ok, bool instance_ok) {
    return CheckStatic(caller, static_ok, instance_ok) && CheckAssigning(caller, ctx, assigning);
  }

  public abstract Location_10 GetLocation(GObject_10 obj);

  // These methods are for fields and properties; indexers have their own versions which take
  // an extra index argument.
  public virtual RValue_10 ^Get(GValue_10 obj) { Debug.Assert(false); return null; }
  public virtual RValue_10 ^Take_10(GValue_10 obj) { Debug.Assert(false); return null; }
  public virtual void Set(GObject_10 obj, RValue_10 ^val)  { Debug.Assert(false); }

  public virtual string Emit()  { Debug.Assert(false); return null; }
  public virtual string EmitSet(string val)  { Debug.Assert(false); return null; }
}

class Field_10 : LMember_10 {
  protected Expression_10 ^initializer_;    // or null if none
  protected GType_10 initializer_type_;

  public Field_10(int attributes, TypeExpr_10 ^type_expr, string name, Expression_10 ^initializer)
  : base(attributes, type_expr, name) {
    initializer_ = initializer;
  }

  // Create a field for an internal class.  Such fields will never be type checked.
  public Field_10(GType_10 type, string name) : this(Attribute_10.Public | Attribute_10.ReadOnly, null, name, null) {
    type_ = type;
  }

  public static Field_10 ^New_10(int attributes, TypeExpr_10 ^type_expr, string name, Expression_10 ^initializer) {
    if ((attributes & Attribute_10.Static) != 0)
      return new StaticField_10(attributes, type_expr, name, initializer);
    if ((attributes & Attribute_10.Const) != 0)
      return new ConstField_10(attributes, type_expr, name, initializer);
    return new Field_10(attributes, type_expr, name, initializer);
  }

  public override int Kind() { return MemberKind_10.Field_10; }

  public Expression_10 Initializer() { return initializer_; }

  protected virtual bool CheckInitializer(Context_10 ctx) {
    if (initializer_ == null)
      return true;

    ctx.EnterExpression();
    initializer_type_ = initializer_.Check(ctx);
    bool b = initializer_type_ != null &&
             Assign_10.CheckAssign(this, type_, initializer_, initializer_type_);
    ctx.FinishExpression();
    return b;
  }

  protected override int ValidAttributes() {
    return Attribute_10.Const | Attribute_10.Private | Attribute_10.Protected | Attribute_10.Public |
           Attribute_10.ReadOnly | Attribute_10.Static;
  }

  public override bool Check(Context_10 ctx) {
    if (!base.Check(ctx))
      return false;

    // We build up a small control graph even when checking field initializers; we do this
    // since expression-checking code uses the graph to determine when temporary
    // ref counts are needed.
    prev_ = unreachable_;
    ctx.SetPrev(this);

    bool b = CheckInitializer(ctx);

    ctx.ClearPrev();
    return b;
  }

  public override bool CheckAssigning(Syntax_10 caller, Context_10 ctx, bool assigning) {
    if (assigning) {
      if (HasAttribute(Attribute_10.Const)) {
        caller.Error("can't assign to const field");
        return false;
      }
      if (HasAttribute(Attribute_10.ReadOnly) &&
          (ctx.class_ != class_ || !(ctx.method_ is Constructor_10)) ) {
        caller.Error("readonly field {0} can only be assigned in constructor", name_);
        return false;
      }
    }
    return true;
  }

  public override RValue_10 ^Get(GValue_10 obj) { return obj.Get(this); }
  public override RValue_10 ^Take_10(GValue_10 obj) { return obj.Take_10(this); }
  public override void Set(GObject_10 obj, RValue_10 ^val) { obj.Set(this, val); }
  public override Location_10 GetLocation(GObject_10 obj) { return obj.GetLocation(this); }

  protected void WriteField(SourceWriter_10 w, bool declaration) {
    w.Indent();
    if (declaration && IsConstOrStatic())
      w.Write("static ");
    w.Write("{0} ", type_.EmitType());
    if (this is ConstField_10)
      w.Write("const ");
    if (!declaration)
      w.Write("{0}::", class_.name_);
    w.Write(name_);
  }

  protected void WriteDeclaration(SourceWriter_10 w) { WriteField(w, true); }
  protected void WriteDefinition(SourceWriter_10 w) { WriteField(w, false); }

  public virtual void EmitDeclaration(SourceWriter_10 w) {
    WriteDeclaration(w);
    w.WriteLine(";");
  }

  public void EmitInitializer(SourceWriter_10 w) {
    w.IWrite("{0} = ", name_);
    if (initializer_ != null)
      w.Write(initializer_.Emit(initializer_type_, type_));
    else w.Write(type_.DefaultValue_10().Emit());
    w.WriteLine(";");
  }

  public virtual void Emit(SourceWriter_10 w) { }

  public override string Emit() { return name_; }

  public override string EmitSet(string val) {
    return String.Format("{0} = {1}", name_, val);
  }
}

class StaticField_10 : Field_10 {
  protected Location_10 ^loc_;

  public StaticField_10(int attributes, TypeExpr_10 ^type_expr, string name, Expression_10 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_10 ctx) {
    if (!base.Check(ctx))
      return false;
    loc_ = new Location_10(Type().DefaultValue_10().Copy());
    return true;
  }

  protected override bool CheckInitializer(Context_10 ctx) {
    ArrayInitializer_10 ai = initializer_ as ArrayInitializer_10;
    if (ai != null) {
      GType_10 type = type_;
      Owning_10 o = type as Owning_10;
      type = (o != null) ? o.BaseType() : null;
      ArrayType_10 at = type as ArrayType_10;
      if (at == null) {
        Error("only owning arrays may have initializers");
        return false;
      }
      return ai.CheckElements(ctx, at.ElementType());
    }

    return base.CheckInitializer(ctx);
  }

  public virtual void Init() {
    ArrayInitializer_10 ai = initializer_ as ArrayInitializer_10;
    if (ai != null)
      loc_.value_ = ai.Eval((ArrayType_10) type_.BaseType());
    else if (initializer_ != null)
      loc_.value_ = initializer_.Eval(Env_10.static_, type_);
  }

  public override RValue_10 ^Get(GValue_10 obj) { return loc_.Get().CopyRef(); }
  public override RValue_10 ^Take_10(GValue_10 obj) { return take loc_.value_; }
  public override void Set(GObject_10 obj, RValue_10 ^val) { loc_.value_ = val; }
  public override Location_10 GetLocation(GObject_10 obj) { return loc_; }

  public override void Emit(SourceWriter_10 w) {
    ArrayInitializer_10 ai = initializer_ as ArrayInitializer_10;
    if (ai != null) {
      GType_10 element_type = ((ArrayType_10) type_.BaseType()).ElementType();
      string varname = String.Format("_{0}_{1}", class_.name_, name_);
      w.Write("{0} {1}[] = ", element_type.EmitGenericType(), varname);
      ai.Emit(w);
      w.WriteLine(";");
      WriteDefinition(w);
      w.Write("(new {0}", GType_10.ConstructType("_StaticArray", element_type.EmitGenericType()));
      w.Write("(&typeid({0}), {1}, {2}))", element_type.EmitType(), ai.initializers_.Count, varname);
    } else {
      WriteDefinition(w);
      if (initializer_ != null)
        initializer_.EmitAsInitializer(w, initializer_type_, type_);
    }
    w.WriteLine(";");
    w.WriteLine("");
  }
}

class ConstField_10 : Field_10 {
  protected SimpleValue_10 ^value_;

  public ConstField_10(int attributes, TypeExpr_10 ^type_expr, string name, Expression_10 ^initializer)
    : base(attributes, type_expr, name, initializer) { }

  public override bool Check(Context_10 ctx) {
    if (!base.Check(ctx))
      return false;
    return initializer_.CheckConstant();
  }

  SimpleValue_10 ^Get() {
    if (value_ == DefaultValue_10.instance_) {
      Error("circular dependency among constant fields");
      Gel_10.Exit();
    }
    if (value_ == null) {
      value_ = new DefaultValue_10();    // marker used to catch circular const references
      value_ = (SimpleValue_10)initializer_.Eval(Env_10.static_, type_);
    }
    return value_.Copy();
  }

  public override RValue_10 ^Get(GValue_10 obj) {
    return Get();
  }

  public override void Set(GObject_10 obj, RValue_10 ^val) { Debug.Assert(false); }
  public override Location_10 GetLocation(GObject_10 obj) { Debug.Assert(false); return null; }

  public override void EmitDeclaration(SourceWriter_10 w) {
    WriteDeclaration(w);
    if (type_ is IntegralType_10)
      w.Write(" = {0}", Get().Emit());
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_10 w) {
    WriteDefinition(w);
    if (!(type_ is IntegralType_10)) {
      w.WriteLine(" = {0};", Get().Emit());
    }
    w.WriteLine(";");
  }
}

class ExpressionTraverser_10 : Traverser_10 {
  readonly Control_10 start_;
  Local_10 local_;
  GType_10 type_;
  bool assign_;
  bool destroy_;

  public ExpressionTraverser_10(Control_10 start, Local_10 local, GType_10 type) {
    start_ = start; local_ = local; type_ = type;
  }

  public override int Handle(Control_10 control) {
    if (control == start_)
      return Cut;
    Node_10 node = control as Node_10;
    if (node != null) {
      if (!destroy_ && node.CanDestroy(type_))
        destroy_ = true;
      else if (local_ != null && node.Sets(local_))
        assign_ = true;
    }
    return Continue_10;
  }

  // Return_10 true if the given expression needs a reference count while we evaluate
  // the control graph nodes between [start] and [end].
  // A local variable needs a ref count if it is assigned to and the object
  // the variable previously pointed to might possibly be destroyed.
  // Any other expression needs a ref count if the object it evaluates to
  // might possibly be destroyed.
  public static bool NeedRef(Control_10 start, Control_10 end, Expression_10 expr, GType_10 type) {
    Debug.Assert(start != null && end != null);
    if (start == end || !type.IsOwned() || expr is This_10 || expr is Base_10)
      return false;
    Local_10 local = expr.GetLocal();
    ExpressionTraverser_10 ^et = new ExpressionTraverser_10(start, local, type);
    end.Traverse(et, Control_10.GetMarkerValue());
    return et.destroy_ && (local == null || et.assign_);
  }
}

abstract class LocalHandler_10 {
  public abstract bool Handle(Local_10 local, Node_10 node, Name_10 use);
}

class LocalChecker_10 : LocalHandler_10 {
  public override bool Handle(Local_10 local, Node_10 node, Name_10 use) {
    if (node == Control_10.unreachable_) {
      if (use != null)
        use.Error("variable {0} may be used before it is assigned a value", use.name_);
      else
        local.Error("out parameter {0} must be assigned before leaving method", local.name_);
      return false;
    }
    if (node.Takes(local)) {
      Name_10 name = (Name_10) node;
      name.Error("can't transfer ownership from {0}: value may be used again", name.name_);
      return false;
    }
    return true;
  }
}

class LocalRefAnalyzer_10 : LocalHandler_10 {
  public override bool Handle(Local_10 local, Node_10 node, Name_10 use) {
    Debug.Assert(node != Control_10.unreachable_);
    if (node.CanDestroy(local.Type())) {
      local.NeedsRef();
      return false;   // abort search
    }
    return true;
  }
}

class LocalTraverser_10 : Traverser_10 {
  readonly Local_10 local_;
  readonly LocalHandler_10 handler_;
  Name_10 use_;

  public LocalTraverser_10(Local_10 local, LocalHandler_10 handler) {
    local_ = local;
    handler_ = handler;
  }

  public void SetUse(Name_10 use) { use_ = use; }

  public override int Handle(Control_10 control) {
    Node_10 node = control as Node_10;
    if (node == null)
      return Continue_10;

    if (node.Sets(local_))
      return Cut;

    return handler_.Handle(local_, node, use_) ? Continue_10 : Abort;
  }
}

class Local_10 : Named_10 {
  protected Expression_10 ^initializer_;    // or null if none
  protected GType_10 initializer_type_;

  public Local_10 next_;    // next variable upward in scope chain

  NonOwningArrayList /* of Name_10 */ ^uses_ = new NonOwningArrayList();    // all uses of this variable

  protected bool mutable_;   // true if this local may ever change after it's first initialized

  protected bool needs_ref_;    // true if this variable needs a reference count in emitted code

  public Expression_10 Initializer() { return initializer_; }

  public void NeedsRef() { needs_ref_ = true; }

  public virtual string Emit() { return name_; }

  // Return_10 true if we represent this local using a smart pointer wrapper (i.e.
  // _Ptr, _Own, _OwnRef or _Ref).
  public virtual bool IsWrapper() {
    return type_ is Owning_10 || type_ == GString_10.type_ || needs_ref_;
  }

  public Local_10(TypeExpr_10 ^type_expr, string name, Expression_10 ^initializer) : base(type_expr, name) {
    initializer_ = initializer;
    next_ = null;
  }

  public bool Check(Context_10 ctx) {
    Local_10 decl = ctx.FindVar(name_);
    if (decl != null) {
      Error("error: variable already defined");
      return false;
    }

    if (initializer_ != null) {
      ctx.EnterExpression();
      initializer_type_ = initializer_.Check(ctx);
      bool ok = initializer_type_ != null &&
                Assign_10.CheckAssign(this, type_, initializer_, initializer_type_);

      // Add this Local_10 to the control graph.  We need to do this before calling
      // FinishExpression since the Local_10 will be initialized before temporaries 
      // are destroyed.
      AddControl(ctx);

      ctx.FinishExpression();
      if (!ok)
        return false;
    }

    next_ = ctx.var_;
    ctx.SetVar(this);

    ctx.method_.AddVar(this);
    return true;
  }

  public override bool Sets(Local_10 local) {
    return this == local && initializer_ != null;
  }

  public virtual GType_10 ReadType() {
    return type_;
  }

  public void AddUse(Name_10 name) {
    uses_.Add(name);
  }

  public void SetMutable() { mutable_ = true; }

  // Traverse the control graph nodes where this local is live, calling the given
  // LocalHandler_10's Handle method on each node.
  public bool Traverse(Method_10 method, LocalHandler_10 h) {
    LocalTraverser_10 ^t = new LocalTraverser_10(this, h);
    int marker = Control_10.GetMarkerValue();
    foreach (Name_10 name in uses_) {
      t.SetUse(name);
      if (!name.prev_.Traverse(t, marker))
        return false;
    }

    Parameter_10 p = this as Parameter_10;
    if (p != null && p.GetMode() == Mode_10.Out) {
      t.SetUse(null);
      if (!method.exit_.Traverse(t, marker))
        return false;
    }
    return true;
  }

  // check variable usage once control flow graph is complete
  public bool CheckUsage(Method_10 method) {
    return Traverse(method, new LocalChecker_10());
  }

  // Determine whether this Local_10 needs a reference count.  This_10 can happen only after
  // we've built up a control graph for all methods.
  public void ComputeRef(Method_10 method) {
    // For_10 now, a variable of type object always needs a reference count since it may
    // contain a string and we don't yet detect string destruction in the graph traversal.
    if (type_ == GObject_10.type_)
      NeedsRef();
    else if (type_.IsOwned())
      Traverse(method, new LocalRefAnalyzer_10());
  }

  public void EvalInit(Env_10 env) {
    env.Add(this, initializer_ != null ? initializer_.Eval(env, type_) : null);
  }

  protected virtual string EmitDeclarationType() {
    return IsWrapper() ? type_.EmitType() : type_.EmitExprType();
  }

  public virtual string EmitDeclarationName() { return name_; }

  public void EmitDeclaration(SourceWriter_10 w) {
    w.Write("{0} {1}", EmitDeclarationType(), EmitDeclarationName());
  }

  public void EmitInitializer(SourceWriter_10 w) {
    if (initializer_ != null)
      initializer_.EmitAsInitializer(w, initializer_type_, type_);
  }
}

class Parameter_10 : Local_10 {
  public Parameter_10(TypeExpr_10 ^type_expr, string name) : base(type_expr, name, null) { }

  // We represent some parameters using both a C++ parameter and a C++ local, which
  // have different types; we call these dual parameters.  For_10 such parameters
  // param_name_ is the C++ parameter name.
  string param_name_;

  public static Parameter_10 ^New_10(int mode, TypeExpr_10 ^type_expr, string name) {
    return mode == 0 ? new Parameter_10(type_expr, name) :
                               new RefOutParameter_10(mode, type_expr, name);
  }

  public virtual int GetMode() { return 0; }
  public string TypeString() { return Mode_10.ToString(GetMode()) + type_.ToString(); }

  public virtual Parameter_10 ^Copy() {
    return new Parameter_10(new TypeLiteral_10(type_), name_);
  }

  public virtual bool CanReceive(Argument_10 a) {
    return a.GetMode() == 0 && a.Type().CanConvert(type_, ConversionContext_10.MethodArg);
  }

  public bool Match(Parameter_10 p) {
    return GetMode() == p.GetMode() && type_.Equals(p.type_);
  }

  public override bool IsWrapper() {
    return type_ is Owning_10 || type_ == GString_10.type_ || mutable_ && needs_ref_;
  }

  public void CheckParameterUsage(Method_10 method) {
    if (type_ is Owning_10 && !(this is RefOutParameter_10)) {
      // We need both a C++ parameter and a C++ local: the parameter type can't be
      // _Own<>, since _Own has no public copy constructor and GCC doesn't allow passing
      // by value when a class's copy constructor is private.
      string n = name_;
      do {
        n = "_" + n;
      } while (method.HasLocal(n));
      param_name_ = n;
    }
  }

  protected override string EmitDeclarationType() {
    // For_10 owning parameters the declaration type is the expression type since we can't
    // pass _Own<> by value.
    return type_ is Owning_10 ? type_.EmitExprType() : base.EmitDeclarationType();
  }

  public override string EmitDeclarationName() {
    return param_name_ != null ? param_name_ : name_;
  }

  public void EmitExtraDeclaration(SourceWriter_10 w) {
    if (param_name_ != null)
      w.IWriteLine("{0} {1}({2});", type_.EmitType(), name_, param_name_);
  }
}

class RefOutParameter_10 : Parameter_10 {
  public readonly int mode_;
  public override int GetMode() { return mode_; }

  public RefOutParameter_10(int mode, TypeExpr_10 ^type_expr, string name) : base(type_expr, name) {
    mode_ = mode;
    mutable_ = true;
  }

  public override Parameter_10 ^Copy() { Debug.Assert(false); return null; }

  public override bool CanReceive(Argument_10 a) {
    if (mode_ != a.GetMode())
      return false;
    RefOutArgument_10 ra = (RefOutArgument_10) a;
    return type_.Equals(ra.StorageType());
  }

  public override GType_10 ReadType() {
    // If_10 a ref parameter has an owning type, we require the user to use the take operator to take
    // ownership of the value, since taking ownership has the visible side effect of clearing the
    // value the ref parameter points to.
    return mode_ == Mode_10.Ref ? type_.BaseType() : type_;
  }

  public override string Emit() {
    return "(*" + name_ + ")";
  }

  protected override string EmitDeclarationType() {
    return type_.EmitType() + " *";
  }
}

abstract class InlineStatement_10 : Statement_10 {
  public abstract void EmitInline(SourceWriter_10 w);

  public override void Emit(SourceWriter_10 w) {
    EmitInline(w);
    w.WriteLine(";");
  }
}

class VariableDeclaration_10 : InlineStatement_10 {
  ArrayList /* of Local_10 */ ^locals_ = new ArrayList();

  public VariableDeclaration_10(TypeExpr_10 ^type_expr, string name, Expression_10 ^initializer) {
    locals_.Add(new Local_10(type_expr, name, initializer));
  }

  public void Add(string name, Expression_10 ^initializer) {
    TypeExpr_10 ^t = ((Local_10) locals_[0]).type_expr_.Copy();
    locals_.Add(new Local_10(t, name, initializer));
  }

  public override bool Check(Context_10 ctx) {
    // local variables are not resolved during the Resolve phase, so we must resolve them here
    foreach (Local_10 l in locals_)
      if (!l.Resolve(ctx.program_) || !l.Check(ctx))
        return false;

    return true;
  }

  // Return_10 the type of all variables in this VariableDeclaration_10.
  public GType_10 Type() { return ((Local_10) locals_[0]).Type(); }

  public override RValue_10 ^Eval(Env_10 env) {
    foreach (Local_10 l in locals_)
      l.EvalInit(env);
    return null;
  }

  void Emit(SourceWriter_10 w, bool in_line) {
    if (in_line)
      Debug.Assert(locals_.Count == 1);

    foreach (Local_10 l in locals_) {
      l.EmitDeclaration(w);
      l.EmitInitializer(w);
      if (!in_line)
        w.WriteLine(";");
    }
  }

  public override void EmitInline(SourceWriter_10 w) { Emit(w, true); }
  public override void Emit(SourceWriter_10 w) { Emit(w, false); }
}

class ExpressionStatement_10 : InlineStatement_10 {
  Expression_10 ^exp_;

  public ExpressionStatement_10(Expression_10 ^e) {
    exp_ = e;
  }

  public override bool Check(Context_10 ctx) {
    if (exp_.CheckTop(ctx) == null)
      return false;
    exp_.SetUnused();
    return true;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    exp_.Eval(env);   // discard expression value
    return null;
  }

  public override void EmitInline(SourceWriter_10 w) {
    w.Write(exp_.Emit());
  }

}

class If_10 : Statement_10 {
  Expression_10 ^condition_;
  Statement_10 ^if_true_;
  Statement_10 ^if_false_;
  Joiner_10 ^join_ = new Joiner_10();

  public If_10(Expression_10 ^condition, Statement_10 ^if_true, Statement_10 ^if_false) {
    condition_ = condition; if_true_ = if_true; if_false_ = if_false;
  }

  public override bool Check(Context_10 ctx) {
    if (!condition_.Check(ctx, GBool_10.type_))
      return false;

    Control_10 c = ctx.Prev();

    if (!if_true_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(c);

    if (if_false_ != null && !if_false_.Check(ctx))
      return false;

    join_.Join(ctx.Prev());
    ctx.SetPrev(join_.Combine());
    return true;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    if (condition_.EvalBool(env))
      return if_true_.Eval(env);
    else
      return if_false_ != null ? if_false_.Eval(env) : null;
  }

  public override void Emit(SourceWriter_10 w) {
    w.Write("if ({0})", condition_.Emit());
    if_true_.EmitEmbedded(w);
    if (if_false_ != null) {
      w.IWrite("else");
      if_false_.EmitEmbedded(w);
    }
  }

}

class DefaultValue_10 : SimpleValue_10 {
  public DefaultValue_10() { }
  public static readonly DefaultValue_10 ^instance_ = new DefaultValue_10();

  public override SimpleValue_10 ^Copy() { Debug.Assert(false); return null; }
  public override GType_10 Type()  { Debug.Assert(false); return null; }
  public override string Emit() { Debug.Assert(false); return null; }
}

// A section in a switch statement.
//
// In GEL2, unlike C# and C++, local variables declared in a switch section are visible only
// in that section.  There doesn't seem to be much point in allowing sections to share locals
// since GEL2 (like C#) doesn't allow control to fall through from one section to the next.  This_10 also
// makes compiling to C++ slightly easier since C++ doesn't allow local variables in switch sections
// other than the last to have initializers (see e.g. C++ Primer, 4th ed., 6.6.5 "Variable Definitions
// inside a switch").

class SwitchSection_10 : Node_10 {
  ArrayList /* of Expression_10 */ ^cases_;     // null represents default:
  public readonly Block_10 ^block_;

  ArrayList /* of GValue_10 */ ^values_ = new ArrayList();

  public SwitchSection_10(ArrayList ^cases, StatementList_10 ^statements) {
    cases_ = cases;
    block_ = new Block_10(statements);
  }

  public bool Check(Context_10 ctx, GType_10 switch_type, OwningHashtable all_values, out bool is_default) {
    is_default = false;
    foreach (Expression_10 e in cases_) {
      GValue_10 ^v;
      if (e == null) {
        is_default = true;
        v = new DefaultValue_10();
      } else {
        if (!e.Check(ctx, switch_type) || !e.CheckConstant())
          return false;
        v = (GValue_10) e.Eval(Env_10.static_, switch_type);
      }
      if (all_values.ContainsKey(v)) {
        Error("switch statement cannot contain the same value twice");
        return false;
      }
      all_values.Set(v, null);
      values_.Add(v);
    }
    return block_.Check(ctx);
  }

  public bool Match(GValue_10 v) {
    foreach (GValue_10 val in values_)
      if (val.Equals(v))
        return true;
    return false;
  }

  public void Emit(SourceWriter_10 w) {
    foreach (Expression_10 c in cases_)
      if (c == null)
        w.IWriteLine("default:");
      else w.IWriteLine("case {0}:", c.Emit());
    w.Indent();
    block_.Emit(w);
  }

  public void EmitString(SourceWriter_10 w) {
    w.IWrite("if (");
    for (int i = 0 ; i < values_.Count ; ++i) {
      if (i > 0) {
        w.WriteLine(" ||");
        w.IWrite("    ");
      }
      w.Write("_s->_Equals({0})", 
              GString_10.EmitStringConst(((GString_10) values_[i]).s_));
    }
    w.Write(") ");
    block_.Emit(w);
  }
}

abstract class Escapable_10 : Scoped_10 {
  public readonly Joiner_10 ^exit_ = new Joiner_10();
}

class Switch_10 : Escapable_10 {
  Expression_10 ^expr_;
  GType_10 type_;
  ArrayList /* of SwitchSection_10 */ ^sections_;
  SwitchSection_10 default_;    // or null if no default section

  public Switch_10(Expression_10 ^expr, ArrayList ^sections) { expr_ = expr; sections_ = sections; }

  public override bool Check(Context_10 ctx) {
    SetStartVar(ctx);
    type_ = expr_.CheckTop(ctx);
    if (type_ == null)
      return false;
    if (type_ != GInt_10.type_ && type_ != GChar_10.type_ && type_ != GString_10.type_) {
      Error("switch expression must be of type int, char or string");
      return false;
    }
    Context_10 ^ctx1 = new Context_10(ctx, this);
    OwningHashtable ^values = new OwningHashtable();
    Control_10 c = ctx1.Prev();
    foreach (SwitchSection_10 s in sections_) {
      bool is_default;
      ctx1.SetPrev(c);
      if (!s.Check(ctx1, type_, values, out is_default))
        return false;
      if (is_default)
        default_ = s;
      if (ctx1.Prev() != unreachable_) {
        s.Error("switch case may not fall through to following case");
        return false;
      }
    }
    if (default_ == null)
      exit_.Join(c);
    ctx1.SetPrev(exit_.Combine());
    return true;
  }

  SwitchSection_10 FindSection(GValue_10 v) {
    foreach (SwitchSection_10 s in sections_)
      if (s.Match(v))
        return s;
    return default_;
  }

  RValue_10 ^CatchBreak(RValue_10 ^v) {
    return v is BreakValue_10 ? null : v;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    RValue_10 ^v = expr_.Eval(env);
    if (v == null)
      return null;
    SwitchSection_10 s = FindSection(v.Get());
    if (s == null)
      return null;
    return CatchBreak(s.block_.Eval(env));
  }

  public override void Emit(SourceWriter_10 w) {
    if (type_ == GString_10.type_) {
      // For_10 now, we implement a switch on strings using a sequence of if statements.  We wrap
      // the sequence in a dummy switch statement so that break statements will work properly.
      // If_10 the switch statement has just a default: label then the Microsoft C++ compiler issues
      // a warning, and if it has just a case 0: label then the compiler doesn't realize that the
      // case will always be executed, which may lead to warnings about not all code paths returning
      // a value.  So we use both default: and case 0:, which seems to work fine.
      w.Write("switch (0) ");
      w.OpenBrace();
      w.IWriteLine("case 0:");
      w.IWriteLine("default:");
      w.IWriteLine("StringPtr _s = {0};", expr_.Emit());
      foreach (SwitchSection_10 s in sections_)
        if (s != default_)
          s.EmitString(w);
      if (default_ != null)
        default_.block_.Emit(w);
      w.CloseBrace();
    } else {
      w.Write("switch ({0}) ", expr_.Emit());
      w.OpenBrace();

      foreach (SwitchSection_10 s in sections_)
        s.Emit(w);

      w.CloseBrace();
    }
  }
}

abstract class Loop_10 : Escapable_10 {
  public readonly Joiner_10 ^loop_ = new Joiner_10();
}

abstract class ForOrWhile_10 : Loop_10 {
  protected Expression_10 ^condition_;
  protected Statement_10 ^statement_;

  protected ForOrWhile_10(Expression_10 ^condition, Statement_10 ^statement) {
    condition_ = condition; statement_ = statement;
  }

  protected abstract InlineStatement_10 Initializer();
  protected abstract InlineStatement_10 Iterator();

  public override bool Check(Context_10 prev_ctx) {
    Context_10 ^ctx = new Context_10(prev_ctx, this);   // initializer may declare new local variable
    SetStartVar(ctx);
    if (!Initializer().Check(ctx))
      return false;
    SetTopVar(ctx);

    loop_.AddControl(ctx);

    if (!condition_.CheckTop(ctx, GBool_10.type_))
      return false;

    if (!condition_.IsTrueLiteral())  // we may exit the loop at this point
      exit_.Join(ctx.Prev());  

    if (!statement_.Check(ctx))
      return false;

    if (!Iterator().Check(ctx))
      return false;

    loop_.Join(ctx.Prev());  // loop back to top

    ctx.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy any local defined in an initializer above.
    AddControl(ctx);

    return true;
  }

  public override RValue_10 ^Eval(Env_10 outer_env) {
    Env_10 ^env = new Env_10(outer_env);   // initializer may declare new local
    for (Initializer().Eval(env); condition_.EvalBool(env); Iterator().Eval(env)) {
      RValue_10 ^v = statement_.Eval(env);
      if (v is BreakValue_10)
        break;
      if (v is ContinueValue_10)
        continue;
      if (v != null)
        return v;
    }
    return null;
  }
}

class While_10 : ForOrWhile_10 {
  public While_10(Expression_10 ^condition, Statement_10 ^statement) : base(condition, statement) { }

  protected override InlineStatement_10 Initializer()  { return EmptyStatement_10.instance_; }
  protected override InlineStatement_10 Iterator()  { return EmptyStatement_10.instance_; }

  public override void Emit(SourceWriter_10 w) {
    w.Write("while ({0})", condition_.Emit());
    statement_.EmitEmbedded(w);
  }
}

class For_10 : ForOrWhile_10 {
  InlineStatement_10 ^initializer_;
  InlineStatement_10 ^iterator_;

  public For_10(InlineStatement_10 ^initializer, Expression_10 ^condition, InlineStatement_10 ^iterator,
             Statement_10 ^statement)
    : base(condition != null ? condition : new Literal_10(new GBool_10(true)),
           statement) {
    initializer_ = initializer != null ? initializer : new EmptyStatement_10();
    iterator_ = iterator != null ? iterator : new EmptyStatement_10();
  }

  protected override InlineStatement_10 Initializer()  { return initializer_; }
  protected override InlineStatement_10 Iterator()  { return iterator_; }

  public override void Emit(SourceWriter_10 w) {
    w.Write("for (");
    initializer_.EmitInline(w);
    w.Write("; {0}; ", condition_.Emit());
    iterator_.EmitInline(w);
    w.Write(")");
    statement_.EmitEmbedded(w);
  }
}

class Do_10 : Loop_10 {
  Statement_10 ^statement_;
  Expression_10 ^condition_;

  Joiner_10 ^join_ = new Joiner_10();

  public Do_10(Statement_10 ^statement, Expression_10 ^condition) {
    statement_ = statement;
    condition_ = condition;
  }

  public override bool Check(Context_10 ctx) {
    join_.AddControl(ctx);

    Context_10 ^ctx1 = new Context_10(ctx, this);
    SetStartVar(ctx);

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx.Prev());  // continue statements jump here
    ctx.SetPrev(loop_.Combine());

    if (!condition_.CheckTop(ctx, GBool_10.type_))
      return false;

    if (!condition_.IsFalseLiteral())
      join_.Join(ctx.Prev());   // loop back to top
    if (!condition_.IsTrueLiteral())
      exit_.Join(ctx.Prev());   // fall through to exit
    ctx.SetPrev(exit_.Combine());

    return true;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    do {
      RValue_10 ^v = statement_.Eval(env);
      if (v is BreakValue_10)
        break;
      if (v is ContinueValue_10)
        continue;
      if (v != null)
        return v;
    } while (condition_.EvalBool(env));
    return null;
  }

  public override void Emit(SourceWriter_10 w) {
    w.IWrite("do");
    statement_.EmitEmbedded(w);
    w.IWriteLine("while ({0});", condition_.Emit());
  }
}

// A helper class for ForEach_10: a node defining a single variable in the control graph.
class Definer_10 : Node_10 {
  Local_10 local_;

  public Definer_10(Local_10 local) { local_ = local; }

  public override bool Sets(Local_10 local) {
    return local_ == local;
  }
}

class ForEach_10 : Loop_10 {
  Local_10 ^local_;
  Expression_10 ^expr_;
  GType_10 expr_type_;
  Statement_10 ^statement_;

  Property_10 count_;
  Indexer_10 indexer_;

  Definer_10 ^definer_;

  public ForEach_10(TypeExpr_10 ^type_expr, string name, Expression_10 ^expr, Statement_10 ^statement) {
    local_ = new Local_10(type_expr, name, null);
    expr_ = expr;
    statement_ = statement;
  }

  public override bool Check(Context_10 ctx) {
    if (!local_.Resolve(ctx.program_))
      return false;

    expr_type_ = expr_.CheckTop(ctx);
    if (expr_type_ == null)
      return false;

    count_ = expr_type_.Lookup(this, ctx.class_, false, MemberKind_10.Property_10, "Count", null, false) as Property_10;
    if (count_ == null) {
      Error("object enumerable by foreach must have an accessible property Count");
      return false;
    }
    if (count_.Type() != GInt_10.type_) {
      Error("object enumerable by foreach must have a property Count of type int");
      return false;
    }

    ArrayList ^args = new ArrayList();
    args.Add(new InArgument_10(GInt_10.type_));
    indexer_ = (Indexer_10) expr_type_.Lookup(this, ctx.class_, false, MemberKind_10.Indexer_10, null, args, false);
    if (indexer_ == null) {
      Error("object enumerable by foreach must have an accessible indexer on integers");
      return false;
    }
    if (!indexer_.CheckAssigning(this, ctx, false))
      return false;

    GType_10 indexer_type = indexer_.Type();
    GType_10 iterator_type = local_.Type();
    if (!indexer_type.CanConvertExplicit(iterator_type, false)) {
      Error("enumeration type {0} is not explicitly convertible to iteration variable type {1}",
        indexer_type, iterator_type);
      return false;
    }

    Context_10 ^ctx1 = new Context_10(ctx, this);

    SetStartVar(ctx1);
    if (!local_.Check(ctx1))   // will add local to scope chain
      return false;
    SetTopVar(ctx1);

    // Add a control graph node representing the creation of the local above.
    definer_ = new Definer_10(local_);
    definer_.AddControl(ctx1);

    loop_.AddControl(ctx1);   // continue statements jump here

    if (!statement_.Check(ctx1))
      return false;

    loop_.Join(ctx1.Prev());   // loop back to top

    exit_.Join(loop_);  // any loop iteration may exit

    ctx1.SetPrev(exit_.Combine());

    // Add this node to the control graph to destroy the local variable created above.
    AddControl(ctx1);

    return true;
  }

  public override RValue_10 ^Eval(Env_10 outer_env) {
    RValue_10 ^r = expr_.Eval(outer_env);
    GValue_10 e = r.Get();
    if (e is Null_10) {
      Error("foreach: can't iterate over null object");
      Gel_10.Exit();
    }

    int count = ((GInt_10) count_.Get(e)).i_;

    Env_10 ^env = new Env_10(outer_env);
    env.Add(local_, null);
    for (int i = 0 ; i < count ; ++i) {
      RValue_10 ^v = indexer_.Get(e, new GInt_10(i));
      env.Set(local_, v.Get().ConvertExplicit(ref v, local_.Type()));
      RValue_10 ^s = statement_.Eval(env);
      if (s is BreakValue_10)
        break;
      if (s is ContinueValue_10)
        continue;
      if (s != null)
        return s;
    }
    return null;
  }

  public override void Emit(SourceWriter_10 w) {
    w.OpenBrace();
    w.IWriteLine("{0} _collection = {1};", expr_type_.BaseType().EmitType(), expr_.Emit());
    w.IWriteLine("int _count = _collection->get_Count();");
    w.IWrite("for (int _i = 0 ; _i < _count ; ++_i) ");
    w.OpenBrace();
    w.Indent();
    local_.EmitDeclaration(w);
    w.WriteLine(" = {0}; ",
      Expression_10.EmitExplicit(indexer_.Type(), local_.Type(), "_collection->get_Item(_i)", true));
    statement_.EmitInExistingBlock(w);
    w.CloseBrace();
    w.CloseBrace();
  }
}

class BreakValue_10 : GValue_10 {
  public BreakValue_10() { }

  public static readonly BreakValue_10 ^instance_ = new BreakValue_10();

  public override GType_10 Type()  { Debug.Assert(false); return null; }
}

abstract class BreakOrContinue_10 : Scoped_10 {
  protected void Link(Context_10 ctx, Scoped_10 target, Joiner_10 joiner) {
    // When traversed in the control graph, we destroy all variables in the scopes we are exiting,
    // excluding variables defined in the containing Escapable_10 or Loop_10.
    start_ = target.GetTop();
    SetTopVar(ctx);

    prev_ = ctx.Prev();
    if (prev_ != unreachable_)
      joiner.Join(this);

    ctx.SetPrev(unreachable_);
  }
}

class Break_10 : BreakOrContinue_10 {
  public override bool Check(Context_10 ctx) {
    Escapable_10 e = ctx.escape_;
    if (e == null) {
      Error("break statement must appear inside a while, do, for, foreach or switch statement");
      return false;
    }
    Link(ctx, e, e.exit_);
    return true;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    return new BreakValue_10();
  }

  public override void Emit(SourceWriter_10 w) {
    w.WriteLine("break;");
  }
}

class ContinueValue_10 : GValue_10 {
  public ContinueValue_10() { }

  public static readonly ContinueValue_10 ^instance_ = new ContinueValue_10();

  public override GType_10 Type()  { Debug.Assert(false); return null; }
}

class Continue_10 : BreakOrContinue_10 {
  public override bool Check(Context_10 ctx) {
    Loop_10 l = ctx.loop_;
    if (l == null) {
      Error("continue statement must appear inside a while, do, for or foreach statement");
      return false;
    }
    Link(ctx, l, l.loop_);
    return true;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    return new ContinueValue_10();
  }

  public override void Emit(SourceWriter_10 w) {
    w.WriteLine("continue;");
  }
}

class Return_10 : Statement_10 {
  Expression_10 ^exp_;    // null if no return value
  GType_10 exp_type_;
  GType_10 type_;

  public Return_10(Expression_10 ^exp) {
    exp_ = exp;
  }

  public override bool Check(Context_10 ctx) {
    if (exp_ == null) {
      if (ctx.method_.ReturnType() != Void_10.type_) {
        Error("error: returning value from function returning void");
        return false;
      }
    } else {
      type_ = ctx.method_.ReturnType();
      ctx.EnterExpression();
      exp_type_ = exp_.CheckAndHold(ctx);
      if (exp_type_ == null ||
          !exp_type_.CheckConvert(this, type_,
            exp_.IsRefOutParameter() ? ConversionContext_10.AssignVar : ConversionContext_10.Other))
        return false;
      exp_.CheckLoseOwnership(exp_type_, type_);
      ctx.FinishExpression();
      exp_.ReleaseRef(ctx);
    }

    ctx.method_.JoinReturn(ctx);
    ctx.SetPrev(unreachable_);
    return true;
  }

  public override RValue_10 ^Eval(Env_10 env) {
    return exp_ != null ? exp_.Eval(env, type_)
                        : Null_10.Instance.Copy();    // an arbitrary value
  }

  public override void Emit(SourceWriter_10 w) {
    if (exp_ != null && exp_.NeedsRef(exp_type_)) {
      // If_10 exp_ needs a reference count, that reference count needs to survive the destruction
      // of temporaries, so we can't simply emit a temporary reference count wrapper.  For_10 example,
      // when compiling the expression "return (new Foo()).Fun();", if Fun() returns a Foo then we
      // need a wrapper, and we can't generate "return _Ptr<Fun>(Foo().Fun()).Get()" since the _Ptr<Fun>
      // wrapper will be destroyed before the temporary Foo() object is destroyed.  So we need to
      // use an extra variable here.
      w.OpenBrace();
      w.IWriteLine("{0} __ret = {1};", exp_type_.EmitType(), exp_.Emit());
      w.IWriteLine("return __ret.Get();");
      w.CloseBrace();
    } else {
      w.Write("return ");
      if (exp_ != null)
        w.Write(exp_.Emit(exp_type_, type_));
      w.WriteLine(";");
    }
  }
}

class Attribute_10 {
  public const int Abstract = 1,
  Const = 2,
  Extern = 4,
  Override = 8,
  Private = 16,
  Protected = 32,
  Public = 64,
  ReadOnly = 128,
  Ref = 256,
  Static = 512,
  Virtual = 1024,
  Setter = 2048;
}

class AttributeUtil_10 {
  public static bool CheckOnly(int a, int allowed) {
    return (a & ~allowed) == 0;
  }
}

class MethodTraverser_10 : Traverser_10 {
  Method_10 method_;

  public MethodTraverser_10(Method_10 method) { method_ = method; }

  public override int Handle(Control_10 control) {
    if (control == Control_10.unreachable_)
      return Cut;

    Node_10 node = control as Node_10;
    if (node != null) {
      Method_10 c = node.Calls();
      if (c != null)
        method_.calls_.Add(c);
      method_.internal_destroys_.Add(node.NodeDestroys());
    }

    return Continue_10;
  }
}

class Method_10 : Member_10 {
  public readonly ArrayList /* of Parameter_10 */ ^parameters_;

  protected Block_10 ^body_;

  public Joiner_10 ^exit_ = new Joiner_10();

  // all parameters and locals defined in this method
  readonly NonOwningArrayList /* of Local_10 */ ^locals_ = new NonOwningArrayList();

  NonOwningArrayList /* of Method_10 */ ^overrides_;   // list of all overrides (virtual methods only)

  // methods called from this method
  public readonly NonOwningArrayList /* of Method_10 */ ^calls_ = new NonOwningArrayList();

  // Types destroyed inside this method, not including types destroyed through
  // calls to other methods.
  public readonly TypeSet_10 ^internal_destroys_ = new TypeSet_10();

  // Types destroyed inside this method or in any methods called by this method.
  TypeSet_10 ^destroys_;

  TypeSet_10 ^parameter_destroys_;

  // A marker used when performing a depth-first search of the method graph to compute destroys_.
  int method_marker_;

  public Method_10(int attributes, TypeExpr_10 ^return_type_expr,
                string name, ArrayList /* of Parameter_10 */ ^parameters, Block_10 ^body)
    : base(attributes, return_type_expr, name) {
    parameters_ = parameters;
    body_ = body;
  }

  public override int Kind() { return MemberKind_10.Method_10; }

  public GType_10 ReturnType() { return type_; }

  public override ArrayList Parameters() {
    return parameters_;
  }

  public bool IsExtern() { return class_.IsExtern(); }

  public bool IsStatic() {
    return HasAttribute(Attribute_10.Static);
  }

  public override bool Resolve(Program_10 program) {
    if (!base.Resolve(program))
      return false;
    foreach (Parameter_10 p in parameters_)
      if (!p.Resolve(program))
        return false;
    return true;
  }

  public void AddVar(Local_10 v) {
    locals_.Add(v);
  }

  public override bool Sets(Local_10 local) {
    foreach (Parameter_10 p in parameters_)
      if (p == local && p.GetMode() != Mode_10.Out)
        return true;
    return false;
  }

  public void JoinReturn(Context_10 ctx) {
    exit_.Join(ctx.Prev());
  }

  public const int kValidAttributes =
    Attribute_10.Abstract | Attribute_10.Override |
    Attribute_10.Private | Attribute_10.Protected | Attribute_10.Public |
    Attribute_10.Static | Attribute_10.Virtual | Attribute_10.Setter;

  protected override int ValidAttributes() {
    return kValidAttributes;
  }

  // overridden by Constructor_10 subclass
  protected virtual bool CheckEntry(Context_10 ctx) { return true; }

  // overridden by Constructor_10 subclass
  public override bool Check(Context_10 prev_ctx) {
    if (!base.Check(prev_ctx))
      return false;

    bool abstract_or_extern = HasAttribute(Attribute_10.Abstract) || IsExtern();

    if (body_.Absent()) {
      if (!abstract_or_extern) {
        Error("a method without a body must be abstract or extern");
        return false;
      }
      return true;
    } 

    if (abstract_or_extern) {
      Error("an abstract or extern method cannot have a body");
      return false;
    }

    Context_10 ^ctx = new Context_10(prev_ctx, this);

    prev_ = unreachable_;
    ctx.SetPrev(this);    // begin the control graph with this Method_10

    foreach (Parameter_10 p in parameters_)
      if (!p.Check(ctx))
        return false;

    if (!CheckEntry(ctx))
      return false;

    if (!body_.Check(ctx))
      return false;

    if (!(this is Constructor_10) && type_ != Void_10.type_ && ctx.Prev() != unreachable_) {
      Error("method must return a value");
      return false;
    }
    JoinReturn(ctx);

    ctx.ClearPrev();  // control graph is complete

    // Traverse the control graph to build calls_ and internal_destroys_.
    MethodTraverser_10 ^mt = new MethodTraverser_10(this);
    exit_.Traverse(mt, Control_10.GetMarkerValue());

    bool ok = true;
    foreach (Local_10 v in locals_)    // for all locals and parameters
      ok &= v.CheckUsage(this);

    foreach (Parameter_10 p in parameters_)
      p.CheckParameterUsage(this);

    return ok;
  }

  // Determine whether each local variable needs a reference count.
  protected void ComputeRefs() {
    foreach (Local_10 v in locals_)
      v.ComputeRef(this);
  }

  // Return_10 true if this method has a local or parameter with the given name.
  public bool HasLocal(string name) {
    foreach (Local_10 l in locals_)
      if (l.name_ == name)
        return true;
    return false;
  }

  public override TypeSet_10 NodeDestroys() {
    if (parameter_destroys_ == null) {
      parameter_destroys_ = new TypeSet_10();
    foreach (Parameter_10 p in parameters_)
        parameter_destroys_.Add(p.Type().VarDestroys());
    }
    return parameter_destroys_;
  }

  protected override void AddOverride(Member_10 m) {
    if (overrides_ == null)
      overrides_ = new NonOwningArrayList();
    overrides_.Add((Method_10) m);
  }

  bool Visit(int marker, TypeSet_10 set) {
    if (method_marker_ == marker)
      return true;

    method_marker_ = marker;
    set.Add(internal_destroys_);
    if (set.IsObject())
      return false;   // we already have object; no point in traversing further

    foreach (Method_10 m in calls_)
      if (!m.Visit(marker, set))
        return false;

    if (overrides_ != null)
      foreach (Method_10 m in overrides_)
        if (!m.Visit(marker, set))
          return false;

    return true;
  }

  public TypeSet_10 Destroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_10();
      Visit(Control_10.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  // overridden by Constructor_10 subclass
  public virtual RValue_10 ^Eval(Env_10 env) {
    return body_.Eval(env);
  }

  public RValue_10 ^Invoke(GValue_10 obj, ArrayList /* of ValueOrLocation_10 */ values) {
    if (body_.Absent()) { // an external method
      ValueList_10 ^list = new ValueList_10(values);
      if (IsStatic())
        return class_.InvokeStatic(this, list);   // let the class handle it
      return obj.Invoke(this, list);   // let the object handle it
    }

    Env_10 ^env = new Env_10(obj);
    Debug.Assert(values.Count == parameters_.Count);
    for (int i = 0 ; i < values.Count ; ++i)
      env.Add((Parameter_10) parameters_[i], (ValueOrLocation_10) values.Take(i));

    return Eval(env);
  }

  protected void EmitParameterNames(SourceWriter_10 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      w.Write(Param(i).EmitDeclarationName());
    }
    w.Write(")");
  }

  protected void EmitParameters(SourceWriter_10 w) {
    w.Write("(");
    for (int i = 0; i < parameters_.Count; ++i) {
      if (i > 0)
        w.Write(", ");
      Param(i).EmitDeclaration(w);
    }
    w.Write(") ");
  }

  void EmitAttributes(SourceWriter_10 w, bool declaration) {
    w.Indent();
    if (!IsStatic() && !IsVirtual())
      return;

    if (!declaration)
      w.Write("/* ");
    if (IsStatic())
      w.Write("static ");
    if (IsVirtual())
      w.Write("virtual ");
    if (!declaration)
      w.Write("*/ ");
  }

  void EmitSignature(SourceWriter_10 w, bool declaration) {
    EmitAttributes(w, declaration);
    w.Write("{0} ", type_.EmitReturnType());
    if (!declaration)
      w.Write("{0}::", class_.name_);
    if (HasAttribute(Attribute_10.Setter))
      w.Write("_");
    w.Write(name_);
    EmitParameters(w);
  }

  public virtual void EmitDeclaration(SourceWriter_10 w) {
    ComputeRefs();
    EmitSignature(w, true);
    if (body_.Absent())
      w.Write("= 0");
    w.WriteLine(";");

    if (HasAttribute(Attribute_10.Setter)) {
      w.WriteLine("");
      EmitAttributes(w, true);
      w.Write("{0} ", Param(parameters_.Count - 1).Type().EmitType());
      w.Write(name_);
      EmitParameters(w);
      w.OpenBrace();
      w.IWrite("_{0}", name_);
      EmitParameterNames(w);
      w.WriteLine(";");
      w.IWriteLine("return value;");
      w.CloseBrace();
    }
  }

  protected void EmitExtraDeclarations(SourceWriter_10 w) {
    foreach (Parameter_10 p in parameters_)
      p.EmitExtraDeclaration(w);
  }

  public virtual void Emit(SourceWriter_10 w) {
    if (!body_.Absent()) {
      EmitSignature(w, false);
      w.OpenBrace();
      EmitExtraDeclarations(w);
      body_.list_.Emit(w);
      w.CloseBrace();
      w.WriteLine("");
    }
    if (Gel_10.print_type_sets_)
      Console.WriteLine("{0}.{1}: {2}", class_.name_, name_, Destroys());
  }
}

class Constructor_10 : Method_10 {
  bool call_base_;
  ArrayList /* of Argument_10 */ ^initializer_params_;

  Constructor_10 initializer_;

  bool invoked_;  // true if another constructor invokes this one using : base() or : this()

  public Constructor_10(int attributes, string name, ArrayList ^parameters,
                     bool call_base, ArrayList ^initializer_params, Block_10 ^body)
    : base(attributes, null, name, parameters, body) {
    call_base_ = call_base;
    initializer_params_ = initializer_params;
  }

  public Constructor_10(int attributes, string name, ArrayList ^parameters, Block_10 ^body)
    : this(attributes, name, parameters, true, new ArrayList(), body) { }

  public override int Kind() { return MemberKind_10.Constructor_10; }

  protected override int ValidAttributes() {
    return Attribute_10.Private | Attribute_10.Protected | Attribute_10.Public;
  }

  public override bool Check(Context_10 ctx) {
    if (name_ != class_.name_) {
      Error("constructor name must match class name");
      return false;
    }
    return base.Check(ctx);
  }

  protected override bool CheckEntry(Context_10 ctx) {
    Class_10 c = call_base_ ? class_.Parent() : class_;
    if (c != null || initializer_params_.Count > 0) {
      initializer_ = (Constructor_10) Invocation_10.CheckInvoke(this, ctx, call_base_, c,
                                      c.name_, initializer_params_, MemberKind_10.Constructor_10);
      if (initializer_ == null)
        return false;
      if (initializer_ == this) {
        Error("constructor initializer invokes itself");
        return false;
      }
      initializer_.invoked_ = true;
    }
    return true;
  }

  // A Constructor_10 node in the control graph represents the call to the base constructor;
  // this node gets added when we call Invocation_10.CheckInvoke() above.
  public override Method_10 Calls() { return initializer_; }

  public override RValue_10 ^Eval(Env_10 env) {
    if (initializer_ == null || initializer_.class_ != class_) {
      // run instance variable initializers
      foreach (Field_10 f in class_.fields_)
        if (!f.IsConstOrStatic() && f.Initializer() != null)
          ((GObject_10) env.this_).Set(f, f.Initializer().Eval(Env_10.static_, f.Type()));
    }
    if (initializer_ != null)
      Invocation_10.CallMethod(env, env.this_, initializer_, initializer_params_, false);
    return body_.Eval(env);
  }

  void EmitInitializerArgs(SourceWriter_10 w) {
    w.WriteLine("({0});", Invocation_10.EmitArguments(initializer_, initializer_params_));
  }

  void EmitConstructorBody(SourceWriter_10 w) {
    w.OpenBrace();
    EmitExtraDeclarations(w);
    if (call_base_) {
      if (class_.constructors_.Count > 1)
        w.IWriteLine("_Init();");
      else class_.EmitInitializers(w);

      Class_10 parent = class_.Parent();
      if (parent != GObject_10.type_) {
        w.IWrite("{0}::_Construct", parent.name_);
        EmitInitializerArgs(w);
      }
    } else {
      w.IWrite("_Construct");
      EmitInitializerArgs(w);
    }

    body_.list_.Emit(w);
    w.CloseBrace();
  }

  public override void EmitDeclaration(SourceWriter_10 w) {
    ComputeRefs();

    // If_10 we're invoked by some other constructor then we need to declare a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void _Construct");
      EmitParameters(w);
      w.WriteLine(";");
    }

    // Now declare the actual C++ constructor.
    w.IWrite(name_);
    EmitParameters(w);
    w.WriteLine(";");
  }

  public override void Emit(SourceWriter_10 w) {
    // If_10 we're invoked by some other constructor then we need to emit a _Construct
    // method which that constructor can call.
    if (invoked_) {
      w.IWrite("void {0}::_Construct", name_);
      EmitParameters(w);
      EmitConstructorBody(w);
      w.WriteLine("");
    }

    // Now emit the actual C++ constructor.
    w.IWrite("{0}::{1}", name_, name_);
    EmitParameters(w);
    Class_10 parent = class_.Parent();
    if (parent != GObject_10.type_)
      w.Write(": {0}((Dummy *) 0) ", parent.name_);

    if (invoked_) {   // call the _Construct method we just generated
      w.Write("{ _Construct");
      EmitParameterNames(w);
      w.WriteLine("; }");
    } else EmitConstructorBody(w);
    w.WriteLine("");
  }
}

abstract class PropertyOrIndexer_10 : LMember_10 {
  // If_10 a get accessor is not declared at all, then get_block_ will be null; if it is
  // declared, but has an empty body ("get;") then get_block_ will be a Block_10 whose list_ is
  // null.  We need to distinguish these cases since for abstract or extern properties the
  // presence of a get accessor with an empty body indicates that a property is readable.
  // (set_block_ works similarly.)
  Block_10 ^get_block_, set_block_;

  protected Method_10 getter_, setter_;

  protected PropertyOrIndexer_10(int attributes, TypeExpr_10 ^type_expr, string name,
                              string id1, Block_10 ^block1, string id2, Block_10 ^block2)
    : base(attributes, type_expr, name) {
    StoreAccessor(id1, block1);
    if (id2 != null)
      StoreAccessor(id2, block2);
    if (id1 == id2)
      Error("can't have two {0} accessors", id1);
  }

  void StoreAccessor(string id, Block_10 ^block) {
    // Note that we don't have scanner tokens GET and SET since these are not keywords in GEL2.
    switch (id) {
      case "get": get_block_ = block; return;
      case "set": set_block_ = block; return;
    }
    Error("expected get or set");
  }

  public Method_10 Getter() { return getter_; }
  public Method_10 Setter() { return setter_; }

  protected abstract string BaseName();

  ArrayList ^CopyParameters() {
    ArrayList ^a = new ArrayList();
    foreach (Parameter_10 p in Parameters())
      a.Add(p.Copy());
    return a;
  }

  public override bool Check(Context_10 ctx) {
    if (!base.Check(ctx))
      return false;

    if (get_block_ != null) {
      Method_10 ^m = new Method_10(attributes_, new TypeLiteral_10(type_), "get_" + BaseName(), CopyParameters(), take get_block_);
      getter_ = m;
      class_.Add(m);
      if (!getter_.Resolve(ctx.program_) || !getter_.Check(ctx))
        return false;
    }

    if (set_block_ != null) {
      ArrayList ^set_params = CopyParameters();
      set_params.Add(new Parameter_10(new TypeLiteral_10(type_), "value"));
      Method_10 ^m = new Method_10(attributes_ | Attribute_10.Setter,
                           new TypeLiteral_10(Void_10.type_), "set_" + BaseName(), set_params, take set_block_);
      setter_ = m;
      class_.Add(m);
      if (!setter_.Resolve(ctx.program_) || !setter_.Check(ctx))
        return false;
    }

    return true;
  }

  public override bool CheckAssigning(Syntax_10 caller, Context_10 ctx, bool assigning) {
    if (assigning && set_block_ == null && setter_ == null) {
      caller.Error("can't assign to read-only {0}", KindString());
      return false;
    }
    if (!assigning && get_block_ == null && getter_ == null) {
      caller.Error("can't read from write-only {0}", KindString());
      return false;
    }
    return true;
  }

  public override Location_10 GetLocation(GObject_10 obj) { Debug.Assert(false); return null; }
}

class Property_10 : PropertyOrIndexer_10 {
  public Property_10(int attributes, TypeExpr_10 ^type_expr, string name,
                  string id1, Block_10 ^block1, string id2, Block_10 ^block2)
    : base(attributes, type_expr, name, id1, block1, id2, block2) { }

  public override int Kind() { return MemberKind_10.Property_10; }

  protected override int ValidAttributes() {
    return Method_10.kValidAttributes;
  }

  protected override string BaseName() { return name_; }

  public override RValue_10 ^Get(GValue_10 obj) {
    return Invocation_10.InvokeMethod(obj, getter_, new ArrayList(), true);
  }

  public override void Set(GObject_10 obj, RValue_10 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(val);
    Invocation_10.InvokeMethod(obj, setter_, a, true);
  }

  public override string Emit() {
    return String.Format("get_{0}()", name_);
  }

  public override string EmitSet(string val) {
    return String.Format("set_{0}({1})", name_, val);
  }
}

class Indexer_10 : PropertyOrIndexer_10 {
  public readonly Parameter_10 parameter_;

  ArrayList /* of Parameter_10 */ ^parameters_;

  public Indexer_10(int attributes, TypeExpr_10 ^type_expr, Parameter_10 ^parameter,
                 string id1, Block_10 ^block1, string id2, Block_10 ^block2)
    : base(attributes, type_expr, null, id1, block1, id2, block2) {
    parameter_ = parameter;

    parameters_ = new ArrayList();
    parameters_.Add(parameter);
  }

  public override int Kind() { return MemberKind_10.Indexer_10; }

  public override bool Resolve(Program_10 program) {
    return base.Resolve(program) && parameter_.Resolve(program);
  }

  protected override int ValidAttributes() {
    return Attribute_10.Abstract | Attribute_10.Override |
    Attribute_10.Private | Attribute_10.Protected | Attribute_10.Public | Attribute_10.Virtual;
  }

  protected override string BaseName() { return "Item"; }

  public override bool Check(Context_10 ctx) {
    if (parameter_ is RefOutParameter_10) {
      Error("indexer parameter may not be ref or out");
      return false;
    }

    return base.Check(ctx);
  }

  public override ArrayList /* of Parameter_10 */ Parameters() {
    return parameters_; 
  }

  public RValue_10 ^Get(GValue_10 obj, RValue_10 ^index) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    return Invocation_10.InvokeMethod(obj, getter_, a, true);
  }

  public void Set(GObject_10 obj, RValue_10 ^index, RValue_10 ^val) {
    ArrayList ^a = new ArrayList();
    a.Add(index);
    a.Add(val);
    Invocation_10.InvokeMethod(obj, setter_, a, true);
  }
}

class Class_10 : Ownable_10 {
  Syntax_10 ^syntax_ = new Syntax_10();
  Program_10 program_;   // containing program
  int attributes_;
  public readonly string name_;
  string parent_name_;    // or null if not specified

  Class_10 parent_;

  public readonly NonOwningArrayList /* of Field_10 */ ^fields_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Method_10 */ ^methods_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Property_10 */ ^properties_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Indexer_10 */ ^indexers_ = new NonOwningArrayList();
  public readonly NonOwningArrayList /* of Constructor_10 */ ^constructors_ = new NonOwningArrayList();

  public readonly ArrayList /* of Member_10 */ ^members_ = new ArrayList();

  public readonly ArrayList /* of Temporaries_10 */ ^temporaries_ = new ArrayList();

  public readonly NonOwningArrayList /* of Class_10 */ ^subclasses_ = new NonOwningArrayList();
  bool emitted_;

  // If_10 virtual_ is true, then this class needs a vtable; we set this for a class C
  // in any of the following cases:
  // - the program converts some type T to C ^ (for then a C ^ may hold a T, and when
  // the owning pointer is destroyed we need to know which destructor to call)
  // - the program explicitly converts from C to some other type (so we need RTTI for C)
  bool virtual_;
  
  // If_10 object_inherit_ is true, then this class must derive from Object in generated C++
  // code; we set this for a class C in any of the following cases:
  // - a member lookup in C yields a member in Object
  // - the program converts from C to Object or from Object to C
  // - the class is used in a generic context, i.e. in the type C [] or C ^ [].  All such types
  //   use the generic compiled classes Array<Object> / Array<_Own<Object>>, and so in this case we need
  //   to be able to cast between C and Object.
  //
  // If_10 object_inherit_ is true then this class and all its superclasses will have vtables since
  // the C++ Object class has a vtable.
  bool object_inherit_;

  bool need_destroy_;  // true if we need to emit _Destroy methods for this class

  // The set of types which may be destroyed when an instance of this class is destroyed.
  TypeSet_10 ^destroys_;

  // A marker used in performing a depth-first search to construct the destroys_ type set.
  int marker_;

  protected Class_10(string name) { name_ = name; }

  public static Class_10 New_10(int attributes, string name, string parent_name) {
    Class_10 c = Internal_10.Find(name);
    if (c == null) {
      Class_10 ^c1 = new Class_10(name);
      c = c1;
      Gel_10.program_.AddOwn(c1);
    }

    c.attributes_ = attributes;
    c.parent_name_ = parent_name;

    return c;
  }

  public override bool IsOwned() { return true; }

  public Program_10 GetProgram() { return program_; }
  public void SetProgram(Program_10 p) { program_ = p; }

  public bool IsExtern() { return HasAttribute(Attribute_10.Extern); }

  public override Class_10 Parent() { return parent_; }

  public override string ToString() { return name_; }

  public override ArrayList Members() { return members_; }

  public override SimpleValue_10 DefaultValue_10() { return Null_10.Instance; }

  public override void SetVirtual() { virtual_ = true; }
  public override void SetObjectInherit() { object_inherit_ = true;  }
  public void NeedDestroy() { need_destroy_ = true; }

  public bool HasAttribute(int a) {
    return ((attributes_ & a) != 0);
  }

  public virtual GValue_10 ^New_10() { return new GObject_10(this); }
  public virtual RValue_10 ^InvokeStatic(Method_10 m, ValueList_10 args) { Debug.Assert(false); return null; }

  public void Add(Field_10 ^f) { f.SetClass(this); fields_.Add(f); members_.Add(f);  }

  public virtual void Add(Method_10 ^m) { m.SetClass(this); methods_.Add(m); members_.Add(m);  }

  public void Add(Property_10 ^p) { p.SetClass(this); properties_.Add(p); members_.Add(p);  }

  public void Add(Indexer_10 ^i) { i.SetClass(this); indexers_.Add(i); members_.Add(i); }

  public void AddConstructor(Constructor_10 ^c) { c.SetClass(this); constructors_.Add(c); members_.Add(c);  }

  public NonOwningArrayList /* of Member_10 */ ^FindAbstractMembers() {
    NonOwningArrayList /* of Member_10 */ ^a;
    if (parent_ != null)  {
      a = parent_.FindAbstractMembers();

      // remove members overridden in this class
      int i = 0;
      while (i < a.Count) {
        Member_10 m = (Member_10) a[i];
        Member_10 n = GetMatchingMember(m);
        if (n != null) {
          Debug.Assert(n.HasAttribute(Attribute_10.Abstract | Attribute_10.Override));
          a.RemoveAt(i);
        } else ++i;
      }
    } else a = new NonOwningArrayList();

    // add abstract members from this class
    foreach (Member_10 m in members_) {
      if (m.HasAttribute(Attribute_10.Abstract))
        a.Add(m);
    }

    return a;
  }

  public bool ResolveAll(Program_10 program) {
    if (parent_name_ != null) {
      parent_ = program.FindClass(parent_name_);
      if (parent_ == null) {
        syntax_.Error("can't find parent class {0}", parent_name_);
        return false;
      }
    } else if (this == GObject_10.type_)
      parent_ = null;
    else parent_ = GObject_10.type_;
    if (parent_ != null)
      parent_.subclasses_.Add(this);

    foreach (Member_10 m in members_)
      if (!m.Resolve(program))
        return false;

    if (!IsExtern() && constructors_.Count == 0)
      // add a default constructor
      AddConstructor(new Constructor_10(Attribute_10.Public, name_, new ArrayList(), Block_10.EmptyBlock()));

    return true;
  }

  // In our first checking pass we check all constant fields since we may need to evaluate them
  // in the course of checking other code.
  public bool Check1(Context_10 prev_ctx) {
    if (!AttributeUtil_10.CheckOnly(attributes_,
         Attribute_10.Abstract | Attribute_10.Extern | Attribute_10.Public)) {
      syntax_.Error("illegal class attribute");
      return false;
    }

    if (prev_ctx.program_.FindClass(name_) != this) {
      syntax_.Error("can't have two classes named {0}", name_);
      return false;
    }

    Context_10 ^ctx = new Context_10(prev_ctx, this);
    bool ok = true;
    foreach (Field_10 f in fields_) {
      ConstField_10 cf = f as ConstField_10;
      if (cf != null)
        ok &= cf.Check(ctx);
    }
    return ok;
  }

  public bool Check(Context_10 prev_ctx) {
    Context_10 ^ctx = new Context_10(prev_ctx, this);

    bool ok = true;

    foreach (Member_10 m in members_)
      if (m is Field_10 && !(m is ConstField_10) || m is Method_10)
        ok &= m.Check(ctx);

    // We need to check properties and indexers separately since they add methods to the members_
    // array as they are checked.
    foreach (Property_10 p in properties_)
      ok &= p.Check(ctx);
    foreach (Indexer_10 i in indexers_)
      ok &= i.Check(ctx);

    if (!HasAttribute(Attribute_10.Abstract)) {
      NonOwningArrayList ^a = FindAbstractMembers();
      if (a.Count > 0) {
        foreach (Member_10 m in a)
          syntax_.Error("class does not define inherited abstract {0} {1}", m.KindString(), m.name_);
        ok = false;
      }
    }

    return ok;
  }

  public void GetMainMethod(NonOwningArrayList /* of Method_10 */ result) {
    foreach (Method_10 m in methods_)
      if (m.name_ == "Main" && m.IsPublic() && m.IsStatic() && m.ReturnType() == Void_10.type_) {
        int c = m.parameters_.Count;
        if (c > 1)
          continue;
        if (c == 1) {
          Parameter_10 p = m.Param(0);
          if (p.GetMode() != 0 || !p.Type().Equals(new ArrayType_10(GString_10.type_)) )
            continue;
        }
        result.Add(m);
      }
  }

  public override void FindTypeDestroys(int marker, TypeSet_10 set) {
    if (marker_ == marker)
      return;
    marker_ = marker;
    set.Add(this);
    for (Class_10 c = this; c != null; c = c.parent_) {
      if (c != this && c.marker_ == marker)
        break;
      foreach (Field_10 f in c.fields_)
        if (!f.IsConstOrStatic())
          f.Type().FindVarDestroys(marker, set);
    }
    foreach (Class_10 c in subclasses_)
      c.FindTypeDestroys(marker, set);
  }

  public override TypeSet_10 TypeDestroys() {
    if (destroys_ == null) {
      destroys_ = new TypeSet_10();
      FindTypeDestroys(Control_10.GetMarkerValue(), destroys_);
    }
    return destroys_;
  }

  public Temporaries_10 NewTemporaries() {
    Temporaries_10 ^t = new Temporaries_10();
    Temporaries_10 ret = t;
    temporaries_.Add(t);
    return ret;
  }

  public void StaticInit() {
    foreach (Field_10 f in fields_) {
      StaticField_10 sf = f as StaticField_10;
      if (sf != null)
        sf.Init();
    }
  }

  public override string EmitTypeName() { return name_; }

  int EmitAccess(SourceWriter_10 w, int old_access, int new_access) {
    new_access = (new_access & Attribute_10.Public) != 0 ? Attribute_10.Public : Attribute_10.Protected;

    if (new_access != old_access) {
      switch (new_access) {
        case Attribute_10.Protected:
          w.Indent(-1);
          w.WriteLine("protected:");
          break;
        case Attribute_10.Public:
          w.Indent(-1);
          w.WriteLine("public:");
          break;
        default:
          Debug.Assert(false);
          break;
      }
    }

    return new_access;
  }

  public void EmitInitializers(SourceWriter_10 w) {
    foreach (Field_10 f in fields_)
      if (!f.IsConstOrStatic())
        f.EmitInitializer(w);
  }

  // Return_10 true if this top-level class must inherit from Object.
  bool ObjectInherit() {
    if (object_inherit_)
      return true;
    foreach (Class_10 c in subclasses_)
      if (c.ObjectInherit())
        return true;
    return false;
  }

  public void EmitDeclaration(SourceWriter_10 w) {
    if (emitted_ || IsExtern())
      return;

    // C++ requires a parent class to appear before its subclasses in a source file.
    parent_.EmitDeclaration(w);

    emitted_ = true;

    w.Write("class {0} ", name_);
    if (parent_ != null)
      w.Write(": public {0} ",
              parent_ == GObject_10.type_ && !ObjectInherit() ? "_Object" : parent_.name_);
    w.OpenBrace();

    int access = 0;

    if (fields_.Count > 0) {
      foreach (Field_10 f in fields_) {
        access = EmitAccess(w, access, f.attributes_);
        f.EmitDeclaration(w);
      }
      w.WriteLine("");
    }

    if (subclasses_.Count > 0) {
      access = EmitAccess(w, access, Attribute_10.Protected);
      w.IWrite("{0}(Dummy *dummy) ", name_);
      if (parent_ != GObject_10.type_)
        w.Write(": {0}(dummy) ", parent_.name_);
      w.WriteLine("{ }");
      w.WriteLine("");
    }

    // If_10 we have more than one constructor, emit an _Init() method which constructors can
    // call to initialize instance variables.
    if (constructors_.Count > 1) {
      access = EmitAccess(w, access, Attribute_10.Protected);
      w.IWriteLine("void _Init();");
      w.WriteLine("");
    }

    foreach (Constructor_10 c in constructors_) {
      access = EmitAccess(w, access, c.attributes_);
      c.EmitDeclaration(w);
    }

    if (virtual_) {
      access = EmitAccess(w, access, Attribute_10.Public);
      w.IWrite("virtual ~{0}()", name_);
      w.WriteLine(" { }");
      w.WriteLine("");
    }

    if (need_destroy_) {
      access = EmitAccess(w, access, Attribute_10.Public);
      w.IWriteLine("GEL_OBJECT({0})", name_);
      w.WriteLine("");
    }

    foreach (Method_10 m in methods_) {
      access = EmitAccess(w, access, m.attributes_);
      m.EmitDeclaration(w);
    }

    w.SubIndent();
    w.WriteLine("};");
    w.WriteLine("");
  }

  public void Emit(SourceWriter_10 w) {
    if (IsExtern())
      return;

    if (fields_.Count > 0) {
      foreach (Field_10 f in fields_)
        f.Emit(w);
      w.WriteLine("");
    }

    if (constructors_.Count > 1) {
      w.IWrite("void {0}::_Init() ", name_);
      w.OpenBrace();
      EmitInitializers(w);
      w.CloseBrace();
      w.WriteLine("");
    }

    foreach (Constructor_10 c in constructors_)
      c.Emit(w);

    foreach (Method_10 m in methods_)
      m.Emit(w);

    if (Gel_10.print_type_sets_)
      Console.WriteLine("~{0}: {1}", name_, TypeDestroys());
  }
}

class ClassPtr_10 {
  public readonly Class_10 class_;

  public ClassPtr_10(Class_10 c) { class_ = c; }
}

class ValueList_10 {
  public ArrayList list_;
  public ValueList_10(ArrayList list) { list_ = list; }

  public GValue_10 Object(int i) { return ((RValue_10) list_[i]).Get(); }
  public bool Bool(int i) { return ((GBool_10) list_[i]).b_; }
  public int Int(int i) { return ((GInt_10) list_[i]).i_; }
  public char Char(int i) { return ((GChar_10) list_[i]).c_; }
  public string GetString(int i) { return ((GString_10) list_[i]).s_; }
}

class Internal_10 : Class_10 {
  static NonOwningArrayList /* of Internal_10 */ ^all_ = new NonOwningArrayList();

  protected Internal_10(string name) : base(name) { }

  public static Internal_10 Find(string name) {
    foreach (Internal_10 p in all_)
      if (p.name_ == name)
        return p;
    return null;
  }

  static void Add(Internal_10 p) { all_.Add(p); }

  public static void Init() {
    Add(GObject_10.type_);
    Add(GArray_10.array_class_);
    Add(GBool_10.type_);
    Add(GChar_10.type_);
    Add(GDouble_10.type_);
    Add(GFloat_10.type_);
    Add(GInt_10.type_);
    Add(GString_10.type_);
    Add(GStringBuilder_10.type_);
    Add(PoolClass_10.instance_);
    Add(DebugClass_10.instance_);
    Add(EnvironmentClass_10.instance_);

    Add(ConsoleClass_10.instance_);
    Add(FileClass_10.instance_);
    Add(PathClass_10.instance_);
    Add(GStreamReader_10.type_);
  }
}

class ObjectClass_10 : Internal_10 {
  public Method_10 equals_;
  public Method_10 get_hash_code_;
  public Method_10 to_string_;

  public ObjectClass_10() : base("Object") { }

  public override void Add(Method_10 ^m) {
    switch (m.name_) {
      case "Equals": equals_ = m; break;
      case "GetHashCode": get_hash_code_ = m; break;
      case "ToString": to_string_ = m; break;
    }
    base.Add(m);
  }
}

class ArrayClass_10 : Internal_10 {
  public ArrayClass_10() : base("Array") { }
}

abstract class SimpleType_10 : Internal_10 {
  protected SimpleType_10(string name) : base(name) { }

  public override bool IsOwned() { return false; }
  public override bool IsReference() { return false; }
  public override bool IsValue() { return true; }

  public override string EmitExprType() { return EmitType(); }
  public override string EmitType() { Debug.Assert(false); return null; }
}

abstract class IntegralType_10 : SimpleType_10 {
  protected IntegralType_10(string name) : base(name) { }
}

class BoolClass_10 : IntegralType_10 {
  public BoolClass_10() : base("Bool") { }

  static GBool_10 ^default_ = new GBool_10(false);
  public override SimpleValue_10 DefaultValue_10() { return default_; }

  public override string ToString() { return "bool"; }

  public override string EmitType() { return "bool"; }
}

class CharClass_10 : IntegralType_10 {
  public CharClass_10() : base("Char") { }

  static GChar_10 ^default_ = new GChar_10('\0');

  public override SimpleValue_10 DefaultValue_10() { return default_; }

  public override bool CanConvert1(GType_10 t) { return t == GInt_10.type_; }

  public override string ToString() { return "char"; }

  public override RValue_10 ^InvokeStatic(Method_10 m, ValueList_10 args) {
    switch (m.name_) {
      case "IsDigit": return new GBool_10(Char.IsDigit(args.Char(0)));
      case "IsLetter": return new GBool_10(Char.IsLetter(args.Char(0)));
      case "IsWhiteSpace": return new GBool_10(Char.IsWhiteSpace(args.Char(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "wchar_t"; }
}

class IntClass_10 : IntegralType_10 {
  public IntClass_10() : base("Int") { }

  static GInt_10 ^default_ = new GInt_10(0);

  public override SimpleValue_10 DefaultValue_10() { return default_; }

  public override bool CanConvert1(GType_10 t) {
    return t == GFloat_10.type_ || t == GDouble_10.type_;
  }

  protected override bool CanConvertExplicit1(GType_10 t) {
    return t == GChar_10.type_;
  }

  public override string ToString() { return "int"; }

  public override RValue_10 ^InvokeStatic(Method_10 m, ValueList_10 args) {
    switch (m.name_) {
      case "Parse": return new GInt_10(int.Parse(args.GetString(0)));
      default: Debug.Assert(false); return null;
    }
  }

  public override string EmitType() { return "int"; }
}

class FloatClass_10 : SimpleType_10 {
  public FloatClass_10() : base("Single") { }

  static GFloat_10 ^default_ = new GFloat_10(0.0f);

  public override SimpleValue_10 DefaultValue_10() { return default_; }

  public override bool CanConvert1(GType_10 t) {
    return t == GDouble_10.type_;
  }

  protected override bool CanConvertExplicit1(GType_10 t) {
    return t == GInt_10.type_;
  }

  public override string ToString() { return "float"; }

  public override string EmitType() { return "float"; }
}

class DoubleClass_10 : SimpleType_10 {
  public DoubleClass_10() : base("Double") { }

  static GDouble_10 ^default_ = new GDouble_10(0.0d);

  public override SimpleValue_10 DefaultValue_10() { return default_; }

  protected override bool CanConvertExplicit1(GType_10 t) {
    return t == GInt_10.type_ || t == GFloat_10.type_;
  }

  public override string ToString() { return "double"; }

  public override string EmitType() { return "double"; }
}

class StringClass_10 : Internal_10 {
  public StringClass_10() : base("String") { }

  public override bool IsOwned() { return false; }
  public override bool IsValue() { return true; }

  public override string ToString() { return "string"; }

  public override string EmitType() {
    return "_Ref<String>";
  }

  public override string EmitReturnType() {
    return EmitType();
  }

  public override string EmitGenericType() {
    return EmitType();
  }

  public override RValue_10 ^InvokeStatic(Method_10 m, ValueList_10 args) {
    switch (m.name_) {
      case "Format": return new GString_10(String.Format(args.GetString(0), args.Object(1)));
      default: Debug.Assert(false); return null;
    }
  }
}

class StringBuilderClass_10 : Internal_10 {
  public StringBuilderClass_10() : base("StringBuilder") { }
  public override GValue_10 ^New_10() { return new GStringBuilder_10(); }
}

class GStringBuilder_10 : GValue_10 {
  readonly StringBuilder ^b_ = new StringBuilder();

  public static readonly StringBuilderClass_10 ^type_ = new StringBuilderClass_10();

  public override GType_10 Type() { return type_; }

  public override RValue_10 ^Invoke(Method_10 m, ValueList_10 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "Append": b_.Append(args.Char(0)); return null;
      case "ToString": return new GString_10(b_.ToString());
      default: Debug.Assert(false); return null;
    }
  }
}

class PoolClass_10 : Internal_10 {
  public PoolClass_10() : base("Pool") { }

  public static PoolClass_10 ^instance_ = new PoolClass_10();
}

class DebugClass_10 : Internal_10 {
  public DebugClass_10() : base("Debug") { }
  public static readonly DebugClass_10 ^instance_ = new DebugClass_10();
  
  public override RValue_10 ^InvokeStatic(Method_10 m, ValueList_10 args) {
    switch (m.name_) {
      case "Assert": Debug.Assert(args.Bool(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

class EnvironmentClass_10 : Internal_10 {
  public EnvironmentClass_10() : base("Environment") { }
  public static readonly EnvironmentClass_10 ^instance_ = new EnvironmentClass_10();

  public override RValue_10 ^InvokeStatic(Method_10 m, ValueList_10 args) {
    switch (m.name_) {
      case "Exit": Environment.Exit(args.Int(0)); return null;
      default: Debug.Assert(false); return null;
    }
  }
}

// built-in I/O classes

class ConsoleClass_10 : Internal_10 {
  public ConsoleClass_10() : base("Console") { }

  public override RValue_10 ^InvokeStatic(Method_10 m, ValueList_10 args) {
    switch (m.name_) {
      case "Write":
        switch (m.parameters_.Count) {
          case 1: Console.Write(args.Object(0)); return null;
          case 2: Console.Write(args.GetString(0), args.Object(1)); return null;
          case 3: Console.Write(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      case "WriteLine":
        switch (m.parameters_.Count) {
          case 1: Console.WriteLine(args.Object(0)); return null;
          case 2: Console.WriteLine(args.GetString(0), args.Object(1)); return null;
          case 3: Console.WriteLine(args.GetString(0), args.Object(1), args.Object(2)); return null;
          default: Debug.Assert(false); return null;
        }
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly ConsoleClass_10 ^instance_ = new ConsoleClass_10();
}

class FileClass_10 : Internal_10 {
  public FileClass_10() : base("File") { }

  public override RValue_10 ^InvokeStatic(Method_10 m, ValueList_10 args) {
    switch (m.name_) {
      case "Delete": File.Delete(args.GetString(0)); return null;
      case "Exists": return new GBool_10(File.Exists(args.ToString()));
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly FileClass_10 ^instance_ = new FileClass_10();
}

class PathClass_10 : Internal_10 {
  public PathClass_10() : base("Path") { }

  public override RValue_10 ^InvokeStatic(Method_10 m, ValueList_10 args) {
    switch (m.name_) {
      case "GetTempFileName": return new GString_10(Path.GetTempFileName());
      default: Debug.Assert(false); return null;
    }
  }

  public static readonly PathClass_10 ^instance_ = new PathClass_10();
}

class StreamReaderClass_10 : Internal_10 {
  public StreamReaderClass_10() : base("StreamReader") { }
  public override GValue_10 ^New_10() { return new GStreamReader_10(); }
}

class GStreamReader_10 : GValue_10 {
  StreamReader ^reader_;

  public static readonly StreamReaderClass_10 ^type_ = new StreamReaderClass_10();

  public override GType_10 Type() { return type_; }

  public override RValue_10 ^Invoke(Method_10 m, ValueList_10 args) {
    if (m.GetClass() != type_)
      return base.Invoke(m, args);
    switch (m.name_) {
      case "StreamReader": reader_ = new StreamReader(args.GetString(0)); return null;
      case "Read": return new GInt_10(reader_.Read());
      case "Peek": return new GInt_10(reader_.Peek());
      default: Debug.Assert(false); return null;
    }
  }
}

class Program_10 {
  ArrayList /* of string */ ^gel_import_ = new ArrayList();
  ArrayList /* of string */ ^cpp_import_ = new ArrayList();

  static Scanner_10 ^scanner_;

  NonOwningArrayList ^classes_ = new NonOwningArrayList();
  ArrayList ^own_classes_ = new ArrayList();

  public bool crt_alloc_;
  public bool debug_;
  public bool safe_ = true;

  public Control_10 prev_;   // previous node in control flow graph, used during graph construction

  public void Import(string s) {
    ArrayList a = null;
    string extension = Path.GetExtension(s);
    switch (extension) {
      case ".gel": a = gel_import_; break;
      case ".cpp": a = cpp_import_; break;
      default:
        new Syntax_10().Error("can't import file with extension {0}", extension);
        Environment.Exit(0);
        break;
    }
    foreach (string i in a)
      if (i == s)
        return;   // already imported
    a.Add(s);
  }

  public void FindAndImport(string s) {
    // First look relative to the importing file.
    string dir = Path.GetDirectoryName(Gel_10.CurrentFile());
    string s1 = Path.Combine(dir, s);
    if (!File.Exists(s1)) {
      // Now look relative to the GEL2 directory.
      s1 = Path.Combine(Gel_10.gel_directory_, s);
      if (!File.Exists(s1)) {
        new Syntax_10().Error("import not found: ", s);
        Environment.Exit(0);
      }
    }
    Import(s1);
  }
  
  public void Add(Class_10 c) {
    c.SetProgram(this);
    classes_.Add(c);
  }

  public void AddOwn(Class_10 ^c) {
    own_classes_.Add(c);
  }

  public Class_10 FindClass(string name) {
    foreach (Class_10 c in classes_)
      if (c.name_ == name)
        return c;
    return null;
  }

  public string CurrentFile() {
    return scanner_.filename_;
  }

  public int Line() {
    return scanner_.Line();
  }

  string Builtin(string module) {
    string file = String.Format("{0}.gel", module);
    return Path.Combine(Gel_10.gel_directory_, file);
  }

  public bool Parse() {
    Parser ^parser = new Parser();
    for (int i = 0; i < gel_import_.Count; ++i) {
      string file = (string) gel_import_[i];
      scanner_ = new Scanner_10(file);
      parser.yyParse(scanner_);
      if (i == 0) {
        Import(Builtin("internal"));
        Import(Builtin("library"));
      }
    }
    return true;
  }

  public bool Resolve() {
    foreach (Class_10 c in classes_)
      if (!c.ResolveAll(this))
        return false;

    return true;
  }

  public bool Check() {
    Context_10 ^ctx = new Context_10(this);
    bool ok = true;

    // Make a first checking pass where we check only constant fields.
    foreach (Class_10 c in classes_)
      ok &= c.Check1(ctx);

    foreach (Class_10 c in classes_)
      ok &= c.Check(ctx);

    return ok;
  }

  Method_10 FindMain() {
    NonOwningArrayList ^methods = new NonOwningArrayList();
    foreach (Class_10 c in classes_) {
      c.GetMainMethod(methods);
    }
    if (methods.Count == 0) {
      Console.WriteLine("no Main() method found");
      return null;
    }
    if (methods.Count > 1) {
      Console.WriteLine("error: found more than one Main() method");
      return null;
    }
    return (Method_10) methods[0];
  }

  public void Eval(ArrayList /* of string */ args) {
    Method_10 m = FindMain();
    if (m == null)
      return;
    ArrayList ^a = new ArrayList();
    if (m.parameters_.Count > 0) {   // Main() takes a string[] argument
      GArray_10 ^arr = new GArray_10(new ArrayType_10(GString_10.type_), args.Count);
      for (int i = 0 ; i < args.Count ; ++i)
        arr.Set(i, new GString_10((string) args[i]));
      a.Add(arr);
    }
    foreach (Class_10 c in classes_)
      c.StaticInit();
    m.Invoke(null, a);
  }

  void EmitMain(SourceWriter_10 w, Method_10 main) {
    bool args = main.parameters_.Count > 0;
    w.Write("int main({0}) ", args ? "int argc, char *argv[]" : "");
    w.OpenBrace();
    w.IWriteLine("return gel_runmain({0}::Main{1});", main.GetClass().name_, args ? ", argc, argv" : "");
    w.CloseBrace();
  }

  public bool Emit(SourceWriter_10 w) {
    Method_10 main = FindMain();
    if (main == null)
      return false;

    w.WriteLine("#define MEMORY_OWN 1");
    if (safe_)
      w.WriteLine("#define MEMORY_SAFE 1");
    if (crt_alloc_)
      w.WriteLine("#define MEMORY_CRT 1");

    foreach (string f in cpp_import_)
      w.WriteLine("#include {0}", GString_10.EmitString(f));

    // We undefine NULL since Gel_10 code may legitimately define fields or variables with that name.
    // Generated code uses 0, not NULL, to indicate the null pointer.
    w.WriteLine("#undef NULL");

    w.WriteLine("");

    // Forward-declare all classes since C++ requires a class to be declared before its name can
    // be used as a type.
    foreach (Class_10 c in classes_)
      if (!(c.HasAttribute(Attribute_10.Extern)))
        w.WriteLine("class {0};", c.name_);
    w.WriteLine("");

    foreach (Class_10 c in classes_)
      c.EmitDeclaration(w);

    foreach (Class_10 c in classes_)
      c.Emit(w);

    EmitMain(w, main);
    return true;
  }

  // Emit C++ code.
  public bool Generate(string basename) {
    string cpp_file = basename + ".cpp";
    StreamWriter ^w = new StreamWriter(cpp_file);
    bool ok = Emit(new SourceWriter_10(w));
    w.Close();
    return ok;
  }

  static string[] ^vsdirs = { "Microsoft Visual Studio 8",
                            "Microsoft Visual Studio .NET 2003",
                            "Microsoft Visual Studio .NET 2002" };

  string VsVars(int i) {
    return String.Format("C:\\Program_10 Files\\{0}\\Common7\\Tools\\vsvars32.bat", vsdirs[i]);
  }

  string FindVsVars() {
    for (int i = 0; i < vsdirs.Length; ++i) {
      string f = VsVars(i);
      if (File.Exists(f))
        return f;
    }

    Console.WriteLine("Error: unable to find vsvars32.bat at any of the following locations:");
    Console.WriteLine("");
    for (int i = 0; i < vsdirs.Length; ++i)
      Console.WriteLine(VsVars(i));
    Console.WriteLine("");
    Console.WriteLine("Your Visual Studio installation may be invalid.  Aborting compilation.");
    return null;
  }

  // Report compilation error. Print error message from a file
  void ReportCompilationError(string error_msg_file) {
      Console.WriteLine(
        "Error: unable to compile generated C++ code.  You may have found a bug in the GEL2 compiler.");
      Console.WriteLine("C++ compiler output follows:");
      Console.WriteLine("");
      Console.WriteLine((new StreamReader(error_msg_file)).ReadToEnd());
  }

  void UnixCppCompile(string basename) {
    string command_out = Path.GetTempFileName();
    string dbg_options = debug_ ? "-g -DDEBUG" : "-O2 -DNDEBUG";
    StringBuilder ^sb = new StringBuilder();
    // -o basename, use basename as the executable name
    // -Werror, make all warnings into hard errors
    sb.AppendFormat("/usr/bin/g++ -o {0} -Werror {1} {2}.cpp",
                    basename, dbg_options, basename);

    // Append redirection of output
    sb.AppendFormat(" > {0} 2>&1", command_out);
 
    string sh_cmd = sb.ToString();

    if (Gel_10.verbose_) 
      Console.WriteLine(sh_cmd);
  
    if (Process.System(sh_cmd) !=0) {
      ReportCompilationError(command_out);
    }
    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".o");
  }

  // Run vsvars32.bat and the run the given command, redirecting output to a file.
  // We must always redirect output since vsvars32 prints a message "Setting environment..."
  // which we don't want users to see.
  int VsRun(string vsvars, string command, string output) {
    command = String.Format("(\"{0}\" & {1}) > \"{2}\"", 
                            vsvars, command, output);
    return Process.System(command);
  }

  void VsCppCompile(string basename) {
    string vsvars = FindVsVars();
    if (vsvars == null)
      return;
    string command_out = Path.GetTempFileName();

    string options = debug_ ?
      //  /MDd - runtime library: multithreaded debug DLL
      //  /Od - optimization: disabled
      //  /ZI - debug information format: Program_10 Database for Edit & Continue_10
      "/MDd /Od /ZI /D \"_DEBUG\"" :

      //  /MD - runtime library: multithreaded DLL
      //  /O2 - optimization: Maximize Speed
      //  /GL - optimization: Whole Program_10 Optimization
      "/MD /O2 /GL /D \"NDEBUG\"";

    StringBuilder ^sb = new StringBuilder();
    //  /WX - treat warnings as errors
    sb.AppendFormat("cl /nologo /WX {0} {1}.cpp", options, basename);
    string mode = debug_ ? "debug" : "release";
    if (!crt_alloc_)
      sb.AppendFormat(" {0}\\{1}\\dlmalloc.obj", Gel_10.gel_directory_, mode);
    sb.Append(" user32.lib shell32.lib shlwapi.lib");
    string command = sb.ToString();
    if (Gel_10.verbose_)
      Console.WriteLine(command);

    if (VsRun(vsvars, command, command_out) != 0) {
      ReportCompilationError(command_out);
    } else {
      // Run the manifest tool to embed the linker-generated manifest into the executable file;
      // this allows the executable to find the C runtime DLL even when the manifest file is absent.
      string mt_command = String.Format("mt -nologo -manifest {0}.exe.manifest -outputresource:\"{0}.exe;#1\"",
                              basename);
      if (Gel_10.verbose_)
        Console.WriteLine(mt_command);
      if (VsRun(vsvars, mt_command, command_out) != 0)
        Console.WriteLine("warning: could not run manifest tool");
    }

    // delete intermediate files
    File.Delete(command_out);
    File.Delete(basename + ".obj");
    File.Delete(basename + ".exe.manifest");
  }

  // Invoke the C++ compiler to generate a native executable.
  void CppCompile(string basename) {
    if (Environment.OSVersion.Platform == PlatformID.Win32NT) 
      VsCppCompile(basename);
    else
      UnixCppCompile(basename);
  }

  public void Compile(string output, bool cpp_only) {
    if (output == null)
      output = Path.GetFileNameWithoutExtension((string) gel_import_[0]);
    if (Generate(output) && !cpp_only)
      CppCompile(output);
  }
}

class Scanner_10 : yyInput {
  public readonly string filename_;

  int line_;
  public int Line() { return line_; }

  StreamReader ^sr_;
  int token_;
  object ^ value_;

  int next_token_ = -1;
  object ^ next_value_;

  public Scanner_10 (string filename) {
    filename_ = filename;
    sr_ = new StreamReader(filename);
    line_ = 1;
  }

  public override int GetToken () {
    return token_;
  }

  public override object ^ GetValue () {
    return take value_;
  }

  int Read() {
    int i = sr_.Read();
    if (i == '\n')
      ++line_;
    return i;
  }

  bool Read(out char c) {
    int i = Read();
    c = (char) i;
    return i != -1;
  }

  char Peek() {
    return (char) sr_.Peek();
  }

  string ReadWord(char first) {
    StringBuilder ^sb = new StringBuilder();
    if (first != '\0')
      sb.Append(first);
    while (true) {
      char c = Peek();
      if (!Char.IsLetter(c) && !Char.IsDigit(c) && c != '_')
        break;
      sb.Append(c);
      Read();
    }
    return sb.ToString();
  }

  // Read to the end of the current line.
  string ReadLine() {
    StringBuilder ^sb = new StringBuilder();
    char c;
    while (Read(out c)) {
      if (c == '\n')
        break;
      sb.Append(c);
    }
    return sb.ToString();
  }

  // Read a comment delimited by /* ... */, assuming we've already read the opening /*.
  // Returns true on success, or false on EOF.
  bool ReadDelimitedComment() {
    char prev = (char) 0;
    while (true) {
      char c;
      if (!Read(out c)) {
        Console.WriteLine("warning: unterminated comment at end of file");
        return false;
      }
      if (c == '/' && prev == '*')
        return true;
      prev = c;
    }
  }

  // Preprocess input, handling whitespace, comments and directives; return the first
  // character not eaten by preprocessing, or -1 on EOF.
  int GetChar() {
    while (true) {
      int i = Read();
      if (i == -1)
        return -1;   // end of input
      if (i == 0)
        continue;   // end of this file; move on
      char c = (char) i;

      if (c == '\n' && Peek() == '#') {
        Read();
        string directive = ReadWord('\0');
        if (directive == "line") {
          ReadLine();
          continue;
        }
        Console.WriteLine("error: unknown preprocessing directive {0}", directive);
        Environment.Exit(0);
      }

      if (Char.IsWhiteSpace(c))
        continue;

      if (c == '/') {
        switch (Peek()) {
          case '/':  // single-line comment
            Read();
            int line = line_;
            string s = ReadLine();
            if (Gel_10.error_test_ && s.StartsWith(" error"))
              Gel_10.expected_error_lines_.Add(line);
            continue;

          case '*':  // comment delimited by /* ... */
            Read();   // move past opening '*'
            if (!ReadDelimitedComment())
              return (char) 0;
            continue;
        }
      }

      return c;
    }
  }

  bool IsDigit(char c, bool hex) {
    if (Char.IsDigit(c))
      return true;
    if (!hex)
      return false;
    return (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');
  }

  // Read a number, possibly including a decimal point and/or exponent.
  string ReadNumber(char first, bool hex, out bool real) {
    bool dot = false, exp = false;
    StringBuilder ^sb = new StringBuilder();
    sb.Append(first);
    if (first == '.')
      dot = true;

    while (true) {
      bool need_digit = false;
      char c = Peek();
      if (c == '.' && !hex && !dot && !exp) {
        sb.Append(c);
        Read();
        dot = true;
        c = Peek();
        need_digit = true;
      }
      else if ((c == 'e' || c == 'E') && !hex && !exp) {
        sb.Append(c);
        Read();
        exp = true;
        c = Peek();
        if (c == '+' || c == '-') {
          sb.Append(c);
          Read();
          c = Peek();
        }
        need_digit = true;
      }
      if (!IsDigit(c, hex)) {
        if (!need_digit)
          break;
        real = false;
        return null;
      }
      sb.Append(c);
      Read();
    }

    real = dot || exp;
    return sb.ToString();
  }

  int ParseNumber(char first, out object ^val) {
    bool hex = false;
    if (first == '0') {
      char p = Peek();
      if (p == 'x' || p == 'X') {
        Read();
        hex = true;
      }
    }
    bool real;
    string s = ReadNumber(first, hex, out real);
    if (s == null) {
      val = null;
      return Parser.SCAN_ERROR;
    }
    if (!hex) {
      switch (Peek()) {
        case 'F':
        case 'f':
          Read();
          val = Single.Parse(s);
          return Parser.FLOAT_LITERAL;
        case 'D':
        case 'd':
          Read();
          real = true;
        break;
    }
    }
    if (real) {
      val = Double.Parse(s);
      return Parser.DOUBLE_LITERAL;
    }
    val = int.Parse(s, hex ? NumberStyles.HexNumber : NumberStyles.Integer);
    return Parser.INT_LITERAL;
  }

  int ParseWord(char first, out object ^val) {
    string s = ReadWord(first);

    val = null;
    switch (s) {
      case "abstract": return Parser.ABSTRACT;
      case "as": return Parser.AS;
      case "base": return Parser.BASE;
      case "bool": return Parser.BOOL;
      case "break": return Parser.BREAK;
      case "case": return Parser.CASE;
      case "char": return Parser.CHAR;
      case "class": return Parser.CLASS;
      case "const": return Parser.CONST_TOKEN;
      case "continue": return Parser.CONTINUE;
      case "default": return Parser.DEFAULT;
      case "do": return Parser.DO;
      case "double": return Parser.DOUBLE;
      case "else": return Parser.ELSE;
      case "extern": return Parser.EXTERN;
      case "false": return Parser.FALSE_TOKEN;
      case "float": return Parser.FLOAT;
      case "for": return Parser.FOR;
      case "foreach": return Parser.FOREACH;
      case "if": return Parser.IF;
      case "import": return Parser.IMPORT;
      case "in": return Parser.IN_TOKEN;
      case "int": return Parser.INT;
      case "is": return Parser.IS;
      case "new": return Parser.NEW;
      case "null": return Parser.NULL;
      case "object": return Parser.OBJECT;
      case "out": return Parser.OUT_TOKEN;
      case "override": return Parser.OVERRIDE;
      case "pool": return Parser.POOL;
      case "private": return Parser.PRIVATE;
      case "protected": return Parser.PROTECTED;
      case "public": return Parser.PUBLIC;
      case "readonly": return Parser.READONLY;
      case "ref": return Parser.REF;
      case "return": return Parser.RETURN;
      case "short": return Parser.SHORT;
      case "static": return Parser.STATIC;
      case "string": return Parser.STRING;
      case "switch": return Parser.SWITCH;
      case "take": return Parser.TAKE;
      case "this": return Parser.THIS_TOKEN;
      case "true": return Parser.TRUE_TOKEN;
      case "virtual": return Parser.VIRTUAL;
      case "void": return Parser.VOID_TOKEN;
      case "while": return Parser.WHILE;
      default:
        val = s;
        return Parser.ID;
    }
  }

  bool ParseEscape(ref char c) {
    if (!Read(out c))
      return false;
    switch (c) {
      case '\'':
      case '\"':
      case '\\':
        break;
      case '0': c = '\0'; break;
      case 'n': c = '\n'; break;
      case 'r': c = '\r'; break;
      case 't': c = '\t'; break;
      default: return false;
    }
    return true;
  }

  int ParseChar(out object ^val) {
    val = null;
    char c;
    if (!Read(out c))
      return Parser.SCAN_ERROR;
    if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
    char d;
    if (!Read(out d) || d != '\'')
      return Parser.SCAN_ERROR;
    val = c;
    return Parser.CHAR_LITERAL;
  }

  int ParseString(out object ^val) {
    val = null;
    StringBuilder ^sb = new StringBuilder();
    while (true) {
      char c;
      if (!Read(out c))
        return Parser.SCAN_ERROR;
      if (c == '"')
        break;
      if (c == '\\' && !ParseEscape(ref c))
        return Parser.SCAN_ERROR;
      sb.Append(c);
    }
    val = sb.ToString();
    return Parser.STRING_LITERAL;
  }

  int ReadToken(out object ^val) {
    val = null;

    int i = GetChar();
    if (i == -1)
      return -1;
    char c = (char) i;

    if (Char.IsDigit(c) || c == '.' && Char.IsDigit(Peek()))
      return ParseNumber(c, out val);

    if (Char.IsLetter(c) || c == '_')
      return ParseWord(c, out val);

    if (c == '\'')
      return ParseChar(out val);

    if (c == '"')
      return ParseString(out val);

    char peek = Peek();
    int token = 0;
    switch (c.ToString() + peek.ToString()) {
      case "++": token = Parser.PLUS_PLUS; break;
      case "--": token = Parser.MINUS_MINUS; break;
      case "&&": token = Parser.OP_AND; break;
      case "||": token = Parser.OP_OR; break;
      case "==": token = Parser.OP_EQUAL; break;
      case "!=": token = Parser.OP_NE; break;
      case "<=": token = Parser.OP_LE; break;
      case "<<": token = Parser.OP_LEFT_SHIFT; break;
      case ">=": token = Parser.OP_GE; break;
      case ">>": token = Parser.OP_RIGHT_SHIFT; break;
      case "*=": token = Parser.STAR_EQUAL; break;
      case "/=": token = Parser.SLASH_EQUAL; break;
      case "%=": token = Parser.PERCENT_EQUAL; break;
      case "+=": token = Parser.PLUS_EQUAL; break;
      case "-=": token = Parser.MINUS_EQUAL; break;
      case "&=": token = Parser.AND_EQUAL; break;
      case "|=": token = Parser.OR_EQUAL; break;

      // Return_10 [] as a single token; this lets the parser distinguish the cases
      // "foo[] a;" and "foo[x] = 4" as soon as it reads the first token after the identifier "foo".
      case "[]": token = Parser.ARRAY_TYPE; break;
    }
    if (token != 0) {
      Read();
    } else token = c;

    val = token;
    return token;
  }

  public override bool Advance () {
    if (next_token_ != -1) {
      token_ = next_token_;
      value_ = take next_value_;
      next_token_ = -1;
    } else {
      token_ = ReadToken(out value_);
      if (token_ == -1) return false;
    }

    if (token_ == ')') {
      // We need to read one token ahead to determine whether this close parenthesis
      // ends a type cast.  See e.g. the discussion in the Cast_10 Expressions section
      // of the C# specification.
      next_token_ = ReadToken(out next_value_);
      switch (next_token_) {
        case -1:  // end of file
          break;
        case '!':
        case '(':
        case Parser.ID:
        case Parser.INT_LITERAL:
        case Parser.CHAR_LITERAL:
        case Parser.STRING_LITERAL:
          token_ = Parser.CAST_CLOSE_PAREN;
          break;
        default:
          if (next_token_ >= Parser.FIRST_KEYWORD && next_token_ <= Parser.LAST_KEYWORD &&
              next_token_ != Parser.AS && next_token_ != Parser.IS)
            token_ = Parser.CAST_CLOSE_PAREN;
          break;
      }
    }
    return true;
  }

  public override void Fatal() {
    new Syntax_10().Error("irrecoverable syntax error");
    Environment.Exit(1);
  }

}

class Gel_10 {
  public static bool verbose_;

  public static bool error_test_;
  public static bool print_type_sets_;

  public static readonly ArrayList /* of int */ ^expected_error_lines_ = new ArrayList();
  public static readonly ArrayList /* of int */ ^error_lines_ = new ArrayList();

  public static Program_10 ^program_;

  public static readonly string gel_directory_ = GetLibraryPath();

  static string GetLibraryPath() {
    return Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName); 
  }

  public static string CurrentFile() {
    return program_ == null ? "" : program_.CurrentFile();
  }

  public static int Line() {
    return program_ == null ? 0 : program_.Line();
  }

  public static void Exit() { Environment.Exit(0); }

  // Given two sorted ArrayLists a, b of ints, return an ArrayList containing all ints which appear
  // in [a] but not in [b].
  ArrayList ^Diff(ArrayList a, ArrayList b) {
    ArrayList ^ret = new ArrayList();
    int bi = 0;
    foreach (int i in a) {
      while (bi < b.Count && (int) b[bi] < i)
        ++bi;
      if (bi >= b.Count || (int) b[bi] > i)
        ret.Add(i);
    }
    return ret;
  }

  void WriteLineNumbers(ArrayList a) {
    for (int i = 0; i < a.Count; ++i) {
      if (i > 0)
        Console.Write(", ");
      Console.Write(a[i]);
    }
    Console.WriteLine("");
  }

  void ErrorTestReport() {
    Console.WriteLine("");
    ArrayList ^e = Diff(error_lines_, expected_error_lines_);
    if (e.Count > 0) {
      Console.Write("unexpected error at line ");
      WriteLineNumbers(e);
    }
    ArrayList ^e2 = Diff(expected_error_lines_, error_lines_);
    if (e2.Count > 0) {
      Console.Write("expected error at line ");
      WriteLineNumbers(e2);
    }
    if (e.Count == 0 && e2.Count == 0)
      Console.WriteLine("all errors expected");
  }

  void Usage_10() {
    Console.WriteLine("usage: gel <source-file> ... [args]");
    Console.WriteLine("       gel -c [-d] [-o <name>] [-u] [-v] [-cpp] <source-file> ...");
    Console.WriteLine("");
    Console.WriteLine("   -c: compile to native executable");
    Console.WriteLine("   -d: debug mode: disable optimizations, link with debug build of C runtime");
    Console.WriteLine("   -o: specify output filename");
    Console.WriteLine("   -u: unsafe: skip reference count checks");
    Console.WriteLine("   -v: verbose: display command used to invoke C++ compiler");
    Console.WriteLine(" -cpp: compile to C++ only");
  }

  public void Run(string[] args) {
    if (args.Length < 1) {
      Usage_10();
      return;
    }

    Internal_10.Init();

    program_ = new Program_10();
    bool compile = false;
    bool cpp_only = false;
    string output = null;
    int i;
    for (i = 0; i < args.Length && args[i].StartsWith("-"); ++i)
      switch (args[i]) {
        case "-c": compile = true; break;
        case "-d": program_.debug_ = true; break;
        case "-e": error_test_ = true; break;
        case "-o":
          if (++i >= args.Length) {
            Usage_10();
            return;
          }
          output = Path.GetFileNameWithoutExtension(args[i]);
          break;
        case "-u": program_.safe_ = false; break;
        case "-v": verbose_ = true; break;
        case "-cpp": cpp_only = true; break;
        case "-crt": program_.crt_alloc_ = true; break;
        case "-typeset": print_type_sets_ = true; break;
        default:
          Console.WriteLine("unrecognized option: {0}", args[i]);
          return;
      }

    for (; i < args.Length ; ++i)
      if (args[i].EndsWith(".gel"))
        program_.Import(args[i]);
      else {
        if (args[i] == "-")   // marker indicating end of source files
          ++i;
        break;
      }

    ArrayList ^program_args = new ArrayList();
    if (compile) {
      if (i < args.Length) {
        Console.WriteLine("file to compile has unrecognized extension: {0}", args[i]);
        return;
      }
    } else {
      for (; i < args.Length; ++i)
        program_args.Add(args[i]);
    }

    if (!program_.Parse())
      return;

    bool ok = program_.Resolve() && program_.Check();
    if (error_test_)
      ErrorTestReport();
    if (!ok)
      return;

    if (compile)
      program_.Compile(output, cpp_only);
    else program_.Eval(program_args);
  }

  public static void Main_10(string[] args) {
    new Gel_10().Run(args);
  }
}
